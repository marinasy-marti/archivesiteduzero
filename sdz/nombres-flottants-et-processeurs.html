<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/nombres-flottants-et-processeurs.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 01:47:54 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/nombres-flottants-et-processeurs.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:28:33 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Nombres flottants et processeurs</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/nombres-flottants-et-processeurs.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Nombres flottants et processeurs</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Nombresflottantsetprocesseurs">Nombres flottants et processeurs</a><br/><a href="#Priseenchargedesflottantsparlehardware">Prise en charge des flottants par le hardware</a><br/><a href="#RappelssurlanormeIEEE754">Rappels sur la norme IEEE 754</a><br/><a href="#Exemplel039architecturex86">Exemple : l&#039;architecture x86</a><br/></div>
<a name="Nombresflottantsetprocesseurs"></a><h2>Nombres flottants et processeurs</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/prise-en-charge-des-flottants-par-le-hardware">
<span class="next">Prise en charge des flottants par le hardware</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-579400" data-claire-element-id="579400">Un ordinateur est souvent décrit comme une machine à calculer programmable. Autrefois, les ordinateurs ne pouvaient faire de calculs que sur des nombres entiers, et pas sur des nombres à virgule. Pour combler ce manque, diverses techniques ont été inventées pour permettre à nos ordinateurs de gérer ces nombres à virgule. La méthode actuelle utilisée pour les représenter s'appelle la virgule flottante, qui permet de coder sous forme binaire un sous-ensemble des nombres à virgule.</p><p id="r-579401" data-claire-element-id="579401">Si vous avez déjà programmé, vous savez sûrement ce qu'est un nombre flottant. Mais savez-vous comment les calculs avec ces nombres flottants sont effectués dans notre ordinateur ?</p><p id="r-579402" data-claire-element-id="579402">Si la réponse est non, alors ce tutoriel va vous ravir.</p><aside id="r-579404" data-claire-element-id="579404" data-claire-semantic="warning"><p id="r-579403" data-claire-element-id="579403">Il est préférable que vous lisiez le tutoriel <a href="http://www.siteduzero.com/tutoriel-3-509203-fonctionnement-d-un-ordinateur-depuis-zero.html">Fonctionnement d'un ordinateur depuis zéro</a> avant de lire ce tutoriel.</p></aside>
</div><a name="Priseenchargedesflottantsparlehardware"></a><h2>Prise en charge des flottants par le hardware</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/rappels-sur-la-norme-ieee-754">
<span class="next">Rappels sur la norme IEEE 754</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-579405" data-claire-element-id="579405">L'ensemble des <a href="http://fr.wikipedia.org/wiki/Instruction_machine"><strong>instructions machines</strong></a> que peut effectuer un processeur s'appelle son <a href="http://fr.wikipedia.org/wiki/Jeu_d%27instructions"><strong>jeu d'instructions</strong></a>. Ce jeu d'instructions est déterminant quand il s'agit de fournir un support matériel efficace des nombres flottants. Il y a une quarantaine d'années, nos processeurs n'étaient capables de n'utiliser que des nombres entiers et aucune instruction machine ne pouvait manipuler de nombres flottants. On devait alors émuler les calculs sur les flottants par une suite d'instructions machines effectuée sur des entiers. Cette émulation était effectuée par un programme écrit par le développeur d'une application, voire par le système d'exploitation : celui-ci fournissait un certain nombre <a href="http://en.wikipedia.org/wiki/System_call"><strong>d'appels système </strong></a>permettant de simuler des calculs effectués sur des nombres flottants à partir d'entiers. Dans les deux cas, les calculs sur des nombres flottants étaient alors vraiment lents, et la manière de stocker des flottants en mémoire dépendait de l'application ou du système d'exploitation.</p><h2 id="r-instructions-flottantes-micro-codees" data-claire-element-id="579409">Instructions flottantes micro-codées</h2><p id="r-579406" data-claire-element-id="579406">Pour limiter la catastrophe, nos processeurs ont alors incorporé des instructions de calculs sur des nombres flottants. Les premiers processeurs de ce type n'incorporaient néanmoins pas le moindre circuit capable d'effectuer des opérations flottantes. Ceux-ci <strong>micro-codaient les instructions flottantes</strong>.</p><p id="r-579407" data-claire-element-id="579407">Sur ces processeurs, chaque instruction machine capable de gérer des nombres flottants était convertie en interne (c'est-à-dire dans le processeur) en une suite d'instruction entière qui émulait l'instruction voulue.</p><p id="r-579408" data-claire-element-id="579408">Pour ce faire, notre processeur incorpore dans ses circuits une petite <a href="http://fr.wikipedia.org/wiki/Mémoire_morte"><strong>mémoire ROM</strong></a>. Celle-ci stocke, pour chaque instruction qui doit être émulée, une suite d'instructions de base exécutables par les circuits de notre processeur. Lorsqu'une instruction à émuler doit être exécutée, notre processeur se contente de lire la suite d'instructions à exécuter dans la mémoire ROM et l’exécute.</p><h2 id="r-fpu-1" data-claire-element-id="579414">FPU</h2><p id="r-579410" data-claire-element-id="579410"><strong>De </strong>nos jours, les circuits capables de calculer sur des nombres flottants sont intégrés dans le processeur et ne sont pas séparés de celui-ci. Néanmoins, ces circuits sont parfois regroupés ensemble dans une grosse unité de calcul nommée une <strong>Floating Point Unit</strong><strong>Floating Point Unit, aussi appelée FPU</strong>. Ces FPU peuvent effectuer des instructions de calcul assez diverses : addition, multiplication, soustraction, division, racine carrée, logarithmes, exponentielles, tangentes, sinus, cosinus, et d'autres fonctions mathématiques.</p><p id="r-579411" data-claire-element-id="579411">Néanmoins, ce regroupement des circuits calculant sur les nombres flottants n'est pas aussi strict qu'on pourrait le croire. Dans certains cas, les circuits capables d'effectuer les divisions flottantes sont séparés des autres circuits (c'est le cas dans la majorité des PC modernes) : tout dépend de l'architecture interne du processeur utilisé.</p><p id="r-579412" data-claire-element-id="579412">Autre détail : notre processeur contient quasiment toujours des petites mémoires très rapides nommées <strong><a href="http://fr.wikipedia.org/wiki/Registre_(informatique)">registres</a></strong> qui sont utilisées pour stocker temporairement des données que le processeur doit manipuler. Cela permet de stocker des résultats temporaires qui n'ont rien à faire en mémoire, ou encore à accélérer les calculs (ces registres sont des mémoires très rapides).</p><p id="r-579413" data-claire-element-id="579413">Dans certains processeurs, des registres sont spécialement dédiés aux unités de calcul flottantes et ne peuvent stocker que des nombres flottants : ces registres sont alors séparés des registres qui stockent des nombres entiers. Dans ce cas, une instruction entière ne peut être appliquée sur un registre contenant un nombre flottant. Parfois, un processeur peut même utiliser plusieurs registres pour stocker un seul flottant et possède des circuits conçus pour travailler sur les deux registres en même temps ! On peut ainsi supporter des flottants d'une taille plus grande que celle des registres.<br/> Dans d'autres processeurs, les registres ne sont pas dédiés à une unité particulière et peuvent stocker indifféremment des nombres flottants et des nombres entiers.</p><h2 id="r-coprocesseurs-arithmetiques" data-claire-element-id="579417">Coprocesseurs arithmétiques</h2><p id="r-579415" data-claire-element-id="579415">Autrefois, ces FPU n'étaient pas incorporés dans le processeur, mais étaient regroupées dans un processeur séparé du processeur principal de la machine : un emplacement dans la carte mère était réservé à un de ces processeurs spécialisés. On appelait ces processeurs spécialisés dans les calculs flottants des <strong>coprocesseurs arithmétiques</strong>.</p><p id="r-579416" data-claire-element-id="579416">Ces coprocesseurs étaient très chers et relativement peu utilisés. Aussi, seules certaines applications assez rares étaient capables d'en tirer profit : des logiciels de conception assistée par ordinateur, par exemple.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs">Nombres flottants et processeurs</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/prise-en-charge-des-flottants-par-le-hardware">
Prise en charge des flottants par le hardware
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/rappels-sur-la-norme-ieee-754">
Rappels sur la norme IEEE 754
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/exemple-l-architecture-x86">
Exemple : l&#039;architecture x86
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/rappels-sur-la-norme-ieee-754">
<span class="next">Rappels sur la norme IEEE 754</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="RappelssurlanormeIEEE754"></a><h2>Rappels sur la norme IEEE 754</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/prise-en-charge-des-flottants-par-le-hardware">
<span class="arrow"></span>
<span class="next">Prise en charge des flottants par le hardware</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/exemple-l-architecture-x86">
<span class="next">Exemple : l&#039;architecture x86</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-579419" data-claire-element-id="579419">Devant la multiplication des processeurs incorporant des FPU, les concepteurs de processeurs se sont dit qu'il fallait normaliser le stockage des flottants en mémoire ainsi que les résultats des calculs afin que tous les ordinateurs supportent les mêmes flottants et pour que les calculs flottants donnent les mêmes résultats quelque soit l'ordinateur. C'est ainsi qu'est née la <strong>norme IEEE 754</strong>. La norme IEEE 754 normalisant les formats des flottants, la façon dont les arrondis et calculs sont faits, le matériel doit donc être prévu pour si on veut éviter de devoir tout émuler avec des entiers et obtenir des performances correctes.</p><p id="r-579420" data-claire-element-id="579420">La norme IEEE 754 impose diverses choses concernant nos flottants. Elle impose un certain format en mémoire : les flottants doivent être stockés dans la mémoire d'une certaine façon, standardisée par la norme. Elle impose une façon d'organiser les bits de nos nombres flottants en mémoire. Il faut tout de même noter qu'il existe d'autres normes et formats de nombres flottants, moins utilisés. On peut par exemple citer l'<a href="http://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture">IBM floating point architecture</a></p><h2 id="r-nombres-flottants" data-claire-element-id="579516">Nombres flottants</h2><p id="r-579421" data-claire-element-id="579421">La façon utilisée pour écrire nos nombres flottants en binaire est très différente de celle utilisée pour coder des nombres entiers. L'écriture d'un nombre flottant en binaire est basée sur son écriture scientifique.</p><p id="r-579422" data-claire-element-id="579422">Pour rappel, en décimal, l’écriture scientifique d'un nombre consiste à écrire celui-ci comme un produit entre un nombre et une puissance de 10.<br/> Ainsi, un nombre x aura une écriture scientifique en base 10 de la forme :</p><p id="r-579423" data-claire-element-id="579423">a imes 10^{Exposant}</p><p id="r-579424" data-claire-element-id="579424">Notre nombre a est un nombre à virgule dont la valeur est comprise entre 1 et 10 (1 inclus et 10 exclus). Ce nombre a ne possède qu'un seul chiffre à gauche de la virgule : on peut toujours trouver un exposant tel que ce soit le cas.</p><p id="r-579425" data-claire-element-id="579425">En binaire, c'est à peut près la même chose. L'écriture scientifique binaire d'un nombre consiste à écrire celui-ci sous la forme</p><p id="r-579426" data-claire-element-id="579426">a imes 2^{exposant}</p><p id="r-579427" data-claire-element-id="579427">Cette fois-ci on n'utilise plus une puissance de 10 (comme c'était le cas avec la base 10), mais une puissance de 2.<br/> Autre changement : a est un nombre à virgule qui ne possède qu'un seul chiffre à gauche de la virgule, comme en base 10. Le seul truc, c'est qu'en binaire, seuls deux chiffres sont possibles : 0 et 1. Le chiffre de a situé à gauche de la virgule est donc soit un zéro ou un 1.<br/> Si le nombre a est différent de zéro, on peut toujours réussir à transformer notre nombre écrit ainsi en binaire de façon à ce que a ait son chiffre situé à gauche de la virgule qui vaut 1.</p><p id="r-579428" data-claire-element-id="579428">En conséquence, l'écriture scientifique d'un nombre en binaire est donc quelque chose de la forme :</p><p id="r-579429" data-claire-element-id="579429">1 . [partie fractionnaire de a] imes 2^{Exposant}</p><p id="r-579430" data-claire-element-id="579430">Sauf pour quelques exceptions qu'on verra plus tard : le zéro par exemple.</p><p id="r-579431" data-claire-element-id="579431">Pour stocker cette écriture scientifique avec des zéros et des un, il nous faut stocker la partie fractionnaire de notre nombre a, qu'on appelle la <strong>mantisse</strong> et l'<strong>exposant</strong>. On rajoute souvent un <strong>bit de signe</strong> qui sert à calculer le signe du nombre flottant : ce bit vaut 1 si ce nombre est négatif et vaut 0 si notre flottant est positif.</p><table id="r-579448" data-claire-element-id="579448"><thead id="r-579439" data-claire-element-id="579439"><tr id="r-579438" data-claire-element-id="579438"><th id="r-579433" data-claire-element-id="579433"><p id="r-579432" data-claire-element-id="579432">Bit de signe</p></th><th id="r-579435" data-claire-element-id="579435"><p id="r-579434" data-claire-element-id="579434">Exposant</p></th><th id="r-579437" data-claire-element-id="579437"><p id="r-579436" data-claire-element-id="579436">Mantisse</p></th></tr></thead><tbody id="r-579447" data-claire-element-id="579447"><tr id="r-579446" data-claire-element-id="579446"><td id="r-579441" data-claire-element-id="579441"><p id="r-579440" data-claire-element-id="579440">0</p></td><td id="r-579443" data-claire-element-id="579443"><p id="r-579442" data-claire-element-id="579442">0011 0001</p></td><td id="r-579445" data-claire-element-id="579445"><p id="r-579444" data-claire-element-id="579444">111 0000 1101 1001</p></td></tr></tbody></table><p id="r-579449" data-claire-element-id="579449">On calcule la valeur d'un flottant IEEE 754 en utilisant la formule qui suit :</p><p id="r-579450" data-claire-element-id="579450">(-1)^{Signe} imes 1.[mantisse] imes 2^{(Exposant-Decalage)}</p><p id="r-579451" data-claire-element-id="579451">Le décalage est là pour permettre aux flottants de coder des nombres très petits : en effet, pour un exposant plus petit que le décalage, {(Exposant-Decalage)} est négatif, et la puissance de deux correspondante sera un nombre très petit. Multiplié par la mantisse, cela permet de coder des nombres très très petits. Sans ce décalage, on ne pourrait pas coder de nombres très petits.</p><p id="r-579452" data-claire-element-id="579452">Remarquez bien un truc avec la mantisse : on doit lui ajouter 1 pour faire nos calculs avec : ne l'oubliez pas !</p><h3 id="r-exemple-173" data-claire-element-id="579464">Exemple</h3><p id="r-579453" data-claire-element-id="579453">Par exemple, prenons le nombre -3141,5. Celui-ci sera codé par le nombre flottant suivant :</p><table id="r-579462" data-claire-element-id="579462"><tbody id="r-579461" data-claire-element-id="579461"><tr id="r-579460" data-claire-element-id="579460"><td id="r-579455" data-claire-element-id="579455"><p id="r-579454" data-claire-element-id="579454"><strong>1</strong></p></td><td id="r-579457" data-claire-element-id="579457"><p id="r-579456" data-claire-element-id="579456"><strong>1000 1010</strong></p></td><td id="r-579459" data-claire-element-id="579459"><p id="r-579458" data-claire-element-id="579458"><strong>1000 1000 1011 0000 0000 000</strong></p></td></tr></tbody></table><p id="r-579463" data-claire-element-id="579463">Ce nombre flottant utilise 23 bits pour la mantisse, 8 pour l'exposant et un bit de signe. Le décalage utilisé est de 127. Il s'agit d'un des types de flottant supportés par la norme IEEE 754 : le format simple précision.</p><h3 id="r-formats-de-flottants-1" data-claire-element-id="579515">Formats de flottants</h3><p id="r-579465" data-claire-element-id="579465">Cette norme va en effet définir quatre types de flottants différents. Chacun de ces types de flottants pourra stocker plus ou moins de valeurs différentes. Ce qui différencie ces types de flottant, c'est simplement le nombre de bits utilisés pour la mantisse et l'exposant, ainsi que le décalage.</p><p id="r-579466" data-claire-element-id="579466">Voici quelques-uns de ces types de flottants :</p><table id="r-579513" data-claire-element-id="579513"><thead id="r-579478" data-claire-element-id="579478"><tr id="r-579477" data-claire-element-id="579477"><th id="r-579468" data-claire-element-id="579468"><p id="r-579467" data-claire-element-id="579467">Format</p></th><th id="r-579470" data-claire-element-id="579470"><p id="r-579469" data-claire-element-id="579469">Nombre de bits utilisés pour coder un flottant</p></th><th id="r-579472" data-claire-element-id="579472"><p id="r-579471" data-claire-element-id="579471">Nombre de bits de l'exposant</p></th><th id="r-579474" data-claire-element-id="579474"><p id="r-579473" data-claire-element-id="579473">Nombre de bits pour la mantisse</p></th><th id="r-579476" data-claire-element-id="579476"><p id="r-579475" data-claire-element-id="579475">Décalage</p></th></tr></thead><tbody id="r-579512" data-claire-element-id="579512"><tr id="r-579489" data-claire-element-id="579489"><td id="r-579480" data-claire-element-id="579480"><p id="r-579479" data-claire-element-id="579479">Simple précision</p></td><td id="r-579482" data-claire-element-id="579482"><p id="r-579481" data-claire-element-id="579481">32</p></td><td id="r-579484" data-claire-element-id="579484"><p id="r-579483" data-claire-element-id="579483">8</p></td><td id="r-579486" data-claire-element-id="579486"><p id="r-579485" data-claire-element-id="579485">23</p></td><td id="r-579488" data-claire-element-id="579488"><p id="r-579487" data-claire-element-id="579487">127</p></td></tr><tr id="r-579500" data-claire-element-id="579500"><td id="r-579491" data-claire-element-id="579491"><p id="r-579490" data-claire-element-id="579490">Double précision</p></td><td id="r-579493" data-claire-element-id="579493"><p id="r-579492" data-claire-element-id="579492">64</p></td><td id="r-579495" data-claire-element-id="579495"><p id="r-579494" data-claire-element-id="579494">11</p></td><td id="r-579497" data-claire-element-id="579497"><p id="r-579496" data-claire-element-id="579496">52</p></td><td id="r-579499" data-claire-element-id="579499"><p id="r-579498" data-claire-element-id="579498">1023</p></td></tr><tr id="r-579511" data-claire-element-id="579511"><td id="r-579502" data-claire-element-id="579502"><p id="r-579501" data-claire-element-id="579501">Double précision étendue</p></td><td id="r-579504" data-claire-element-id="579504"><p id="r-579503" data-claire-element-id="579503">80 ou plus</p></td><td id="r-579506" data-claire-element-id="579506"><p id="r-579505" data-claire-element-id="579505">15 ou plus</p></td><td id="r-579508" data-claire-element-id="579508"><p id="r-579507" data-claire-element-id="579507">64 ou plus</p></td><td id="r-579510" data-claire-element-id="579510"><p id="r-579509" data-claire-element-id="579509">16383 ou plus</p></td></tr></tbody></table><p id="r-579514" data-claire-element-id="579514">Certains formats de flottants ne sont pas forcément supportés par les unités de calcul de notre processeur. Par exemple, certains ne supportent que les flottants simple précision et rien d'autre. Si un processeur ne supporte pas un format de flottant, il doit émuler son support, généralement par logiciel. Exemple : les premiers processeurs intel ne géraient que les flottants double précision étendue.<br/> De plus, certains processeurs gèrent des formats de flottant spéciaux qui ne font pas partie de la norme IEEE 754, même s'il sont plus rares.</p><h2 id="r-flottants-speciaux" data-claire-element-id="579601">Flottants spéciaux</h2><p id="r-579517" data-claire-element-id="579517">IEEE 754 impose aussi le support de certains nombres flottants spéciaux. Parmi eux, on trouve <strong>l'infini</strong> (aussi bien en négatif qu'en positif), la valeur <strong>NaN</strong> qui est utilisée pour signaler des erreurs ou des calculs n'ayant mathématiquement pas de sens, ou des nombres spéciaux nommés les <strong>dénormaux</strong> qui représentent des valeurs très petites et qui sont utilisés dans des scénarios de calcul assez particuliers.</p><h3 id="r-flottants-denormalises-1" data-claire-element-id="579540">Flottants dénormalisés</h3><p id="r-579518" data-claire-element-id="579518">Pour les dénormaux, aussi appelés flottants dénormalisés, l'exposant auquel on a enlevé le décalage prend la plus petite valeur possible : en clair, l'exposant vaut zéro.<br/> Ces flottants ont une particularité. On calcule leur valeur grâce à la formule suivante :</p><p id="r-579519" data-claire-element-id="579519">(-1)^{signe} imes 0.[mantisse] imes 2^{(Exposant-Decalage)}</p><p id="r-579520" data-claire-element-id="579520">On n'a pas besoin d'ajouter 1 à la mantisse pour calculer avec.</p><table id="r-579537" data-claire-element-id="579537"><thead id="r-579528" data-claire-element-id="579528"><tr id="r-579527" data-claire-element-id="579527"><th id="r-579522" data-claire-element-id="579522"><p id="r-579521" data-claire-element-id="579521">Bit de signe</p></th><th id="r-579524" data-claire-element-id="579524"><p id="r-579523" data-claire-element-id="579523">Exposant</p></th><th id="r-579526" data-claire-element-id="579526"><p id="r-579525" data-claire-element-id="579525">Mantisse</p></th></tr></thead><tbody id="r-579536" data-claire-element-id="579536"><tr id="r-579535" data-claire-element-id="579535"><td id="r-579530" data-claire-element-id="579530"><p id="r-579529" data-claire-element-id="579529">1 ou 0</p></td><td id="r-579532" data-claire-element-id="579532"><p id="r-579531" data-claire-element-id="579531">0</p></td><td id="r-579534" data-claire-element-id="579534"><p id="r-579533" data-claire-element-id="579533">Mantisse différente de zéro</p></td></tr></tbody></table><p id="r-579538" data-claire-element-id="579538">Là encore, ces flottants dénormalisés ne sont pas forcément supportés par certains processeurs. Si le résultat d'un calcul est un nombre dénormalisé, notre processeur va générer ce qu'on appelle une <strong>exception matérielle</strong> : le processeur va interrompre temporairement l’exécution du programme en cours et va exécuter un petit programme capable de traiter l'exception. Dans notre cas, ce programme va émuler logiciellement le traitement de ces dénormaux.</p><p id="r-579539" data-claire-element-id="579539">Mais même lorsque la gestion des dénormaux est implémentée en hardware (comme c'est le cas sur certains processeurs AMD), celle-ci reste malgré tout très lente.</p><h3 id="r-le-zero-2" data-claire-element-id="579560">Le zéro</h3><p id="r-579541" data-claire-element-id="579541">Le zéro est le second de ces flottants spéciaux. Il ressemble un peu aux flottants dénormalisés, à un détail prêt : la mantisse est nulle ! C'est la seule différence avec les autres flottants dénormalisés : l'exposant et bel et bien nul, et on n'a pas besoin d'ajouter 1 à la mantisse pour calculer sa valeur à partir de sa représentation en binaire.</p><table id="r-579558" data-claire-element-id="579558"><thead id="r-579549" data-claire-element-id="579549"><tr id="r-579548" data-claire-element-id="579548"><th id="r-579543" data-claire-element-id="579543"><p id="r-579542" data-claire-element-id="579542">Bit de signe</p></th><th id="r-579545" data-claire-element-id="579545"><p id="r-579544" data-claire-element-id="579544">Exposant</p></th><th id="r-579547" data-claire-element-id="579547"><p id="r-579546" data-claire-element-id="579546">Mantisse</p></th></tr></thead><tbody id="r-579557" data-claire-element-id="579557"><tr id="r-579556" data-claire-element-id="579556"><td id="r-579551" data-claire-element-id="579551"><p id="r-579550" data-claire-element-id="579550">1 ou 0</p></td><td id="r-579553" data-claire-element-id="579553"><p id="r-579552" data-claire-element-id="579552">0</p></td><td id="r-579555" data-claire-element-id="579555"><p id="r-579554" data-claire-element-id="579554">0</p></td></tr></tbody></table><p id="r-579559" data-claire-element-id="579559">Au fait, remarquez que le zéro est codé deux fois à cause du bit de signe. Si vous mettez l'exposant et la mantisse à la bonne valeur de façon à avoir zéro, le bit de signe pourra valoir aussi bien 1 que 0 : on se retrouve avec un -0 et un +0.</p><h3 id="r-l-infini" data-claire-element-id="579579">l'infini !</h3><p id="r-579561" data-claire-element-id="579561">La norme impose la présence de deux flottants représentant respectivement l'infini positif et l'infini négatif. <br/> L'infini (\infty) est codé de la façon suivante :</p><table id="r-579578" data-claire-element-id="579578"><thead id="r-579569" data-claire-element-id="579569"><tr id="r-579568" data-claire-element-id="579568"><th id="r-579563" data-claire-element-id="579563"><p id="r-579562" data-claire-element-id="579562">Bit de signe</p></th><th id="r-579565" data-claire-element-id="579565"><p id="r-579564" data-claire-element-id="579564">Exposant</p></th><th id="r-579567" data-claire-element-id="579567"><p id="r-579566" data-claire-element-id="579566">Mantisse</p></th></tr></thead><tbody id="r-579577" data-claire-element-id="579577"><tr id="r-579576" data-claire-element-id="579576"><td id="r-579571" data-claire-element-id="579571"><p id="r-579570" data-claire-element-id="579570">0 ou 1</p></td><td id="r-579573" data-claire-element-id="579573"><p id="r-579572" data-claire-element-id="579572">Valeur maximale possible de l'exposant</p></td><td id="r-579575" data-claire-element-id="579575"><p id="r-579574" data-claire-element-id="579574">0000 0000 0000 0000 ...</p></td></tr></tbody></table><h3 id="r-nan-1" data-claire-element-id="579600">NaN</h3><p id="r-579580" data-claire-element-id="579580">NaN est l'abréviation de Not A Number, ce qui signifie : n'est pas un nombre. NaN est utilisée pour signaler des erreurs ou des calculs n'ayant mathématiquement pas de sens. Malgré son nom explicite, on peut faire des opérations avec NaN, mais cela ne sert pas vraiment à grand-chose : une opération arithmétique appliquée avec un NaN aura un résultat toujours égal à NaN.</p><p id="r-579581" data-claire-element-id="579581">Voici comment celui-ci est codé :</p><table id="r-579598" data-claire-element-id="579598"><thead id="r-579589" data-claire-element-id="579589"><tr id="r-579588" data-claire-element-id="579588"><th id="r-579583" data-claire-element-id="579583"><p id="r-579582" data-claire-element-id="579582">Bit de signe</p></th><th id="r-579585" data-claire-element-id="579585"><p id="r-579584" data-claire-element-id="579584">Exposant</p></th><th id="r-579587" data-claire-element-id="579587"><p id="r-579586" data-claire-element-id="579586">Mantisse</p></th></tr></thead><tbody id="r-579597" data-claire-element-id="579597"><tr id="r-579596" data-claire-element-id="579596"><td id="r-579591" data-claire-element-id="579591"><p id="r-579590" data-claire-element-id="579590">1 ou 0, c'est au choix</p></td><td id="r-579593" data-claire-element-id="579593"><p id="r-579592" data-claire-element-id="579592">Valeur maximale possible de l'exposant</p></td><td id="r-579595" data-claire-element-id="579595"><p id="r-579594" data-claire-element-id="579594">Différent de zéro</p></td></tr></tbody></table><p id="r-579599" data-claire-element-id="579599">En fait, il existe différents types de NaN, qui différent par la valeur de leur mantisse, ainsi que par les effets qu'ils peuvent avoir. Pour avoir plus de renseignements, voir ce lien : <a href="http://en.wikipedia.org/wiki/NaN">Nan - Wikipédia</a>.</p><h2 id="r-exceptions-et-arrondis-1" data-claire-element-id="579650">Exceptions et arrondis</h2><p id="r-579602" data-claire-element-id="579602">La norme impose aussi une gestion des exceptions (attention, rien à voir avec les exceptions matérielles vues plus haut), qui arrivent lors de calculs particuliers. Ces exceptions correspondant à des erreurs, il est parfois possible de corriger celles-ci de façon à traiter l'erreur. Cette réponse peut être un arrêt de l’exécution du programme, ou un traitement particulier.</p><p id="r-579603" data-claire-element-id="579603">En voici la liste :</p><ul id="r-579614" data-claire-element-id="579614"><li id="r-579605" data-claire-element-id="579605"><p id="r-579604" data-claire-element-id="579604"><em><strong>Invalid operation</strong></em> : opération qui produit un NAN.</p></li><li id="r-579607" data-claire-element-id="579607"><p id="r-579606" data-claire-element-id="579606"><em><strong>Overflow</strong></em> : résultat trop grand pour être stocké dans un flottant. Le plus souvent, on traite l'erreur en arrondissant le résultat vers +\infty.</p></li><li id="r-579609" data-claire-element-id="579609"><p id="r-579608" data-claire-element-id="579608"><em><strong>Underflow</strong></em> : pareil, mais avec un résultat trop petit. Le plus souvent, on traite l'erreur en arrondissant le résultat vers 0.</p></li><li id="r-579611" data-claire-element-id="579611"><p id="r-579610" data-claire-element-id="579610"><strong>Division par zéro</strong>. La réponse la plus courante est de répondre + ou - l'infini.</p></li><li id="r-579613" data-claire-element-id="579613"><p id="r-579612" data-claire-element-id="579612"><strong>Inexact</strong> : le résultat ne peut être représenté par un flottant et on doit l'arrondir.</p></li></ul><p id="r-579615" data-claire-element-id="579615">De temps en temps, le processeur peut être configuré de façon à répondre silencieusement à ces exceptions en fournissant un résultat, mais peut aussi être configuré de façon à déclencher une exception matérielle (à ne pas confondre avec les exceptions de la norme) qui fera remonter l'erreur à un programme qui s'occupera de gérer cette exception, qui corrigera celle-ci.</p><h3 id="r-arrondis-1" data-claire-element-id="579629">Arrondis</h3><p id="r-579616" data-claire-element-id="579616">Pour donner un exemple avec l'exception <em><strong>Inexact</strong></em>, on va prendre le nombre 0.1. Ce nombre ne semble pourtant pas méchant, mais c'est parce qu'il est écrit en décimal.</p><p id="r-579617" data-claire-element-id="579617">En binaire, ce nombre s'écrit comme ceci : 0 \hspace{1mm} . \hspace{1mm} 1100 \hspace{1mm} 1100 \hspace{1mm} 1100 \hspace{1mm} 1100 \hspace{1mm} 1100 \hspace{1mm} 1100... et ainsi de suite jusqu’à l'infini. Notre nombre utilise une infinité de décimales. Bien évidemment, on ne peut pas utiliser une infinité de bits pour stocker notre nombre et on doit impérativement l'arrondir.</p><p id="r-579618" data-claire-element-id="579618">Comme vous le voyez avec la dernière exception, le codage des nombres flottants peut parfois poser problème : dans un ordinateur, il se peut qu'une opération sur deux nombres flottants donne un résultat qui ne peut être codé par un flottant. On est alors obligé d'arrondir ou de tronquer le résultat de façon à le faire rentrer dans un flottant.</p><p id="r-579619" data-claire-element-id="579619">Pour éviter que des ordinateurs différents utilisent des méthodes d'arrondis différentes, on a décidé de normaliser les calculs sur les nombres flottants et les méthodes d'arrondis. Pour cela, la norme impose le support de quatre modes d'arrondis :</p><ul id="r-579628" data-claire-element-id="579628"><li id="r-579621" data-claire-element-id="579621"><p id="r-579620" data-claire-element-id="579620"><strong>Arrondir vers + l'infini</strong>,</p></li><li id="r-579623" data-claire-element-id="579623"><p id="r-579622" data-claire-element-id="579622"><strong>vers - l'infini</strong>,</p></li><li id="r-579625" data-claire-element-id="579625"><p id="r-579624" data-claire-element-id="579624"><strong>vers zéro</strong></p></li><li id="r-579627" data-claire-element-id="579627"><p id="r-579626" data-claire-element-id="579626"><strong>vers le nombre flottant le plus proche</strong>.</p></li></ul><h3 id="r-autres-exceptions" data-claire-element-id="579649">Autres exceptions</h3><p id="r-579630" data-claire-element-id="579630">L'exception <em><strong>Invalid operation</strong></em> est levée dans deux cas :</p><ul id="r-579635" data-claire-element-id="579635"><li id="r-579632" data-claire-element-id="579632"><p id="r-579631" data-claire-element-id="579631">des calculs ayant un résultat qui est un nombre complexe : \hspace*{1mm} \sqrt {-1} \hspace{1mm} , \ln (-5), et autres.</p></li><li id="r-579634" data-claire-element-id="579634"><p id="r-579633" data-claire-element-id="579633">le calcul est une <a href="http://fr.wikipedia.org/wiki/Opérations_sur_les_limites%23Formes_ind.C3.A9termin.C3.A9es">forme indéterminée</a></p></li></ul><p id="r-579636" data-claire-element-id="579636">Pour ceux qui ne savent pas trop ce que sont les formes indéterminées, voici en exclusivité la liste des calculs qui retournent NaN :</p><ul id="r-579647" data-claire-element-id="579647"><li id="r-579638" data-claire-element-id="579638"><p id="r-579637" data-claire-element-id="579637">\frac {0} {0}</p></li><li id="r-579640" data-claire-element-id="579640"><p id="r-579639" data-claire-element-id="579639">\infty \hspace*{1mm} / \hspace*{1mm} \infty</p></li><li id="r-579642" data-claire-element-id="579642"><p id="r-579641" data-claire-element-id="579641">(+\infty) \hspace*{1mm} - \hspace*{1mm} (+\infty) \hspace*{1mm} ;</p></li><li id="r-579644" data-claire-element-id="579644"><p id="r-579643" data-claire-element-id="579643">0 \hspace*{1mm} imes \hspace*{1mm} \infty et \infty \hspace*{1mm} imes \hspace*{1mm} 0</p></li><li id="r-579646" data-claire-element-id="579646"><p id="r-579645" data-claire-element-id="579645">dans certains cas,\hspace*{1mm} 0^{0} \hspace*{1mm} , \hspace*{1mm} 1^{\infty} \hspace*{1mm}, et \hspace*{1mm} \infty ^{0} \hspace*{1mm}</p></li></ul><p id="r-579648" data-claire-element-id="579648">Les <em><strong>overflow</strong></em> et <strong><em>underflow</em></strong> sont beaucoup plus rares : un nombre flottant peu contenir aussi bien de nombres très grands que des nombres très petits. Par exemple, un flottant simple précision peut stocker des nombres pouvant aller jusqu’à 3.4028234 imes 10^{38} : difficile d'obtenir un <em>overflow</em> dans ces conditions.</p><h2 id="r-calculs-standards" data-claire-element-id="579666">Calculs standards</h2><p id="r-579651" data-claire-element-id="579651">IEEE 754 standardise aussi quelques instructions sur les flottants qui doivent impérativement être supportées :</p><ul id="r-579664" data-claire-element-id="579664"><li id="r-579653" data-claire-element-id="579653"><p id="r-579652" data-claire-element-id="579652">l'addition <code data-claire-semantic="c">+</code>,</p></li><li id="r-579655" data-claire-element-id="579655"><p id="r-579654" data-claire-element-id="579654">la multiplication <code data-claire-semantic="c">*</code>,</p></li><li id="r-579657" data-claire-element-id="579657"><p id="r-579656" data-claire-element-id="579656">la soustraction <code data-claire-semantic="c">-</code>,</p></li><li id="r-579659" data-claire-element-id="579659"><p id="r-579658" data-claire-element-id="579658">la division <code data-claire-semantic="c">/</code>,</p></li><li id="r-579661" data-claire-element-id="579661"><p id="r-579660" data-claire-element-id="579660">la racine carrée <code data-claire-semantic="c">sqrt</code>.</p></li><li id="r-579663" data-claire-element-id="579663"><p id="r-579662" data-claire-element-id="579662">et les différentes comparaisons <code data-claire-semantic="c">&gt;, &lt;, &gt;=, &lt;=, ==, !=</code>.</p></li></ul><p id="r-579665" data-claire-element-id="579665">Le support de ces instructions est souvent matériel : le processeur possède souvent des instructions machines capables d'effectuer des comparaisons, additions, soustractions, multiplications, divisions et racine carrées. De nos jours, ces instructions sont directement câblées dans les circuits du processeur et ne sont plus émulées, sauf pour quelques-unes. Le choix du mode d'arrondi ou la gestion des exceptions sont implémentés directement dans le matériel et sont souvent configurables grâce à un registre du processeur : suivant la valeur mise dans celui-ci, le processeur arrondira les résultats des calculs d'une certaine façon et pas d'une autre, ou réagira d'une certaine manière aux exceptions vues au-dessus.</p><h2 id="r-processeur-et-norme-ieee-754" data-claire-element-id="579669">Processeur et norme IEEE 754</h2><p id="r-579667" data-claire-element-id="579667">Il faut néanmoins préciser que le support de la norme IEEE 754 n'est pas une obligation : certains processeurs s'en moquent royalement. Dans certaines applications, la précision des calculs flottants n'est pas indispensable, et les programmeurs ont souvent besoin d'avoir des calculs qui s'effectuent rapidement : de telles situations nécessitent des calculs flottants rapides et se contentent très bien d'un résultat approché. Dans ces situations, on peut utiliser des formats de flottants différents de la norme IEEE 754 et les circuits de la FPU sont simplifiés pour être plus rapides. Par exemple, certains circuits ne gèrent pas les <em>underflow</em>, <em>overflow</em>, les NaN ou les infinis, voir utilisent des formats de flottants exotiques.</p><p id="r-579668" data-claire-element-id="579668">De plus, certaines architectures supportent la norme IEEE 754, mais ont besoin que le compilateur ou les programmes fassent quelques manipulations pour que les calculs effectués avec des flottants respectent la norme IEEE 754. Tout dépend des instructions machines que le compilateur utilise. Par exemple, certains processeurs implémentent non seulement les instructions de la norme, mais aussi d'autres instructions sur les flottants qui ne sont pas supportées par la norme IEEE 754. Par exemple, certaines fonctions mathématiques telles que sinus, cosinus, tangente, arctangente et d'autres, sont supportées par certaines FPU. Le seul problème, c'est que ces instructions peuvent mener à des erreurs de calcul. Or, certaines de ces instructions sont parfois utilisées par certains compilateurs, ce qui peut produire des erreurs de calcul incompatibles avec la norme IEEE 754.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs">Nombres flottants et processeurs</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/prise-en-charge-des-flottants-par-le-hardware">
Prise en charge des flottants par le hardware
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/rappels-sur-la-norme-ieee-754">
Rappels sur la norme IEEE 754
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/exemple-l-architecture-x86">
Exemple : l&#039;architecture x86
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/prise-en-charge-des-flottants-par-le-hardware">
<span class="arrow"></span>
<span class="next">Prise en charge des flottants par le hardware</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/exemple-l-architecture-x86">
<span class="next">Exemple : l&#039;architecture x86</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Exemplel039architecturex86"></a><h2>Exemple : l&#039;architecture x86</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/rappels-sur-la-norme-ieee-754">
<span class="arrow"></span>
<span class="next">Rappels sur la norme IEEE 754</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-579671" data-claire-element-id="579671">Voyons maintenant ce qu'il en est pour les processeurs basés sur <strong>l'architecture x86</strong>. Pour rappel, ces processeurs sont ceux qui sont présents à l'intérieur de nos PC : tous les processeurs Intel et AMD actuels sont des processeurs basés sur l'architecture x86. Ceux-ci peuvent très bien se passer complètement de FPU : celle-ci n'est rien d'autre qu'une option qui a été rajoutée au cours de l'existence de l'architecture. Néanmoins, de nos jours, tous les processeurs x86 présents dans nos PC possèdent au moins une FPU. Oui, j'ai dit au moins une, car certains processeurs récents possèdent une unité de calcul spécialisée dans les calculs multimédia qui est aussi capable de travailler sur des nombres flottants : l'unité SSE.</p><h2 id="r-fpu-x87" data-claire-element-id="579884">FPU x87</h2><p id="r-579672" data-claire-element-id="579672">Tous les processeurs x86 capables de manipuler des flottants comportent une FPU de base, capable d’effectuer des opérations sur les flottants. L'ensemble des instructions machines supportées par cette unité s'appelle le <strong>jeu d'instruction x87</strong>. En conséquence, cette FPU est couramment appelée la <strong>FPU x87</strong>.</p><p id="r-579673" data-claire-element-id="579673">La FPU x87 est la FPU qui est utilisée par défaut sur les PC x86 32 bits. Par contre, avec le jeu d'instruction x86-64 bits, l'unité SSE est celle qui est utilisée de base pour calculer sur les nombres flottants, l'unité x87 étant souvent inutilisée.</p><p id="r-579674" data-claire-element-id="579674">Cette unité de calcul incorpore</p><ul id="r-579681" data-claire-element-id="579681"><li id="r-579676" data-claire-element-id="579676"><p id="r-579675" data-claire-element-id="579675">8 registres de données capables de stocker un nombre flottant chacun,</p></li><li id="r-579678" data-claire-element-id="579678"><p id="r-579677" data-claire-element-id="579677">3 registres d'état chargés de stocker des bits utiles pour configurer la FPU,</p></li><li id="r-579680" data-claire-element-id="579680"><p id="r-579679" data-claire-element-id="579679">et un registre interne à la FPU utilisé pour gérer les exceptions flottantes, auquel seul le processeur a accès.</p></li></ul><h3 id="r-pile-de-registre" data-claire-element-id="579694">Pile de registre</h3><p id="r-579682" data-claire-element-id="579682">Les registres de l'unité x87 sont gérés d'une manière assez inédite : ceux-ci forment ce qu'on appelle une <strong>pile de registres</strong>. Les processeurs qui gèrent leurs registres de cette manière sont très rares. Il faut aussi préciser que les autres unités de calcul d'un processeur x86 gèrent leurs registres différemment. Mais voyons un peu ce que cette pile de registres a de particulier.</p><p id="r-579683" data-claire-element-id="579683">Si vous souhaitez stocker un flottant dans un registre, vous ne pouvez pas décider dans quel registre celui-ci sera stocké : nos registres sont en effet organisés sous la forme d'une pile de registre que l'on remplit dans un ordre bien précis.</p><p id="r-579684" data-claire-element-id="579684">Tout d'abord, ces 8 registres sont ordonnés et numérotés de 0 à 7 : le premier registre est le registre 7, tandis que le dernier registre est le registre 0. Lorsque la FPU x87 est initialisée, ces 8 registres sont complètement vides : ils ne contiennent aucun flottant.</p><p id="r-579685" data-claire-element-id="579685">Si on veut ajouter des flottants dans nos registres, on doit les &quot;remplir&quot; dans un ordre de remplissage imposé : on remplit d'abord le registre 7, puis le 6, puis le 5, et ainsi de suite jusqu’au registre 0. Si on veut ajouter un flottant dans cette pile de registre, celui-ci sera stocké dans le premier registre vide dans l'ordre de remplissage indiqué au-dessus. Prenons un exemple, les 3 premiers registres sont occupés par un flottant et on veut charger un flottant supplémentaire : le 4éme registre sera utilisé pour stocker ce flottant.</p><figure id="r-579687" data-claire-element-id="579688"><img id="r-579686" data-claire-element-id="579686" src="medias/uploads.siteduzero.com_files_324001_325000_324171.png" alt="Image utilisateur"/></figure><p id="r-579689" data-claire-element-id="579689">La même chose existe pour le &quot;dé-remplissage&quot; des registres. Imaginez que vous souhaitez déplacer le contenu d'un registre dans la mémoire RAM et effacer complètement son contenu. On ne peut pas choisir n'importe quel registre pour faire cela : on est obligé de prendre le registre non-vide ayant le numéro le plus grand.</p><figure id="r-579691" data-claire-element-id="579692"><img id="r-579690" data-claire-element-id="579690" src="medias/uploads.siteduzero.com_files_324001_325000_324542.png" alt="Image utilisateur"/></figure><p id="r-579693" data-claire-element-id="579693">Vous remarquerez sûrement que ce flottant est le dernier à avoir été dans cette &quot;pile&quot; de registre. Notre pile de registre est donc gérée par un algorithme de type LIFO : <em>Last Input First Output</em> : dernier entré, premier sorti.</p><h3 id="r-registres-de-controle-et-de-statut" data-claire-element-id="579789">Registres de contrôle et de statut</h3><p id="r-579695" data-claire-element-id="579695">Si vous avez bonne mémoire, vous vous souvenez surement de ce que j'ai dit sur les registres de la FPU : elle contient 3 registres spéciaux qui ne stockent pas de flottants mais sont malgré tout utiles. Ces 3 registres portent chacun un nom : <strong>Control Word</strong>, <strong>Status Word</strong> et <strong>Tag Word</strong>. Voilà, les présentations sont faites ! :D</p><p id="r-579696" data-claire-element-id="579696">On va commencer par vous détailler le registre <strong>Tag Word</strong>. Celui-ci est utilisé par le processeur pour savoir si un registre est vide ou non : avouez que c'est pratique pour gérer la pile de registre vue au-dessus. Ce registre contient 16 bits et pour chacun des 8 registres de donnée de la FPU, 2 bits sont réservés dans le registre Tag Word. Ces deux bits contiennent des informations sur le contenu du registre de donnée réservé.</p><ul id="r-579705" data-claire-element-id="579705"><li id="r-579698" data-claire-element-id="579698"><p id="r-579697" data-claire-element-id="579697">Si ces deux bits valent 00, le registre contient un flottant &quot;normal&quot; différent de zéro</p></li><li id="r-579700" data-claire-element-id="579700"><p id="r-579699" data-claire-element-id="579699">Si ces deux bits valent 01, le registre contient une valeur nulle : <strong>0</strong></p></li><li id="r-579702" data-claire-element-id="579702"><p id="r-579701" data-claire-element-id="579701">Si ces deux bits valent 10, le registre contient un NAN, un infini, ou un dénormal</p></li><li id="r-579704" data-claire-element-id="579704"><p id="r-579703" data-claire-element-id="579703">Si ces deux bits valent 11, le registre est vide et ne contient pas de nombre flottant</p></li></ul><p id="r-579706" data-claire-element-id="579706">Passons maintenant au <strong>Status Word</strong>. Celui-ci fait lui aussi 16 bits et chacun de ces bits a une utilité particulière. On ne va en citer que quelques-uns.</p><table id="r-579744" data-claire-element-id="579744"><thead id="r-579712" data-claire-element-id="579712"><tr id="r-579711" data-claire-element-id="579711"><th id="r-579708" data-claire-element-id="579708"><p id="r-579707" data-claire-element-id="579707">Bit</p></th><th id="r-579710" data-claire-element-id="579710"><p id="r-579709" data-claire-element-id="579709">Utilité</p></th></tr></thead><tbody id="r-579743" data-claire-element-id="579743"><tr id="r-579717" data-claire-element-id="579717"><td id="r-579714" data-claire-element-id="579714"><p id="r-579713" data-claire-element-id="579713"><strong>TOP</strong></p></td><td id="r-579716" data-claire-element-id="579716"><p id="r-579715" data-claire-element-id="579715">Ce registre contient trois bits regroupés en un seul ensemble nommé TOP, qui stocke le numéro du premier registre vide dans l'ordre de remplissage. Idéal pour gérer notre pile de registres</p></td></tr><tr id="r-579722" data-claire-element-id="579722"><td id="r-579719" data-claire-element-id="579719"><p id="r-579718" data-claire-element-id="579718"><strong>U</strong></p></td><td id="r-579721" data-claire-element-id="579721"><p id="r-579720" data-claire-element-id="579720">Sert à détecter les underflow. Il est mis à 1 lorsqu'un underflow a lieu.</p></td></tr><tr id="r-579727" data-claire-element-id="579727"><td id="r-579724" data-claire-element-id="579724"><p id="r-579723" data-claire-element-id="579723"><strong>O</strong></p></td><td id="r-579726" data-claire-element-id="579726"><p id="r-579725" data-claire-element-id="579725">Pareil que U mais pour les overflow : ce registre est mis à 1 lors d'un overflow.</p></td></tr><tr id="r-579732" data-claire-element-id="579732"><td id="r-579729" data-claire-element-id="579729"><p id="r-579728" data-claire-element-id="579728"><strong>Z</strong></p></td><td id="r-579731" data-claire-element-id="579731"><p id="r-579730" data-claire-element-id="579730">C'est un bit qui est mis à 1 lorsque notre FPU exécute une division par zéro</p></td></tr><tr id="r-579737" data-claire-element-id="579737"><td id="r-579734" data-claire-element-id="579734"><p id="r-579733" data-claire-element-id="579733"><strong>D</strong></p></td><td id="r-579736" data-claire-element-id="579736"><p id="r-579735" data-claire-element-id="579735">Ce bit est est mis à 1 lorsqu'un résultat de calcul est un dénormal ou lorsqu'une instruction doit être exécutée sur un dénormal</p></td></tr><tr id="r-579742" data-claire-element-id="579742"><td id="r-579739" data-claire-element-id="579739"><p id="r-579738" data-claire-element-id="579738"><strong>I</strong></p></td><td id="r-579741" data-claire-element-id="579741"><p id="r-579740" data-claire-element-id="579740">Bit mis à 1 lors de certaines erreurs telle l’exécution d'une instruction de racine carrée sur un négatif ou une division du type 0/0</p></td></tr></tbody></table><p id="r-579745" data-claire-element-id="579745">Comme vous le voyez, le <strong>Status Word</strong> contient tout ce qu'il faut pour qu'un programme puisse comprendre la cause d'une exception.</p><p id="r-579746" data-claire-element-id="579746">Enfin, voyons le <strong>Control Word</strong>, le petit dernier. Celui fait toujours 16 bits et contient lui aussi des bits ayant chacun une utilité précise. Beaucoup de bits de ce registre sont inutilisés et on ne va citer que les plus utiles.</p><table id="r-579788" data-claire-element-id="579788"><thead id="r-579752" data-claire-element-id="579752"><tr id="r-579751" data-claire-element-id="579751"><th id="r-579748" data-claire-element-id="579748"><p id="r-579747" data-claire-element-id="579747">Bit</p></th><th id="r-579750" data-claire-element-id="579750"><p id="r-579749" data-claire-element-id="579749">Utilité</p></th></tr></thead><tbody id="r-579787" data-claire-element-id="579787"><tr id="r-579757" data-claire-element-id="579757"><td id="r-579754" data-claire-element-id="579754"><p id="r-579753" data-claire-element-id="579753">Infinity Control</p></td><td id="r-579756" data-claire-element-id="579756"><p id="r-579755" data-claire-element-id="579755">S'il vaut zéro, les infinis sont tous traités comme s'ils valaient +\infty.<br/> S'il vaut un, les infinis sont traités normalement.</p></td></tr><tr id="r-579771" data-claire-element-id="579771"><td id="r-579759" data-claire-element-id="579759"><p id="r-579758" data-claire-element-id="579758">Rouding Control</p></td><td id="r-579770" data-claire-element-id="579770"><p id="r-579760" data-claire-element-id="579760">C'est un ensemble de deux bits qui détermine le mode d'arrondi utilisé</p><ul id="r-579769" data-claire-element-id="579769"><li id="r-579762" data-claire-element-id="579762"><p id="r-579761" data-claire-element-id="579761">00 : <strong>vers le nombre flottant le plus proche</strong> : c'est la valeur par défaut.</p></li><li id="r-579764" data-claire-element-id="579764"><p id="r-579763" data-claire-element-id="579763">01 : <strong>vers - l'infini</strong>,</p></li><li id="r-579766" data-claire-element-id="579766"><p id="r-579765" data-claire-element-id="579765">10 : <strong>vers + l'infini</strong>,</p></li><li id="r-579768" data-claire-element-id="579768"><p id="r-579767" data-claire-element-id="579767">11 : <strong>vers zéro</strong></p></li></ul></td></tr><tr id="r-579786" data-claire-element-id="579786"><td id="r-579773" data-claire-element-id="579773"><p id="r-579772" data-claire-element-id="579772">Precision Control</p></td><td id="r-579785" data-claire-element-id="579785"><p id="r-579774" data-claire-element-id="579774">Ensemble de deux bits qui détermine la taille de la mantisse de l'arrondi du résultat d'un calcul. En effet, on peut demander à notre FPU d'arrondir le résultat de chaque calcul qu'elle effectue. Cette instruction ne touche pas à l'exposant, mais seulement à la mantisse.</p><ul id="r-579783" data-claire-element-id="579783"><li id="r-579776" data-claire-element-id="579776"><p id="r-579775" data-claire-element-id="579775">00 : mantisse codée sur 24 bits</p></li><li id="r-579778" data-claire-element-id="579778"><p id="r-579777" data-claire-element-id="579777">01 : valeur inutilisée</p></li><li id="r-579780" data-claire-element-id="579780"><p id="r-579779" data-claire-element-id="579779">10 : mantisse codée sur 53 bits</p></li><li id="r-579782" data-claire-element-id="579782"><p id="r-579781" data-claire-element-id="579781">11 : mantisse codée sur 64 bits</p></li></ul><p id="r-579784" data-claire-element-id="579784">La valeur par défaut de ces deux bits est 11 : notre FPU utilise donc des flottants double précision étendue. Les valeurs 00 et 10 demandent au processeur d'utiliser des flottants non-pris en compte par la norme IEEE 754.</p></td></tr></tbody></table><h3 id="r-instructions-x87" data-claire-element-id="579854">Instructions x87</h3><p id="r-579790" data-claire-element-id="579790">Notre FPU est capable d'effectuer un certain nombre d'instructions sur ces registres : les instructions de base supportées par la norme IEEE 754. Mais elle est aussi capable d'en effectuer d'autres.</p><p id="r-579791" data-claire-element-id="579791">La FPU x87 dispose d'instructions de comparaisons compatibles avec la norme IEEE 754, capables de comparer le flottant au sommet de la pile avec un autre nombre qui peut être flottant ou entier ! <br/> Voici une liste de quelques instructions de comparaisons supportées par les FPU 87 :</p><ul id="r-579800" data-claire-element-id="579800"><li id="r-579793" data-claire-element-id="579793"><p id="r-579792" data-claire-element-id="579792"><code data-claire-semantic="nasm">FCOM</code> : compare le contenu du registre 0 avec une constante flottante</p></li><li id="r-579795" data-claire-element-id="579795"><p id="r-579794" data-claire-element-id="579794"><code data-claire-semantic="nasm">FCOMI</code> : compare le contenu des registres 0 et 1.</p></li><li id="r-579797" data-claire-element-id="579797"><p id="r-579796" data-claire-element-id="579796"><code data-claire-semantic="nasm">FICOM</code> : compare le contenu du registre 0 avec une constante entière</p></li><li id="r-579799" data-claire-element-id="579799"><p id="r-579798" data-claire-element-id="579798"><code data-claire-semantic="nasm">FTST</code> compare le registre numéroté 0 avec la valeur 0</p></li></ul><p id="r-579801" data-claire-element-id="579801">On trouve aussi des instructions de calculs, bien évidemment compatibles avec la norme IEE754.</p><ul id="r-579814" data-claire-element-id="579814"><li id="r-579803" data-claire-element-id="579803"><p id="r-579802" data-claire-element-id="579802">L'addition : <code data-claire-semantic="nasm">FADD</code></p></li><li id="r-579805" data-claire-element-id="579805"><p id="r-579804" data-claire-element-id="579804">la soustraction <code data-claire-semantic="nasm">FSUB</code></p></li><li id="r-579807" data-claire-element-id="579807"><p id="r-579806" data-claire-element-id="579806">la multiplication <code data-claire-semantic="nasm">FMUL</code></p></li><li id="r-579809" data-claire-element-id="579809"><p id="r-579808" data-claire-element-id="579808">la division <code data-claire-semantic="nasm">FDIV</code></p></li><li id="r-579811" data-claire-element-id="579811"><p id="r-579810" data-claire-element-id="579810">la racine carrée <code data-claire-semantic="nasm">FSQRT</code></p></li><li id="r-579813" data-claire-element-id="579813"><p id="r-579812" data-claire-element-id="579812">Des instructions de calcul de la valeur absolue (<code data-claire-semantic="nasm">FABS</code>) ou encore de changement de signe (<code data-claire-semantic="nasm">FCHS</code>)</p></li></ul><p id="r-579815" data-claire-element-id="579815">Notre FPU implémente aussi des instructions non-prévues dans la norme IEE754 telles que</p><ul id="r-579826" data-claire-element-id="579826"><li id="r-579817" data-claire-element-id="579817"><p id="r-579816" data-claire-element-id="579816">le cosinus : instruction <code data-claire-semantic="nasm">FCOS</code>,</p></li><li id="r-579819" data-claire-element-id="579819"><p id="r-579818" data-claire-element-id="579818">le sinus :instruction <code data-claire-semantic="nasm">FSIN</code>,</p></li><li id="r-579821" data-claire-element-id="579821"><p id="r-579820" data-claire-element-id="579820">la tangente : instruction <code data-claire-semantic="nasm">FPTAN</code>,</p></li><li id="r-579823" data-claire-element-id="579823"><p id="r-579822" data-claire-element-id="579822">l'arctangente : instruction <code data-claire-semantic="nasm">FPATAN</code>,</p></li><li id="r-579825" data-claire-element-id="579825"><p id="r-579824" data-claire-element-id="579824">ou encore des instructions de calcul de logarithmes ou d’exponentielles.</p></li></ul><p id="r-579827" data-claire-element-id="579827">Il va de soi que ces instructions ne sont pas supportées par la norme IEEE 754 et que tout compilateur qui souhaite être compatible avec la norme IEEE 754 ne doit pas utiliser ces instructions de calcul non-supportées.</p><p id="r-579828" data-claire-element-id="579828">Les instructions de calcul n'ayant besoin que d'un seul flottant pour s’exécuter (les instructions de calcul d'une tangente, d'une racine carrée et d'autres) vont utiliser le flottant situé au sommet de la pile. Les instructions qui ont besoin de deux flottants (multiplication, addition, soustraction et autres) vont agir différemment suivant la situation. Elles peuvent prendre les deux flottants les plus haut placés dans cette pile, prendre le flottant au sommet de la pile, utiliser une donnée en provenance de la mémoire, ou encore utiliser le flottant le plus haut placé et un flottant stocké dans l'importe quel registre de cette pile de registres.</p><p id="r-579829" data-claire-element-id="579829">En plus de ces instructions de calcul, notre FPU possède des instructions permettant de transférer des flottants entre la mémoire et les registres, ou entre registres. On peut citer par exemple</p><table id="r-579852" data-claire-element-id="579852"><thead id="r-579835" data-claire-element-id="579835"><tr id="r-579834" data-claire-element-id="579834"><th id="r-579831" data-claire-element-id="579831"><p id="r-579830" data-claire-element-id="579830">Instruction</p></th><th id="r-579833" data-claire-element-id="579833"><p id="r-579832" data-claire-element-id="579832">Ce qu'elle fait</p></th></tr></thead><tbody id="r-579851" data-claire-element-id="579851"><tr id="r-579840" data-claire-element-id="579840"><td id="r-579837" data-claire-element-id="579837"><p id="r-579836" data-claire-element-id="579836"><code data-claire-semantic="nasm">FLD</code></p></td><td id="r-579839" data-claire-element-id="579839"><p id="r-579838" data-claire-element-id="579838">Elle est capable de charger un nombre flottant depuis la mémoire vers notre pile de registres vue au-dessus. Cette instruction peut charger un flottant codé sur 32 bits, 64 bits ou 80 bits.</p></td></tr><tr id="r-579845" data-claire-element-id="579845"><td id="r-579842" data-claire-element-id="579842"><p id="r-579841" data-claire-element-id="579841"><code data-claire-semantic="nasm">FSTP</code></p></td><td id="r-579844" data-claire-element-id="579844"><p id="r-579843" data-claire-element-id="579843">Déplace le contenu d'un registre vers la mémoire.<br/> Une autre instruction existe qui est capable de copier le contenu d'un registre vers la mémoire sans effacer le contenu du registre : c'est l'instruction <code data-claire-semantic="nasm">FST</code>.</p></td></tr><tr id="r-579850" data-claire-element-id="579850"><td id="r-579847" data-claire-element-id="579847"><p id="r-579846" data-claire-element-id="579846"><code data-claire-semantic="nasm">FXCH</code></p></td><td id="r-579849" data-claire-element-id="579849"><p id="r-579848" data-claire-element-id="579848">Échange le contenu du dernier registre non-vide dans l'ordre de remplissage (celui situé au sommet de la pile) avec un autre registre.</p></td></tr></tbody></table><p id="r-579853" data-claire-element-id="579853">D'autres instructions existent qui chargent certaines constantes (PI, 1, 0, certains logarithmes en base 2) dans le registre au sommet de la pile de registre.</p><h3 id="r-double-rounding" data-claire-element-id="579883"><em>Double Rounding</em></h3><p id="r-579855" data-claire-element-id="579855">Chacun des registres de données vus plus haut stocke un nombre flottant codé sur 80bits. Oui, vous avez bien lu, 80 bits et non 32 ou 64 : cette FPU calcule sur des nombres flottants double précision étendue et non sur des flottants simple ou double précision, qui ne sont pas gérés par la FPU x87.</p><div id="r-579857" data-claire-element-id="579857" data-claire-semantic="question"><p id="r-579856" data-claire-element-id="579856">Mais comment cette FPU fait-elle pour calculer avec des flottants simple et double précision ?</p></div><p id="r-579858" data-claire-element-id="579858">Tout se joue lors de l’accès à la mémoire avec l'instruction <code data-claire-semantic="nasm">FLD</code> : celle-ci se comporte différemment suivant le flottant qu'on lui demande de charger. En effet, cette instruction peut charger depuis la mémoire un flottant simple précision, double précision ou double précision étendue. Le format du flottant qui doit être chargé est stocké directement dans l'instruction. Je m'explique : une instruction machine est stockée en mémoire sous la forme d'une suite de bits, et pour certaines instructions, des bits supplémentaires sont ajoutés. Dans notre cas, ces bits optionnels servent à indiquer à notre instruction le format du flottant qu'elle doit charger.</p><p id="r-579859" data-claire-element-id="579859">La FPU x87 peut charger depuis la mémoire un nombre flottant 80 bits directement dans un registre. Pour les flottants 32 et 64 bits, la FPU va devoir effectuer une conversion de notre flottant simple ou double précision en un flottant 80bits. Tous les calculs faits par notre FPU vont donner des résultats codés sur 80bits, et ceux-ci restent codés sur 80 bits tant que ceux-ci sont stockés dans les registres de la FPU. Par contre, dès qu'il faut enregistrer un nombre flottant en mémoire RAM, les problèmes commencent. Si le flottant en question est stocké dans la mémoire sur 32 ou 64 bits, notre processeur doit convertir le contenu du registre dans le format du flottant en mémoire, histoire de conserver le bon format de base. Cette conversion est faite automatiquement par l'instruction d'écriture en mémoire utilisée. Par contre, si notre flottant est représenté en mémoire sur 80bits, l'écriture en mémoire est directe : pas de conversion.</p><p id="r-579860" data-claire-element-id="579860">Et ces conversions posent problème : elles ne respectent pas la norme IEEE 754 !</p><p id="r-579861" data-claire-element-id="579861">Comparons un calcul effectué sur un processeur gérant nativement les formats 64 et 32 bits et ce même calcul exécuté par la x87. Sur le premier processeur, le calcul sera effectué sur des flottants simple ou double précision. Notre processeur va faire ses calculs sur notre flottant directement dans ses registres.</p><figure id="r-579863" data-claire-element-id="579864"><img id="r-579862" data-claire-element-id="579862" src="medias/uploads.siteduzero.com_files_324001_325000_324467.png" alt="Image utilisateur"/></figure><p id="r-579865" data-claire-element-id="579865">On se retrouve donc avec deux cas de figure :</p><ul id="r-579870" data-claire-element-id="579870"><li id="r-579867" data-claire-element-id="579867"><p id="r-579866" data-claire-element-id="579866">Si un des résultats de ces calculs est un flottant, celui-ci sera directement codé sur 32 ou 64 bits sans arrondi.</p></li><li id="r-579869" data-claire-element-id="579869"><p id="r-579868" data-claire-element-id="579868">Par contre, si un de ces résultats n'est pas un flottant, celui-ci sera arrondi de façon à donner un résultat qui peut être contenu dans un flottant 32/64 bits. On a donc un seul arrondi : celui qui arrive lors des calculs.</p></li></ul><p id="r-579871" data-claire-element-id="579871">Avec la x87, le scénario est différent. Nos flottants 32/64 bits sont convertis en un flottant x87 80 bits lorsque l'on charge ceux-ci depuis la mémoire. Le calcul est ensuite effectué sur des flottants 80 bits. Là encore, le résultat est soit un flottant x87, soit est arrondi pour donner un flottant x87.<br/> Maintenant, si vous voulez enregistrer ce flottant x87 80 bits dans la mémoire, il va falloir convertir celui-ci dans son format de base : 32 ou 64 bits. Notre résultat se fait arrondir au flottant 32 ou 64 bits le plus proche. On se retrouve donc avec un arrondi supplémentaire : c'est le phénomène du <em><strong>double rouding</strong></em> (qui signifie double arrondi en français).</p><figure id="r-579873" data-claire-element-id="579874"><img id="r-579872" data-claire-element-id="579872" src="medias/uploads.siteduzero.com_files_324001_325000_324468.png" alt="Image utilisateur"/></figure><p id="r-579875" data-claire-element-id="579875">Et rien n'implique que le résultat de ces deux conversions aurait donné le même résultat que le calcul effectué sur des flottants 64 bits avec un seul éventuel arrondi ! Le pire, c'est qu'on aucune solution à ce problème, pour les calculs faits avec la FPU x87.</p><p id="r-579876" data-claire-element-id="579876">Pour citer un exemple, sachez que des failles de sécurité de PHP et de Java aujourd’hui corrigés et <a href="http://web.developpez.com/actu/26785/PHP-deux-correctifs-pour-le-bogue-des-nombres-a-virgule-flottante-l-equipe-de-PHP-recommande-de-l-appliquer-immediatement/">qui avaient fait la une de la presse informatique</a> étaient causés par ces arrondis supplémentaires. Bien sûr, sachez que ce bug a pu être reproduit sur de nombreux autres langages et n'était certainement pas limité au PHP ou au Java : c'est le non-respect de la norme IEE754 par notre unité de calcul x87 qui était clairement en cause.</p><p id="r-579877" data-claire-element-id="579877">Mais ces problèmes d'arrondis ne s’arrêtent pas là. Si une série de calculs est faite sur des flottants stockés dans l'un de ces 8 registres, les résultats intermédiaires auront une précision supérieure, et seul le résultat final, stocké en mémoire sera arrondi. Dans ces conditions, le résultat peut être différent de celui qu'on aurait obtenu en utilisant seulement des flottants 64 bits lors des calculs.</p><p id="r-579878" data-claire-element-id="579878">Par exemple, prenons le calcul de e, la base des logarithmes népériens. Cette constante est égale à la somme de l'inverse des factorielles des nombres entiers. e = \sum \limits_{n=0}}^\infty \frac {1} {n!}</p><p id="r-579879" data-claire-element-id="579879">Si vous calculez cette constante sur un ordinateur vous allez devoir effectuer le calcul suivant : 1 + \frac {1} {2!} + + \frac {1} {3!} + \frac {1} {4!} + \frac {1} {5!} + \frac {1} {6!} + ... + \frac {1} {k!}. Bien sûr, vous allez devoir arrêter de calculer quand le résultat aura atteint la précision requise (nombre k).</p><p id="r-579880" data-claire-element-id="579880">Et bien sachez que ce calcul effectué sur l'unité x87 ne donnera pas un résultat identique au même calcul effectué sur autre unité de calcul flottante. Bien sûr, l'erreur de calcul n'est pas énorme et n'apparait qu'après une bonne dizaine de décimales, mais elle existe.</p><p id="r-579881" data-claire-element-id="579881">Autre problème : rares sont les calculs effectués intégralement dans les registres, et on est parfois obligé de temporairement sauvegarder en mémoire le contenu d'un registre pour laisser le registre libre pour un autre nombre flottant. C'est le programmeur ou le compilateur qui gère quand effectuer ce genre de sauvegarde et sur quels registres. Chacune de ces sauvegardes va arrondir le flottant que l'on souhaite sauvegarder. Conséquence : suivant l'ordre de ces sauvegardes, le moment auquel elles ont lieu et les flottants qui sont choisis pour être sauvegardés, le résultat ne sera pas le même ! Avec le même programme, si vous décidez de sauvegarder un flottant et votre voisin un autre, ce ne sera pas le même flottant qui sera arrondi lors de son transfert en mémoire, et le résultat des calculs sur votre ordinateur sera différent des résultats obtenus sur l'ordinateur de votre voisin.</p><p id="r-579882" data-claire-element-id="579882">Pour limiter la casse, il existe une solution : sauvegarder tout résultat d'un calcul sur un flottant directement dans la mémoire RAM. Comme cela, on se retrouve avec des calculs effectués uniquement sur des flottants 32/64 bits ce qui supprime pas mal d'erreurs de calcul.</p><h2 id="r-unites-de-calcul-sse" data-claire-element-id="579901">Unités de calcul SSE</h2><p id="r-579885" data-claire-element-id="579885">Notre unité SSE est plus vertueuse : elle gère totalement la norme IEEE 754 et possède des circuits parfaitement compatibles avec la norme IEEE 754. Elle gère nativement les nombres flottants simple et double précision sans problème ni conversions en flottants 80 bits : plus aucun problème de <em>double rouding</em>. Cette unité est rarement utilisée de nos jours par les programmes compilés en 32 bits. Pour des raisons de compatibilité, rares sont les compilateurs qui utilisent par défaut les instructions SSE pour calculer sur les flottants : le jeu d'instruction SSE a en effet été rajouté récemment à l'architecture x86 et certains processeurs anciens ne le supportent pas.</p><p id="r-579886" data-claire-element-id="579886">Sur les processeurs x86 64 bits, c'est l'inverse : les instructions SSE font partie intégrante du jeu d'instruction x86-64 et l'unité SSE est utilisée par défaut à la place de l’unité x87 pour tout calcul sur les flottants.</p><h3 id="r-jeu-d-instruction-sse" data-claire-element-id="579891">Jeu d'instruction SSE</h3><p id="r-579887" data-claire-element-id="579887">Il faut savoir qu'il existe plusieurs versions du jeu d'instruction SSE. Une première version est apparue en 1999 sur le processeur Pentium III, qui comportait 70 instructions. Depuis, de nombreuses autres instructions ont été ajoutées aux unités SSE, et chacun de ces rajouts a été accompagné d'un changement de nom du jeu d'instruction, dans un but marketing évident : SSE2, SSE3, SSSE3, SSE4, SSE5...</p><p id="r-579888" data-claire-element-id="579888">Il faut remarquer une chose : ces instructions ne travaillent pas toutes avec des nombres flottants et certaines peuvent &quot;instructionner&quot; sur des nombres entiers ! Notre unité SSE n'est donc pas vraiment une FPU au sens propre du terme.</p><p id="r-579889" data-claire-element-id="579889">Bien sûr, on retrouve les instructions de base de la norme IEEE 754 pour les calculs flottants, ainsi que de nombreuses autres instructions supplémentaires, non normalisées par la norme IEEE 754. Mais ne comptez pas sur moi pour vous détailler les centaines d'instructions supportées par cette unité de calcul comme on l'a fait pour la FPU x87. :p</p><p id="r-579890" data-claire-element-id="579890">L’unité SSE possède un mode de gestion des dénormaux, activé par défaut, qui consiste à remplacer tous les dénormaux par des zéros, afin de gagner en performances. En effet, les calculs sur les dénormaux sont particulièrement lents et remplacer ceux-ci par des zéros permettra d'améliorer la rapidité des calculs (en diminuant légèrement leur précision). Il va de soi que la norme IEE754 n'est pas censée tolérer ce genre de comportements.</p><h3 id="r-registres-sse" data-claire-element-id="579900">Registres SSE</h3><p id="r-579892" data-claire-element-id="579892">La FPU SSE des processeurs 32 bits contient 8 registres dédiés à cette unité de calcul. Ces registres sont nommés de XMM0 à XMM7. Sur les processeurs 64 bits, on trouve 16 registres numérotés de XMM0 à XMM15. En plus de ces registres de donnée, un nouveau registre 32 bits de contrôle/statut nommé MXCSR a fait son apparition. Chacun de ces registres peut contenir 128 bits, ce qui leur permet de contenir plusieurs nombres flottants à la fois : 4 flottants simple précision et 2 flottants double précision. Il faut savoir que le jeu d'instruction SSE a été inventé pour que chaque instruction SSE puisse être effectuée sur plusieurs données à la fois. Pour faciliter la conception des unités de calcul SSE, les concepteurs de cette unité ont décidé de placer plusieurs de ces données dans un seul et même registre. Il a donc fallu utiliser des registres assez grands en taille.</p><figure id="r-579894" data-claire-element-id="579895"><img id="r-579893" data-claire-element-id="579893" src="medias/uploads.siteduzero.com_files_324001_325000_324219.png" alt="Image utilisateur"/></figure><p id="r-579896" data-claire-element-id="579896">Ces registres ne sont pas organisés comme les registres de la FPU x87 et peuvent être lus, sélectionnés et écrits de façon indépendante : il n' y a pas d'ordre de remplissage et une instruction peut agir sur des données venant de n'importe quel registre.</p><p id="r-579897" data-claire-element-id="579897">Vu que le jeu d'instruction SSE n'est pas limité aux flottants mais gère aussi des calculs sur des entiers, ces registres peuvent stocker aussi bien des flottants que des entiers.</p><p id="r-579898" data-claire-element-id="579898">Voilà, ce tutoriel est enfin terminé.</p><p id="r-579899" data-claire-element-id="579899">Je vais finir en vous donnant quelques liens pour pourraient vous être utiles si vous voulez approfondir le sujet.</p><h2 id="r-liens-7" data-claire-element-id="579903">Liens</h2><p id="r-579902" data-claire-element-id="579902"><a href="http://hal.archives-ouvertes.fr/docs/00/28/14/29/PDF/floating-point-article.pdf">Pitfalls with floating point calculus</a><br/><a href="http://www.website.masmforum.com/tutorials/fptute/index.html">Jeu d'instruction d'une FPU x87</a></p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs">Nombres flottants et processeurs</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/prise-en-charge-des-flottants-par-le-hardware">
Prise en charge des flottants par le hardware
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/rappels-sur-la-norme-ieee-754">
Rappels sur la norme IEEE 754
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/exemple-l-architecture-x86">
Exemple : l&#039;architecture x86
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/nombres-flottants-et-processeurs/rappels-sur-la-norme-ieee-754">
<span class="arrow"></span>
<span class="next">Rappels sur la norme IEEE 754</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/nombres-flottants-et-processeurs.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 01:47:57 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/nombres-flottants-et-processeurs.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:28:34 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/les-listes-doublement-chainees-de-la-theorie-a-la-pratique.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 01:19:00 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-listes-doublement-chainees-de-la-theorie-a-la-pratique.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:21:02 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Les listes doublement chaînées: de la théorie à la pratique</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Les listes doublement chaînées: de la théorie à la pratique</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Leslistesdoublementchanesdelathorielapratique">Les listes doublement chaînées: de la théorie à la pratique</a><br/><a href="#Lebesoin">Le besoin</a><br/><a href="#Rflchiravantd039agir">Réfléchir avant d&#039;agir</a><br/><a href="#Avantdecommencer">Avant de commencer</a><br/><a href="#Correction">Correction</a><br/><a href="#Amliorations">Améliorations</a><br/></div>
<a name="Leslistesdoublementchanesdelathorielapratique"></a><h2>Les listes doublement chaînées: de la théorie à la pratique</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/le-besoin">
<span class="next">Le besoin</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-589453" data-claire-element-id="589453">Après avoir vu la <strong><a href="http://www.siteduzero.com/tutoriel-3-66283-les-listes-doublement-chainees-en-langage-c.html">théorie</a></strong> sur les listes doublement chaînées, nous allons mettre en oeuvre nos connaissances sur un petit sujet. Pour suivre ce tutoriel, la lecture du premier tutoriel sur les listes doublement chaînées est indispensable, sans quoi vous risqueriez de ne pas comprendre les concepts mis en jeu.<br/> Les objectifs de ce tutoriel sont les suivants :</p><ul id="r-589460" data-claire-element-id="589460"><li id="r-589455" data-claire-element-id="589455"><p id="r-589454" data-claire-element-id="589454">appliquer nos connaissances sur les listes doublement chaînées via un exemple concret,</p></li><li id="r-589457" data-claire-element-id="589457"><p id="r-589456" data-claire-element-id="589456">apprendre à étudier un projet avant de se lancer tête baissée dans le code,</p></li><li id="r-589459" data-claire-element-id="589459"><p id="r-589458" data-claire-element-id="589458">réaliser un petit interpréteur de commandes.</p></li></ul><p id="r-589461" data-claire-element-id="589461">Allez, en route.</p>
</div><a name="Lebesoin"></a><h2>Le besoin</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/reflechir-avant-d-agir">
<span class="next">Réfléchir avant d&#039;agir</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-589462" data-claire-element-id="589462">La réalisation d'un projet informatique doit suivre plusieurs étapes. La première de ces étapes est l'étape de <strong>spécification</strong>. Ici, il s'agit de répondre à la question <strong>QUOI ?</strong>. On parle aussi de <strong>cahier des charges</strong>. Nous allons donc dans un premier temps définir en détails notre besoin. Lors de la réalisation d'un projet, il est primordial de savoir ce que l'on veut réaliser, sans quoi on risque d'aller droit dans le mur.</p><h3 id="r-le-projet-4" data-claire-element-id="589464">Le projet</h3><p id="r-589463" data-claire-element-id="589463">De nos jours, de nombreuses entreprises ont à manipuler des pièces afin de par exemple les assembler. Avant le travail était manuel, désormais il est devenu <strong>automatisé</strong>. Différentes chaînes de montage sont alors mises en place dans les ateliers afin de manipuler et véhiculer les différentes pièces d'un atelier à un autre. Pour véhiculer les pièces, des <strong>bras manipulateurs</strong> ont alors été conçus. Ceux-ci constituent ce que l'on appelle un <strong>système automatisé</strong>. En effet, ces bras manipulateurs sont capables d'agir par eux-mêmes, sans pour autant avoir besoin d'un pilotage quelconque. Il suffit alors de paramétrer les mouvements que doit effectuer le bras et le tour est joué.<br/> Dans ce tutoriel, nous nous proposons de mettre en place un système de <strong>simulation</strong> de bras automatisé. Dans le cadre du tutoriel, nous nous contenterons de prendre un bras minimaliste. En effet, si lors de vos études vous vous êtes déjà rendus dans un laboratoire de sciences de l'ingénieur, vous avez peut-être eu l'occasion de voir un bras manipulateur capable d'effectuer certains mouvements, pilotable directement par automate programmable. Ce bras porte le nom de Bras Schrader.</p><h3 id="r-ce-que-l-on-souhaite-realiser" data-claire-element-id="589483">Ce que l'on souhaite réaliser</h3><p id="r-589465" data-claire-element-id="589465">Afin de mettre en oeuvre le concept des listes doublement chaînées, nous souhaitons réaliser un programme de simulation de bras automatisé. Ce programme sera effectué sous forme d'un <strong>interpréteur de commandes</strong> (<strong>shell</strong>). Nous aurons donc l'occasion d'apprendre à réaliser un interpréteur de commandes minimaliste. Cet interpréteur de commandes permettra alors à l'utilisateur de contrôler le bras afin de lui faire effectuer certains mouvements. Le bras que nous souhaitons simuler dispose d'une base rotative ainsi que d'une pince permettant de saisir un objet de petite taille. Les mouvements pouvant être effectués par le bras sont les suivants :</p><ul id="r-589482" data-claire-element-id="589482"><li id="r-589467" data-claire-element-id="589467"><p id="r-589466" data-claire-element-id="589466">montée du bras,</p></li><li id="r-589469" data-claire-element-id="589469"><p id="r-589468" data-claire-element-id="589468">descente du bras,</p></li><li id="r-589471" data-claire-element-id="589471"><p id="r-589470" data-claire-element-id="589470">rotation du bras vers la gauche,</p></li><li id="r-589473" data-claire-element-id="589473"><p id="r-589472" data-claire-element-id="589472">rotation du bras vers la droite,</p></li><li id="r-589475" data-claire-element-id="589475"><p id="r-589474" data-claire-element-id="589474">avancée de la pince,</p></li><li id="r-589477" data-claire-element-id="589477"><p id="r-589476" data-claire-element-id="589476">recul de la pince,</p></li><li id="r-589479" data-claire-element-id="589479"><p id="r-589478" data-claire-element-id="589478">ouverture de la pince,</p></li><li id="r-589481" data-claire-element-id="589481"><p id="r-589480" data-claire-element-id="589480">fermeture de la pince.</p></li></ul><h3 id="r-l-interpreteur-de-commandes" data-claire-element-id="589534">L'interpréteur de commandes</h3><p id="r-589484" data-claire-element-id="589484">Chaque mouvement doit disposer d'une commande permettant de l'effectuer. D'autre part, la casse doit être prise en compte. Une commande écrite en minuscules sera considérée comme invalide. Ainsi, afin de paramétrer un mouvement au bras, l'utilisateur devra taper une certaine commande. Les commandes dont on dispose sont les suivantes :</p><table id="r-589532" data-claire-element-id="589532"><thead id="r-589490" data-claire-element-id="589490"><tr id="r-589489" data-claire-element-id="589489"><th id="r-589486" data-claire-element-id="589486"><p id="r-589485" data-claire-element-id="589485">Nom de la commande</p></th><th id="r-589488" data-claire-element-id="589488"><p id="r-589487" data-claire-element-id="589487">Rôle de la commande</p></th></tr></thead><tbody id="r-589531" data-claire-element-id="589531"><tr id="r-589495" data-claire-element-id="589495"><td id="r-589492" data-claire-element-id="589492"><p id="r-589491" data-claire-element-id="589491">UP</p></td><td id="r-589494" data-claire-element-id="589494"><p id="r-589493" data-claire-element-id="589493">Montée du bras</p></td></tr><tr id="r-589500" data-claire-element-id="589500"><td id="r-589497" data-claire-element-id="589497"><p id="r-589496" data-claire-element-id="589496">DOWN</p></td><td id="r-589499" data-claire-element-id="589499"><p id="r-589498" data-claire-element-id="589498">Descente du bras</p></td></tr><tr id="r-589505" data-claire-element-id="589505"><td id="r-589502" data-claire-element-id="589502"><p id="r-589501" data-claire-element-id="589501">ROTL</p></td><td id="r-589504" data-claire-element-id="589504"><p id="r-589503" data-claire-element-id="589503">Rotation du bras vers la gauche</p></td></tr><tr id="r-589510" data-claire-element-id="589510"><td id="r-589507" data-claire-element-id="589507"><p id="r-589506" data-claire-element-id="589506">ROTR</p></td><td id="r-589509" data-claire-element-id="589509"><p id="r-589508" data-claire-element-id="589508">Rotation du bras vers la droite</p></td></tr><tr id="r-589515" data-claire-element-id="589515"><td id="r-589512" data-claire-element-id="589512"><p id="r-589511" data-claire-element-id="589511">FORWARD</p></td><td id="r-589514" data-claire-element-id="589514"><p id="r-589513" data-claire-element-id="589513">Avancée de la pince</p></td></tr><tr id="r-589520" data-claire-element-id="589520"><td id="r-589517" data-claire-element-id="589517"><p id="r-589516" data-claire-element-id="589516">BACKWARD</p></td><td id="r-589519" data-claire-element-id="589519"><p id="r-589518" data-claire-element-id="589518">Recul de la pince</p></td></tr><tr id="r-589525" data-claire-element-id="589525"><td id="r-589522" data-claire-element-id="589522"><p id="r-589521" data-claire-element-id="589521">OPEN</p></td><td id="r-589524" data-claire-element-id="589524"><p id="r-589523" data-claire-element-id="589523">Ouverture de la pince</p></td></tr><tr id="r-589530" data-claire-element-id="589530"><td id="r-589527" data-claire-element-id="589527"><p id="r-589526" data-claire-element-id="589526">CLOSE</p></td><td id="r-589529" data-claire-element-id="589529"><p id="r-589528" data-claire-element-id="589528">Fermeture de la pince</p></td></tr></tbody></table><p id="r-589533" data-claire-element-id="589533">Un mouvement ne peut être effectué deux fois de suite. Ainsi, lors de la saisie de deux commandes identiques d'affilée, un avertissement sera affiché.<br/> Une fois le mouvement du bras paramétré, l'utilisateur devra saisir la commande <strong>VIEW</strong> afin de visualiser le mouvement sur la sortie standard. La visualisation doit se faire sous forme de texte. La commande <strong>REINIT</strong> quant à elle permet de replacer le bras en position par défaut, à savoir en position basse intermédiaire. Enfin, la commande <strong>HELP</strong> doit permettre à l'utilisateur de visualiser la liste de toutes les commandes ainsi que leur description. Pour quitter la console, l'utilisateur devra saisir la commande <strong>EXIT</strong>.</p><h3 id="r-l-affichage-6" data-claire-element-id="589542">L'affichage</h3><p id="r-589535" data-claire-element-id="589535">Afin de visualiser le résultat du mouvement paramétré, l'utilisateur devra saisir la commande <strong>VIEW</strong>. Une fois celle-ci saisie, l'affichage du mouvement final doit être réalisé sur la sortie standard (à savoir <strong>stdout</strong>). Pour chaque commande, deux informations<br/> devront s'afficher à l'écran :</p><ul id="r-589540" data-claire-element-id="589540"><li id="r-589537" data-claire-element-id="589537"><p id="r-589536" data-claire-element-id="589536">le mouvement même (exemple : montée du bras), on appellera ceci l'action ;</p></li><li id="r-589539" data-claire-element-id="589539"><p id="r-589538" data-claire-element-id="589538">le résultat une fois le mouvement accompli (exemple : bras en position haute), on appellera ceci la transition.</p></li></ul><p id="r-589541" data-claire-element-id="589541">Pour faire la différence, toute action devra débuter par un point '.' et toute transition devra débuter par un tiret '-'. Afin de s'approcher le plus possible d'un comportement réel, une temporisation devra être mise en place entre chaque mouvement et transition, et entre chaque transition et mouvement. Par exemple, le programme devra attendre 0.5 seconde avant d'afficher la transition associée au mouvement, et 1 seconde avant d'afficher le mouvement suivant.</p><h3 id="r-exemple-177" data-claire-element-id="589545">Exemple</h3><p id="r-589543" data-claire-element-id="589543">Voici un exemple de comportement :</p><pre id="r-589544" data-claire-element-id="589544"><code data-claire-semantic="console">Bras:&gt; UP
Ajout commande UP (Levee du bras)
Bras:&gt; UP
Attention: commande UP deja realisee
Bras:&gt; COME
Erreur: commande 'COME' inconnue
Bras:&gt; ROTR
Ajout commande ROTR (Rotation droite)
Bras:&gt; FORWARD
Ajout commande FORWARD (Avancee de la pince)
Bras:&gt; OPEN 
Ajout commande OPEN (Ouverture de la pince)
Bras:&gt; CLOSE
Ajout commande CLOSE (Fermeture de la pince)
Bras:&gt; VIEW
Visualisation en mode pas a pas 
- Levee du bras
. Bras en position haute
- Rotation droite
. Bras en butee droite
- Avancee de la pince
. Pince avancee
- Ouverture de la pince
. Pince ouverte
- Fermeture de la pince
. Pince fermee
Fin de visualisation
Bras:&gt; REINIT
Bras en position par defaut
Bras:&gt; EXIT</code></pre>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique">Les listes doublement chaînées: de la théorie à la pratique</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/le-besoin">
Le besoin
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/reflechir-avant-d-agir">
Réfléchir avant d&#039;agir
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/avant-de-commencer-29">
Avant de commencer
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/correction-201">
Correction
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/ameliorations-30">
Améliorations
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/reflechir-avant-d-agir">
<span class="next">Réfléchir avant d&#039;agir</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Rflchiravantd039agir"></a><h2>Réfléchir avant d&#039;agir</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/le-besoin">
<span class="arrow"></span>
<span class="next">Le besoin</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/avant-de-commencer-29">
<span class="next">Avant de commencer</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-589547" data-claire-element-id="589547">Lorsque l'on est confronté à un problème bien défini, il est nécessaire de savoir comment on va le résoudre. Cette phase de l'élaboration d'un projet informatique est appelée phase de <strong>conception</strong>. Il s'agit alors de répondre à la question <strong>COMMENT ?</strong> après avoir répondu à la question <strong>QUOI ?</strong>. Cette étape est tout autant primordiale que la première. En effet, dans un projet informatique, la phase de codage n'est qu'une toute petite étape. Si l'on se lance directement dans le code tête baissée, on risque de se cogner sur un mur. Plus le projet est gros et plus le risque est important. 'Réfléchir avant d'agir' est ici l'expression clé.<br/> Pour nous, le but de cette étape est d'établir les points suivants :</p><ul id="r-589554" data-claire-element-id="589554"><li id="r-589549" data-claire-element-id="589549"><p id="r-589548" data-claire-element-id="589548">découpage du projet en différents fichiers,</p></li><li id="r-589551" data-claire-element-id="589551"><p id="r-589550" data-claire-element-id="589550">détermination des différentes fonctions,</p></li><li id="r-589553" data-claire-element-id="589553"><p id="r-589552" data-claire-element-id="589552">détermination des structures de données à utiliser.</p></li></ul><p id="r-589555" data-claire-element-id="589555">Commençons alors par réfléchir aux différents fichiers dont nous aurons besoin. <br/> Tout d'abord, et comme la coutume le veut, le point d'entrée du programme (à savoir la fonction main), sera placé dans le fichier <strong>main.c</strong>. <br/> Ensuite, nous aurons besoin d'un fichier contenant toutes les fonctions en rapport avec notre bras et notre interpréteur de commandes. Tiens, pourquoi ne pas l'appeler <strong>bras.c</strong> ? Ça colle bien, vous ne trouvez pas ? Et soyons fous, appelons <strong>bras.h</strong> le fichier interface du fichier bras.c. Il contiendra alors tous les prototypes nécessaires.<br/> Ce n'est pas tout. Eh oui, ne l'oublions pas mais nous allons avoir besoin de manipuler une liste doublement chaînée. Il va donc falloir un fichier source <strong>liste.c</strong> contenant l'implémentation de toutes les fonctions nécessaires à la manipulation de notre liste et bien évidemment un fichier <strong>liste.h</strong> contenant la définition de notre liste et tous les prototypes correspondants.<br/> Enfin, dans notre programme nous allons avoir besoin d'allouer une certaine quantité de mémoire. Nous allons donc créer un fichier <strong>memoire.c</strong> contenant des fonctions utilitaires de gestion de la mémoire prenant directement en compte la gestion des erreurs et un fichier <strong>memoire.h</strong> qui va avec.<br/> Pour résumer, l'organisation de notre projet sera la suivante :</p><ul id="r-589576" data-claire-element-id="589576"><li id="r-589557" data-claire-element-id="589557"><p id="r-589556" data-claire-element-id="589556">fichiers sources</p></li><ul id="r-589566" data-claire-element-id="589566"><li id="r-589559" data-claire-element-id="589559"><p id="r-589558" data-claire-element-id="589558">main.c</p></li><li id="r-589561" data-claire-element-id="589561"><p id="r-589560" data-claire-element-id="589560">bras.c</p></li><li id="r-589563" data-claire-element-id="589563"><p id="r-589562" data-claire-element-id="589562">liste.c</p></li><li id="r-589565" data-claire-element-id="589565"><p id="r-589564" data-claire-element-id="589564">memoire.c</p></li></ul><li id="r-589568" data-claire-element-id="589568"><p id="r-589567" data-claire-element-id="589567">fichiers interfaces</p></li><ul id="r-589575" data-claire-element-id="589575"><li id="r-589570" data-claire-element-id="589570"><p id="r-589569" data-claire-element-id="589569">bras.h</p></li><li id="r-589572" data-claire-element-id="589572"><p id="r-589571" data-claire-element-id="589571">liste.h</p></li><li id="r-589574" data-claire-element-id="589574"><p id="r-589573" data-claire-element-id="589573">memoire.h</p></li></ul></ul><p id="r-589577" data-claire-element-id="589577">Maintenant que nous avons découpé notre projet en fichiers distincts, nous allons devoir faire un effort de réflexion supplémentaire afin de découper chaque fichier en fonctions distinctes (sous-programmes). Chaque fonction doit effectuer une tâche <strong>précise</strong> en rapport avec le fichier dans lequel elle est placée. En effet, nous n'allons pas placer notre fonction d'ajout d'un élément dans une liste chaînée dans le fichier bras.c, question de bon sens.<br/> Voyons donc les principales fonctions dont nous allons avoir besoin. Tout d'abord, notre programme devra être constitué d'une <em>boucle principale</em>. Il s'agit là tout simplement de notre interpréteur de commandes. C'est l'élément central de notre programme, nous allons donc devoir créer une fonction de signature suivante : <code data-claire-semantic="c">void bras(Liste *p_liste) </code> où p_liste sera notre liste contenant les commandes saisies par l'utilisateur. Cependant, nous n'allons pas encapsuler tout notre code dans cette fonction. Nous allons alors créer plusieurs fonctions en rapport avec nos commandes, à savoir :</p><table id="r-589600" data-claire-element-id="589600"><thead id="r-589583" data-claire-element-id="589583"><tr id="r-589582" data-claire-element-id="589582"><th id="r-589579" data-claire-element-id="589579"><p id="r-589578" data-claire-element-id="589578">Signature</p></th><th id="r-589581" data-claire-element-id="589581"><p id="r-589580" data-claire-element-id="589580">Rôle</p></th></tr></thead><tbody id="r-589599" data-claire-element-id="589599"><tr id="r-589588" data-claire-element-id="589588"><td id="r-589585" data-claire-element-id="589585"><p id="r-589584" data-claire-element-id="589584"><code data-claire-semantic="c">void lire_commande(char commande[ LONGUEUR_MAX ]);</code></p></td><td id="r-589587" data-claire-element-id="589587"><p id="r-589586" data-claire-element-id="589586">Lire une commande au clavier de façon sécurisée (utilisation de fgets).</p></td></tr><tr id="r-589593" data-claire-element-id="589593"><td id="r-589590" data-claire-element-id="589590"><p id="r-589589" data-claire-element-id="589589"><code data-claire-semantic="c">int valide_commande(char commande[ LONGUEUR_MAX ]);</code></p></td><td id="r-589592" data-claire-element-id="589592"><p id="r-589591" data-claire-element-id="589591">Vérifier si la commande saisie est valide ou non.</p></td></tr><tr id="r-589598" data-claire-element-id="589598"><td id="r-589595" data-claire-element-id="589595"><p id="r-589594" data-claire-element-id="589594"><code data-claire-semantic="c">char const *derniere_commande(Liste *p_liste);</code></p></td><td id="r-589597" data-claire-element-id="589597"><p id="r-589596" data-claire-element-id="589596">Retourner la dernière commande de la liste.</p></td></tr></tbody></table><p id="r-589601" data-claire-element-id="589601">Enfin, afin de satisfaire la commande <strong>HELP</strong> nous aurons besoin d'une fonction <code data-claire-semantic="c">void affiche_aide(void); </code> ; nous aurons aussi besoin d'une fonction <code data-claire-semantic="c">void visualisation(Liste *p_liste) </code> permettant de satisfaire la commande <strong>VIEW</strong>. Nous venons donc de déterminer la liste des fonctions principales dont nous aurons besoin dans notre fichier bras.c.</p><p id="r-589602" data-claire-element-id="589602">Maintenant, voyons quelles fonctions nous seront utiles pour la manipulation de notre liste chaînée. Avant tout, nous aurons besoin d'allouer une nouvelle liste, une fonction <code data-claire-semantic="c">Liste *nouvelle_liste(void); </code> ne sera donc pas de refus. Ensuite, le sujet ne nous impose uniquement l'ajout de commandes, nous allons donc avoir besoin d'une fonction <code data-claire-semantic="c">Liste *ajoute_requete(Liste *p_liste, char const *nom); </code>. Enfin, une fois le programme terminé, il va nous falloir libérer toute la mémoire allouée. Ce sera le rôle d'une fonction <code data-claire-semantic="c">void supprime_requete(Liste **p_liste); </code>.</p><p id="r-589603" data-claire-element-id="589603">Il ne nous reste alors plus qu'à déterminer nos dernières fonctions de gestion de la mémoire. Nous allons tout d'abord mettre en place une fonction analogue à malloc, mis à part le fait que la gestion d'erreur sera intégrée à celle-ci. Lorsque malloc échouera, nous quitterons alors le programme. Enfin, nous allons avoir besoin d'une fonction de copie de chaîne de caractères dans une autre, utilisant notre fonction d'allocation précédemment évoquée. Notre fichier memoire.c sera donc constitué des deux fonctions que voici :</p><table id="r-589621" data-claire-element-id="589621"><thead id="r-589609" data-claire-element-id="589609"><tr id="r-589608" data-claire-element-id="589608"><th id="r-589605" data-claire-element-id="589605"><p id="r-589604" data-claire-element-id="589604">Signature</p></th><th id="r-589607" data-claire-element-id="589607"><p id="r-589606" data-claire-element-id="589606">Rôle</p></th></tr></thead><tbody id="r-589620" data-claire-element-id="589620"><tr id="r-589614" data-claire-element-id="589614"><td id="r-589611" data-claire-element-id="589611"><p id="r-589610" data-claire-element-id="589610"><code data-claire-semantic="c">void *xmalloc(size_t taille);</code></p></td><td id="r-589613" data-claire-element-id="589613"><p id="r-589612" data-claire-element-id="589612">Allouer de la mémoire en prenant en compte les erreurs.</p></td></tr><tr id="r-589619" data-claire-element-id="589619"><td id="r-589616" data-claire-element-id="589616"><p id="r-589615" data-claire-element-id="589615"><code data-claire-semantic="c">char *xstrdup(char const *s);</code></p></td><td id="r-589618" data-claire-element-id="589618"><p id="r-589617" data-claire-element-id="589617">Dupliquer une chaîne dans une autre.</p></td></tr></tbody></table><p id="r-589622" data-claire-element-id="589622">La plus grosse partie du travail a été réalisée. Désormais, il ne nous reste plus qu'à clarifier le dernier point de notre conception, à savoir la détermination des structures de données que nous allons devoir utiliser. En effet, dans un programme en langage C, il n'est pas rare d'avoir à utiliser des structures, énumérations, structures de données, etc. C'est donc ce que nous allons voir. Commençons alors par l'élément central : notre liste chaînée. Cette liste sera doublement chaînée. Nous allons créer un <em>noeud</em> nommé requete contenant le nom de la commande ainsi qu'un pointeur vers les éléments suivant et précédent. Ainsi, afin de faciliter les opérations sur notre liste, celle-ci sera constituée d'un pointeur vers le premier et le dernier noeud de la liste. Nous obtenons donc les structures suivantes :</p><pre id="r-589623" data-claire-element-id="589623"><code data-claire-semantic="c">typedef struct requete
{
    char *nom;

    struct requete *p_suivant;
    struct requete *p_precedent;
} Requete;

typedef struct liste
{
    struct requete *p_tete;
    struct requete *p_fin;
} Liste;</code></pre><p id="r-589624" data-claire-element-id="589624">Ensuite, nous devons disposer d'une structure représentant la table des différentes commandes, ainsi que leur rôle et leur statut une fois effectuées. Cela nous donne donc la structure suivante :</p><pre id="r-589625" data-claire-element-id="589625"><code data-claire-semantic="c">struct table
{
    char const *nom;
    char const *role;
    char const *status;
};</code></pre><p id="r-589626" data-claire-element-id="589626">que nous allons initialiser comme ceci :</p><pre id="r-589627" data-claire-element-id="589627"><code data-claire-semantic="c">static struct table commandes[] =
{ 
    { &quot;UP&quot;, &quot;Montee du bras&quot;, &quot;Bras en position haute&quot;              },
    /* reste des commandes */
};</code></pre><p id="r-589628" data-claire-element-id="589628">Cette table étant uniquement utilisée dans notre fichier bras.c, nous la qualifions de <strong>static</strong> afin de réduire sa portée à ce fichier.</p><p id="r-589629" data-claire-element-id="589629">Enfin, afin d'éviter de renvoyer 0 ou 1 en cas de validité ou non de la commande saisie, nous allons créer une énumération :</p><pre id="r-589630" data-claire-element-id="589630"><code data-claire-semantic="c">enum { COMMANDE_INVALIDE, COMMANDE_VALIDE } ;</code></pre><p id="r-589631" data-claire-element-id="589631">Nous renverrons alors soit COMMANDE_INVALIDE soit COMMANDE_VALIDE dans notre fonction valide_commande.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique">Les listes doublement chaînées: de la théorie à la pratique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/le-besoin">
Le besoin
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/reflechir-avant-d-agir">
Réfléchir avant d&#039;agir
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/avant-de-commencer-29">
Avant de commencer
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/correction-201">
Correction
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/ameliorations-30">
Améliorations
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/le-besoin">
<span class="arrow"></span>
<span class="next">Le besoin</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/avant-de-commencer-29">
<span class="next">Avant de commencer</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Avantdecommencer"></a><h2>Avant de commencer</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/reflechir-avant-d-agir">
<span class="arrow"></span>
<span class="next">Réfléchir avant d&#039;agir</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/correction-201">
<span class="next">Correction</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-589633" data-claire-element-id="589633">C'est maintenant à vous de jouer. Vous avez toutes les cartes en main pour ne pas être bloqué lors de la réalisation du programme.<br/> Cependant, avec que vous ne commenciez, il vous est nécessaire de prendre en compte ces quelques détails :</p><h3 id="r-la-temporisation" data-claire-element-id="589637">La temporisation</h3><p id="r-589634" data-claire-element-id="589634">Une temporisation en langage C ne se réalise pas de la même façon selon le système d'exploitation que l'on utilise. Sous Windows, il existe la fonction Sleep déclarée dans le header <code data-claire-semantic="c">&lt;windows.h&gt; </code> permettant de mettre en pause le programme un certain nombre de millisecondes. Sous unixoïde, il existe la fonction usleep déclarée dans le header <code data-claire-semantic="c">&lt;unistd.h&gt; </code>. Ainsi, afin de n'utiliser qu'une fonction Sleep mettant en pause le programme un certain nombre de millisecondes, nous allons utiliser le bout de code suivant :</p><pre id="r-589635" data-claire-element-id="589635"><code data-claire-semantic="c">#if defined (WIN32) || defined (_WIN32)
    #include &lt;windows.h&gt;
#else
    #include &lt;unistd.h&gt;
    #define Sleep(x) usleep(x * 1000)
#endif</code></pre><p id="r-589636" data-claire-element-id="589636">Si nous nous trouvons sous un autre système que Windows, nous définissons une macro Sleep identique à la fonction disponnible sous Windows.</p><h3 id="r-la-portee-des-fonctions" data-claire-element-id="589639">La portée des fonctions</h3><p id="r-589638" data-claire-element-id="589638">Afin d'aboutir à un programme propre, veillez à qualifier de static les fonctions que vous utiliserez uniquement dans un seul fichier. Par exemple, la fonction affiche_aide devra être static. Si vous le souhaitez, allez relire la partie du cours de M@teo21 sur le sujet se trouvant <a href="http://www.siteduzero.com/tutoriel-3-13993-0-la-programmation-modulaire.html#ss_part_4">ici</a>.</p><h3 id="r-protection-des-fichiers-d-en-tete" data-claire-element-id="589642">Protection des fichiers d'en-tête</h3><p id="r-589640" data-claire-element-id="589640">Enfin, pensez aussi à protéger vos fichiers d'en-tête (.h) contre des éventuelles inclusions multiples. Si vous possédez Code::Blocks, celui-ci devrait vous proposer de le faire automatiquement. Si vous avez des doutes, n'hésitez pas à aller consulter le tutoriel de M@teo21 <a href="http://www.siteduzero.com/tutoriel-3-14033-0-le-preprocesseur.html#ss_part_4">ici</a>.</p><p id="r-589641" data-claire-element-id="589641">Voilà, c'est maintenant à vous de jouer, vous savez tout ce que vous aviez à savoir pour réaliser ce programme. Si vous êtes bloqués, ne regardez pas tout de suite la solution, et continuez à chercher. Si vraiment vous n'y arrivez pas, alors regardez la solution et essayez à tout prix de la comprendre. ;)</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique">Les listes doublement chaînées: de la théorie à la pratique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/le-besoin">
Le besoin
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/reflechir-avant-d-agir">
Réfléchir avant d&#039;agir
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/avant-de-commencer-29">
Avant de commencer
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/correction-201">
Correction
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/ameliorations-30">
Améliorations
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/reflechir-avant-d-agir">
<span class="arrow"></span>
<span class="next">Réfléchir avant d&#039;agir</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/correction-201">
<span class="next">Correction</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Correction"></a><h2>Correction</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/avant-de-commencer-29">
<span class="arrow"></span>
<span class="next">Avant de commencer</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/ameliorations-30">
<span class="next">Améliorations</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-589644" data-claire-element-id="589644">Voici donc la correction, fichier par fichier, suivie des explications nécessaires à la compréhension du code.</p><h2 id="r-gestion-de-la-memoire-1" data-claire-element-id="589652">Gestion de la mémoire</h2><h3 id="r-memoire-h" data-claire-element-id="589647">memoire.h</h3><pre id="r-589645" data-claire-element-id="589645"><code data-claire-semantic="c">#ifndef MEMOIRE_H_INCLUDED
#define MEMOIRE_H_INCLUDED

#include &lt;stddef.h&gt;

void *xmalloc(size_t taille);
char *xstrdup(char const *s);

#endif</code></pre><p id="r-589646" data-claire-element-id="589646">Pas de surprise, nous retrouvons notre fichier interface avec les prototypes de nos deux fonctions qui vont nous être utiles pour gérer la mémoire. Notez cependant la présence du header <code data-claire-semantic="c">&lt;stddef.h&gt; </code>, qui contient la déclaration du type <code data-claire-semantic="c">size_t </code>.</p><h3 id="r-memoire-c" data-claire-element-id="589651">memoire.c</h3><pre id="r-589648" data-claire-element-id="589648"><code data-claire-semantic="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &quot;memoire.h&quot;

void *xmalloc(size_t taille)
{
    void *p = malloc(taille);
    if (p == NULL)
    {
        perror(&quot;Erreur d'allocation memoire&quot;);
        exit(EXIT_FAILURE);
    }

    return p;
}

char *xstrdup(char const *s)
{
    char *p = xmalloc(strlen(s) + 1);
    return strcpy(p, s);
}</code></pre><p id="r-589649" data-claire-element-id="589649">Comme vous le voyez, pour notre fonction xmalloc, nous commençons par demander à malloc de nous allouer la mémoire. Si celle-ci échoue (NULL renvoyé), nous affichons un message d'erreur sur la sortie standard grâce à la fonction perror. L'avantage de perror est qu'elle permet d'afficher la dernière erreur rencontrée dans le programme. Pour plus d'informations sur cette fonction, vous pouvez consulter <a href="http://www.linux-kheops.com/doc/man/manfr/man-html-0.9/man3/perror.3.html">le manuel</a>.<br/> Enfin, pour notre fonction xstrdup, nous réutilisons dans un premier temps notre fonction xmalloc afin d'allouer la taille nécessaire à la duplication de le chaîne passée en paramètre, en n'oubliant pas le +1 pour le '\0' final. strcpy renvoyant un pointeur sur notre chaîne de destination (à savoir p), nous utilisons directement son retour en guise de valeur renvoyée par notre fonction xstrdup. Nous utiliserons alors notre fonction comme ceci :</p><pre id="r-589650" data-claire-element-id="589650"><code data-claire-semantic="c">char *s = xstrdup(&quot;Bonjour tout le monde&quot;);
/* ... */
free(s);</code></pre><h2 id="r-gestion-de-la-liste-chainee" data-claire-element-id="589667">Gestion de la liste chaînée</h2><h3 id="r-liste-h" data-claire-element-id="589655">liste.h</h3><pre id="r-589653" data-claire-element-id="589653"><code data-claire-semantic="c">#ifndef LISTE_H_INCLUDED
#define LISTE_H_INCLUDED

typedef struct requete
{
    char *nom;

    struct requete *p_suivant;
    struct requete *p_precedent;
} Requete;

typedef struct liste
{
    struct requete *p_tete;
    struct requete *p_fin;
} Liste;

Liste *nouvelle_liste(void);
Liste *ajoute_requete(Liste *p_liste, char const *nom);
void supprime_requetes(Liste **p_liste);

#endif</code></pre><p id="r-589654" data-claire-element-id="589654">Ici, rien d'inattendu donc. Nous retrouvons bien notre liste chaînée préalablement déterminée dans notre étape de conception. Nous avons ensuite placé nos trois prototypes de fonctions qui vont nous servir à manipuler notre liste, à savoir la création d'une nouvelle liste (nouvelle_liste), l'ajout d'une commande dans la liste (ajoute_requete), et la suppression des requêtes une fois le travail fini (supprime_requetes).</p><h3 id="r-liste-c" data-claire-element-id="589666">liste.c</h3><pre id="r-589656" data-claire-element-id="589656"><code data-claire-semantic="c">#include &lt;stdlib.h&gt;
#include &quot;liste.h&quot;
#include &quot;memoire.h&quot;

Liste *nouvelle_liste(void)
{
    Liste *nouveau = xmalloc(sizeof *nouveau);
    nouveau-&gt;p_fin = nouveau-&gt;p_tete = NULL;
    return nouveau;
}

Liste *ajoute_requete(Liste *p_liste, char const *nom)
{
    if (p_liste != NULL)
    {
        Requete *nouveau = xmalloc(sizeof *nouveau);
        nouveau-&gt;nom = xstrdup(nom);
        nouveau-&gt;p_suivant = NULL;
        if (p_liste-&gt;p_fin == NULL)
        {
            p_liste-&gt;p_fin = p_liste-&gt;p_tete = nouveau;
        }
        else
        {
            nouveau-&gt;p_precedent = p_liste-&gt;p_fin;
            p_liste-&gt;p_fin-&gt;p_suivant = nouveau;
            p_liste-&gt;p_fin = nouveau;
        }
    }
    return p_liste;
}

void supprime_requetes(Liste **p_liste)
{
    if (*p_liste != NULL)
    {
        Requete *parcours = (*p_liste)-&gt;p_tete;
        while (parcours != NULL)
        {
            Requete *supprime = parcours;
            parcours = parcours-&gt;p_suivant;
            free(supprime-&gt;nom);
            free(supprime);
        }
        (*p_liste)-&gt;p_tete = (*p_liste)-&gt;p_fin = NULL;
    }
}</code></pre><p id="r-589657" data-claire-element-id="589657">Comme vous pouvez le constater, dans notre fonction nouvelle_liste, nous utilisons la fonction xmalloc que nous avons précédemment écrite. En cas d'erreur d'allocation mémoire, le programme sera directement quitté. Ensuite, cette ligne peut vous paraitre un peu inhabituelle :</p><pre id="r-589658" data-claire-element-id="589658"><code data-claire-semantic="c">nouveau-&gt;p_fin = nouveau-&gt;p_tete = NULL;</code></pre><p id="r-589659" data-claire-element-id="589659">on retrouve ici deux opérateurs d'affectation '=' sur la même ligne. En fait, ceci est tout à fait valide et revient à écrire :</p><pre id="r-589660" data-claire-element-id="589660"><code data-claire-semantic="c">nouveau-&gt;p_fin = (nouveau-&gt;p_tete = NULL);</code></pre><p id="r-589661" data-claire-element-id="589661">Cela permet alors d'initialiser différentes variables avec la même valeur (ici NULL), sur la même ligne.</p><p id="r-589662" data-claire-element-id="589662">Pour notre fonction ajoute_requetes, rien de bien particulier à redire, mis à part le fait qu'ici aussi nous utilisons notre fonction xmalloc ainsi que notre xstrdup afin de dupliquer (copier) le nom de notre commande dans notre champ nom. En fait, xstrdup fait tout simplement malloc + strcpy en une seule fonction. Si vous ne comprenez pas le reste de la fonction, relisez la théorie du tutoriel précédent.</p><p id="r-589663" data-claire-element-id="589663">De même, il n'y a rien de bien particulier à commenter au niveau de notre fonction supprime_requetes. Afin d'effectuer directement les modifications au niveau de la liste (suppression des éléments), nous devons en effet utiliser un pointeur double (Liste **). Nous n'oublions aussi pas de supprimer la mémoire allouée pour notre champ nom, sans quoi nous aurions des <strong>fuites de mémoire</strong>. Enfin, nous retrouvons la même syntaxe :</p><pre id="r-589664" data-claire-element-id="589664"><code data-claire-semantic="c">(*p_liste)-&gt;p_tete = (*p_liste)-&gt;p_fin = NULL;</code></pre><p id="r-589665" data-claire-element-id="589665">pour complètement réinitialiser notre liste chaînée.</p><h2 id="r-le-coeur-du-systeme" data-claire-element-id="589683">Le coeur du système</h2><p id="r-589668" data-claire-element-id="589668">Enfin, nous allons maintenant nous attaquer au coeur du système, c'est-à-dire la gestion même de notre bras.</p><h3 id="r-bras-h" data-claire-element-id="589671">bras.h</h3><pre id="r-589669" data-claire-element-id="589669"><code data-claire-semantic="c">#ifndef BRAS_H_INCLUDED
#define BRAS_H_INCLUDED

#include &quot;liste.h&quot;

void bras(Liste *p_liste);

#endif</code></pre><p id="r-589670" data-claire-element-id="589670">Contrairement à ce qu'on pourrait attendre, nous ne retrouvons ici qu'un seul et unique prototype. Il s'agit de la fonction qui va se charger d'effectuer la boucle principale. Et pour cause, toutes les autres fonctions sont des fonctions utilitaires qui seront de portée <strong>privée</strong> (<strong>static</strong>), c'est-à-dire qui seront accessibles uniquement à notre fichier bras.c.</p><h3 id="r-bras-c" data-claire-element-id="589682">bras.c</h3><pre id="r-589672" data-claire-element-id="589672"><code data-claire-semantic="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#if defined (WIN32) || defined (_WIN32)
    #include &lt;windows.h&gt;
#else
    #include &lt;unistd.h&gt;
    #define Sleep(x) usleep(x * 1000)
#endif

#include &quot;liste.h&quot;

#define LONGUEUR_MAX 25
#define TEMPO 500

struct table
{
    char const *nom;
    char const *role;
    char const *status;
} ;

static struct table commandes[] =
{
    { &quot;UP&quot;, &quot;Montee du bras&quot;, &quot;Bras en position haute&quot;              },
    { &quot;DOWN&quot;, &quot;Descente du bras&quot;, &quot;Bras en position basse&quot;          },
    { &quot;ROTL&quot;, &quot;Rotation gauche du bras&quot;, &quot;Bras en butee gauche&quot;     },
    { &quot;ROTR&quot;, &quot;Rotation droite du bras&quot;, &quot;Bras en butee droite&quot;     },
    { &quot;FORWARD&quot;, &quot;Avancee de la pince&quot;, &quot;Pince avancee&quot;             },
    { &quot;BACKWARD&quot;, &quot;Recul de la pince&quot;, &quot;Pince reculee&quot;              },
    { &quot;OPEN&quot;, &quot;Ouverture de la pince&quot;, &quot;Pince ouverte&quot;              },
    { &quot;CLOSE&quot;, &quot;Fermeture de la pince&quot;, &quot;Pince fermee&quot;              },
    { &quot;VIEW&quot;, &quot;Visulation des mouvements&quot;, NULL                     },
    { &quot;REINIT&quot;, &quot;Reinitialisation du bras en position defaut&quot;, NULL },
    { &quot;HELP&quot;, &quot;Affiche l'aide d'une commande&quot;, NULL                 },
    { &quot;EXIT&quot;, &quot;Quitte la console&quot;, NULL                             }
};

enum { COMMANDE_INVALIDE, COMMANDE_VALIDE } ;

static void affiche_aide(void)
{
    char const *aide = &quot;UP : Montee du bras\n&quot;
                       &quot;DOWN : Descente du bras\n&quot;
                       &quot;ROTL : Rotation gauche du bras\n&quot;
                       &quot;ROTR : Rotation droite du bras\n&quot;
                       &quot;FORWARD : Avancee de la pince\n&quot;
                       &quot;BACKWARD : Recul de la pince\n&quot;
                       &quot;OPEN : Ouverture de la pince\n&quot;
                       &quot;CLOSE : Fermeture de la pince\n&quot;
                       &quot;VIEW : Visualisation des mouvements\n&quot;
                       &quot;REINIT : Reinitialisation du bras en &quot;
                       &quot;position defaut\n&quot;
                       &quot;HELP : Affiche l'aide d'une commande\n&quot;
                       &quot;EXIT : Quitte la console\n&quot;;
    puts(aide);
}

static struct table *infos(char commande[ LONGUEUR_MAX ])
{
    struct table *ret = NULL;
    size_t i, nombre_commandes = sizeof commandes / sizeof *commandes;
    for (i = 0; i &lt; nombre_commandes; i++)
    {
        struct table *p = commandes + i;
        if (strcmp(p-&gt;nom, commande) == 0)
        {
            ret = p;
        }
    }
    return ret;
}

static void visualisation(Liste *p_liste)
{
    if (p_liste == NULL)
    {
        printf(&quot;Aucune requete parametree\n&quot;);
    }
    else
    {
        Requete *parcours = p_liste-&gt;p_tete;
        printf(&quot;Visulation en mode pas a pas\n&quot;);
        while (parcours != NULL)
        {
            struct table const *commande = infos(parcours-&gt;nom);
            printf(&quot;- %s\n&quot;, commande-&gt;role);
            Sleep(TEMPO);
            printf(&quot;. %s\n&quot;, commande-&gt;status);
            Sleep(TEMPO * 2);
            parcours = parcours-&gt;p_suivant;
        }
        printf(&quot;Fin de visualisation\n&quot;);
    }
}

static void fclean(char *buffer, FILE *fp)
{
    char *p = strchr(buffer, '\n');
    if (p != NULL)
    {
        *p = 0;
    }
    else
    {
        int c;
        while ((c = fgetc(fp)) != '\n' &amp;&amp; c != EOF)
        {
        }
    }
}

static void lire_commande(char commande[ LONGUEUR_MAX ])
{
    printf(&quot;Bras:&gt; &quot;);
    fflush(stdout);
    fgets(commande, LONGUEUR_MAX, stdin);
    fclean(commande, stdin);
}

static int valide_commande(char commande[ LONGUEUR_MAX ])
{
    size_t i, nombre_commandes = sizeof commandes / sizeof *commandes;
    int ret = COMMANDE_INVALIDE;
    for (i = 0 ; i &lt; nombre_commandes ; i++)
    {
        struct table const *p = commandes + i;
        if (strcmp(p-&gt;nom, commande) == 0)
        {
            ret = COMMANDE_VALIDE;
        }
    }
    return ret;
}

static char const *derniere_commande(Liste *p_liste)
{
    char const *ret = &quot;&quot;;
    if (p_liste-&gt;p_fin != NULL)
    {
        ret = p_liste-&gt;p_fin-&gt;nom;
    }
    return ret;
}

void bras(Liste *p_liste)
{
    char commande[ LONGUEUR_MAX ] = &quot;&quot;;
    do
    {
        lire_commande(commande);
        if (valide_commande(commande) == COMMANDE_INVALIDE)
        {
            printf(&quot;Erreur: commande '%s' inconnue\n&quot;, commande);
        }
        else if (strcmp(commande, &quot;HELP&quot;) == 0)
        {
            affiche_aide();
        }
        else if (strcmp(commande, &quot;REINIT&quot;) == 0)
        {
            supprime_requetes(&amp;p_liste);
            printf(&quot;Bras en position par defaut\n&quot;);
        }
        else if (strcmp(commande, &quot;VIEW&quot;) == 0)
        {
            visualisation(p_liste);
        }
        else
        {
            if (strcmp(derniere_commande(p_liste), commande) == 0)
            {
                printf(&quot;Attention: commande '%s' deja realisee\n&quot;, commande);
            }
            else
            {
                struct table const *p = infos(commande);
                p_liste = ajoute_requete(p_liste, commande);
                printf(&quot;Ajout commande %s (%s)\n&quot;, p-&gt;nom, p-&gt;role);
            }
        }
    }
    while (strcmp(commande, &quot;EXIT&quot;) != 0) ;
    supprime_requetes(&amp;p_liste);
}</code></pre><p id="r-589673" data-claire-element-id="589673">Comme vous le voyez, ce fichier est le plus volumineux de notre projet, c'est lui qui contient le plus de lignes de codes. Normal, étant donné qu'il constitue le coeur de notre système. Pour des raisons pratiques, je ne pourrai expliquer de manière détaillée le fonctionnement intégral des différentes fonctions. C'est pourquoi je ne me contenterai d'expliquer que les grandes lignes. À commencer par notre fonction bras. Cette fonction est la fonction principale de notre fichier puisque c'est elle qui va gérer notre petit interpréteur de commandes. Tout d'abord, nous commençons par définir un tableau de caractères qui accueillera notre commande lue au clavier. Bien entendu, nous définissons aussi une taille maximum grâce à la constante <code data-claire-semantic="c">LONGUEUR_MAX </code>, ici définie à 25. Ensuite, nous rentrons dans notre boucle principale. Nous bouclons alors <strong>tant que</strong> nous ne rencontrons pas la commande <strong>EXIT</strong> (cela était bien spécifié par le cahier des charges). Afin de lire une commande au clavier, nous avons crée une fonction lire_commande, à laquelle nous passons notre tableau de caractères en paramètre. Comme vous pouvez le constater, et cela afin de sécuriser notre application, nous n'utilisons pas la fonction <code data-claire-semantic="c">scanf </code> mais la fonction <code data-claire-semantic="c">fgets </code>. Ce procédé de saisie est expliqué dans l'annexe du tutoriel de M@teo21 à <a href="http://www.siteduzero.com/tutoriel-3-14185-0-la-saisie-de-texte-securisee.html">cette adresse</a>. <br/> Une fois notre commande lue et le caractère ' ' enlevé de notre tableau, nous devons vérifier si celle-ci est valide grâce à une fonction valide_commande qui retourne soit COMMANDE_VALIDE soit COMMANDE_INVALIDE, d'où l'intérêt de notre énumération. Celle-ci va alors effectuer une rechercher dans notre table de commandes, afin de vérifier si elle est présente ou non.</p><aside id="r-589677" data-claire-element-id="589677" data-claire-semantic="information"><p id="r-589674" data-claire-element-id="589674"><code data-claire-semantic="c">size_t nombre_commandes = sizeof commandes / sizeof *commandes; </code> est une astuce afin de récupérer directement la taille d'un tableau. L'opérateur sizeof renvoie alors la taille en byte d'un objet. Si l'on prend :</p><pre id="r-589675" data-claire-element-id="589675"><code data-claire-semantic="c">int tableau[4] = {1, 2, 3, 4};</code></pre><p id="r-589676" data-claire-element-id="589676">notre tableau occupe en tout une place mémoire de 4 * sizeof(int). sizeof *tableau est alors strictement équivalent à sizeof tableau[0] et nous renvoie la taille du premier élément de notre tableau c'est à dire aussi sizeof(int) (n'oublions pas que notre tableau est de type int). Ainsi, l'opération (4 * sizeof(int)) / sizeof(int) nous donne bien le résultat 4.</p></aside><p id="r-589678" data-claire-element-id="589678">Si notre commande n'existe pas dans notre tableau, nous affichons alors une erreur comme spécifié dans le cahier des charges. Sinon, cela signifie qu'elle est bel et bien valide, et nous utilisons donc la fonction strcmp afin d'effectuer notre comparaison. Plusieurs fonctions sont alors appelées selon la commande saisie. Par exemple, si l'utilisateur saisit la commande HELP, alors la fonction affiche_aide est appelée. Sinon, si l'utilisateur saisit la commande VIEW, la fonction visualisation est appelée, et ainsi de suite. <br/> Si aucune de ces commandes n'a été saisie, cela veut dire que l'utilisateur a saisi une commande permettant de faire effectuer un mouvement au bras. Dans ce cas-là, nous vérifions d'abord grâce à la fonction derniere_commande si cette commande n'a pas été saisie juste avant, auquel cas nous affichons un avertissement (<strong>warning</strong>). Si ce n'est pas le cas, alors nous pouvons ajouter notre commande à notre liste chaînée et signaler à l'utilisateur que celle-ci a bien été prise en compte.</p><p id="r-589679" data-claire-element-id="589679">Voilà, nous avons bouclé notre travail. Il ne nous reste plus qu'à écrire une fonction main() afin de passer à l'étape de test :</p><pre id="r-589680" data-claire-element-id="589680"><code data-claire-semantic="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;liste.h&quot;
#include &quot;bras.h&quot;

int main(void)
{
    Liste *reqs = nouvelle_liste();
    bras(reqs);
    free(reqs);
    return 0;
}</code></pre><p id="r-589681" data-claire-element-id="589681">Désormais, nous pouvons compiler notre programme et le tester en profondeur afin de détecter d'éventuels bogues et les corriger.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique">Les listes doublement chaînées: de la théorie à la pratique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/le-besoin">
Le besoin
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/reflechir-avant-d-agir">
Réfléchir avant d&#039;agir
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/avant-de-commencer-29">
Avant de commencer
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/correction-201">
Correction
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/ameliorations-30">
Améliorations
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/avant-de-commencer-29">
<span class="arrow"></span>
<span class="next">Avant de commencer</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/ameliorations-30">
<span class="next">Améliorations</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Amliorations"></a><h2>Améliorations</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/correction-201">
<span class="arrow"></span>
<span class="next">Correction</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-589685" data-claire-element-id="589685">Notre programme est désormais compilable et exécutable, mais ne nous arrêtons pas en si bon chemin. Il s'agit là d'un comportement assez minimaliste. Voici quelques idées d'améliorations que nous pourrions nous amuser à ajouter :</p><ul id="r-589692" data-claire-element-id="589692"><li id="r-589687" data-claire-element-id="589687"><p id="r-589686" data-claire-element-id="589686">une commande <strong>LIST</strong> permettant de visualiser la liste des commandes saisies avec leur ID avant de lancer la commande VIEW afin de bien vérifier que notre mouvement est bien conforme à ce que nous voulons ;</p></li><li id="r-589689" data-claire-element-id="589689"><p id="r-589688" data-claire-element-id="589688">une commande <strong>DEL #id</strong> permettant de supprimer une commande d'ID #id. Ceci permettrait de rectifier en cas d'erreur et ferait effectuer un travail supplémentaire sur notre liste chaînée ;</p></li><li id="r-589691" data-claire-element-id="589691"><p id="r-589690" data-claire-element-id="589690">une commande <strong>OPEN fileName</strong> permettant d'importer directement une liste de commandes depuis un fichier quelconque. Grâce à cette commande, vous pourriez vous entraîner à manipuler les fichiers, ce qui est un petit plus.</p></li></ul><p id="r-589693" data-claire-element-id="589693">Ces trois petites commandes constituent alors des idées d'améliorations. Bien sûr, on pourrait continuer à améliorer notre programme. La seule limite étant notre imagination. ;)</p><p id="r-589694" data-claire-element-id="589694">Ce tutoriel / TP touche désormais à sa fin. J'espère que le sujet qui vous a été présenté vous a permis de mieux comprendre le principe des listes chaînées et qu'il vous a permis de pratiquer le langage C comme vous l'avez appris dans le tutoriel de M@teo21.<br/> Bien d'autres sujets sont tout aussi imaginables pour pratiquer ce genre de concept. On pourrait par exemple imaginer de programmer un système de gestion de distributeur de boissons (façade administrateur avec l'ajout de boissons et façade utilisateur avec le choix d'une boisson).</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique">Les listes doublement chaînées: de la théorie à la pratique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/le-besoin">
Le besoin
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/reflechir-avant-d-agir">
Réfléchir avant d&#039;agir
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/avant-de-commencer-29">
Avant de commencer
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/correction-201">
Correction
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/ameliorations-30">
Améliorations
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-de-la-theorie-a-la-pratique/correction-201">
<span class="arrow"></span>
<span class="next">Correction</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/les-listes-doublement-chainees-de-la-theorie-a-la-pratique.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 01:19:00 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-listes-doublement-chainees-de-la-theorie-a-la-pratique.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:21:02 GMT -->
</html>
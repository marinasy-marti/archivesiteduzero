<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/le-bios-qu-est-ce-que-c-est.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 06:45:54 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/le-bios-qu-est-ce-que-c-est.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:13:28 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Le BIOS : qu&#039;est-ce que c&#039;est ?</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/le-bios-qu-est-ce-que-c-est.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Le BIOS : qu&#039;est-ce que c&#039;est ?</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#LeBIOSqu039est-cequec039est">Le BIOS : qu&#039;est-ce que c&#039;est ?</a><br/><a href="#Unpeud039archologieinformatique">Un peu d&#039;archéologie informatique</a><br/><a href="#Dmarraged039unordinateurx86">Démarrage d&#039;un ordinateur x86</a><br/><a href="#CMOSRAMetautres">CMOS RAM et autres</a><br/></div>
<a name="LeBIOSqu039est-cequec039est"></a><h2>Le BIOS : qu&#039;est-ce que c&#039;est ?</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/un-peu-d-archeologie-informatique">
<span class="next">Un peu d&#039;archéologie informatique</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-419993" data-claire-element-id="419993">Vous avez sûrement déjà entendu parler du BIOS et on vous a sûrement dit que c'était quelque chose qui servait au démarrage de votre ordinateur ? Eh bien, il est maintenant temps de passer aux choses sérieuses : ce tutoriel va vous expliquer et détailler un peu plus le rôle du BIOS dans un ordinateur et son fonctionnement.</p><p id="r-419994" data-claire-element-id="419994">Vous savez sûrement que dans un ordinateur, il y a plusieurs composants (processeur, mémoire RAM…). Ces composants sont tous installés sur une carte électronique qui est chargée de les faire communiquer entre eux et qu'on appelle la <strong>carte mère</strong>. Parmi tous ces composants indispensables, chaque ordinateur contient au moins une mémoire ROM sur laquelle se trouve un programme (un ordinateur sans programme serait vraiment inutile) : le <strong>BIOS</strong>.</p><p id="r-419995" data-claire-element-id="419995">Il s'agit d'un petit programme qui se lance au démarrage de l'ordinateur et dont le rôle est de :</p><ul id="r-420002" data-claire-element-id="420002"><li id="r-419997" data-claire-element-id="419997"><p id="r-419996" data-claire-element-id="419996">s'occuper de la gestion de certains périphériques ;</p></li><li id="r-419999" data-claire-element-id="419999"><p id="r-419998" data-claire-element-id="419998">faire ce qu'il faut pour allumer l'ordinateur ;</p></li><li id="r-420001" data-claire-element-id="420001"><p id="r-420000" data-claire-element-id="420000">faire démarrer un système d'exploitation présent sur une mémoire de masse.</p></li></ul><p id="r-420003" data-claire-element-id="420003">Autrefois, le BIOS était stocké dans une mémoire ROM placée sur la carte mère. De nos jours, on préfère utiliser de la mémoire EEPROM (souvent de la flash) pour stocker celui-ci. On peut ainsi remplacer le programme contenu dans la mémoire EEPROM du BIOS par un autre : on appelle cela <strong>flasher le BIOS</strong>.</p>
</div><a name="Unpeud039archologieinformatique"></a><h2>Un peu d&#039;archéologie informatique</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/demarrage-d-un-ordinateur-x86">
<span class="next">Démarrage d&#039;un ordinateur x86</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-420004" data-claire-element-id="420004">Notre BIOS a comme première fonction de prendre en charge une partie de la gestion du matériel et de fournir quelques abstractions matérielles minimales au système d'exploitation et à l'utilisateur. Pour simplifier le travail, on a incorporé de petits programmes dans notre BIOS dont le rôle était de gérer une partie du matériel présent sur la carte mère. Ces programmes ont été standardisés de façon à assurer la compatibilité des programmes utilisant ces routines sur tous les BIOS existants. Ce n'est pas pour rien que « BIOS » est l'abréviation de <em>Basic Input Output Software</em>, ce qui signifie « programme basique d'entrée − sortie ».</p><h2 id="r-rappel-sur-les-interruptions" data-claire-element-id="420035">Rappel sur les interruptions</h2><p id="r-420005" data-claire-element-id="420005">Pour communiquer avec le matériel, le BIOS utilise des fonctionnalités de notre processeur qu'on appelle les <strong>interruptions</strong>.</p><div id="r-420007" data-claire-element-id="420007" data-claire-semantic="question"><p id="r-420006" data-claire-element-id="420006">Oh là, c'est quoi, une interruption ?</p></div><p id="r-420008" data-claire-element-id="420008">C'est une fonctionnalité de notre processeur qui permet d'arrêter temporairement l'exécution d'un programme pour en exécuter un autre. On utilise les interruptions dans quelques cas bien précis, qui nécessitent un traitement ne pouvant attendre trop longtemps : communiquer avec un ou des périphériques, par exemple. Ainsi, pour communiquer avec une carte graphique, un disque dur ou un clavier, notre BIOS devra utiliser des interruptions.</p><p id="r-420009" data-claire-element-id="420009">Celles-ci ont pour but d'interrompre l'exécution d'un programme afin de réagir à un événement extérieur (matériel, erreur fatale d'exécution d'un programme…) et de le traiter en temps voulu, avant de rendre la main au programme interrompu. Notre interruption va donc effectuer un petit traitement (ici, communiquer avec un périphérique). Ce traitement est effectué par un petit programme auquel on a donné un nom technique : <strong>routine d'interruption</strong>.</p><p id="r-420010" data-claire-element-id="420010">Lorsqu'un processeur doit exécuter une interruption, celui-ci :</p><ul id="r-420017" data-claire-element-id="420017"><li id="r-420012" data-claire-element-id="420012"><p id="r-420011" data-claire-element-id="420011">arrête l'exécution du programme en cours ;</p></li><li id="r-420014" data-claire-element-id="420014"><p id="r-420013" data-claire-element-id="420013">exécute la <strong>routine d'interruption</strong> ;</p></li><li id="r-420016" data-claire-element-id="420016"><p id="r-420015" data-claire-element-id="420015">reprend l'exécution du programme suspendu là où elle en était.</p></li></ul><p id="r-420018" data-claire-element-id="420018">Il existe trois moyens pour déclencher une interruption :</p><ul id="r-420025" data-claire-element-id="420025"><li id="r-420020" data-claire-element-id="420020"><p id="r-420019" data-claire-element-id="420019">une instruction un peu spéciale du processeur ;</p></li><li id="r-420022" data-claire-element-id="420022"><p id="r-420021" data-claire-element-id="420021">les exceptions, qui se produisent automatiquement lorsque le processeur rencontre une erreur (par exemple une division par zéro) ;</p></li><li id="r-420024" data-claire-element-id="420024"><p id="r-420023" data-claire-element-id="420023">les requêtes d'interruption, qui sont déclenchées par un événement d'origine matérielle.</p></li></ul><p id="r-420026" data-claire-element-id="420026">Comme vous le voyez, les interruptions peuvent non seulement être appelées par un programme quelconque, grâce à l'instruction <code data-claire-semantic="nasm">int</code>, mais elles permettent aussi de réagir à des événements purement matériels, comme l'appui d'une touche au clavier.</p><p id="r-420027" data-claire-element-id="420027">Comme on l'a dit, une interruption a été conçue pour réagir à un événement, mais c'est avant tout un programme, qui peut être exécuté comme n'importe quel autre programme. Dans notre cas, ces interruptions seront simplement considérées comme des programmes simplistes permettant d'agir sur un périphérique. Bien sûr, devant la multiplicité des périphériques, on se doute bien qu'il n'existe pas d'interruption à tout faire : il va de soi qu'un programme envoyant un ordre au disque dur sera différent d'un programme agissant sur une carte graphique. Dans chaque cas, on aura besoin d'effectuer un traitement différent, on doit donc disposer de <strong>plusieurs</strong> routines d'interruption. Pour le cas de notre BIOS, celui-ci fournit beaucoup de routines de base pour communiquer avec les périphériques de notre ordinateur.</p><h3 id="r-vecteur-d-interruption" data-claire-element-id="420034">Vecteur d'interruption</h3><p id="r-420028" data-claire-element-id="420028">Cependant, il faut bien décider quelle est l'interruption à exécuter suivant la situation. Par exemple, exécuter l'interruption de gestion du clavier alors qu'on souhaite communiquer avec notre disque dur produirait un résultat plutôt comique. :p Par conséquent, on doit stocker plusieurs de ces routines dans sa mémoire. Mais comment les retrouver ? Comme les autres données ! Pour expliquer correctement cela, il va falloir faire un petit rappel.</p><p id="r-420029" data-claire-element-id="420029">La mémoire de notre ordinateur est un vulgaire amas de cellules mémoire, chacune capable de retenir des bits ; on rappelle qu'un bit est une information qui peut prendre deux valeurs : 0 ou 1. Ces cellules sont regroupées en paquets de 8, qu'on appelle des cases mémoire. Ces cases contiennent donc des données (ou des morceaux de données : un nombre entier occupe souvent plusieurs cases). Pour savoir dans quelle case mémoire on a stocké notre donnée, notre ordinateur identifie chaque case par un nombre unique : l'<strong>adresse mémoire</strong>. Chaque routine est alors placée dans la mémoire à un certain endroit, localisable par son adresse, qui indique sa position dans la mémoire.</p><p id="r-420030" data-claire-element-id="420030">Pour retrouver la position de notre routine et savoir laquelle exécuter, certains ordinateurs utilisent une partie de leur mémoire pour stocker les adresses de début de toutes les routines d'interruption. En gros, cette partie de la mémoire contient les adresses permettant de localiser chaque routine. Cette portion de la mémoire s'appelle le <strong>vecteur d'interruption</strong>. Pour chaque interruption, une partie fixe de la mémoire contient l'adresse de début de l'interruption à effectuer.</p><aside id="r-420032" data-claire-element-id="420032" data-claire-semantic="information"><p id="r-420031" data-claire-element-id="420031">Pour ceux qui connaissent un peu la programmation, vous pouvez voir ce vecteur d'interruption comme un tableau de pointeurs sur fonction, les fonctions étant les routines à exécuter.</p></aside><p id="r-420033" data-claire-element-id="420033">Le BIOS initialise le vecteur d'interruption au démarrage de l'ordinateur et fournit quelques interruptions de gestion du matériel fondamentales. Néanmoins, le système d'exploitation peut fournir ses propres routines. Pour que celles-ci soient exécutées, il suffit à l'OS de <strong>détourner l'interruption</strong>. Cela consiste à remplacer l'adresse de l'interruption contenue dans le vecteur d'interruption par l'adresse de la routine que l'OS a chargée en mémoire (bien sûr, l'ancienne adresse est sauvegardée). <br/> En clair, le vecteur d'interruption ne contiendra plus l'adresse servant à localiser la routine du BIOS, mais celle localisant la routine de l'OS.</p><h2 id="r-routines-d-interruption-du-bios" data-claire-element-id="420274">Routines d'interruption du BIOS</h2><p id="r-420036" data-claire-element-id="420036">Le BIOS fournit de base un grand nombre de routines d'interruption préprogrammées. Ces routines peuvent, par exemple, être exécutées quand on appuie sur une touche du clavier, ou quand une information en provenance de la souris est disponible sur le port PS/2.</p><p id="r-420037" data-claire-element-id="420037">De nos jours (depuis Windows 95), une fois le système d'exploitation chargé, ces routines ne peuvent être utilisées que par les noyaux des systèmes d'exploitation, et quelques pilotes. Pour ceux qui ne le savent pas, une fois le système d'exploitation chargé, la mémoire d'un ordinateur x86 (architecture 32 bits, ce qui signifie que nous pouvons charger 32 bits de données en même temps) est coupée en au moins deux portions, dont deux principales :</p><ul id="r-420042" data-claire-element-id="420042"><li id="r-420039" data-claire-element-id="420039"><p id="r-420038" data-claire-element-id="420038">une partie dans laquelle tout programme qui s'y trouve peut gérer les périphériques et effectuer des manipulations avancées sur la mémoire : l'<strong>espace noyau</strong> ;</p></li><li id="r-420041" data-claire-element-id="420041"><p id="r-420040" data-claire-element-id="420040">une autre pour les programmes qui ne doivent ni manipuler les périphériques ni faire de manipulations avancées sur la mémoire : l'<strong>espace utilisateur</strong>.</p></li></ul><p id="r-420043" data-claire-element-id="420043">Nos routines sont alors inaccessibles par un programme localisé dans l'espace utilisateur. Uniquement les programmes localisés dans l'espace noyau ont le droit d'accéder au matériel. Seule une partie du système d'exploitation, nommée noyau et contenant quelques <em>drivers</em>, est placée dans l'espace noyau et peut donc faire exécuter les routines du BIOS si besoin est. <br/> Mais attention : cela ne vaut qu'une fois que le système d'exploitation est chargé (en fait, une fois que le processeur passe du mode réel où tout est permis au mode protégé où certaines opérations sont restreintes). Avant, la mémoire est gérée autrement, et il n'existe pas de distinction entre espace noyau et espace utilisateur, ce qui permet au BIOS de s'exécuter librement.</p><p id="r-420044" data-claire-element-id="420044">Les routines du BIOS, voire l'intégralité de son contenu, étaient parfois recopiées dans la mémoire RAM afin de rendre leur exécution plus rapide, à l'époque où celles-ci servaient encore (MS-DOS). La mémoire RAM est en effet bien plus rapide que la mémoire (EEP)ROM dans laquelle le BIOS est stocké. Certaines options du BIOS, souvent nommées <em>BIOS memory shadowing</em> (ou autres noms ressemblants), permettent justement de copier le BIOS dans une partie de la mémoire RAM afin d'accélérer l'exécution de ses routines. Sachez que ce genre de choses est inutile depuis que le BIOS ne sert plus qu'à l'allumage de l'ordinateur.</p><p id="r-420045" data-claire-element-id="420045">On va lister quelques routines importantes. Dans ce qui suit, l'adresse mentionnée sera l'adresse stockée dans le vecteur d'interruption de ladite routine (relisez plusieurs fois si besoin). Il faudra cependant être vigilant : la grande majorité de ces interruptions est détournée par notre système d'exploitation, et n'est utilisée que lors de l'allumage de l'ordinateur. En fait, dès qu'il existe un <em>driver</em> pour un périphérique quelconque, sachez que les routines du BIOS sont complètement détournées par votre OS.</p><p id="r-420046" data-claire-element-id="420046">Une grande partie de ces routines ont besoin qu'on leur fournisse des <strong>paramètres</strong>, des informations pour qu'elles fassent ce qu'elles doivent faire. Par exemple, une routine devant afficher une lettre à l'écran aura besoin qu'on lui donne en entrée la lettre à afficher. Pour chaque routine, il suffira de copier ces paramètres de la mémoire vers de petites mémoires ultra-rapides intégrées dans le processeur qu'on appelle les <strong>registres</strong>. Chacun de ces registres possède un nom qui permet de l'identifier : AX, AH, AL… Pour chaque routine, chaque registre contiendra une donnée ayant une signification bien précise pour notre routine. Ce seront souvent les registres AH ou AL du processeur.</p><p id="r-420047" data-claire-element-id="420047">Dans ce qui suit, nous listerons quelques routines pour montrer un peu leur utilité. On nommera ces routines. <br/> Chaque routine est identifiée par :</p><ul id="r-420054" data-claire-element-id="420054"><li id="r-420049" data-claire-element-id="420049"><p id="r-420048" data-claire-element-id="420048">l'identifiant <strong>INT</strong>, qui sert à préciser que l'on souhaite exécuter une interruption ;</p></li><li id="r-420051" data-claire-element-id="420051"><p id="r-420050" data-claire-element-id="420050">les registres, utilisés pour configurer notre routine ;</p></li><li id="r-420053" data-claire-element-id="420053"><p id="r-420052" data-claire-element-id="420052">un numéro, qui permet d'identifier la routine à exécuter.</p></li></ul><p id="r-420055" data-claire-element-id="420055">En effet, nos routines sont numérotées. Mais attention : ce numéro est un nombre hexadécimal ! En clair, INT 10 n'est pas la dixième interruption, mais la seizième. Pour ceux qui ne connaissent pas l'hexadécimal, rassurez-vous, vous pourrez comprendre la suite sans problème.</p><h3 id="r-int-10h-affichage" data-claire-element-id="420097">INT 10h : affichage</h3><p id="r-420056" data-claire-element-id="420056">Nos cartes graphiques actuelles contiennent toutes une mémoire ROM (voire EEPROM) contenant elle-même des tas de routines capables de faire afficher du texte et des graphismes monochromes ou 256 couleurs à l'écran. Dans les cartes graphiques compatibles avec les formats VGA/ESA, ce <em>firmware</em> (programme intégré au composant — le BIOS est un <em>firmware</em>), appelé improprement <strong>BIOS vidéo</strong>, est localisé dans l'espace d'adressage aux adresses 000C 0000 ou 000E 0000. Lors du démarrage de l'ordinateur, ce sont ces routines qui sont utilisées pour gérer l'affichage avant que le système d'exploitation ne lance les <em>drivers</em> graphiques. Ces fonctions sont extrêmement basiques, ce qui fait que les graphismes affichés à l'écran ont cet aspect si caractéristique, moche, faisant penser à l'informatique des années 1950…</p><p id="r-420057" data-claire-element-id="420057">Mais faites attention : une fois le pilote de la carte graphique démarré, ces fonctions de base ne servent plus ; le système d'exploitation, le <em>driver</em> vidéo et les programmes lancés gèrent eux-mêmes ce genre de choses et détournent sans vergogne les interruptions qu'ils souhaitent.</p><p id="r-420058" data-claire-element-id="420058">Si aucune ROM vidéo n'est détectée, le BIOS peut quand même communiquer directement avec la carte graphique grâce à une routine qu'il possède. Cette routine a plusieurs fonctions différentes, et peut tout aussi bien envoyer un caractère à l'écran que renvoyer la position du curseur. Pour spécifier le traitement à effectuer, on doit placer une certaine valeur dans le registre AH du processeur : la routine est programmée pour déduire le traitement à effectuer uniquement à partir de la valeur du registre AH.<br/> Exemple :</p><table id="r-420096" data-claire-element-id="420096"><thead id="r-420066" data-claire-element-id="420066"><tr id="r-420065" data-claire-element-id="420065"><th id="r-420060" data-claire-element-id="420060"><p id="r-420059" data-claire-element-id="420059">INT 0x10</p></th><th id="r-420062" data-claire-element-id="420062"><p id="r-420061" data-claire-element-id="420061">Valeur à placer dans le registre AH</p></th><th id="r-420064" data-claire-element-id="420064"><p id="r-420063" data-claire-element-id="420063">Description</p></th></tr></thead><tbody id="r-420095" data-claire-element-id="420095"><tr id="r-420073" data-claire-element-id="420073"><td id="r-420068" data-claire-element-id="420068"><p id="r-420067" data-claire-element-id="420067">INT 0x10</p></td><td id="r-420070" data-claire-element-id="420070"><p id="r-420069" data-claire-element-id="420069">0x00</p></td><td id="r-420072" data-claire-element-id="420072"><p id="r-420071" data-claire-element-id="420071">Permet de régler la résolution et le nombre de couleurs de l'écran.</p></td></tr><tr id="r-420080" data-claire-element-id="420080"><td id="r-420075" data-claire-element-id="420075"><p id="r-420074" data-claire-element-id="420074">INT 0x10</p></td><td id="r-420077" data-claire-element-id="420077"><p id="r-420076" data-claire-element-id="420076">0x01</p></td><td id="r-420079" data-claire-element-id="420079"><p id="r-420078" data-claire-element-id="420078">Place le curseur de la souris à la position voulue sur l'écran.</p></td></tr><tr id="r-420087" data-claire-element-id="420087"><td id="r-420082" data-claire-element-id="420082"><p id="r-420081" data-claire-element-id="420081">INT 0x10</p></td><td id="r-420084" data-claire-element-id="420084"><p id="r-420083" data-claire-element-id="420083">0x03</p></td><td id="r-420086" data-claire-element-id="420086"><p id="r-420085" data-claire-element-id="420085">Renvoie la position qu'occupe le curseur de la souris à l'écran.</p></td></tr><tr id="r-420094" data-claire-element-id="420094"><td id="r-420089" data-claire-element-id="420089"><p id="r-420088" data-claire-element-id="420088">INT 0x10</p></td><td id="r-420091" data-claire-element-id="420091"><p id="r-420090" data-claire-element-id="420090">0x0E</p></td><td id="r-420093" data-claire-element-id="420093"><p id="r-420092" data-claire-element-id="420092">Affiche un caractère ASCII.</p></td></tr></tbody></table><h3 id="r-int-11h" data-claire-element-id="420099">INT 11h</h3><p id="r-420098" data-claire-element-id="420098">Cette routine renvoie un nombre codé sur 16 bits contenant des informations sur certains périphériques présents sur l'ordinateur.</p><h3 id="r-int-12h" data-claire-element-id="420101">INT 12h</h3><p id="r-420100" data-claire-element-id="420100">Cette routine ne prend aucun paramètre et renvoie la taille de la mémoire en kilo-octets dans le registre AX.</p><h3 id="r-int-13h-memoires-de-masse" data-claire-element-id="420150">INT 13h : mémoires de masse</h3><p id="r-420102" data-claire-element-id="420102">Une routine du BIOS permet de lire ou d'écrire sur le disque dur ou sur une disquette. Cette routine lui sert à lire les premiers octets d'un disque dur afin de pouvoir charger le système d'exploitation, mais on verra cela au chapitre suivant.</p><p id="r-420103" data-claire-element-id="420103">Comme la routine INT 10, elle est polyvalente et on doit spécifier le traitement à effectuer en mettant le registre AH à une valeur unique pour chaque traitement.<br/> Exemple :</p><table id="r-420148" data-claire-element-id="420148"><thead id="r-420111" data-claire-element-id="420111"><tr id="r-420110" data-claire-element-id="420110"><th id="r-420105" data-claire-element-id="420105"><p id="r-420104" data-claire-element-id="420104">INT 0x13</p></th><th id="r-420107" data-claire-element-id="420107"><p id="r-420106" data-claire-element-id="420106">Valeur à placer dans le registre AH</p></th><th id="r-420109" data-claire-element-id="420109"><p id="r-420108" data-claire-element-id="420108">Description</p></th></tr></thead><tbody id="r-420147" data-claire-element-id="420147"><tr id="r-420118" data-claire-element-id="420118"><td id="r-420113" data-claire-element-id="420113"><p id="r-420112" data-claire-element-id="420112">INT 0x13</p></td><td id="r-420115" data-claire-element-id="420115"><p id="r-420114" data-claire-element-id="420114">0x00</p></td><td id="r-420117" data-claire-element-id="420117"><p id="r-420116" data-claire-element-id="420116">Réinitialise le disque sélectionné.</p></td></tr><tr id="r-420125" data-claire-element-id="420125"><td id="r-420120" data-claire-element-id="420120"><p id="r-420119" data-claire-element-id="420119">INT 0x13</p></td><td id="r-420122" data-claire-element-id="420122"><p id="r-420121" data-claire-element-id="420121">0x01</p></td><td id="r-420124" data-claire-element-id="420124"><p id="r-420123" data-claire-element-id="420123">Vérifie l'état du disque.</p></td></tr><tr id="r-420132" data-claire-element-id="420132"><td id="r-420127" data-claire-element-id="420127"><p id="r-420126" data-claire-element-id="420126">INT 0x13</p></td><td id="r-420129" data-claire-element-id="420129"><p id="r-420128" data-claire-element-id="420128">0x02</p></td><td id="r-420131" data-claire-element-id="420131"><p id="r-420130" data-claire-element-id="420130">Lit une donnée à partir du disque sélectionné.</p></td></tr><tr id="r-420139" data-claire-element-id="420139"><td id="r-420134" data-claire-element-id="420134"><p id="r-420133" data-claire-element-id="420133">INT 0x13</p></td><td id="r-420136" data-claire-element-id="420136"><p id="r-420135" data-claire-element-id="420135">0x03</p></td><td id="r-420138" data-claire-element-id="420138"><p id="r-420137" data-claire-element-id="420137">Écrit une donnée sur le disque sélectionné.</p></td></tr><tr id="r-420146" data-claire-element-id="420146"><td id="r-420141" data-claire-element-id="420141"><p id="r-420140" data-claire-element-id="420140">…</p></td><td id="r-420143" data-claire-element-id="420143"><p id="r-420142" data-claire-element-id="420142">…</p></td><td id="r-420145" data-claire-element-id="420145"><p id="r-420144" data-claire-element-id="420144">…</p></td></tr></tbody></table><p id="r-420149" data-claire-element-id="420149">Cette routine était utilisée par les systèmes d'exploitation du style MS-DOS pour lire ou écrire sur le disque dur. Mais cela appartient à l'histoire, et les OS actuels n'hésitent plus à détourner ces interruptions pour fournir des méthodes de gestion du disque bien plus efficaces.</p><h3 id="r-int-14h-port-serie" data-claire-element-id="420190">INT 14h : port série</h3><p id="r-420151" data-claire-element-id="420151">Cette interruption était utilisée pour communiquer avec le port série RS232 de notre ordinateur. Comme les autres, elle est configurée par une valeur dans le registre AH.</p><table id="r-420189" data-claire-element-id="420189"><thead id="r-420159" data-claire-element-id="420159"><tr id="r-420158" data-claire-element-id="420158"><th id="r-420153" data-claire-element-id="420153"><p id="r-420152" data-claire-element-id="420152">​INT 0x14</p></th><th id="r-420155" data-claire-element-id="420155"><p id="r-420154" data-claire-element-id="420154">Valeur à placer dans le registre AH​</p></th><th id="r-420157" data-claire-element-id="420157"><p id="r-420156" data-claire-element-id="420156">Description</p></th></tr></thead><tbody id="r-420188" data-claire-element-id="420188"><tr id="r-420166" data-claire-element-id="420166"><td id="r-420161" data-claire-element-id="420161"><p id="r-420160" data-claire-element-id="420160">INT 0x14</p></td><td id="r-420163" data-claire-element-id="420163"><p id="r-420162" data-claire-element-id="420162">0x00</p></td><td id="r-420165" data-claire-element-id="420165"><p id="r-420164" data-claire-element-id="420164">Initialise le port série.</p></td></tr><tr id="r-420173" data-claire-element-id="420173"><td id="r-420168" data-claire-element-id="420168"><p id="r-420167" data-claire-element-id="420167">INT 0x14</p></td><td id="r-420170" data-claire-element-id="420170"><p id="r-420169" data-claire-element-id="420169">0x01</p></td><td id="r-420172" data-claire-element-id="420172"><p id="r-420171" data-claire-element-id="420171">Émet un caractère sur le port série.</p></td></tr><tr id="r-420180" data-claire-element-id="420180"><td id="r-420175" data-claire-element-id="420175"><p id="r-420174" data-claire-element-id="420174">INT 0x14</p></td><td id="r-420177" data-claire-element-id="420177"><p id="r-420176" data-claire-element-id="420176">0x02</p></td><td id="r-420179" data-claire-element-id="420179"><p id="r-420178" data-claire-element-id="420178">Réceptionne un caractère.</p></td></tr><tr id="r-420187" data-claire-element-id="420187"><td id="r-420182" data-claire-element-id="420182"><p id="r-420181" data-claire-element-id="420181">INT 0x14</p></td><td id="r-420184" data-claire-element-id="420184"><p id="r-420183" data-claire-element-id="420183">0x03</p></td><td id="r-420186" data-claire-element-id="420186"><p id="r-420185" data-claire-element-id="420185">Renvoie l'état du port série (occupé, libre…).</p></td></tr></tbody></table><h3 id="r-int-15h-fonctions-systeme-avancees" data-claire-element-id="420193">INT 15h : fonctions système avancées</h3><p id="r-420191" data-claire-element-id="420191">Cette interruption a des fonctions diverses et variées, toutes plus ou moins rattachées à la gestion du matériel. Le BIOS était autrefois en charge de la gestion de l'alimentation de notre ordinateur : il se chargeait de la mise en veille, de réduire la fréquence du processeur, d'éteindre les périphériques inutilisés. Pour cela, la routine INT 15 était utilisée. Ses fonctions de gestion de l'énergie étaient encore utilisées jusqu'à la création de Windows 95. De nos jours, avec l'arrivée de la norme ACPI, le système d'exploitation gère tout seul la gestion de l'énergie de notre ordinateur et cette routine est donc obsolète.</p><p id="r-420192" data-claire-element-id="420192">À toute règle, il faut une exception : cette routine est utilisée par les systèmes d'exploitation modernes à leur démarrage afin d'obtenir une description correcte et précise de l'organisation de la mémoire de l'ordinateur. Pour cela, nos OS configurent cette routine en plaçant la valeur <strong>0x0000e820</strong> dans le registre EAX. C'est une des très rares exceptions à la règle : les routines du BIOS sont obsolètes.</p><h3 id="r-int-16h-clavier" data-claire-element-id="420237">INT 16h : clavier</h3><p id="r-420194" data-claire-element-id="420194">Notre clavier communique avec notre ordinateur en envoyant trois sortes de signaux, qui permettent de déterminer ce que l'utilisateur fait avec son clavier. Chacun de ces signaux génère une interruption, qui sera interprétée par la routine adéquate.</p><p id="r-420195" data-claire-element-id="420195">Trois messages principaux sont utilisés :</p><ul id="r-420202" data-claire-element-id="420202"><li id="r-420197" data-claire-element-id="420197"><p id="r-420196" data-claire-element-id="420196">touche appuyée : signal spécifiant qu'on a appuyé sur une touche ;</p></li><li id="r-420199" data-claire-element-id="420199"><p id="r-420198" data-claire-element-id="420198">touche relâchée : signal spécifiant qu'on a relâché une touche ;</p></li><li id="r-420201" data-claire-element-id="420201"><p id="r-420200" data-claire-element-id="420200">et touche répétée, qui spécifie que la touche du clavier est restée enfoncée depuis le dernier envoi de message. Ce message sert quand on appuie continument sur une touche sans la relâcher.</p></li></ul><p id="r-420203" data-claire-element-id="420203">Chacun de ces signaux spécifie la touche en question, évidemment.</p><p id="r-420204" data-claire-element-id="420204">Cette routine permet de gérer une partie du clavier, et souvent de le configurer. Comme la routine INT 10, elle est très polyvalente et peut effectuer de nombreux traitements : on précise le traitement voulu en mettant le registre AH à une certaine valeur.</p><table id="r-420235" data-claire-element-id="420235"><thead id="r-420212" data-claire-element-id="420212"><tr id="r-420211" data-claire-element-id="420211"><th id="r-420206" data-claire-element-id="420206"><p id="r-420205" data-claire-element-id="420205">INT 0x16</p></th><th id="r-420208" data-claire-element-id="420208"><p id="r-420207" data-claire-element-id="420207">Valeur à placer dans le registre AH</p></th><th id="r-420210" data-claire-element-id="420210"><p id="r-420209" data-claire-element-id="420209">Description</p></th></tr></thead><tbody id="r-420234" data-claire-element-id="420234"><tr id="r-420219" data-claire-element-id="420219"><td id="r-420214" data-claire-element-id="420214"><p id="r-420213" data-claire-element-id="420213">INT 0x16</p></td><td id="r-420216" data-claire-element-id="420216"><p id="r-420215" data-claire-element-id="420215">0x00</p></td><td id="r-420218" data-claire-element-id="420218"><p id="r-420217" data-claire-element-id="420217">Identifie la touche tapée au clavier. Cette fonction est bloquante : on doit attendre la fin de l'exécution de cette routine avant de pouvoir faire exécuter quoi que ce soit d'autre par le processeur.</p></td></tr><tr id="r-420226" data-claire-element-id="420226"><td id="r-420221" data-claire-element-id="420221"><p id="r-420220" data-claire-element-id="420220">INT 0x16</p></td><td id="r-420223" data-claire-element-id="420223"><p id="r-420222" data-claire-element-id="420222">0x01</p></td><td id="r-420225" data-claire-element-id="420225"><p id="r-420224" data-claire-element-id="420224">Identifie la touche tapée au clavier. Cette routine est non bloquante.</p></td></tr><tr id="r-420233" data-claire-element-id="420233"><td id="r-420228" data-claire-element-id="420228"><p id="r-420227" data-claire-element-id="420227">INT 0x16</p></td><td id="r-420230" data-claire-element-id="420230"><p id="r-420229" data-claire-element-id="420229">0x02</p></td><td id="r-420232" data-claire-element-id="420232"><p id="r-420231" data-claire-element-id="420231">Spécifie le nombre d'envois maximal de messages (comme « touche répétée ») par seconde.</p></td></tr></tbody></table><p id="r-420236" data-claire-element-id="420236">Cette routine est utilisée tant que le système d'exploitation n'a pas démarré, c'est pour cela que vous pouvez utiliser le clavier pour naviguer dans l'écran de configuration de votre BIOS. <br/> En revanche, aucune routine standard ne permet la communication avec la souris : il est impossible d'utiliser la souris dans la plupart des BIOS. Certains BIOS possèdent malgré tout des routines capables de gérer la souris, mais ils sont très rares. Encore une fois, ces routines sont détournées par le système d'exploitation à son lancement.</p><h3 id="r-int-17h-port-parallele" data-claire-element-id="420270">INT 17h : port parallèle</h3><p id="r-420238" data-claire-element-id="420238">Cette routine permet de communiquer avec une imprimante sur le port parallèle de l'ordinateur. Comme les autres, on la configure avec le registre AH.</p><table id="r-420269" data-claire-element-id="420269"><thead id="r-420246" data-claire-element-id="420246"><tr id="r-420245" data-claire-element-id="420245"><th id="r-420240" data-claire-element-id="420240"><p id="r-420239" data-claire-element-id="420239">INT 0x17</p></th><th id="r-420242" data-claire-element-id="420242"><p id="r-420241" data-claire-element-id="420241">Valeur à placer dans le registre AH</p></th><th id="r-420244" data-claire-element-id="420244"><p id="r-420243" data-claire-element-id="420243">Description</p></th></tr></thead><tbody id="r-420268" data-claire-element-id="420268"><tr id="r-420253" data-claire-element-id="420253"><td id="r-420248" data-claire-element-id="420248"><p id="r-420247" data-claire-element-id="420247">INT 0x17</p></td><td id="r-420250" data-claire-element-id="420250"><p id="r-420249" data-claire-element-id="420249">0x00</p></td><td id="r-420252" data-claire-element-id="420252"><p id="r-420251" data-claire-element-id="420251">Imprime un caractère.</p></td></tr><tr id="r-420260" data-claire-element-id="420260"><td id="r-420255" data-claire-element-id="420255"><p id="r-420254" data-claire-element-id="420254">INT 0x17</p></td><td id="r-420257" data-claire-element-id="420257"><p id="r-420256" data-claire-element-id="420256">0x01</p></td><td id="r-420259" data-claire-element-id="420259"><p id="r-420258" data-claire-element-id="420258">Initialise l'imprimante.</p></td></tr><tr id="r-420267" data-claire-element-id="420267"><td id="r-420262" data-claire-element-id="420262"><p id="r-420261" data-claire-element-id="420261">INT 0x17</p></td><td id="r-420264" data-claire-element-id="420264"><p id="r-420263" data-claire-element-id="420263">0x02</p></td><td id="r-420266" data-claire-element-id="420266"><p id="r-420265" data-claire-element-id="420265">Vérifie l'état de l'imprimante (en cours d'impression, libre…).</p></td></tr></tbody></table><h3 id="r-int-19h" data-claire-element-id="420273">INT 19h</h3><p id="r-420271" data-claire-element-id="420271">C'est une surprise !</p><p id="r-420272" data-claire-element-id="420272">Vous verrez dans le chapitre sur le démarrage d'un ordinateur.</p><h2 id="r-conclusion-39" data-claire-element-id="420276">Conclusion</h2><p id="r-420275" data-claire-element-id="420275">Comme vous le voyez, le BIOS fournit beaucoup de routines qui étaient au départ censées faciliter la gestion du matériel. Il y a longtemps, cela simplifiait la conception des systèmes d'exploitation, et de nombreux OS, tel MS-DOS, utilisaient ces fonctions. Mais de nos jours, connaître ce genre de choses est plus synonyme d'archéologie expérimentale qu'autre chose.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est">Le BIOS : qu&#039;est-ce que c&#039;est ?</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/un-peu-d-archeologie-informatique">
Un peu d&#039;archéologie informatique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/demarrage-d-un-ordinateur-x86">
Démarrage d&#039;un ordinateur x86
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/cmos-ram-et-autres">
CMOS RAM et autres
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/demarrage-d-un-ordinateur-x86">
<span class="next">Démarrage d&#039;un ordinateur x86</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Dmarraged039unordinateurx86"></a><h2>Démarrage d&#039;un ordinateur x86</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/un-peu-d-archeologie-informatique">
<span class="arrow"></span>
<span class="next">Un peu d&#039;archéologie informatique</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/cmos-ram-et-autres">
<span class="next">CMOS RAM et autres</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-420278" data-claire-element-id="420278">Comme je l'ai dit plus haut, le BIOS sert aussi à allumer l'ordinateur et à le configurer correctement avant de laisser la main au système d'exploitation. Cette phase s'appelle le <em><strong>Power On Self Test</strong></em>, que l'on nomme communément POST. Durant cette phase, les périphériques sont détectés, testés et configurés pour garantir leur fonctionnement. Le premier élément vérifié lors du POST (<em>Power On Self Test</em>) est la stabilité de l'alimentation électrique de l'ordinateur. Le BIOS teste les tensions 12 volts, 5 volts et 3,3 volts, et continue son exécution uniquement si celles-ci sont stables et à la bonne valeur. Si les tensions d'alimentation ne sont pas stables ou ne sont pas à la bonne valeur, le BIOS arrête immédiatement le démarrage, pour éviter d'endommager le processeur ou d'autres composants de l'ordinateur.</p><p id="r-420279" data-claire-element-id="420279">Ensuite, le BIOS vérifie la stabilité de l'horloge et de quelques autres composants : les 64 premiers kilo-octets de la mémoire, par exemple.</p><p id="r-420280" data-claire-element-id="420280">Étape suivante : initialiser le vecteur d'interruption de notre ordinateur avec ses valeurs par défaut, fournies par le BIOS. Si le vecteur d'interruption est écrit sans erreur dans la mémoire RAM, le BIOS émet un petit bip, pour signaler que tout va bien. En effet, un <em>buzzer</em> est placé sur la carte mère et est directement commandable par le processeur. Au moindre problème à l'allumage, le processeur demande à ce <em>buzzer</em> de bipper. Suivant l'erreur, la série de bips émise sera différente, afin de pouvoir identifier l'erreur facilement. Attention, cependant : les séries de bips n'ont pas été standardisées par les fabricants de BIOS. Chaque fabricant a sa propre manière de faire bipper le <em>buzzer</em> en cas d'erreur.</p><p id="r-420281" data-claire-element-id="420281">Ensuite, le clavier et la carte vidéo vont être configurés par les routines vues plus haut. Pour détecter la présence d'une carte vidéo VGA/ESA, le BIOS regarde les adresses mémoire <strong>0x000C 0000</strong> et <strong>0x000E 0000</strong> : ce sont les adresses d'une mémoire ROM, intégrée à la carte graphique, qui contient toutes les fonctions de base servant à afficher des graphismes à l'écran. Si tout fonctionne bien, le BIOS va alors demander l'affichage d'un message à l'écran. Si un problème a lieu durant cette phase de test, le BIOS émet un signal sonore.</p><p id="r-420282" data-claire-element-id="420282">À la suite du POST et après avoir détecté les périphériques en communiquant avec les différents bus système, notre BIOS va chercher lesquels peuvent contenir un système d'exploitation qu'il peut charger.</p><h2 id="r-on-est-tombe-sur-un-os" data-claire-element-id="420285">On est tombé sur un OS !</h2><p id="r-420283" data-claire-element-id="420283">Dans les anciens ordinateurs, le seul programme que pouvait exécuter l'ordinateur était un simple programme stocké dans une mémoire ROM. Mais avec l'apparition d'ordinateurs plus sophistiqués, on a rendu possible l'exploitation par un ordinateur de programmes différents de celui placé dans sa mémoire ROM. L'invention des systèmes d'exploitation a été un pas de plus dans ce sens, mais il a fallu trouver un moyen de démarrer l'ordinateur de façon à charger un système d'exploitation à partir d'une mémoire autre que la mémoire ROM placée sur sa carte mère.</p><p id="r-420284" data-claire-element-id="420284">Dans tous les ordinateurs, le système d'exploitation est placé sur le disque dur, la carte mère n'a alors aucun moyen de charger le système d'exploitation directement depuis le disque dur dans la mémoire RAM pour qu'il puisse s'exécuter. Pour résoudre ce problème, on laisse faire le BIOS.</p><h2 id="r-rappels-sur-le-disque-dur" data-claire-element-id="420296">Rappels sur le disque dur</h2><p id="r-420286" data-claire-element-id="420286">Comme vous le savez tous, un disque dur est un périphérique servant à mémoriser des données de façon permanente : les données inscrites sur un disque dur ne s'effacent pas quand on coupe le courant. Ce disque dur est composé de plusieurs <strong>plateaux</strong>, fabriqués dans un matériau magnétique et sur lesquels on inscrit des données. Notre disque dur est découpé en petits blocs de données, chacun capable de contenir un bit, qu'on aimantera dans une direction pour stocker un 1 et dans l'autre sens pour stocker un 0.</p><h3 id="r-secteurs-cylindres-et-tetes" data-claire-element-id="420290">Secteurs, cylindres et têtes</h3><p id="r-420287" data-claire-element-id="420287">Un disque dur contient plusieurs de ces plateaux. Mais il faut connaître un peu la façon dont chaque plateau est organisé avant de poursuivre. J'ai parlé plus haut de ces cellules capables de stocker un bit ; eh bien, sachez que plusieurs de ces bits, appartenant à différents plateaux, sont superposés les uns au-dessus des autres. Cela forme ce qu'on appelle un <strong>cylindre</strong>. Pour un disque dur possédant n cylindres, ceux-ci sont numérotés de 0 à n-1.</p><p id="r-420288" data-claire-element-id="420288">Les cellules d'un même plateau sont regroupées en paquets de plusieurs centaines de bits qui se suivent les uns à côté des autres : les <strong>secteurs</strong>. Pour simplifier le travail de l'électronique du disque dur, on préfère utiliser des paquets ayant une taille de la forme 2^{n}. Sur les disques durs actuels, un secteur a une taille de 512 octets, soit 4 096 bits. Ces secteurs sont numérotés en commençant à 1.</p><p id="r-420289" data-claire-element-id="420289">Notre disque dur contient aussi de petits dispositifs mobiles capables de lire ou écrire une donnée sur le disque dur : les <strong>têtes de lecture − écriture</strong>, avec une tête de lecture par plateau. Un disque dur en possède plusieurs. Pour un disque dur contenant n têtes de lecture − écriture, on les numérote de 0 à n-1.</p><h3 id="r-adressage-chs-1" data-claire-element-id="420295">Adressage CHS</h3><p id="r-420291" data-claire-element-id="420291">Pour localiser un secteur sur un disque dur, il suffit alors de préciser le numéro du cylindre, le secteur et la tête de lecture (pour préciser le bon plateau). Cette façon d'adresser un secteur du disque dur s'appelle l'<strong>adressage CHS</strong>. Le seul problème avec cet adressage, c'est que le BIOS utilise 10 bits pour coder le numéro du cylindre, 8 bits pour le numéro de tête (parfois 4) et 6 bits pour le numéro de secteur, ce qui limite la taille maximale possible du disque dur à environ 500 méga-octets. Pour contrer cette limite et pour que le BIOS détecte les disques durs avec la bonne taille au démarrage, on a inventé diverses astuces.</p><p id="r-420292" data-claire-element-id="420292">Une de ces astuces consiste à transformer les coordonnées CHS codées sur 24 bits (10 bits pour le cylindre + 8 pour le numéro de tête + 6 pour le numéro de secteur) en coordonnées de 28 bits. Pour cela, les routines de gestion du disque dur ont été modifiées pour réaliser ces traductions de coordonnées, ce qui a repoussé la limite de taille des disques durs à environ 8 giga-octets.</p><p id="r-420293" data-claire-element-id="420293">Enfin, devant la progression de la taille des disques durs, on a inventé l'<strong>adressage LBA</strong>. Celui-ci numérote simplement chaque secteur du disque dur par un nombre, sans se préoccuper de son numéro de tête, de cylindre ou de secteur. Il est donc identifié par un simple nombre : l'adresse logique, qui peut être traduite par le BIOS ou l'électronique intégrée dans le disque dur en une adresse CHS codée sur suffisamment de bits.</p><p id="r-420294" data-claire-element-id="420294">Nos BIOS peuvent utiliser différents types d'adressage en fonction de la carte mère et certains peuvent en utiliser plusieurs (aussi bien CHS que LBA, par exemple). En fait, la routine standardisée INT 13 manipule des coordonnées CHS, mais on peut parfaitement trouver d'autres routines complémentaires qui travaillent avec des coordonnées LBA. Certaines ne sont pas standardisées, mais d'autres le sont : on peut citer notamment les <em><a href="http://www.t10.org/t13/technical/d98120r0.pdf">Enhanced Disk Drive</a></em>.</p><h2 id="r-mbr" data-claire-element-id="420306">MBR</h2><p id="r-420297" data-claire-element-id="420297">Le <strong>MBR</strong>, abréviation de <em><strong>Master Boot Record</strong></em>, est le nom donné au premier secteur du disque dur (aussi bien en adressage LBA qu'en adressage CHS). Ses coordonnées CHS sont donc (0, 0, 1). C'est dans ce MBR que toutes les informations nécessaires au démarrage d'un système d'exploitation sont placées. Ce MBR est assez bien organisé et contient trois grandes parties aux usages différents.</p><h3 id="r-code-executable" data-claire-element-id="420301">Code exécutable</h3><p id="r-420298" data-claire-element-id="420298">Les premiers octets du MBR sont remplis par un programme servant à charger le système d'exploitation. Ceux-ci sont chargés à la fin du POST, par la routine INT 19h, qui copie le premier secteur dans la mémoire RAM, à l'adresse 0x7C00. Cette routine configure ensuite le processeur en plaçant l'adresse de base de ce code en mémoire (notre fameux 0x7C00) dans le registre pointeur d'instruction E(IP) du processeur, ce qui permet d'exécuter ce programme et donc de lancer l'OS.</p><p id="r-420299" data-claire-element-id="420299">Toutefois, il existe quand même une condition à cela : à la toute fin du MBR, les deux derniers octets doivent avoir une valeur bien précise pour que le BIOS autorise l'exécution de ce programme. Cette valeur, appelée le nombre magique, vaut 0xAA55, ce qui correspond à 43 605 en décimal. Mais le résultat est encore plus joli en binaire : 1010101001010101. ;)</p><p id="r-420300" data-claire-element-id="420300">Ce programme est suivi par quelques octets optionnels, souvent vides, puis par la table des partitions. Le programme en lui-même fait 440 octets.</p><h3 id="r-table-des-partitions" data-claire-element-id="420303">Table des partitions</h3><p id="r-420302" data-claire-element-id="420302">La table des partitions contient des informations sur les différentes partitions installées sur le disque dur : leur « nom », leur taille, et leur localisation sur le disque dur. Chaque ligne d'une table de partition contient l'adresse CHS de début d'une partition et sa taille. On ne peut créer que quatre lignes dans cette table, on se trouve donc limité à quatre partitions principales. Il faut dire que cette table ne fait que 64 octets (elle a été conçue comme cela).</p><h3 id="r-messages-d-erreur" data-claire-element-id="420305">Messages d'erreur</h3><p id="r-420304" data-claire-element-id="420304">Il existe enfin une zone contenant les messages d'erreur à afficher dans le cas où le lancement du système d'exploitation échouerait. Par exemple, le message d'erreur NTDLR manquant est stocké dans cette zone.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est">Le BIOS : qu&#039;est-ce que c&#039;est ?</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/un-peu-d-archeologie-informatique">
Un peu d&#039;archéologie informatique
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/demarrage-d-un-ordinateur-x86">
Démarrage d&#039;un ordinateur x86
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/cmos-ram-et-autres">
CMOS RAM et autres
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/un-peu-d-archeologie-informatique">
<span class="arrow"></span>
<span class="next">Un peu d&#039;archéologie informatique</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/cmos-ram-et-autres">
<span class="next">CMOS RAM et autres</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="CMOSRAMetautres"></a><h2>CMOS RAM et autres</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/demarrage-d-un-ordinateur-x86">
<span class="arrow"></span>
<span class="next">Démarrage d&#039;un ordinateur x86</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-420308" data-claire-element-id="420308">Vous avez sûrement remarqué que notre ordinateur est capable de retenir la date, et ce même débranché ? Eh bien notre BIOS a un petit rapport avec cela !</p><h2 id="r-cmos-ram" data-claire-element-id="420323">CMOS RAM</h2><p id="r-420309" data-claire-element-id="420309">Dans un ordinateur, et dans tout composant électronique capable de conserver une heure ou une date, on trouve une mémoire capable de retenir l'heure et la date. Mais cela ne suffit pas : il faut aussi que l'heure ne se dérègle pas, et pour cela, il faut continuer à compter, même quand l'ordinateur est débranché. Il nous faut donc un circuit capable de compter, qui est incrémenté de façon cyclique à chaque fois qu'une durée bien précise s'est écoulée. Enfin, il nous faut aussi une source d'énergie qui remplace l'alimentation secteur lorsque l'ordinateur est débranché, pour alimenter ces circuits. Cette source d'énergie est quasiment toujours une pile au lithium installée sur la carte mère.</p><p id="r-420310" data-claire-element-id="420310">Pour récapituler, il nous faut donc :</p><ul id="r-420319" data-claire-element-id="420319"><li id="r-420312" data-claire-element-id="420312"><p id="r-420311" data-claire-element-id="420311">une <strong>horloge</strong>, pour synchroniser les composants ;</p></li><li id="r-420314" data-claire-element-id="420314"><p id="r-420313" data-claire-element-id="420313">un <strong>compteur</strong>, qui est un circuit comptant de un en un à chaque tic d'horloge (ou en plusieurs tics d'horloge, c'est selon) ;</p></li><li id="r-420316" data-claire-element-id="420316"><p id="r-420315" data-claire-element-id="420315">une mémoire capable de conserver la date et l'heure, qui sont mises à jour au besoin (date, heure…) ;</p></li><li id="r-420318" data-claire-element-id="420318"><p id="r-420317" data-claire-element-id="420317">et une pile pour alimenter le tout.</p></li></ul><p id="r-420320" data-claire-element-id="420320">Première précision : l'horloge dont je viens de parler n'a rien à voir avec l'autre horloge nommée <strong>horloge système</strong>, créée pour cadencer les différents bus, et qui est utilisée par le processeur et la mémoire pour ajuster leur fréquence. On va appeler l'horloge censée compter le temps l'<strong>horloge RTC</strong>, pour <em>Real Time Clock</em>. La RTC est créée par un oscillateur à quartz, et a une fréquence qui est souvent calibrée à 32 768 Hz. Cette fréquence correspond à 2^{15} cycles d'horloge par seconde, ce qui permet de compter à la seconde près sans décalage. Du moins en théorie, car cette horloge n'a pas une fréquence de 32,768 kHz tout pile, et quelques ajustements sont parfois nécessaires.</p><p id="r-420321" data-claire-element-id="420321">Autre précision : la mémoire utilisée pour stocker l'heure est une <strong>mémoire SRAM</strong> ! Ce n'est pas une mémoire EEPROM, comme on pourrait le penser. Il s'agit souvent d'une mémoire fabriquée avec des transistors CMOS, d'où son nom de <strong>CMOS RAM</strong>.</p><p id="r-420322" data-claire-element-id="420322">D'autres circuits additionnels permettent de mettre à jour l'heure, les minutes, les secondes ou la date présentes dans la CMOS SRAM (en cas de changement d'heure, par exemple). Les circuits de gestion de l'horloge, le compteur de temps ainsi que la mémoire RAM sont placés en dehors du BIOS et sont lus par le BIOS au démarrage. Seuls les circuits de gestion du temps, l'horloge (différente de l'horloge système) et la mémoire RAM sont encore alimentés par la pile de l'ordinateur une fois celui-ci éteint.</p><h2 id="r-autres-parametres-du-bios" data-claire-element-id="420335">Autres paramètres du BIOS</h2><p id="r-420324" data-claire-element-id="420324">Les paramètres modifiables du BIOS sont souvent stockés dans une mémoire FLASH ou EEPROM séparée du BIOS, qui est lue par le BIOS à l'allumage de l'ordinateur. De nos jours, cette mémoire est fusionnée avec le circuit de gestion du temps et est placée directement dans le <em>southbridge</em> dans un seul et unique circuit.</p><p id="r-420325" data-claire-element-id="420325">Cette mémoire, la mémoire CMOS, est adressable, ce qui signifie qu'on peut y accéder par une adresse. Mais on y accède indirectement, car on communique avec cette adresse comme si c'était un périphérique : le contenu de la CMOS RAM ne peut pas être écrit ou lu directement case mémoire par case mémoire par notre processeur, mais il peut envoyer des ordres de lecture ou des informations à écrire une par une sur une adresse bien précise. Cela lui permet d'aller lire les informations contenues dans cette RAM, pour afficher l'heure dans son menu de configuration, par exemple. On y accède <em>via</em> les adresses <strong>0x0007 0000</strong> et <strong>0x0007 0001</strong> (ces adresses sont écrites en hexadécimal).</p><p id="r-420326" data-claire-element-id="420326">Et voilà, vous savez maintenant ce qu'est le BIOS.</p><p id="r-420327" data-claire-element-id="420327">Pour ceux qui désirent en savoir un peu plus sur les interruptions du BIOS, voici quelques liens :</p><ul id="r-420334" data-claire-element-id="420334"><li id="r-420329" data-claire-element-id="420329"><p id="r-420328" data-claire-element-id="420328"><a href="http://en.wikipedia.org/wiki/INT_10H">interruption INT 10h</a> ;</p></li><li id="r-420331" data-claire-element-id="420331"><p id="r-420330" data-claire-element-id="420330"><a href="http://en.wikipedia.org/wiki/INT_13H">interruption INT 13h</a> ;</p></li><li id="r-420333" data-claire-element-id="420333"><p id="r-420332" data-claire-element-id="420332"><a href="http://en.wikipedia.org/wiki/INT_14H">interruption INT 14h</a>.</p></li></ul>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est">Le BIOS : qu&#039;est-ce que c&#039;est ?</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/un-peu-d-archeologie-informatique">
Un peu d&#039;archéologie informatique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/demarrage-d-un-ordinateur-x86">
Démarrage d&#039;un ordinateur x86
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/cmos-ram-et-autres">
CMOS RAM et autres
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-bios-qu-est-ce-que-c-est/demarrage-d-un-ordinateur-x86">
<span class="arrow"></span>
<span class="next">Démarrage d&#039;un ordinateur x86</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/le-bios-qu-est-ce-que-c-est.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 06:45:54 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/le-bios-qu-est-ce-que-c-est.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:13:28 GMT -->
</html>
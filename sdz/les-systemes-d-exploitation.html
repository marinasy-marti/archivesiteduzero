<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/les-systemes-d-exploitation.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 06:50:59 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-systemes-d-exploitation.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:14:41 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Les systèmes d&#039;exploitation</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/les-systemes-d-exploitation.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Les systèmes d&#039;exploitation</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Lessystmesd039exploitation">Les systèmes d&#039;exploitation</a><br/><a href="#Mcanismesd039abstractiondespriphriques">Mécanismes d&#039;abstraction des périphériques</a><br/><a href="#Programmessystmesetapplicatifs">Programmes systèmes et applicatifs</a><br/><a href="#Rappelsurlesinterruptions">Rappel sur les interruptions</a><br/><a href="#Noyaud039unOS">Noyau d&#039;un OS</a><br/><a href="#Notremmoiretourneenrond">Notre mémoire tourne en rond !</a><br/><a href="#Principauxtypesdenoyaux">Principaux types de noyaux</a><br/><a href="#Ordonnancement">Ordonnancement</a><br/><a href="#C039estquoi">C&#039;est quoi ?</a><br/><a href="#Algorithmesd039ordonnancement">Algorithmes d&#039;ordonnancement</a><br/><a href="#Processusetthreads">Processus et threads</a><br/><a href="#Processusetthreads">Processus et threads</a><br/><a href="#Sectionscritiques">Sections critiques</a><br/><a href="#Allocationetprotectionmmoireavance">Allocation et protection mémoire avancée</a><br/><a href="#Systmesmono-programms">Systémes mono-programmés</a><br/><a href="#Partitionsmmoiresfixes">Partitions mémoires fixes</a><br/><a href="#Allocationdynamique">Allocation dynamique</a><br/><a href="#Adressagemmoirequelquessubtilits">Adressage mémoire : quelques subtilités</a><br/></div>
<a name="Lessystmesd039exploitation"></a><h2>Les systèmes d&#039;exploitation</h2><div class="content" role="article">
<p id="r-548559" data-claire-element-id="548559">Vous utilisez tous les jours un système d'exploitation, sans forcément savoir ce qui se cache derrière ce mot. Mais savez-vous ce qu'est un système d'exploitation, son utilité, en quoi c'est fait ? Si la réponse est non, alors ce tutoriel risque sûrement de vous intéresser.</p>
</div>
<div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1358423835269-0" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1358423835269-0');
        });
    }
    </script>
</div><a name="Mcanismesd039abstractiondespriphriques"></a><h2>Mécanismes d&#039;abstraction des périphériques</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
<span class="next">Programmes systèmes et applicatifs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-548562" data-claire-element-id="548562">L'abstraction matérielle consiste à camoufler le fonctionnement du matériel aux programmes et faire en sorte que ceux-ci fonctionnent sur des matériels divers et variés sans problème. Dans cette partie, on va voir comment notre système d’exploitation fait pour abstraire le matériel : les mécanismes généraux d'abstraction matérielle seront vus dans ce chapitre et on se concentrera sur les mécanismes utilisés par nos programmes pour utiliser les périphériques.</p>
</div><a name="Programmessystmesetapplicatifs"></a><h2>Programmes systèmes et applicatifs</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">
<span class="arrow"></span>
<span class="next">Mécanismes d&#039;abstraction des périphériques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
<span class="next">Rappel sur les interruptions</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-548563" data-claire-element-id="548563">Pour comprendre ce que sont les systèmes d'exploitation, on va voir la différence entre un ordinateur qui en possède un et un autre qui n'en a pas.</p><h2 id="r-sans-systeme-d-exploitation" data-claire-element-id="548566">Sans système d'exploitation</h2><p id="r-548564" data-claire-element-id="548564">Un seul et unique programme dans l'ordinateur se charge de tout faire, y compris manipuler le matériel. Et bien évidemment, un programmeur qui souhaite se passer de système d'exploitation doit tout programmer, y compris les parties du programme en charge de la gestion des périphériques, des ports d'entrée-sortie, de la mémoire...</p><p id="r-548565" data-claire-element-id="548565">De plus, ce que le programmeur aura programmé sera difficilement portable sur d'autres ordinateurs, qui n'auront pas le même matériel : on ne gère pas les périphériques et/ou la mémoire de la même façon sur tous les ordinateurs. Autant vous dire que pour rendre notre programme compatible avec un autre ordinateur, il faudrait reprogrammer une grande partie du programme ainsi conçu.</p><h2 id="r-avec-un-systeme-d-exploitation" data-claire-element-id="548613">Avec un système d'exploitation</h2><p id="r-548567" data-claire-element-id="548567">Plutôt que de créer un seul et unique programme informatique chargé de tout gérer, on segmente ce programme en plusieurs programmes séparés. Ces programmes peuvent être divisés en deux types :</p><table id="r-548593" data-claire-element-id="548593"><thead id="r-548573" data-claire-element-id="548573"><tr id="r-548572" data-claire-element-id="548572"><th id="r-548569" data-claire-element-id="548569"><p id="r-548568" data-claire-element-id="548568">Programmes systèmes</p></th><th id="r-548571" data-claire-element-id="548571"><p id="r-548570" data-claire-element-id="548570">Programmes applicatifs</p></th></tr></thead><tbody id="r-548592" data-claire-element-id="548592"><tr id="r-548591" data-claire-element-id="548591"><td id="r-548582" data-claire-element-id="548582"><p id="r-548574" data-claire-element-id="548574">Ils sont en charge de la gestion du matériel de l'ordinateur. Ils gèrent :</p><ul id="r-548581" data-claire-element-id="548581"><li id="r-548576" data-claire-element-id="548576"><p id="r-548575" data-claire-element-id="548575">la gestion de la mémoire ;</p></li><li id="r-548578" data-claire-element-id="548578"><p id="r-548577" data-claire-element-id="548577">les périphériques et ports d'entrée-sortie ;</p></li><li id="r-548580" data-claire-element-id="548580"><p id="r-548579" data-claire-element-id="548579">l'exécution des autres programmes (ceux qui ne sont pas des programmes systèmes) exécutés sur l'ordinateur.</p></li></ul></td><td id="r-548590" data-claire-element-id="548590"><p id="r-548583" data-claire-element-id="548583">Ces programmes applicatifs sont des programmes comme les autres qui font exécuter directement leurs instructions par le processeur, mais qui :</p><ul id="r-548588" data-claire-element-id="548588"><li id="r-548585" data-claire-element-id="548585"><p id="r-548584" data-claire-element-id="548584">Ne peuvent pas gérer les périphériques et ports d'entrée-sortie.</p></li><li id="r-548587" data-claire-element-id="548587"><p id="r-548586" data-claire-element-id="548586">Ne peuvent manipuler qu'une portion de la mémoire que le(s) programme(s) système(s) leur a(ont) attribué.</p></li></ul><p id="r-548589" data-claire-element-id="548589">Lorsqu'ils ont besoin de le faire, ceux-ci délèguent les taches à effectuer aux programmes systèmes.</p></td></tr></tbody></table><p id="r-548594" data-claire-element-id="548594">Généralement, les programmes systèmes (et quelques programmes applicatifs de base) sont tous regroupés dans ce qu'on appelle un <strong>système d'exploitation</strong>, aussi appelé OS (<em>operating system</em> en anglais). En plus de ces programmes systèmes, le reste de l'OS est composé de programmes applicatifs qui permettent par exemple d'afficher une interface qui permet à l'utilisateur de pouvoir utiliser l'ordinateur comme il le souhaite.</p><p id="r-548595" data-claire-element-id="548595">Évidement, ces sous-programmes systèmes ne sont pas les mêmes sur tous les systèmes d'exploitations. Ce qui est une des raisons qui font que certains programmes ne sont compatibles qu'avec <em>(mettez ici le nom de n'importe quel OS</em>).</p><div id="r-548597" data-claire-element-id="548597" data-claire-semantic="question"><p id="r-548596" data-claire-element-id="548596">L'intérêt de cette séparation ?</p></div><p id="r-548598" data-claire-element-id="548598">Très simple : plutôt que de devoir reprogrammer à chaque fois la gestion de la mémoire, des périphériques, et cetera, on programme une seule fois les programmes qui s'occupent de la gestion du matériel. Ensuite, on crée des programmes applicatifs, qui pourront si besoin est communiquer avec les programmes systèmes. L'avantage, c'est que tout le travail de programmation de l'accès au matériel est déjà fait. Les programmeurs peuvent se contenter de créer des programmes applicatifs et n'ont pas besoin de programmer les programmes systèmes.</p><p id="r-548599" data-claire-element-id="548599">Pour information, voici une liste des taches qui sont déléguées aux programmes systèmes :</p><ul id="r-548612" data-claire-element-id="548612"><li id="r-548601" data-claire-element-id="548601"><p id="r-548600" data-claire-element-id="548600">gérer une partie de ce qui concerne la mémoire ;</p></li><li id="r-548603" data-claire-element-id="548603"><p id="r-548602" data-claire-element-id="548602">la gestion de l’exécution de plusieurs programmes sur un même ordinateur ;</p></li><li id="r-548605" data-claire-element-id="548605"><p id="r-548604" data-claire-element-id="548604">permettre à plusieurs programmes d'échanger des données entre eux si besoin est ;</p></li><li id="r-548607" data-claire-element-id="548607"><p id="r-548606" data-claire-element-id="548606">gérer tous les périphériques de l'ordinateur ;</p></li><li id="r-548609" data-claire-element-id="548609"><p id="r-548608" data-claire-element-id="548608">la gestion des fichiers , du réseau , du son, de l'affichage ;</p></li><li id="r-548611" data-claire-element-id="548611"><p id="r-548610" data-claire-element-id="548610">...</p></li></ul><h2 id="r-pilotes" data-claire-element-id="548616">Pilotes</h2><p id="r-548614" data-claire-element-id="548614">Un système d'exploitation ne sait généralement pas utiliser tous les périphériques et ports d'entrée-sortie existants. Pour cela, on a inventé les <strong>pilotes de périphériques</strong>, des programmes qui permettent à un programme (ici, le système d'exploitation) de communiquer avec un périphérique. Ils contiennent des programmes systèmes qui effectuent chacun une action particulière sur le périphérique.</p><p id="r-548615" data-claire-element-id="548615">Par exemple, un pilote de carte réseau contient un programme système qui va permettre d'envoyer des données à la carte réseau et capable de manipuler les bus adéquats. Ce programme système est différent pour chaque carte réseau. Mais du point de vue du programme applicatif, peut importe la façon dont ce programme système est conçu, celui-ci va envoyer une donnée à la carte réseau. Ainsi, quelque soit le pilote, et donc le périphérique, le résultat sera le même : la façon dont la carte réseau fonctionne n'intervient pas ! Évidement, la façon dont le pilote de périphérique va communiquer avec le système d'exploitation est standardisée pour faciliter le tout.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation">Les systèmes d&#039;exploitation</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Programmes systèmes vs programmes applicatifs
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">Mécanismes d&#039;abstraction des périphériques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
Programmes systèmes et applicatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
Rappel sur les interruptions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">Noyau d&#039;un OS</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
Notre mémoire tourne en rond !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
Principaux types de noyaux
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Si on utilisait plusieurs programmes ?
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">Ordonnancement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
Algorithmes d&#039;ordonnancement
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">Processus et threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
Processus et threads
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
Sections critiques
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Gestion de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">Allocation et protection mémoire avancée</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
Systémes mono-programmés
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
Partitions mémoires fixes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
Allocation dynamique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
Adressage mémoire : quelques subtilités
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">
<span class="arrow"></span>
<span class="next">Mécanismes d&#039;abstraction des périphériques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
<span class="next">Rappel sur les interruptions</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Rappelsurlesinterruptions"></a><h2>Rappel sur les interruptions</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
<span class="arrow"></span>
<span class="next">Programmes systèmes et applicatifs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">
<span class="next">Noyau d&#039;un OS</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-548618" data-claire-element-id="548618">On vient de voir que notre OS et nos pilotes ont comme fonction la prise en charge d'une partie de la gestion du matériel et fournissent quelques abstractions matérielles minimales au système d'exploitation et à l'utilisateur. On peut légitimement se demander comment nos programmes systèmes vont-ils faire pour gérer le matériel et comment nos programmes applicatifs vont-ils pouvoir les utiliser comme bon leur semble. Pour communiquer avec le matériel, nos fameux programmes systèmes vont utiliser des fonctionnalités de notre processeur qu'on appelle les <strong>interruptions</strong>.</p><h2 id="r-interruptions-1" data-claire-element-id="548627">Interruptions</h2><div id="r-548620" data-claire-element-id="548620" data-claire-semantic="question"><p id="r-548619" data-claire-element-id="548619">Holà, c'est quoi une interruption ?</p></div><p id="r-548621" data-claire-element-id="548621">C'est une fonctionnalité de notre processeur qui va permettre d’arrêter temporairement l’exécution d'un programme pour en exécuter un autre. On les utilise pour quelques cas bien précis, qui nécessitent un traitement ne pouvant attendre trop longtemps : communiquer avec un ou des périphériques, par exemple. Ainsi, pour communiquer avec une carte graphique, un disque dur ou encore avec le clavier, nos programmes applicatifs vont devoir utiliser des interruptions.</p><p id="r-548622" data-claire-element-id="548622">Ces interruptions ont pour but d'interrompre l’exécution d'un programme afin de réagir à un événement extérieur (matériel, erreur fatale d’exécution d'un programme...) et de la traiter en temps voulu, avant de rendre la main au programme interrompu. Notre interruption va donc devoir effectuer un petit traitement (ici, communiquer avec un périphérique). Ce petit traitement est fait par un petit programme au auquel on a donné un nom technique : <strong>routine d'interruption</strong>.</p><figure id="r-548624" data-claire-element-id="548625"><img id="r-548623" data-claire-element-id="548623" src="medias/uploads.siteduzero.com_files_324001_325000_324697.png" alt="Image utilisateur"/></figure><p id="r-548626" data-claire-element-id="548626">Notre OS et nos pilotes fournissent toutes les routines d'interruptions de bases pour que notre matériel fonctionne : la majorité des programmes systèmes sont des interruptions. Voici comment nos programmes applicatifs peuvent exploiter le matériel sans se fatiguer : en exécutant l'interruption qui va bien. Vous voulez écrire une donnée sur le disque dur, un programme système exécutant des interruptions est fourni par votre OS.</p><h2 id="r-vecteur-d-interruption-1" data-claire-element-id="548635">Vecteur d'interruption</h2><p id="r-548628" data-claire-element-id="548628">Comme on l'a dit, une interruption a été conçue pour réagir à un événement, mais ce sont avant tout des programmes comme les autres, qui peuvent être exécutés comme n'importe quelle autre programme. Dans notre cas, ces interruptions seront simplement considérées comme des programmes simplistes permettant d'agir sur un périphérique. Bien sûr, devant la multiplicité des périphériques, on se doute bien qu'il n'existe pas d'interruption à tout faire : il va de soi qu'un programme envoyant un ordre au disque dur sera différent d'un programme agissant sur une carte graphique. Dans chaque cas, on aura besoin d'effectuer un traitement différent. On a donc besoin de plusieurs routines d'interruption.</p><p id="r-548629" data-claire-element-id="548629">Mais il faut bien décider quelle est l'interruption à exécuter suivant la situation. Par exemple, exécuter l'interruption de gestion du clavier alors qu'on souhaite communiquer avec notre disque dur donnerait un résultat plutôt comique. :p On va donc devoir stocker plusieurs de ces routines dans sa mémoire. Mais comment les retrouver ? Comme les autres données ! Pour expliquer correctement cela, il va falloir faire un petit rappel.</p><p id="r-548630" data-claire-element-id="548630">La mémoire de notre ordinateur est un vulgaire amas de cellules mémoire, chacune capable de retenir des bits : on rappelle qu'un bit est une information qui peut prendre deux valeurs : 0 ou 1. Ces cellules mémoires sont regroupées en paquets de 8, qu'on appelle des cases mémoires. Ces cases mémoires vont donc contenir des données (ou des morceaux de données : un nombre entier prend souvent plusieurs cases mémoires). Pour savoir à quelle case mémoire on a stocké notre donnée, notre ordinateur va identifier chaque case mémoire par un nombre unique : l'<strong>adresse mémoire</strong>. Chaque routine est donc placée dans la mémoire à un certain endroit, localisable par son adresse : elle indique sa position dans la mémoire.</p><p id="r-548631" data-claire-element-id="548631">Pour retrouver la position de notre routine en mémoire et savoir laquelle exécuter, certains ordinateurs utilisent une partie de leur mémoire pour stocker toutes les adresses de début de chaque routine d'interruption. En gros, cette partie de la mémoire contient toute les adresse permettant de localiser chaque routine. Cette portion de la mémoire s'appelle le vecteur d'interruption. Pour chaque interruption, une partie fixe de la mémoire contiendra l'adresse de début de l'interruption à effectuer.</p><aside id="r-548633" data-claire-element-id="548633" data-claire-semantic="information"><p id="r-548632" data-claire-element-id="548632">Pour ceux qui connaissent un peu la programmation, vous pouvez voir ce vecteur d'interruption comme un tableau de pointeur sur fonction. Les fonctions étant les routines à exécuter.</p></aside><p id="r-548634" data-claire-element-id="548634">Ce vecteur d'interruption est initialisé par le BIOS au démarrage de l'ordinateur. Néanmoins, nos pilotes et le système d'exploitation vont fournir leurs propres routines. Pour que celles-ci soient exécutées, il suffit à l'OS de &quot;détourner l'interruption&quot;. Cela consiste à remplacer l'adresse de l'interruption contenue dans le vecteur d'interruption par l'adresse de la routine que l'OS a chargé en mémoire (bien sûr, l'ancienne adresse est sauvegardée).<br/> En clair, le vecteur d'interruption ne contiendra plus l'adresse servant à localiser la routine du BIOS, mais renverra vers l'adresse localisant la routine de l'OS.</p><h2 id="r-comment-profiter-de-ces-interruptions" data-claire-element-id="548647">Comment profiter de ces interruptions ?</h2><p id="r-548636" data-claire-element-id="548636">Vous l'avez compris, une grande partie des programmes systèmes sont des routines d'interruptions. Notre système d'exploitation fournit donc un grand nombre d'interruptions ayant chacune une fonction bien précise. Ce peut être des interruptions qui servent à communiquer avec un disque dur, ou des interruptions qui servent à effectuer des manipulations plus évoluées (gérer la mémoire notamment). Ces interruptions ne sont pas toutes standardisées et certaines d'entre elles peuvent varier suivant les systèmes d'exploitation, ce qui est la cause de quelques incompatibilités.</p><p id="r-548637" data-claire-element-id="548637">Il y a trois manières de déclencher une interruption :</p><ul id="r-548644" data-claire-element-id="548644"><li id="r-548639" data-claire-element-id="548639"><p id="r-548638" data-claire-element-id="548638">exécuter <a href="http://fr.wikipedia.org/wiki/Instruction_machine">l'instruction machine</a><code data-claire-semantic="nasm">int</code>,</p></li><li id="r-548641" data-claire-element-id="548641"><p id="r-548640" data-claire-element-id="548640">les exceptions, qui se produisent automatiquement lorsque le processeur rencontre une erreur (du style une division par zéro),</p></li><li id="r-548643" data-claire-element-id="548643"><p id="r-548642" data-claire-element-id="548642">les requêtes d'interruptions, qui sont déclenchées par un événement d'origine matérielle.</p></li></ul><p id="r-548645" data-claire-element-id="548645">Nos programmes applicatifs utilisent la premiére méthode : l'instruction machine <code data-claire-semantic="nasm">int</code>. Cette instruction machine a besoin de quelques petites informations pour faire ce qui est demandé. Tout d'abord, elle a besoin de savoir quelle interruption exécuter. Pour cela, elle a besoin du numéro de l'interruption dans le vecteur d'interruption. En clair, l'adresse de la routine est stockée dans ce vecteur d'interruption, quelque part, à une adresse bien précise. Notre instruction <code data-claire-semantic="nasm">int</code> a besoin de connaitre cette adresse qui correspond à la portion de mémoire qui stocke l'adresse de la routine. Elle ne peut prendre directement l'adresse de la routine : si celle-ci est détournée, cette adresse changera et ne sera pas connue du programme applicatif.</p><p id="r-548646" data-claire-element-id="548646">Un grande partie de ces routines a besoin qu'on leur fournisse des paramètres, des informations pour qu'elles fassent ce qu'elles doivent faire. Par exemple, une routine devant afficher une lettre à l'écran aura besoin qu'on lui passe en entrée la lettre à afficher. Pour chaque routine, il suffira de copier ces paramètres de la mémoire vers des petites mémoires ultra-rapides intégrées dans le processeur qu'on appelle les <strong>registres</strong>. Ces registres ont des utilités différentes suivant la situation et ne servent pas que pour les interruptions : ils peuvent servir à conserver temporairement une donnée, stocker des informations sur l'état du processeur ou pour quoique ce soit d'autre. Chacun de ces registres possède un nom qui permet de l'identifier : EAX, AX, AH, AL...Pour chaque routine, chaque registre va contenir une donnée ayant une signification bien précise pour notre routine.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation">Les systèmes d&#039;exploitation</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Programmes systèmes vs programmes applicatifs
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">Mécanismes d&#039;abstraction des périphériques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
Programmes systèmes et applicatifs
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
Rappel sur les interruptions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">Noyau d&#039;un OS</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
Notre mémoire tourne en rond !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
Principaux types de noyaux
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Si on utilisait plusieurs programmes ?
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">Ordonnancement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
Algorithmes d&#039;ordonnancement
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">Processus et threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
Processus et threads
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
Sections critiques
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Gestion de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">Allocation et protection mémoire avancée</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
Systémes mono-programmés
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
Partitions mémoires fixes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
Allocation dynamique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
Adressage mémoire : quelques subtilités
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
<span class="arrow"></span>
<span class="next">Programmes systèmes et applicatifs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">
<span class="next">Noyau d&#039;un OS</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Noyaud039unOS"></a><h2>Noyau d&#039;un OS</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
<span class="arrow"></span>
<span class="next">Rappel sur les interruptions</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
<span class="next">Notre mémoire tourne en rond !</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-548650" data-claire-element-id="548650">On l'a vu auparavant, les programmes systèmes et les programmes applicatifs n'ont pas vraiment les mêmes droits : certains peuvent accéder à la mémoire et d'autres non. Pour le moment, on a aucune certitude qu'un programme applicatif n'accédera pas aux périphériques ou fasse des manipulations dangereuses avec la mémoire. Il faut donc trouver un moyen de protéger le matériel contre les actions dangereuses des programmes applicatifs et faire en sorte que ceux-ci restent à leur place. Pour cela, on doit trouver une solution. Et cette solution est fournie par notre système d’exploitation ainsi que par le matériel de notre ordinateur. Cette solution, c'est la présence d'<strong>anneaux mémoires</strong>.</p>
</div><a name="Notremmoiretourneenrond"></a><h2>Notre mémoire tourne en rond !</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">
<span class="arrow"></span>
<span class="next">Noyau d&#039;un OS</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
<span class="next">Principaux types de noyaux</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<div id="r-548652" data-claire-element-id="548652" data-claire-semantic="question"><p id="r-548651" data-claire-element-id="548651">Des anneaux mémoires, le terme est amusant, mais que cache-il ?</p></div><p id="r-548653" data-claire-element-id="548653">Comme on l'a vu plus haut, les programmes de notre ordinateurs sont séparés en deux catégories : les programmes systèmes, qui doivent manipuler mémoire et périphériques, et ceux qui ne doivent pas le faire. Alors pourquoi ne pas créer des zones de mémoire qui auraient des droit différents ? Ainsi, on aurait des zones de mémoires dans lesquelles tout programme stockée dedans ne pourrait pas accéder aux périphériques. De même, on aurait des zones de mémoires dans lesquelles les programmes stockés dedans seraient privilégiées et auraient tout les droits ! Voici ce qu'est un anneau mémoire : c'est une portion de mémoire dans laquelle tout programme stocké dedans reçoit ou non l'autorisation de faire certaines manipulations sur le matériel.</p><h2 id="r-niveaux-de-privileges" data-claire-element-id="548664">Niveaux de privilèges</h2><p id="r-548654" data-claire-element-id="548654">Pour obtenir une bonne séparation entre programmes systèmes et programmes applicatifs, il nous faut donc deux niveaux de privilèges distincts. Cela nous donne donc au moins deux anneaux mémoire : un anneau dans lequel on place les programmes systèmes ; et un autre qui stocke le programmes applicatifs. Le premier anneau, dans lequel les programmes sont tout puissants est ce qu'on appelle <strong>l'espace noyau</strong>. L'autre anneau mémoire et appelé <strong>l'espace utilisateur</strong>.</p><p id="r-548655" data-claire-element-id="548655">Il peut y en avoir plus sur certains ordinateurs : par exemple, un processeur x86 32 bits supporte 4 niveaux de privilèges, même si seulement deux sont utilisés en pratique. Le maximum est un nombre de 8 niveaux de privilèges, sur les ordinateurs basés sur l'OS <em>Multics system</em>. Ces niveaux de privilèges ont des droits plus ou moins souples Bien sur, on pourrait parfaitement créer des systèmes d'exploitation dans lesquels on ne ferait pas de telles distinctions : les programmes systèmes aurait les mêmes droits que les programmes applicatifs. Mais cela aurait quelques petits problèmes en terme de sécurité.</p><aside id="r-548657" data-claire-element-id="548657" data-claire-semantic="warning"><p id="r-548656" data-claire-element-id="548656">Sur certains systèmes, la mémoire n'est pas séparée comme suit, tout dépend de comment le CPU gère la mémoire !</p></aside><h3 id="r-espace-noyau" data-claire-element-id="548661">Espace noyau</h3><p id="r-548658" data-claire-element-id="548658">Tout programme qui s'exécute avec le niveau de privilège de l'espace noyau va pouvoir faire tout ce qu'il souhaite. Notamment, notre programme pourra accéder en lecture et en écriture à toute donnée placée dans la mémoire. Toute la mémoire peut donc être lue ou écrite. Un programme localisé dans l'espace noyau peut : accéder aux périphériques et aux ports d'entrée-sortie, manipuler l'intégralité de la mémoire, et dire à tel ou tel programme qu'il ne peut pas accéder à telle ou telle partie de la mémoire.</p><p id="r-548659" data-claire-element-id="548659">Le fait que les programmes exécutés en espace noyau ont tous les droits peut poser de nombreux problèmes : la moindre erreur de programmation, et cela a des conséquences graves. Tous vos écrans bleus ou vos <em>kernel panic</em> (l'équivalent chez les OS UNIX) sont dus à une erreur commise par un programme en espace noyau (généralement par un driver de carte 3d ou un problème matériel).</p><p id="r-548660" data-claire-element-id="548660">Tous les programmes de notre système d’exploitation placés dans l'espace noyau sont ce qu'on appelle <strong>le noyau du système d’exploitation</strong>. Il comprend souvent de quoi gérer la mémoire et les processus, une grande partie des interruptions fournies de base par l'OS et parfois quelques trucs supplémentaires.</p><h3 id="r-espace-utilisateur" data-claire-element-id="548663">Espace utilisateur</h3><p id="r-548662" data-claire-element-id="548662">Les autres programmes (ceux qui n'appartiennent pas au noyau), sont placé dans l'espace utilisateur. Tout programme en espace utilisateur ne pourra pas faire ce qu'il souhaite. Certaines actions sur la mémoire lui seront interdites. Un programme en espace utilisateur ne pourra pas écrire ou lire dans la mémoire des autres programmes, ne peut pas communiquer avec un périphérique : il devra déléguer cette tache à un programme système, ne peut pas faire exécuter directement un programme système en mode noyau : il doit exécuter une interruption pour cela , etc. L'avantage, c'est qu'une erreur commise par un programme en espace utilisateur n'entraine pas d'écrans bleus. C'est donc un gage de sureté et de fiabilité.</p><h2 id="r-implementation-27" data-claire-element-id="548675">Implémentation</h2><p id="r-548665" data-claire-element-id="548665">Pour implémenter les anneaux mémoires de façon simple, les fabricants de hardware n'ont pas hésité à implanter directement de quoi gérer les anneaux mémoires dans des circuits du processeur. Notre processeur contient ainsi un circuit spécial qui gère tout ce qui a rapport avec la gestion de la mémoire : la <strong>Memory Management Unit</strong>, abréviée en MMU. C'est donc cette MMU qui interviendra quand un programme applicatif effectuera une action interdite par son niveau de privilège. Bien sur, notre MMU servira à pleins d'autres choses : c'est un circuit généraliste qui gère la mémoire, et la gestion des anneaux mémoires n'est qu'une partie de son travail. Mais revenons à nos moutons.</p><h3 id="r-gestion-d-erreurs" data-claire-element-id="548669">Gestion d'erreurs</h3><p id="r-548666" data-claire-element-id="548666">La gestion de ces niveaux de privilège s'effectue donc directement dans cette MMU. Certains registres du processeur contiennent des données permettant de gérer les niveaux de privilèges du processeur. Par exemple, le niveau de privilège d'un programme en cours d'exécution est connu grâce à des bits contenus dans des registres spéciaux placés dans le processeur.</p><p id="r-548667" data-claire-element-id="548667">Dans l'espace utilisateur, diverses <a href="http://fr.wikipedia.org/wiki/Instruction_machine">instructions machines</a> du processeur ne sont pas autorisées : trop dangereuses. Par exemple, sur un processeur à architecture x86, les instruction <code data-claire-semantic="nasm">in</code> et <code data-claire-semantic="nasm">out</code>, qui permettent respectivement de lire/écrire un octet depuis un périphérique sont interdites. Dans le même genre, certaines routines d'interruptions ne sont pas exécutables directement en espace utilisateur. Et c'est aussi le cas de bien d'autres fonctionnalités du processeur, qui sont rendues inaccessibles en espace utilisateur.</p><p id="r-548668" data-claire-element-id="548668">Lorsqu'un programme effectue une instruction ou demande l’exécution d'une fonctionnalité du CPU interdite par son niveau de privilège, l'unité de gestion mémoire (la MMU) va déclencher une interruption d'un type un peu particulier. Ce genre d'interruptions n'est executée lorsque le processeur rencontre une erreur : on appelle cela une <strong>exception matérielle</strong>. Cette interruption va alors démarrer une routine qui sera chargée de corriger l'erreur. Généralement, le programme est arrêté sauvagement, supprimé de la mémoire et un message d'erreur est affiché. Vous savez maintenant d'où viennent vos messages d'erreurs sous votre OS préféré.</p><h3 id="r-appels-systemes" data-claire-element-id="548674">Appels systèmes</h3><p id="r-548670" data-claire-element-id="548670">Un programme ne peut changer d'anneau mémoire au cours de son exécution. Cela signifierait que notre programme applicatif essaye de faire une manipulation avancée du matériel, qui devrait être déléguée à un programme système. Par contre, un programme applicatif peut demander l’exécution d'un programme système au besoin en exécutant une instruction appelant l'interruption voulue. On se retrouve donc avec un programme applicatif en espace utilisateur qui demande un service localisé en espace noyau. Pour cela, le processeur devra changer de niveau d’exécution en cours.</p><p id="r-548671" data-claire-element-id="548671">Là encore, l’exécution de notre interruption en espace noyau par un programme en espace utilisateur va être gérée de différentes façons suivant le matériel utilisé. Dans certains cas, cela va déclencher une exception qui va alors changer d'anneaux mémoire en prenant moult précautions : le niveau de privilège sera alors celui du noyau. Une fois cette exception exécutée, l'interruption demandée par notre programme applicatif pourra alors s’exécuter comme bon lui semble.</p><p id="r-548672" data-claire-element-id="548672">Bien sur, une fois notre interruption terminée, l'interruption fait reprendre notre programme là ou il en était, et le niveau de privilège redevient celui du programme applicatif. En effet, lors de l’exécution d'une interruptions, les registres du processeurs sont sauvegardés, histoire de retrouver notre programme dans l'état où il était avant l'interruption. Et ces registres sont restaurés à la fin de l'interruption, y compris les registres qui contiennent le niveau de privilège du programme en cours d’exécution.</p><p id="r-548673" data-claire-element-id="548673">L'ensemble des opérations qui permettent à notre programme applicatif d’exécuter des programmes systèmes (changements du niveau de privilège, appel de l'interruption, sauvegardes diverses qui permettent au processeur de revenir ou il en était à la fin de l'interruption, s'appelle un <strong>appel système</strong>.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation">Les systèmes d&#039;exploitation</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Programmes systèmes vs programmes applicatifs
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">Mécanismes d&#039;abstraction des périphériques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
Programmes systèmes et applicatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
Rappel sur les interruptions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">Noyau d&#039;un OS</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
Notre mémoire tourne en rond !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
Principaux types de noyaux
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Si on utilisait plusieurs programmes ?
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">Ordonnancement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
Algorithmes d&#039;ordonnancement
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">Processus et threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
Processus et threads
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
Sections critiques
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Gestion de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">Allocation et protection mémoire avancée</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
Systémes mono-programmés
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
Partitions mémoires fixes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
Allocation dynamique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
Adressage mémoire : quelques subtilités
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">
<span class="arrow"></span>
<span class="next">Noyau d&#039;un OS</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
<span class="next">Principaux types de noyaux</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Principauxtypesdenoyaux"></a><h2>Principaux types de noyaux</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
<span class="arrow"></span>
<span class="next">Notre mémoire tourne en rond !</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">
<span class="next">Ordonnancement</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-548677" data-claire-element-id="548677">On l'a vu, lorsqu'un programme déclenche un appel système, cela entraine l'exécution d'une interruption. Et cela a une conséquence : cette interruption est très lente à exécuter. Exécuter de nombreuses interruptions sera donc long, ce qui sera du temps perdu : exécuter des instructions juste pour changer de niveau de privilège et demander l’exécution d'une routine, c'est quelque chose qui pourrait être évité. Faites-le trop souvent et les performances s'effondreront.</p><p id="r-548678" data-claire-element-id="548678">Mais en même temps, on doit bien garder une gestion des niveaux de privilèges cohérente et ne pas laisser tous les processus possibles en espace noyau : on doit donc en laisser en espace utilisateur, ce qui créera beaucoup d'appels systèmes.</p><p id="r-548679" data-claire-element-id="548679">Suivant ce qu'on met dans le noyau, le nombre d'appels systèmes sera plus ou moins important. On se retrouve donc avec deux contraintes : les performances, et la sécurité. Avoir de bonnes performances nécessite de diminuer le nombre d'appels systèmes, ce qui se fait en diminuant le nombre d'appels systèmes. Par contre, la sécurité s'obtiendra en mettant un maximum de trucs en espace utilisateurs, ce qui augmente le nombre d'appels systèmes. On peut ainsi classer les noyaux en plusieurs types, selon leurs priorité et la façon dont ils gèrent ce genre de problèmes.</p><h2 id="r-noyau-monolithique" data-claire-element-id="548684">Noyau monolithique</h2><p id="r-548680" data-claire-element-id="548680">Dans le cas du noyau monolithique, un maximum de programmes systèmes est placé dans l'espace noyau. Ces noyaux contiennent donc beaucoup de programmes systèmes et prennent donc beaucoup de place.</p><p id="r-548681" data-claire-element-id="548681">Avec ce genre d'organisation, très peu d'appels systèmes sont effectués, ce qui est un avantage en terme de performances. Voici pourquoi : imaginez qu'on mette un programme système dans l'espace utilisateur, au lieu de le mettre dans le noyau. Ce programme étant un programme système, il devait faire des manipulations sur la mémoire, utiliser des instructions spéciales ou communiquer avec des périphériques. En espace utilisateur, cela lui sera impossible. Donc on ne peut pas bouger l'intégralité du programme en espace utilisateur : on doit donc segmenter celui en un programme qui appellera des routines du noyau quand il en aura besoin.<br/> Si notre programme système avait été placé dans l'espace noyau, notre programme système n'aurait pas exécuté un seul appel système. Mais si on le place en espace utilisateur, il déléguera une partie de son travail à des routines du noyau, et devra donc faire plusieurs appels systèmes : on a donc plus d'appels systèmes.</p><p id="r-548682" data-claire-element-id="548682">De plus, en mettant un programme système en espace utilisateur, celui-ci devra donc communiquer avec les autres programmes applicatifs qui voudront l'utiliser. Hors, faire communiquer deux programmes applicatifs placés en espace utilisateur est quelque chose qui est souvent plus lent qu'un appel système.</p><p id="r-548683" data-claire-element-id="548683">Mais cela est aussi un désavantage en terme de sureté. En mettant un maximum de programmes dans le noyau, chacun de ces programmes pourra faire ce qu'il veut : lire ou écrire n'importe où dans la mémoire, envoyer des données erronées à un périphérique, et autres manipulations dangereuses interdites dans l'espace utilisateur. Cela ne signifiera pas que ces programmes en question feront forcément des choses dangereuses, mais au moindre bug ou comportement non prévu par le programmeur, on risque la catastrophe. En plaquant ces programmes dans l'espace utilisateur, ces manipulations dangereuses seront impossibles : toute tentative se soldera par la levée d'une exception qui terminera l’exécution du programme avant que celui-ci n'a le temps de faire quoique ce soit.</p><h2 id="r-noyau-modulaire" data-claire-element-id="548687">Noyau modulaire</h2><p id="r-548685" data-claire-element-id="548685">Un noyau modulaire ressemble beaucoup à un noyau monolithique mais se distingue de ce dernier par son organisation. Le noyau est divisé en plusieurs parties bien distinctes nommées les <strong>modules</strong>. Par exemple, chaque pilote de périphérique sera stocké dans un module séparé du reste du noyau.</p><p id="r-548686" data-claire-element-id="548686">Avec ce genre d'organisation, on peut éviter d'avoir à charger l'intégralité des fonctionnalités du noyau et tous les pilotes de périphériques au démarrage de l'ordinateur : on charge ce dont on a besoin quand on en a besoin. Cela permet d'éviter de charger un pilote d'un périphérique qui n'est pas branché sur l'ordinateur, pour citer un exemple. Cela permet aussi de rajouter plus facilement des modules dans le noyau sans avoir à refaire celui-ci depuis le début.</p><h2 id="r-micro-noyau" data-claire-element-id="548690">Micro noyau</h2><p id="r-548688" data-claire-element-id="548688">Pour gagner en sureté de fonctionnement, certains créateurs de systèmes d'exploitation ont décidé d'utiliser une autre approche : plutôt que de mettre tous les programmes systèmes et les drivers dans l'espace noyau, on décide de placer un maximum de ces programmes systèmes dans l'espace utilisateur, et on ne garde dans l'espace noyau que les programmes qui ont absolument besoin d'un niveau de privilège élevé. Ces micro-noyaux sont souvent très légers : peu de programmes systèmes sont présents dans le noyaux, les autres étant évacués dans l'espace utilisateur.</p><p id="r-548689" data-claire-element-id="548689">L'avantage, c'est qu'un bug dans le noyau aura des conséquences moins néfastes : un bug dans l'espace utilisateur ne fait pas planter la machine. Mais cela implique de nombreux appels systèmes entre les programmes systèmes en espace utilisateurs et ceux en espace noyau, ce qui réduit les performances.</p><h2 id="r-noyau-hybride" data-claire-element-id="548692">Noyau hybride</h2><p id="r-548691" data-claire-element-id="548691">Dans les noyaux hybride, on garde la même philosophie que pour les micro-noyaux, en étant un peu plus souple : on évacue un maximum de programmes systèmes dans l'espace utilisateur. Néanmoins, certains programmes systèmes, très demandeurs en appels systèmes sont placés en espace noyau. Cela évite de plomber les performances en générant trop d'appels systèmes.</p><h2 id="r-exokernels" data-claire-element-id="548696">Exokernels</h2><p id="r-548693" data-claire-element-id="548693">Enfin, une dernière catégorie de noyaux existe : les exokernels. Celle-ci est particulière : elle consiste à extraire le plus de programmes systèmes du noyau tout en conservant la sécurité de fonctionnement en utilisant les anneaux mémoires. En clair, même des programmes systèmes deviennent des programmes en espace utilisateur qui utilisent un ensemble minimal de fonctionnalités fournies par un noyau réduit à son strict minimum.</p><p id="r-548694" data-claire-element-id="548694">Les différentes abstractions matérielles, qui permettent de simplifier la façon dont un programme va devoir gérer la mémoire, le disque dur, le processeur et tout le reste sont donc placés dans l'espace utilisateur. Seul un minuscule noyau existe, qui se charge simplement de contenir quelques routines qu'on a pas pu évacuer dans l'espace utilisateur. Par exemple, prenons l'exemple du disque dur : un exokernel n'implémentera pas de quoi camoufler l’organisation physique du disque dur (cylindre, têtes et pistes) et n'implémentera pas de systèmes de fichiers.</p><p id="r-548695" data-claire-element-id="548695">L'avantage, c'est qu'un programmeur peut reprogrammer tout seul la gestion de la mémoire, du disque dur ou du reste du systéme d’exploitation. Dans certains cas particuliers, cela permet d'avoir soit une meilleure sécurité, soit de pouvoir programmer en étant bien plus proche du matériel ou en optimisant nettement mieux notre application.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation">Les systèmes d&#039;exploitation</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Programmes systèmes vs programmes applicatifs
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">Mécanismes d&#039;abstraction des périphériques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
Programmes systèmes et applicatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
Rappel sur les interruptions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">Noyau d&#039;un OS</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
Notre mémoire tourne en rond !
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
Principaux types de noyaux
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Si on utilisait plusieurs programmes ?
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">Ordonnancement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
Algorithmes d&#039;ordonnancement
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">Processus et threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
Processus et threads
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
Sections critiques
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Gestion de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">Allocation et protection mémoire avancée</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
Systémes mono-programmés
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
Partitions mémoires fixes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
Allocation dynamique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
Adressage mémoire : quelques subtilités
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
<span class="arrow"></span>
<span class="next">Notre mémoire tourne en rond !</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">
<span class="next">Ordonnancement</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Ordonnancement"></a><h2>Ordonnancement</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
<span class="arrow"></span>
<span class="next">Principaux types de noyaux</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
<span class="next">C&#039;est quoi ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-548701" data-claire-element-id="548701">Vous avez surement déjà remarqués que vous pouvez parfaitement lancer plusieurs programmes en même temps sur votre ordinateur ? Par exemple, vous pouvez télécharger quelque chose grâce à Firefox et regarder une vidéo en même temps sans que cela pose problème. Pourtant, vous n'avez qu'un seul processeur dans votre ordinateur. Avec un seul processeur, vous ne devriez pas pouvoir le faire : un processeur ne peut exécuter qu'un seul programme à la fois (sauf cas particuliers du style processeurs SMT ou multi-cores). Et bien sachez que c'est grâce à votre systéme d'exploitation !</p><p id="r-548702" data-claire-element-id="548702">Certains systèmes d'exploitation, comme MS-DOS, ne permettent pas à plusieurs programmes de s’exécuter simultanément : ceux-ci sont dits <strong>mono-taches</strong>. Mais d'autres peuvent exécuter plusieurs programmes en même temps sur le même ordinateur : ceux-ci sont appelées des systèmes d'exploitation <strong>multitâches</strong>. Ceux-ci permettent à plusieurs programmes de s’exécuter &quot;en même temps&quot; sur un ordinateur. On parle aussi de <strong>multiprogrammation</strong>.</p><p id="r-548703" data-claire-element-id="548703">Au départ, la multiprogrammation a été inventée pour masquer la lenteur des périphériques ou de certaines mémoire d'un ordinateur. Il se peut en effet qu'un programme ne puisse continuer son exécution car il attend une donnée en provenance de la RAM ou d'un périphérique. Dans certains cas, tant que cette donnée n'est pas disponible, le programme ne peut continuer son exécution.</p><p id="r-548704" data-claire-element-id="548704">En utilisant plusieurs programmes sur le même ordinateur on peut résoudre plus ou moins ce problème en faisant exécuter les calculs d'un autre programme pendant que le premier attend. On rentabilise ainsi le temps d’exécution de notre programme. Dans ce cas, on se retrouve donc avec plusieurs programmes cherchant à s’exécuter sur le même ordinateur, et on en exécute un parmi tout ceux-là. Si celui-ci est bloqué et a besoin d'une donnée en provenance d'un périphérique ou mémoire assez lent(e) : on aura un programme bloqué qui attend une donnée et au moins un programme parmi tous les autres qui n'a pas ce problème et peut parfaitement continuer leur exécution. L'exécution totale du programme peut ainsi se poursuivre durant les accès aux périphériques : on gagne en performance. On peut ainsi répartir les différents programmes sur le processeur au cours du temps de façon à gagner en efficacité.</p><p id="r-548705" data-claire-element-id="548705">Mais l'apparition de la multiprogrammation a nécessité quelques améliorations dans la façon dont s'exécutent nos programmes. De nombreux problèmes se sont en effet posés :</p><ul id="r-548714" data-claire-element-id="548714"><li id="r-548707" data-claire-element-id="548707"><p id="r-548706" data-claire-element-id="548706">Comment répartir la mémoire entre les différents programmes sans accrocs ?</p></li><li id="r-548709" data-claire-element-id="548709"><p id="r-548708" data-claire-element-id="548708">Comment éviter qu'un programme aille modifier les données d'un autre programme ?</p></li><li id="r-548711" data-claire-element-id="548711"><p id="r-548710" data-claire-element-id="548710">Comment décider quel programme exécuter quand un programme doit accéder à une entrée-sortie ?</p></li><li id="r-548713" data-claire-element-id="548713"><p id="r-548712" data-claire-element-id="548712">...</p></li></ul><p id="r-548715" data-claire-element-id="548715">Voyons le premier problème.</p><div id="r-548717" data-claire-element-id="548717" data-claire-semantic="question"><p id="r-548716" data-claire-element-id="548716">Comment faire pour exécuter plusieurs programmes sur un ordinateur avec un seul processeur ?</p></div><p id="r-548718" data-claire-element-id="548718">Évidement, notre processeur ne peut exécuter qu'un seul programme à la fois (enfin presque, il existe des exceptions et on en reparlera, mais un processeur &quot;normal&quot; ne peut pas).</p>
</div><a name="C039estquoi"></a><h2>C&#039;est quoi ?</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">
<span class="arrow"></span>
<span class="next">Ordonnancement</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
<span class="next">Algorithmes d&#039;ordonnancement</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-548719" data-claire-element-id="548719">Notre système d'exploitation utilise une technique très simple pour permettre la multiprogrammation sur les ordinateurs à un seul processeur : <strong>l'ordonnancement</strong>. Cela consiste à constamment switcher entre les différents programmes qui doivent être exécutés. Ainsi, en switchant assez vite entre les différentes processus, on peut donner l'illusion que plusieurs processus s'exécutent en même temps sur notre ordinateur. Bien sur, le processeur n’exécute ainsi qu'un seul programme à la fois et c'est un programme système inclus dans le systéme d'exploitation qui gère le tout.</p><h2 id="r-principe-de-l-ordonnancement" data-claire-element-id="548745">Principe de l'ordonnancement</h2><p id="r-548720" data-claire-element-id="548720">Tout d'abord, il faut décider quel est le programme à exécuter. Pour cela, le principe est de savoir quels sont les programmes qui ont besoin d'utiliser le processeur et quels sont ceux qui n'en ont pas besoin.</p><p id="r-548721" data-claire-element-id="548721">Pour cela, on va donner à chaque processus un état qui permettra de savoir si notre programme veut s'exécuter sur le processeur.<br/> Un processus peut donc être dans trois états :</p><ul id="r-548728" data-claire-element-id="548728"><li id="r-548723" data-claire-element-id="548723"><p id="r-548722" data-claire-element-id="548722"><strong>Élu</strong> : un processus en état élu est en train de s'exécuter sur le processeur.</p></li><li id="r-548725" data-claire-element-id="548725"><p id="r-548724" data-claire-element-id="548724"><strong>Prêt</strong> : celui-ci a besoin de s'exécuter sur le processeur et attend son tour.</p></li><li id="r-548727" data-claire-element-id="548727"><p id="r-548726" data-claire-element-id="548726"><strong>Bloqué</strong> : celui-ci n'a pas besoin de s'exécuter (par exemple, parce que que celui-ci attend une donnée en provenance d'une entrée-sortie).</p></li></ul><p id="r-548729" data-claire-element-id="548729">Ces trois états sont le strict minimum : certains systèmes d'exploitation utilisent parfois d'autres états supplémentaires, mais le principe reste le même.</p><p id="r-548730" data-claire-element-id="548730">L'ensemble des processus prêts est ce qu'on appelle une <strong>file d'attente</strong>. Quand un programme démarre, celui-ci est ajouté à cette file d'attente. Les programmes ayant fini leur exécution sont retiré de la liste d'attente. Bien sur, cette file d'attente n'accepte qu'un nombre limité de programmes : l'ordonnanceur décide toujours si oui ou non un programme peut être ajouté à cette liste et le nombre de programme dans cette liste a une limite fixée par le système d'exploitation.</p><p id="r-548731" data-claire-element-id="548731">Il arrive qu'un programme stoppe son exécution. Il peut y avoir plusieurs raisons à cela :</p><ul id="r-548738" data-claire-element-id="548738"><li id="r-548733" data-claire-element-id="548733"><p id="r-548732" data-claire-element-id="548732">notre programme peut avoir besoin d'accéder à un périphérique et passe donc à l'état bloqué,</p></li><li id="r-548735" data-claire-element-id="548735"><p id="r-548734" data-claire-element-id="548734">notre programme n'a plus rien à faire et a fini (temporairement ou définitivement) son exécution,</p></li><li id="r-548737" data-claire-element-id="548737"><p id="r-548736" data-claire-element-id="548736">ou il est interrompu sauvagement par le système d'exploitation, histoire de laisser la place à un autre programme.</p></li></ul><p id="r-548739" data-claire-element-id="548739">Dans ce cas, un petit programme, nommé <strong>l'ordonnanceur</strong>, va s'exécuter. Cet ordonnanceur va passer , et va faire passer un des processus en état prêt à l'état élu : ce processus sera donc choisit et pourra s'exécuter.</p><figure id="r-548741" data-claire-element-id="548742"><img id="r-548740" data-claire-element-id="548740" src="medias/uploads.siteduzero.com_files_327001_328000_327374.png" alt="Image utilisateur"/></figure><p id="r-548743" data-claire-element-id="548743">Le rôle de l'ordonnanceur (aussi appelé <em>scheduler</em>) est donc de choisir le bon processus à exécuter. Pour utiliser notre processeur au mieux, il faut faire en sorte que tous les processus aient leur part du gâteau, et éviter qu'un petit nombre de processus monopolisent le processeur. Il faut donc choisir le bon processus à exécuter. Pour cela, il existe pleins d'algorithmes qui permettent de décider quel processus doit être choisit. Tous sont plus ou moins efficaces suivant les situations, et un ordonnanceur efficace est un grand plus en terme de performances quand plusieurs programmes doivent s'exécuter.</p><p id="r-548744" data-claire-element-id="548744">On peut aussi préciser que certains algorithmes vont privilégier certains programmes sur d'autres : chaque programme aura alors une priorité, codée par un nombre, plus ou moins grande. Plus celle-ci est grande, plus l'ordonnanceur aura tendance à élire souvent ce processus ou plus ce processus s’exécutera sur le processeur longtemps.</p><h2 id="r-notre-os-est-un-communiste" data-claire-element-id="548774">Notre OS est un communiste !</h2><p id="r-548746" data-claire-element-id="548746">On peut aussi préciser qu'il existe deux grandes formes d'ordonnancements : l'<strong>ordonnancement collaboratif</strong>, et l'<strong>ordonnancement préemptif</strong>.</p><table id="r-548764" data-claire-element-id="548764"><thead id="r-548752" data-claire-element-id="548752"><tr id="r-548751" data-claire-element-id="548751"><th id="r-548748" data-claire-element-id="548748"><p id="r-548747" data-claire-element-id="548747">Ordonnancement</p></th><th id="r-548750" data-claire-element-id="548750"><p id="r-548749" data-claire-element-id="548749">Définition</p></th></tr></thead><tbody id="r-548763" data-claire-element-id="548763"><tr id="r-548757" data-claire-element-id="548757"><td id="r-548754" data-claire-element-id="548754"><p id="r-548753" data-claire-element-id="548753">Ordonnancement collaboratif</p></td><td id="r-548756" data-claire-element-id="548756"><p id="r-548755" data-claire-element-id="548755">C'est le processus lui-même qui décide de passer de l'état élu à l'état bloqué ou prêt. Dans ces conditions, il n'est pas rare qu'un processus &quot;un peu égoïste&quot; décide de ne pas rendre la main et monopolise le processeur.</p></td></tr><tr id="r-548762" data-claire-element-id="548762"><td id="r-548759" data-claire-element-id="548759"><p id="r-548758" data-claire-element-id="548758">Ordonnancement préemptif</p></td><td id="r-548761" data-claire-element-id="548761"><p id="r-548760" data-claire-element-id="548760">C'est le systéme d’exploitation qui décide de stopper l’exécution d'un processus, sans lui demander son avis. Un processus peut être sauvagement interrompu, et le processeur réquisitionné au profit d'un autre processus. Ainsi, il est presque impossible qu'un processus un peu trop égoïste puisse monopoliser le processeur au dépend des autres processus.</p></td></tr></tbody></table><h3 id="r-technique-du-quantum-de-temps" data-claire-element-id="548773">Technique du quantum de temps</h3><p id="r-548765" data-claire-element-id="548765">L'ordonnancement préemptif se base souvent sur la technique du <strong>quantum de temps</strong> : chaque programme choisit par l’ordonnanceur va s’exécuter durant un temps fixé une bonne fois pour toute, qui est le même pour tous les processus. Une fois ce quantum de temps terminé, le processus est stoppé temporairement par l'ordonnanceur, qui va alors choisir un processus à exécuter (qui peut être différent ou au contraire rester le même). En clair, toutes les X millisecondes, le programme en cours d’exécution est interrompu et l'ordonnanceur exécuté.</p><p id="r-548766" data-claire-element-id="548766">Bien sur, si un programme a fini (temporairement ou définitivement) son exécution ou dit accéder à un périphérique avant la fin de son quantum de temps, ce processus s’arrête et appelle l’ordonnanceur : on ne perd pas le temps restant.</p><p id="r-548767" data-claire-element-id="548767">La durée optimale de ce quantum de temps dépend de quelques petits trucs. Déjà, cette durée doit être très grande devant le temps mit pour changer de programme (et oui, ce n'est pas instantané). En même temps, on doit avoir un temps suffisamment petit pour que plusieurs programmes s’exécutent et éviter qu'un programme utilise tout son quantum de temps et ne laisse pas trop de temps aux nombreux autres programmes. Généralement, un quantum de temps de 100 millisecondes convient correctement.</p><div id="r-548769" data-claire-element-id="548769" data-claire-semantic="question"><p id="r-548768" data-claire-element-id="548768">Mais comment faire ?</p></div><p id="r-548770" data-claire-element-id="548770">Dans la majorité des ordinateurs, on trouve divers composants : processeur, mémoire, bus, et d'autres. Mais plus méconnu est le ou les <strong>Timer</strong>. Ce <em>timer</em> est un composant permettant de mesurer des durées.</p><p id="r-548771" data-claire-element-id="548771">Ce Timer est un composant relié à une horloge, une tension qui varie cycliquement. Il existe plusieurs horloges dans notre ordinateur, dont une qui crée pour cadencer les différents bus, et qui est utilisée par le processeur et la mémoire pour ajuster leur fréquence : <strong>l'horloge système</strong>. Notre Timer contient un registre qui stocke un nombre, ainsi qu'un compteur, qui est un circuit qui augmente ou diminue le contenu du registre de 1 à chaque tic d'horloge (ou en plusieurs tics d'horloges, c'est selon).</p><p id="r-548772" data-claire-element-id="548772">Prenons un Timer qui compte de façon décroissante : celui-ci est initialisé à une certaine valeur (qu'on choisit de façon à compter une durée voulue). Le nombre contenu dans le registre diminue de un en un à chaque fois que la tension fait un cycle, et fini par atteindre zéro.<br/> Quand ce Timer atteint zéro, le nombre contenu dans le registre est réinitialisé à une certaine valeur, et une interruption matérielle est générée. La routine d'interruption executée par cette interruption matérielle n'est autre que l'ordonnanceur.</p><h2 id="r-dispatcher" data-claire-element-id="548831">Dispatcher</h2><p id="r-548775" data-claire-element-id="548775">Une fois le prochain processus sélectionné, il faut faire exécuter celui-ci par notre processeur. C'est un des rôles donné à un programme intégré à notre ordonnanceur, nommé le <strong>dispatcher</strong>.</p><p id="r-548776" data-claire-element-id="548776">Pour comprendre ce que fait notre dispatcher, il va falloir faire quelques rappels sur les registres.</p><h3 id="r-registres-2" data-claire-element-id="548811">Registres</h3><p id="r-548777" data-claire-element-id="548777">Tout programme ne fait que manipuler des données localisées dans la mémoire. Pour diverses raisons, notre processeur possède de toutes petites mémoires internes ultra-rapides nommées <a href="http://fr.wikipedia.org/wiki/Registre_(informatique)">registres</a>.</p><p id="r-548778" data-claire-element-id="548778">Ces registres ont des utilités différentes suivant la situation, mais certains reviennent assez souvent dans la majorité des processeurs :</p><table id="r-548810" data-claire-element-id="548810"><thead id="r-548784" data-claire-element-id="548784"><tr id="r-548783" data-claire-element-id="548783"><th id="r-548780" data-claire-element-id="548780"><p id="r-548779" data-claire-element-id="548779">Registre</p></th><th id="r-548782" data-claire-element-id="548782"><p id="r-548781" data-claire-element-id="548781">Utilité</p></th></tr></thead><tbody id="r-548809" data-claire-element-id="548809"><tr id="r-548789" data-claire-element-id="548789"><td id="r-548786" data-claire-element-id="548786"><p id="r-548785" data-claire-element-id="548785"><strong>Registre d'adresse d'instruction</strong> E(IP)</p></td><td id="r-548788" data-claire-element-id="548788"><p id="r-548787" data-claire-element-id="548787">Le registre pointeur d'instruction stocke l'adresse mémoire de l'instruction qui est en cours de calcul. Il est relié à un petit circuit nommé compteur ordinal qui permet de calculer l'adresse de l'instruction suivante qui doit être exécuter.</p></td></tr><tr id="r-548803" data-claire-element-id="548803"><td id="r-548791" data-claire-element-id="548791"><p id="r-548790" data-claire-element-id="548790"><strong>le registre d'état</strong></p></td><td id="r-548802" data-claire-element-id="548802"><p id="r-548792" data-claire-element-id="548792">Le registre d'état contient plusieurs bits qui ont chacun une utilité particulière et qui renseigne sur l'état du processeur.<br/> Ce registre est très différent suivant les processeurs , mais certains bits reviennent souvent :</p><ul id="r-548801" data-claire-element-id="548801"><li id="r-548794" data-claire-element-id="548794"><p id="r-548793" data-claire-element-id="548793">Le <strong>bit d'overflow</strong>, qui vaut 1 si le registre de travail ne peut stocker complétement le résultat d'une instruction</p></li><li id="r-548796" data-claire-element-id="548796"><p id="r-548795" data-claire-element-id="548795">le <strong>bit null </strong>: précise que le registre de travail contient une valeur nulle (utile quand on obtient un overflow dans certaines instructions)</p></li><li id="r-548798" data-claire-element-id="548798"><p id="r-548797" data-claire-element-id="548797">le <strong>bit de retenue</strong>, utile pour les additions</p></li><li id="r-548800" data-claire-element-id="548800"><p id="r-548799" data-claire-element-id="548799">divers bits utilisés lors d'opérations de comparaisons ou de tests qui servent à donner le résultat de celles-ci</p></li></ul></td></tr><tr id="r-548808" data-claire-element-id="548808"><td id="r-548805" data-claire-element-id="548805"><p id="r-548804" data-claire-element-id="548804"><strong>Les registres généraux</strong></p></td><td id="r-548807" data-claire-element-id="548807"><p id="r-548806" data-claire-element-id="548806">Ce sont des registres qui n'ont pas d'utilité particulière et qui peuvent stocker toute sorte de donnée codée en binaire, qui sont utilisés si besoin est. Cette donnée est manipulée au besoin par des instructions machine d'un programme.</p></td></tr></tbody></table><h3 id="r-context-switch" data-claire-element-id="548830">Context switch</h3><p id="r-548812" data-claire-element-id="548812">Ces divers registres contiennent une grande partie des informations nécéssaires pour que notre programme reprennent là ou il en était :</p><ul id="r-548819" data-claire-element-id="548819"><li id="r-548814" data-claire-element-id="548814"><p id="r-548813" data-claire-element-id="548813">le registre d'adresse d'instruction contient l'endroit auquel on doit reprendre notre programme ;</p></li><li id="r-548816" data-claire-element-id="548816"><p id="r-548815" data-claire-element-id="548815">les registres généraux contiennent les données qu'on était en train de manipuler ;</p></li><li id="r-548818" data-claire-element-id="548818"><p id="r-548817" data-claire-element-id="548817">et le registre de contrôle contient des informations sur l'état du processeur.</p></li></ul><p id="r-548820" data-claire-element-id="548820">Bien sur, d'autres registres stockent des informations tout aussi utiles (les registres contenant le niveau de privilège du programme, par exemple). On appelle cet ensemble de registres le <strong>contexte d'exécution du processus</strong>. Pour que notre programme puisse reprendre où il en était quand l'ordonnanceur lui redonne la main, il faut impérativement que son contexte d’exécution redevienne ce qu'il était. Pour cela, ce contexte d’exécution est sauvegardé en mémoire quand l’ordonnanceur interrompt l’exécution de notre programme. Cela passe par une sauvegarde de tous les registres du processeurs, y compris ceux vus plus haut.</p><p id="r-548821" data-claire-element-id="548821">Pour reprendre l’exécution d'un programme là ou il en était, il suffit de remettre le contexte sauvegardé. On remet ainsi les registres tels qu'ils étaient la dernière fois en restaurant les valeurs sauvegardées dans les bons registres. Notre dispatcher doit donc :</p><ul id="r-548828" data-claire-element-id="548828"><li id="r-548823" data-claire-element-id="548823"><p id="r-548822" data-claire-element-id="548822">arrêter l’exécution du programme que l'ordonnanceur a décidé de stopper temporairement ;</p></li><li id="r-548825" data-claire-element-id="548825"><p id="r-548824" data-claire-element-id="548824">sauvegarder le contexte du programme interrompu ;</p></li><li id="r-548827" data-claire-element-id="548827"><p id="r-548826" data-claire-element-id="548826">et restaurer le contexte d’exécution du programme élu par l'ordonnanceur.</p></li></ul><p id="r-548829" data-claire-element-id="548829">On appelle cela un <strong>context switch</strong>, aussi appelée commutation de contexte.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation">Les systèmes d&#039;exploitation</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Programmes systèmes vs programmes applicatifs
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">Mécanismes d&#039;abstraction des périphériques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
Programmes systèmes et applicatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
Rappel sur les interruptions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">Noyau d&#039;un OS</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
Notre mémoire tourne en rond !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
Principaux types de noyaux
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Si on utilisait plusieurs programmes ?
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">Ordonnancement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
Algorithmes d&#039;ordonnancement
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">Processus et threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
Processus et threads
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
Sections critiques
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Gestion de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">Allocation et protection mémoire avancée</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
Systémes mono-programmés
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
Partitions mémoires fixes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
Allocation dynamique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
Adressage mémoire : quelques subtilités
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">
<span class="arrow"></span>
<span class="next">Ordonnancement</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
<span class="next">Algorithmes d&#039;ordonnancement</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Algorithmesd039ordonnancement"></a><h2>Algorithmes d&#039;ordonnancement</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
<span class="arrow"></span>
<span class="next">C&#039;est quoi ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">
<span class="next">Processus et threads</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-548833" data-claire-element-id="548833">Dans cette partie, on va voir quelques algorithmes d'ordonnancement simples. Bien sur, ces algorithmes sont rarement utilisés tels quels dans le systèmes d'exploitations modernes, qui utilisent des algorithmes d'ordonnancements bien plus complexes et souvent plus efficaces.</p><h2 id="r-algorithmes-collaboratifs" data-claire-element-id="548842">Algorithmes collaboratifs</h2><p id="r-548834" data-claire-element-id="548834">Tout d'abord, on va commencer par un systéme d'exploitation qui exécute des programmes qui s’exécute les uns après les autres. Ces programmes sont exécutés jusqu’à ce qu'ils finissent leur travail ou décident eux-mêmes de stopper leur exécution, soit pour accéder à un périphérique, soit pour laisser la place à un autre programme.</p><h3 id="r-first-input-first-output" data-claire-element-id="548836">First Input First Output</h3><p id="r-548835" data-claire-element-id="548835">Avec cet algorithme, les programme à exécuter sont ajoutés dans la file d'attente quand on les démarre. Ceux-ci sont alors stockés dans la file d'attente dans l'ordre dans lesquels on les a fait démarrer. L'ordonnanceur décide alors d’exécuter le programme entré dans la file d'attente avant tous les autres en premier. En clair, les programmes sont exécutés dans l'ordre dans lequel ils sont rentrés dans la file d'attente.</p><h3 id="r-last-input-first-output-1" data-claire-element-id="548839">Last Input First Output</h3><p id="r-548837" data-claire-element-id="548837">Avec cet algorithme, les programmes à exécuter sont ajoutés dans la file d'attente quand on les démarre. Ceux-ci sont alors stockés dans la file d'attente dans l'ordre dans lesquels on les a fait démarrer. Mais contrairement à l'algorithme First Input First Output, l'ordonnanceur exécuter le programme entré en dernier dans la file d'attente, et non le premier. Si vous ajoutez un programme dans une file d'attente contenant déjà des programmes en attente, ce sera lui le prochain à être exécuté, vu qu'il a été ajouté en dernier.</p><p id="r-548838" data-claire-element-id="548838">Cet algorithme peu souffrir d'un phénomène assez particulier : dans certains cas, un programme peut très bien mettre énormément de temps avant d'être exécuté. Si vous exécutez beaucoup de programme, ceux-ci seront rentrés dans la file d'attente avant les tout premiers programmes exécutés en premier. Ceux-ci doivent alors attendre la fin de l’exécution de tous les programmes rentrés avant eux.</p><h3 id="r-shortest-job-first" data-claire-element-id="548841">Shortest Job First</h3><p id="r-548840" data-claire-element-id="548840">Cet algorithme est basé sur une logique simple. Les programmes à exécuter sont placés dans la file d'attente et l’ordonnanceur va alors décider d’exécuter ces processus dans l'ordre. Pour appliquer cet algorithme, on suppose que les temps d’exécution des différents programmes sont connus à l'avance et sont parfaitement bornés. Cette contrainte peut sembler absurde, mais elle a un sens dans certains cas assez rares dans lesquels on connait à l'avance le temps mit par un programme pour s’exécuter. Dans ce cas, l'algorithme est simple : on exécute le programme qui met le moins de temps à s’exécuter en premier. Une fois celui-ci terminé, on le retire de la fil d'attente et on recommence.</p><h2 id="r-algorithmes-preemptifs" data-claire-element-id="548863">Algorithmes préemptifs</h2><h3 id="r-shortest-remaining-time-next" data-claire-element-id="548844">Shortest Remaining Time Next</h3><p id="r-548843" data-claire-element-id="548843">C'est une variante préemptive de l'algorithme <strong>Shortest Job First</strong> vu au dessus. Dans cette version, si un programme est ajouté dans la file d'attente, on regarde le temps que ce nouveau venu mettrait à s’exécuter, et on compare avec le temps qu'il reste au processus en cours d’exécution avant que celui-ci finisse son travail. Si le temps mit par le nouveau programme est plus faible que le temps d’exécution du programme en train de s’exécuter, on change et on exécute le nouveau venu à la place.</p><h3 id="r-fixed-priority-pre-emptive-scheduling" data-claire-element-id="548846">Fixed priority pre-emptive scheduling</h3><p id="r-548845" data-claire-element-id="548845">Avec cet algorithme, chaque programme possède une priorité : certains programmes seront donc prioritaires sur les autres. Cette priorité est définie par un nombre. Cette priorité est toujours la même et ne peut pas changer. L'ordonnanceur exécute toujours le programme le plus prioritaire.</p><h3 id="r-round-robin" data-claire-element-id="548849">Round-robin</h3><p id="r-548847" data-claire-element-id="548847">Cet algorithme est le premier de nos algorithmes qui utilise la méthode du quantum de temps : on donne à chaque programme un temps fixé une bonne fois pour toute durant lequel il peut s’exécuter. Une fois ce temps fini, l'ordonnanceur stoppe celui-ci et demande l’exécution d'un autre programme. Il se base toujours sur une file d'attente de programmes. Cette liste est ordonnée (comme pour l'algorithme FIFO et LIFO) et a un début et une fin. Tout programme qui vient d’être lancé est placé à la fin de cette liste.</p><p id="r-548848" data-claire-element-id="548848">Chaque programme dans la file d'attente a droit à un quantum de temps. Quand un programme a fini son exécution, il doit attendre que tous les autres programmes aient eu droit à leur quantum de temps avant de pouvoir être exécuté une nouvelle fois. Pour cela, à la fin de chaque quantum de temps, on place le programme a la fin de la liste d'attente.</p><h3 id="r-multilevel-feedback-queue" data-claire-element-id="548862">Multilevel feedback queue</h3><p id="r-548850" data-claire-element-id="548850">Cet algorithme est déjà plus proche de ceux implémentés dans les systèmes d'exploitations actuels. La philosophie derrière cet algorithme est</p><ul id="r-548857" data-claire-element-id="548857"><li id="r-548852" data-claire-element-id="548852"><p id="r-548851" data-claire-element-id="548851">d'ordonnancer aux mieux un ensemble de programmes aux temps d’exécutions et aux particularités disparates ;</p></li><li id="r-548854" data-claire-element-id="548854"><p id="r-548853" data-claire-element-id="548853">d’exécuter en priorité les programmes rapides ;</p></li><li id="r-548856" data-claire-element-id="548856"><p id="r-548855" data-claire-element-id="548855">d’exécuter en priorité les programmes qui accèdent souvent aux périphériques.</p></li></ul><p id="r-548858" data-claire-element-id="548858">Donner la priorité aux programmes rapides et qui n’épuisent donc que peu leur quantum de temps sert à avoir un système plus réactif. La priorité donnée aux programmes accédant aux périphériques est simple : ces programmes utilisent peu le processeur et passent leur temps à attendre le ou les périphériques. Pour éviter que ces programmes prennent trop de temps à s’exécuter, il faut limiter ce temps d'attente en privilégiant leur exécution.</p><p id="r-548859" data-claire-element-id="548859">Le principe de cet algorithme est simple : on dispose de plusieurs files d'attentes comme celle de l'algorithme round-robin. Ces files d'attente sont classées de la plus basse à la plus haute. Ces files d'attentes ont des priorités différentes. De plus, le quantum de temps est différent suivant la file d'attente : la file d'attente la plus haute a un quantum de temps très petit, tandis que la file la plus basse a un quantum de temps élevé.</p><p id="r-548860" data-claire-element-id="548860">Une autre différence : dans certaines variantes de cet algorithme, chaque file d'attente peut utiliser un algorithme d'ordonnancement différent ! La file d'attente la plus haute peut par exemple avoir un ordonnancement du type SJF, la file intermédiaire un ordonnancement de type round robin et la fil la plus basse un algorithme différent. L'utilité, c'est que chaque file aura un algorithme d’ordonnancement adapté pour des programmes plus ou moins rapides. La file la plus haute sera adaptée pur les programmes très rapide, la file intermédiaire pour des programmes au temps d’exécution moyen, et la file la plus basse pour les programmes les plus lents.</p><p id="r-548861" data-claire-element-id="548861">Quand on exécute un programme, celui-ci est placé dans la file d'attente la plus haute et donc la plus prioritaire, adaptée aux programmes rapides. Si ce programme n'utilise pas totalement son quantum de temps, cela signifie que ce programme est un programme rapide ou qu'il accède souvent à des périphériques. Celui va alors rester dans cette file la plus haute. Par contre, si le programme utilise tout le quantum de temps, il descend d'un niveau et va passer directement à la file juste en dessous. La seule façon pour lui de remonter d'un niveau est soit de ne plus utiliser complètement son quantum de temps, ou d'accéder à un périphérique. Et ce processus continue : un programme va alors baisser ou monter de file suivant son temps d’exécution.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation">Les systèmes d&#039;exploitation</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Programmes systèmes vs programmes applicatifs
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">Mécanismes d&#039;abstraction des périphériques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
Programmes systèmes et applicatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
Rappel sur les interruptions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">Noyau d&#039;un OS</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
Notre mémoire tourne en rond !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
Principaux types de noyaux
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Si on utilisait plusieurs programmes ?
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">Ordonnancement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
C&#039;est quoi ?
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
Algorithmes d&#039;ordonnancement
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">Processus et threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
Processus et threads
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
Sections critiques
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Gestion de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">Allocation et protection mémoire avancée</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
Systémes mono-programmés
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
Partitions mémoires fixes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
Allocation dynamique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
Adressage mémoire : quelques subtilités
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
<span class="arrow"></span>
<span class="next">C&#039;est quoi ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">
<span class="next">Processus et threads</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Processusetthreads"></a><h2>Processus et threads</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
<span class="arrow"></span>
<span class="next">Algorithmes d&#039;ordonnancement</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
<span class="next">Processus et threads</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-548866" data-claire-element-id="548866">La présence d'un système d'exploitation implique souvent que plusieurs programmes soient présents dans notre ordinateur. Bien sur, on ne peut, sur une machine à un seul processeur, exécuter plusieurs programmes en même temps. Mais les autres programmes démarrés par l'utilisateur ou par le système d'exploitation, doivent absolument se partager la mémoire RAM, même s'il ne s’exécutent pas.</p><p id="r-548867" data-claire-element-id="548867">La cohabitation de plusieurs programmes pose en effet quelques problèmes. Si un programme pouvait modifier toute donnée placée dans la mémoire RAM de notre ordinateur, on se retrouverait rapidement avec une situation non-prévue par le programmeur. Cela a des conséquences qui vont de comiques à catastrophiques. Généralement cela fini par un joli plantage.</p>
</div><a name="Processusetthreads"></a><h2>Processus et threads</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">
<span class="arrow"></span>
<span class="next">Processus et threads</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
<span class="next">Sections critiques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<div id="r-548869" data-claire-element-id="548869" data-claire-semantic="question"><p id="r-548868" data-claire-element-id="548868">Comment éviter qu'un programme accède à une donnée d'un autre programme ?</p></div><p id="r-548870" data-claire-element-id="548870">Très simple : on définit pour chaque programme une portion de la mémoire dans laquelle il pourra écrire ou lire. Le reste de la mémoire sera inaccessible en lecture et en écriture, à part quelques petites parties de la mémoire, partagées entre différents programmes. Aucun autre programme ne pourra alors lire ou écrire dans cette partie réservée de la mémoire.</p><h2 id="r-processus-threads-et-fibers" data-claire-element-id="548875">Processus, <em>Threads </em>et <em>Fibers</em></h2><p id="r-548871" data-claire-element-id="548871">Certains programmes reçoivent une portion de mémoire rien qu'a eux. Cette partie de la mémoire lui est réservée et seul lui peut lire ou écrire dans cette portion de la mémoire. Inversement, ce programme aura interdiction d'accéder à toute donnée en mémoire appartenant à un autre programme. Un programme ainsi conçu ne peut donc pas partager ses données avec d'autres. On appelle un programme ainsi conçu : un <strong>processus</strong>.</p><p id="r-548872" data-claire-element-id="548872">D'autres programmes ont des droits d'accès différents : ils peuvent décider d'autoriser les lectures et écritures dans la mémoire qui leur est allouée. En clair, la mémoire qui leur est allouée (le tas et la mémoire statique) ne leur est pas réservée, et ils peuvent la partager avec d'autres programmes.</p><p id="r-548873" data-claire-element-id="548873">Il existe deux catégories de programmes de ce type : les <em><strong>threads </strong></em>et les <strong><em>fibers</em></strong>.<br/> La seule différence entre les deux est que les <em>threads </em>sont gérés via ordonnancement préemptif, tandis que les <em>fibers </em>sont gérés via ordonnancement collaboratif.</p><p id="r-548874" data-claire-element-id="548874">L'utilité de ces <em>threads/fibers</em> est simple : cela permet à deux programmes d'échanger des données assez simplement. Il suffit pour cela de placer ces données dans la mémoire partagée entre ces deux <em>threads</em>. Avec des processus, l'échange de données est plus compliqué : il faut passer par des <strong>mécanismes de communication inter-processus</strong>. Ceux-ci sont souvent dépendants du système d'exploitation, qui sont parfois plus lents. Bien sur, il y a des précautions à prendre et ce n'est pas aussi simple, mais l'idée est là. De plus, la commutation entre deux <em>threads </em>(le passage de l'un à l'autre lors de l’exécution) est beaucoup plus rapide que le passage d'un processus à l'autre. En effet, le fait que les <em>threads </em>se partagent la même mémoire permet sur les ordinateurs actuels d'éviter certaines manipulations obligatoires avec les processus. Par exemple, on n'est pas obligé de vider le contenu des mémoires caches, sur certains processeurs (qui utilisent des caches <em>Virtually Tagged</em>).</p><h2 id="r-pauvre-processeur" data-claire-element-id="548878">Pauvre processeur</h2><p id="r-548876" data-claire-element-id="548876">Le processeur de la machine doit être modifié pour permettre cette protection de la mémoire, ou son partage. Celui-ci doit contenir un circuit qui retiendra pour chaque programme les autorisations d'accès à la mémoire et les manipulations permises. Ce circuit est placé, avec d'autres circuits chargés de la gestion de la mémoire, dans notre fameuse <strong>MMU</strong>. La <strong>MMU</strong> empêchera aux programmes d'aller écrire ou lire des données qu'ils n'ont pas le droit de toucher. Ces droits sont différents pour chaque programme et peuvent être différents pour la lecture et l'écriture : on peut ainsi autoriser à un programme de lire une partie de la mémoire, mais pas d'y écrire, ou autoriser lecture et écriture, ou interdire les deux.</p><p id="r-548877" data-claire-element-id="548877">Toute tentative d'accès à une partie de la mémoire non-autorisée déclenchera ce qu'on appelle une exception matérielle (rappelez-vous le chapitre sur les interruptions) qui devra être traitée par une routine du système d'exploitation. Généralement, le programme fautif est sauvagement arrêté et supprimé de la mémoire, et un message d'erreur est affiché à l'écran.</p><h2 id="r-process-control-block" data-claire-element-id="548881">Process Control Block</h2><p id="r-548879" data-claire-element-id="548879">Pour pouvoir manipuler ces processus ou <em>threads</em>, notre système d'exploitation doit mémoriser des informations sur eux. Il doit se souvenir des portions de la mémoire attribué à chaque processus, par exemple. Il doit aussi gérer tout ce qui a rapport à l’ordonnancement. Il doit ainsi se souvenir de l'instruction à laquelle notre processus s'est arrête lors de sa dernière exécution , son contexte d’exécution, etc. Bref, cela fait pas mal d’informations à sauvegarder.</p><p id="r-548880" data-claire-element-id="548880">Toutes ces informations sont stockées dans ce qu'on appelle un <strong><em>Process Control Block</em></strong>, une portion de la mémoire dans laquelle le système d'exploitation va stocker toutes les informations attribuée à un processus ou à un <em>thread</em>. Chaque processus ou <em>thread</em> se verra donc attribuer un <em>Process Control Block</em>, qui stockera tout ces paramètres utilisés par l'OS, et qui sera mis à jour automatiquement pas notre système d'exploitation.</p><h2 id="r-l-organisation-de-la-memoire-d-un-processus" data-claire-element-id="548908">L'organisation de la mémoire d'un processus</h2><p id="r-548882" data-claire-element-id="548882">Généralement, cette mémoire attribuée à notre processus, ou notre <em>thread</em>, est assez bien organisée. Sur la majorité des OS actuels, elle est découpée comme ceci :</p><ul id="r-548891" data-claire-element-id="548891"><li id="r-548884" data-claire-element-id="548884"><p id="r-548883" data-claire-element-id="548883">d'une <strong>mémoire programme</strong> ;</p></li><li id="r-548886" data-claire-element-id="548886"><p id="r-548885" data-claire-element-id="548885">d'une <strong>mémoire statique</strong> ;</p></li><li id="r-548888" data-claire-element-id="548888"><p id="r-548887" data-claire-element-id="548887">d'une <strong>pile</strong> ;</p></li><li id="r-548890" data-claire-element-id="548890"><p id="r-548889" data-claire-element-id="548889">d'un <strong>tas</strong>.</p></li></ul><figure id="r-548893" data-claire-element-id="548894"><img id="r-548892" data-claire-element-id="548892" src="medias/uploads.siteduzero.com_files_379001_380000_379474.png" alt="Image utilisateur"/></figure><p id="r-548895" data-claire-element-id="548895">La mémoire programme sert...à stocker le programme. Son nom est suffisamment clair.</p><p id="r-548896" data-claire-element-id="548896">La mémoire de travail statique est une partie de la mémoire de travail dans laquelle on stocke des données définitivement. En clair, on ne peut pas supprimer l'espace mémoire utilisé par une donnée dont on n'a plus besoin pour l'utiliser pour stocker une autre donnée. On peut donc lire ou modifier la valeur d'une donnée, mais pas la supprimer. Et c'est pareil pour la mémoire programme : on ne peut pas supprimer tout un morceau de programme en cours d’exécution (sauf dans le cas d'éventuels cas pathologiques que je ne connais pas).</p><p id="r-548897" data-claire-element-id="548897">A l'inverse, on peut utiliser le reste de la mémoire pour stocker temporairement des données et les effacer lorsqu'elles deviennent inutiles. Cela permet de limiter l'utilisation de la mémoire. Cette partie de la mémoire utilisable au besoin peut être utilisée de deux façon :</p><ul id="r-548902" data-claire-element-id="548902"><li id="r-548899" data-claire-element-id="548899"><p id="r-548898" data-claire-element-id="548898">Soit avec une <strong>pile</strong></p></li><li id="r-548901" data-claire-element-id="548901"><p id="r-548900" data-claire-element-id="548900">Soit avec un <strong>tas</strong>.</p></li></ul><p id="r-548903" data-claire-element-id="548903">La différence principale entre le tas et la pile est la façon dont sont organisées les données dedans. Une autre différence est leur utilisation : le tas est intégralement géré par le logiciel (par le programme ne cours d’exécution et éventuellement le système d'exploitation), tandis que la pile est en partie, voire totalement, gérée par le matériel de notre ordinateur.</p><p id="r-548904" data-claire-element-id="548904">Le tas (aussi appelé <strong>heap</strong>), a souvent une taille variable. Lorsqu'un programme souhaite avoir un peu plus de mémoire pour y stocker temporairement une donnée, il va exécuter une routine du système d'exploitation spécialement codée pour lui obtenir l'accès à un peu plus de mémoire. Si il y a suffisamment de mémoire pour contenter la demande du programme, l'OS va réserver une partie de la mémoire inutilisée pour le processus demandeur. Inversement, notre processus peut libérer une partie de la mémoire, grâce à un autre appel système : notre processus ne peut donc plus y accéder (il n'en a plus le droit), mais cette partie de la mémoire libérée peut être réservée pour les autres programmes.</p><p id="r-548905" data-claire-element-id="548905">Il faut noter que le tas est souvent optionnel : on verra dans le chapitre suivant que celui-ci n'existe pas forcément.</p><h3 id="r-threads-1" data-claire-element-id="548907">Threads</h3><p id="r-548906" data-claire-element-id="548906">Pour les <em>threads</em>, il faut signaler que seule le tas, la mémoire statique et parfois la mémoire programme sont partagées. La pile est réservée à notre <em>thread</em>, et ne peut en aucun cas être modifiée par un autre <em>thread </em>que le possesseur de cette pile.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation">Les systèmes d&#039;exploitation</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Programmes systèmes vs programmes applicatifs
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">Mécanismes d&#039;abstraction des périphériques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
Programmes systèmes et applicatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
Rappel sur les interruptions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">Noyau d&#039;un OS</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
Notre mémoire tourne en rond !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
Principaux types de noyaux
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Si on utilisait plusieurs programmes ?
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">Ordonnancement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
Algorithmes d&#039;ordonnancement
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">Processus et threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
Processus et threads
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
Sections critiques
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Gestion de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">Allocation et protection mémoire avancée</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
Systémes mono-programmés
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
Partitions mémoires fixes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
Allocation dynamique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
Adressage mémoire : quelques subtilités
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">
<span class="arrow"></span>
<span class="next">Processus et threads</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
<span class="next">Sections critiques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Sectionscritiques"></a><h2>Sections critiques</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
<span class="arrow"></span>
<span class="next">Processus et threads</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">
<span class="next">Allocation et protection mémoire avancée</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-548910" data-claire-element-id="548910">J'ai dit plus haut que les <em>threads </em>se partageaient des données. Cela a des avantages, comme un passage d'un <em>thread </em>à un autre plus rapide, ou un partage des données évitant de passer par de couteux mécanismes de communication fournis par l'OS. On pourrait se dire que les <em>threads </em>n'ont que des avantages.. Mais on n'a pas encore vu le revers de la médaille.</p><p id="r-548911" data-claire-element-id="548911">Nos <em>threads </em>sont avant tout des programmes pouvant s’exécuter en même temps, sans que cela ne pose problème. Ainsi, si vous avez une machine pouvant éxecuter plusieurs programmes simultanément (avec plusieurs processeurs, par exemple), vous pouvez lancer plusieurs <em>threads </em>, chacun s’exécutant dans son coin. C'est une technique assez efficace : au lieu d’exécuter nos <em>threads </em>uns par uns, on les exécute en même temps : cela va beaucoup plus vite, et prend nettement moins de temps (si c'est bien fait). Mais il y a un hic...</p><h2 id="r-problemes-4" data-claire-element-id="548919">Problèmes</h2><p id="r-548912" data-claire-element-id="548912">Dans ces conditions, deux <em>threads </em>peuvent parfaitement vouloir manipuler une donnée partagée simultanément. Par exemple, un <em>thread </em>peut vouloir lire une donnée en même temps qu'un autre cherche à l'écrire. Ou encore pire : deux <em>threads </em>peuvent vouloir écrire simultanément dans une données partagée. A votre avis : quel est le résultat de ce genre de situation ? Je vous le donne en mille : on n'en sait rien ! Des situations pareilles sont justes des nids à bugs, et il faut les éviter comme la peste.</p><p id="r-548913" data-claire-element-id="548913">Prenons un exemple : on utilise une donnée partagée entre plusieurs <em>threads</em>, chaque <em>thread</em> s’exécutant sur un processeur x86. Notre donnée est un vulgaire nombre entier. Chaque <em>thread </em>veut l'augmenter de 1 régulièrement. Seul problème, augmenter de 1 la donnée n'est pas effectuée en une seule instruction sur les processeurs x86. Il faut en effet lire la donnée, l'augmenter de 1, puis l'écrire. Et si deux processeurs veulent augmenter simultanément cette donnée, on court à la catastrophe. Chaque <em>thread</em> peut être interrompu à n'importe quel moment par un autre processeur qui voudra modifier sa donnée. Les instructions de nos <em>threads </em>s’exécuteront en série, comme le modèle de consistance nous l'impose, mais le processeur peut parfaitement être dérangé par un autre processeur entre deux instructions.</p><p id="r-548914" data-claire-element-id="548914">Dans notre exemple, voici ce que cela donnerait.</p><figure id="r-548916" data-claire-element-id="548917"><img id="r-548915" data-claire-element-id="548915" src="medias/uploads.siteduzero.com_files_396001_397000_396525.png" alt="Image utilisateur"/></figure><p id="r-548918" data-claire-element-id="548918">On a donc une valeur de départ de 5, qui est augmentée de 1 deux fois, ce qui donne au final 6... Nos processeurs sont pas foutus de faire des calculs tellement basiques qu'on pourrait les laisser à des enfants de 5 ans !</p><h2 id="r-solutions-9" data-claire-element-id="548922">Solutions</h2><p id="r-548920" data-claire-element-id="548920">Bon, blague à part, pour avoir le bon résultat il y a une seule et unique solution : on n'a qu'une seule solution : éviter des modifications simultanées dans une donnée partagée. Mais c'est plus facile à dire qu'à faire. Le premier processeur doit avoir un accès exclusif à la donnée partagée. Sans cela, l'autre processeur ira lire une version de la donnée qui n'aura pas encore été modifiée par l'autre processeur. Dans notre exemple, un seul <em>thread </em>doit pouvoir manipuler notre compteur à la fois.</p><p id="r-548921" data-claire-element-id="548921">Et bien sûr, cette réponse peut, et doit se généraliser à presque toutes les autres situations impliquant une donnée partagée. Chaque <em>thread </em>doit donc avoir un accès exclusif à notre donnée partagée, sans qu'aucun autre <em>thread </em>ne puisse manipuler notre donnée. On doit donc définir ce qu'on appelle une <strong>section critique</strong> : un morceau de temps durant lequel un <em>thread </em>aura un accès exclusif à une donnée partagée : notre <em>thread </em>est certain qu'aucun autre <em>thread </em>n'ira modifier la donnée qu'il manipule durant ce temps.<br/> Pour cela, des spécialistes et des chercheurs ont cherchés des solutions, et on trouvé quelques solutions intéressantes. Il existe en effet des moyens pour faire en sorte que nos accès à une donnée partagée se fassent les uns après les autres, dans l'ordre, et pas simultanément. C'est ce que fait notre système d'exploitation : il fournit des petits programmes simplistes, qui permettent de lire ou d'écrire une donnée partagée sans problèmes.</p><h2 id="r-exclusion-mutuelle-2" data-claire-element-id="548961">Exclusion mutuelle</h2><p id="r-548923" data-claire-element-id="548923">Autant prévenir tout de suite : créer de telles sections critiques se base sur des mécanismes mêlant le matériel et le logiciel. Il existe deux grandes solutions, qui peuvent être soit codées sous la forme de programmes, soit implantées directement dans le silicium de nos processeurs. Voyons la première de ces solutions : l'<strong>exclusion mutuelle</strong>.</p><p id="r-548924" data-claire-element-id="548924">Avec celle-ci, on fait en sorte qu'un seul <em>thread </em>puisse accéder à notre donnée partagée. Un <em>thread </em>qui veut manipuler cette donnée va donc attendre qu'elle soit libre pour la réserver afin de l'utiliser, et la libérera une fois qu'il en a fini avec elle. Si la donnée est occupée par un <em>thread</em>, tous les autres <em>threads </em>devront attendre leur tour.</p><p id="r-548925" data-claire-element-id="548925">Pour mettre en œuvre cette réservation/dé-réservation, on va devoir ajouter quelque chose à chaque donnée à partager. Dans le cas le plus simple, ce quelque chose sera un simple compteur, écrit en mémoire à coté de la donnée, qui indiquera si la donnée partagée est libre ou si un programme se l'est déjà réservée. Dans le cas le plus simple, ce compteur vaudra 0 si la donnée est réservée, et 1 si elle est libre. Ainsi, un <em>thread </em>qui voudra réserver la donnée va d'abord devoir vérifier si ce nombre est à 1 avant de pouvoir réserver sa donnée. Si c'est le cas, il réservera la donnée en passant ce nombre à 0. Si la donnée est réservée par un autre <em>thread</em>, il devra tout simplement attendre son tour. On a alors crée ce qu'on appelle un <strong>verrou d'exclusion mutuelle</strong>.</p><p id="r-548926" data-claire-element-id="548926">Seul problème : cette vérification et modification du compteur pose problème. Celle-ci ne peut pas être interrompue, sous peine de problèmes. On peut reprendre l'exemple du dessus pour l'illustrer. Si notre compteur est à 0, et que deux <em>threads </em>veulent lire et modifier ce compteur simultanément, il est possible que les deux <em>threads </em>lisent le compteur en même temps : ils liront alors un zéro, et essayeront alors de se réserver la donnée simultanément. Bref, retour à la case départ...</p><p id="r-548927" data-claire-element-id="548927">Quoique non, il y a peut-être possibilité de faire en sorte que la vérification et modification de ce compteur puisse se faire correctement. En tout cas, cette vérification et modification du compteur se fait en plusieurs étapes : une lecture du compteur, puis une écriture si le compteur est à la bonne valeur. Il faudrait que cette lecture et l'écriture se fassent en une seule fois.</p><h3 id="r-solutions-logicielles" data-claire-element-id="548929">Solutions logicielles</h3><p id="r-548928" data-claire-element-id="548928">Et bien c'est possible. Cela peut se faire de manière logicielle. On pourrait citer l'algorithme de Dekker's, l'algorithme de Petterson, et encore d'autres algorithmes crées par des mathématiciens ou informaticiens plus ou moins connus. Seul problème : ces algorithmes ne sont pas utilisés dans nos OS actuels. Leur défaut principal est qu'ils ne fonctionnent pas sur les processeurs modernes, qui exécutent les accès à la mémoire dans un différent de celui imposé par le programme. Certains processeurs actuels se permettent de changer l'ordre d’exécution de certaines instructions et peuvent ainsi faire sauter ces algorithmes dans certaines situations.</p><h3 id="r-exclusion-mutuelle-materielle" data-claire-element-id="548960">Exclusion mutuelle matérielle</h3><p id="r-548930" data-claire-element-id="548930">Pour régler ce problème, certains processeurs fournissent des instructions spécialisées, in-interruptibles, capables d'effectuer cette modification du compteur en une seule fois. Ces instructions peuvent ainsi lire ce compteur, décider si on peut le modifier, et écrire la bonne valeur sans être dérangé par un autre processeur qui viendrait s'inviter dans la mémoire sans autorisation ! Par exemple, sur les processeurs x86, la vérification/modification du compteur vue plus haut peut se faire avec l'instruction <code data-claire-semantic="nasm">test and set</code>.</p><p id="r-548931" data-claire-element-id="548931">D'autres instructions atomiques similaires existent pour résoudre ce genre de problèmes. Leur rôle est toujours d'implémenter des verrous d'exclusion mutuelle plus ou moins sophistiqués, en permettant d'effectuer une lecture, suivie d'une écriture en une seule fois. Ces instructions permettent ainsi de créer des sémaphores, des <em>Locks</em>, etc. Généralement, un programmeur n'a pas à devoir manipuler des instructions atomiques lui-même, mais ne fait que manipuler des abstractions basées sur ces instructions atomiques, fournies par des bibliothèques ou son langage de programmation.</p><p id="r-548932" data-claire-element-id="548932">Voici la plupart de ces instructions atomiques les plus connues :</p><table id="r-548955" data-claire-element-id="548955"><thead id="r-548938" data-claire-element-id="548938"><tr id="r-548937" data-claire-element-id="548937"><th id="r-548934" data-claire-element-id="548934"><p id="r-548933" data-claire-element-id="548933">Instruction</p></th><th id="r-548936" data-claire-element-id="548936"><p id="r-548935" data-claire-element-id="548935">Description</p></th></tr></thead><tbody id="r-548954" data-claire-element-id="548954"><tr id="r-548943" data-claire-element-id="548943"><td id="r-548940" data-claire-element-id="548940"><p id="r-548939" data-claire-element-id="548939">Compare And Swap</p></td><td id="r-548942" data-claire-element-id="548942"><p id="r-548941" data-claire-element-id="548941">Cette instruction va lire une donnée en mémoire, va comparer celle-ci à l'opérande de notre instruction (une donnée fournie par l'instruction), et va écrire un résultat en mémoire si ces deux valeurs sont différentes. Ce fameux résultat est fourni par l'instruction, ou est stocké dans un registre du processeur.</p></td></tr><tr id="r-548948" data-claire-element-id="548948"><td id="r-548945" data-claire-element-id="548945"><p id="r-548944" data-claire-element-id="548944">Fetch And Add</p></td><td id="r-548947" data-claire-element-id="548947"><p id="r-548946" data-claire-element-id="548946">Cette instruction charge la valeur de notre compteur depuis la mémoire, l'incrémente, et écrit sa valeur en une seule fois. Elle permet de réaliser ce qu'on appelle des sémaphores. Elle permet aussi d'implémenter des compteurs concurrents.</p></td></tr><tr id="r-548953" data-claire-element-id="548953"><td id="r-548950" data-claire-element-id="548950"><p id="r-548949" data-claire-element-id="548949">XCHG</p></td><td id="r-548952" data-claire-element-id="548952"><p id="r-548951" data-claire-element-id="548951">Cette instruction peut échanger le contenu d'un registre et d'un morceau de mémoire de façon atomique. Elle est notoirement utilisée sur les processeurs x86 de nos PC, qui implémentent cette instruction.</p></td></tr></tbody></table><p id="r-548956" data-claire-element-id="548956">Néanmoins, cette technique des verrous d'exclusion mutuelle pose quelques problèmes.</p><p id="r-548957" data-claire-element-id="548957">Premièrement, ils imposent qu'un seul <em>thread </em>puisse accéder à notre donnée, en forçant tous les autres à se mettre en pause. Les autres <em>thread </em>doivent alors attendre que la donnée partagée soit libérée pour continuer leur exécution. Et c'est obligatoire, même s'ils veulent lire la donnée sans la modifier.</p><p id="r-548958" data-claire-element-id="548958">Deuxièmement, si on ne fait pas trop gaffe, il est possible qu'un <em>thread </em>réserve la donnée en oubliant la libérer. Dans ce cas, tous les autres <em>threads </em>seront définitivement bloqués. Ce genre de chose est souvent synonyme de mauvaise programmation, mais c'est malgré tout un défaut des verrous d'exclusion mutuelle.</p><p id="r-548959" data-claire-element-id="548959">Enfin, il est possible qu'un <em>thread </em>n'aie jamais accès à la donnée partagée parce que tous les autres <em>threads </em>passent devant : à chaque fois que le <em>thread </em>regarde si la donnée est libre, elle est occupé par un de ses collègues indélicat qui sera passé avant. Bref, nos verrous d’exclusion mutuelle ne sont pas la panacée.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation">Les systèmes d&#039;exploitation</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Programmes systèmes vs programmes applicatifs
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">Mécanismes d&#039;abstraction des périphériques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
Programmes systèmes et applicatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
Rappel sur les interruptions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">Noyau d&#039;un OS</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
Notre mémoire tourne en rond !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
Principaux types de noyaux
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Si on utilisait plusieurs programmes ?
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">Ordonnancement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
Algorithmes d&#039;ordonnancement
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">Processus et threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
Processus et threads
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
Sections critiques
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Gestion de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">Allocation et protection mémoire avancée</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
Systémes mono-programmés
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
Partitions mémoires fixes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
Allocation dynamique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
Adressage mémoire : quelques subtilités
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
<span class="arrow"></span>
<span class="next">Processus et threads</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">
<span class="next">Allocation et protection mémoire avancée</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Allocationetprotectionmmoireavance"></a><h2>Allocation et protection mémoire avancée</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
<span class="arrow"></span>
<span class="next">Sections critiques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
<span class="next">Systémes mono-programmés</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-548965" data-claire-element-id="548965">Vous avez vu dans les chapitres précédents que notre systéme d'exploitation redoublait d'ingéniosité pour passer sous le tapis les différentes problèmes dus à l'utilisation de la plusieurs programmes. Et bien nous allons continuer dans cette voie et voir comment notre OS fait pour gérer la répartition de la mémoire sur les différents processus/threads.</p><p id="r-548966" data-claire-element-id="548966">De nombreuses instructions ou fonctionnalités d'un programme nécéssitent pour fonctionner de connaitre ou de manipuler des adresses mémoires qui sont censées être fixes (accès à une variable, pointeurs, branchements camouflés dans des structures de contrôles, et d'autres). Le seul problème, c'est que dans un ordinateur multiprogrammé complexe, un programme n'est pas toujours stocké au même endroit en mémoire quand on l’exécute plusieurs fois. Ces adresses ne peuvent pas être connues à la compilation, et pourtant cela n’empêche pas le compilateur de compiler.</p><div id="r-548968" data-claire-element-id="548968" data-claire-semantic="question"><p id="r-548967" data-claire-element-id="548967">Comment notre programme fait-il pour s'y retrouver ?</p></div>
</div><a name="Systmesmono-programms"></a><h2>Systémes mono-programmés</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">
<span class="arrow"></span>
<span class="next">Allocation et protection mémoire avancée</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
<span class="next">Partitions mémoires fixes</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-548969" data-claire-element-id="548969">Sur les ordinateurs mono-programmés, capables d’exécuter un seul programme à la fois, la technique la plus souvent utilisée est la technique du moniteur résident. Cela consiste à découper la mémoire en deux parties :</p><ul id="r-548974" data-claire-element-id="548974"><li id="r-548971" data-claire-element-id="548971"><p id="r-548970" data-claire-element-id="548970">une portion de taille fixe et constante qui sera réservée au système d'exploitation ainsi qu'a quelques autres machins (gestion des périphériques);</p></li><li id="r-548973" data-claire-element-id="548973"><p id="r-548972" data-claire-element-id="548972">et le reste de la mémoire qui sera réservé au programme à exécuter.</p></li></ul><figure id="r-548976" data-claire-element-id="548977"><img id="r-548975" data-claire-element-id="548975" src="medias/uploads.siteduzero.com_files_324001_325000_324295.png" alt="Image utilisateur"/></figure><p id="r-548978" data-claire-element-id="548978">La portion de mémoire réservée pour le système étant fixe, l'adresse à laquelle commence le programme applicatif est donc toujours la même et ne change jamais. A chaque fois que l'on exécute notre programme applicatif, on sait à quelle adresse il commence.</p><h2 id="r-registre-limite" data-claire-element-id="548986">Registre limite</h2><p id="r-548979" data-claire-element-id="548979">Encore une fois, le besoin de protection mémoire se fait sentir. Pour le moment on a aucun moyen de protéger les données de notre OS contre une mauvaise utilisation d'un programme utilisateur. Un virus qui voudrait modifier un fichier système copié en mémoire RAM n'a strictement aucune barrière matérielle qui pourrait l’empêcher de nuire.</p><div id="r-548981" data-claire-element-id="548981" data-claire-semantic="question"><p id="r-548980" data-claire-element-id="548980">Comment éviter que notre programme aille modifier les données du système d’exploitation ?</p></div><p id="r-548982" data-claire-element-id="548982">La solution a été d'implanter un <strong>registre limite</strong>. Ce registre contient la fameuse adresse à partir de laquelle un programme applicatif est stocké en mémoire. Quand un programme applicatif cherche à accéder à la mémoire, l'adresse à laquelle il veut accéder va être comparée à celle contenue dans ce registre limite. Si cette adresse est plus petite que celle contenue dans le registre limite, cela signifie que le programme cherche à accéder à une donnée placée dans la mémoire réservée au système, et l’accès mémoire est interdit : une exception matérielle est levée, ce qui exécute une routine d'interruption du système d'exploitation. Généralement, cette routine va supprimer le programmes fautif de la mémoire et va afficher un beau message d'erreur. Bien sur, si l'adresse à laquelle accède notre programme est supérieur ou égale à l'adresse contenue dans notre registre limite, pas de problème : l'accès mémoire est autorise et notre programme s’exécute normalement.</p><figure id="r-548984" data-claire-element-id="548985"><img id="r-548983" data-claire-element-id="548983" src="medias/uploads.siteduzero.com_files_324001_325000_324298.png" alt="Image utilisateur"/></figure>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation">Les systèmes d&#039;exploitation</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Programmes systèmes vs programmes applicatifs
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">Mécanismes d&#039;abstraction des périphériques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
Programmes systèmes et applicatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
Rappel sur les interruptions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">Noyau d&#039;un OS</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
Notre mémoire tourne en rond !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
Principaux types de noyaux
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Si on utilisait plusieurs programmes ?
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">Ordonnancement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
Algorithmes d&#039;ordonnancement
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">Processus et threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
Processus et threads
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
Sections critiques
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Gestion de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">Allocation et protection mémoire avancée</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
Systémes mono-programmés
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
Partitions mémoires fixes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
Allocation dynamique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
Adressage mémoire : quelques subtilités
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">
<span class="arrow"></span>
<span class="next">Allocation et protection mémoire avancée</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
<span class="next">Partitions mémoires fixes</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Partitionsmmoiresfixes"></a><h2>Partitions mémoires fixes</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
<span class="arrow"></span>
<span class="next">Systémes mono-programmés</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
<span class="next">Allocation dynamique</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-548988" data-claire-element-id="548988">Mais si l'on souhaite utiliser un ordinateur multi-programmé, comment notre système d'exploitation va-t-il faire pour gérer la répartition de la mémoire pour les différentes processus ? Après tout, plusieurs programmes vont devoir se partager la mémoire et notre système d'exploitation doit prendre en charge tout cela.</p><p id="r-548989" data-claire-element-id="548989">Une solution simple est de partager la mémoire en blocs qui serviront chacun à stocker un programme : on appelle chacun de ces blocs une <strong>partition mémoire</strong>. Quand on démarre notre programme, celui-ci sera placé dans une de ces partition (qui n'est pas forcément la même à chaque exécution). Suivant la méthode retenue, ces partitions peuvent avoir</p><ul id="r-548994" data-claire-element-id="548994"><li id="r-548991" data-claire-element-id="548991"><p id="r-548990" data-claire-element-id="548990">des tailles identiques (elle utilisent chacune la même quantité de mémoire) ;</p></li><li id="r-548993" data-claire-element-id="548993"><p id="r-548992" data-claire-element-id="548992">ou des tailles différentes, histoire de pouvoir mieux utiliser al mémoire.</p></li></ul><figure id="r-548996" data-claire-element-id="548997"><img id="r-548995" data-claire-element-id="548995" src="medias/uploads.siteduzero.com_files_324001_325000_324308.png" alt="Image utilisateur"/></figure><p id="r-548998" data-claire-element-id="548998">Il faut que le programme tienne complétement dans la partition qui lui sera réservée. En utilisant des partitions ayant des tailles différentes, on prend généralement la plus petite partition vide (ne contenant pas de programme) capable d’accueillir le programme.</p><h2 id="r-deux-registres-limite" data-claire-element-id="549003">Deux registres limite</h2><p id="r-548999" data-claire-element-id="548999">Encore une fois, la protection mémoire ne doit pas être prise à la légère.</p><div id="r-549001" data-claire-element-id="549001" data-claire-semantic="question"><p id="r-549000" data-claire-element-id="549000">Comment empêcher un programme d'accéder à des zones mémoire n'appartenant pas à sa partition qui lui est dédiée ?</p></div><p id="r-549002" data-claire-element-id="549002">Après tout, un programme pourrait parfaitement décider d'accéder à des adresses situées en dessous de sa partition, ou encore au dessus. Avec cette façon de répartir les programme en mémoire, un simple registre limite ne suffit plus. Il nous faut donc deux registres : un qui retient l'adresse à laquelle commence le programme, et un qui retient l'adresse à laquelle la partition dédiée au programme se termine. A chaque accès mémoire, on doit comparer si l'adresse mémoire à laquelle le programme veut écrire ou lire est bien comprise entre les deux valeurs minimales et maximale indiquée par les registres limite.</p><h2 id="r-desavantages-et-avantages" data-claire-element-id="549006">Désavantages et avantages</h2><p id="r-549004" data-claire-element-id="549004">Cette technique est très simple à mettre en œuvre et est redoutablement simple à comprendre. Elle possède même quelques avantages : la gestion de la mémoire est très rapide, notamment. Un des problèmes de cette solution, c'est qu'elle ne marche que si la consommation mémoire maximum de chaque programme est bornée et ne peut pas dépasser un maximum. Imaginez qu'un programme prenne plus de place que ce qu'on a réservé dans le bloc de mémoire qui lui est dédié : catastrophe ! Un autre problème apparait quand on utilise cette méthode : de la mémoire est gaspillée.</p><p id="r-549005" data-claire-element-id="549005">Imaginez que vous ne lanciez un programme : celui-ci est placé dans sa partition. Cette partition est prévue pour accueillir le programme dans toutes les circonstances et réserve ainsi autant de mémoire que notre programme peut en consommer dans le pire des cas. Évidemment, la majorité du temps, notre programme prendra bien moins de mémoire que ce qui lui a été réservé dans sa partition : on gaspille de la mémoire inutilement. De plus, si on ne lance qu'un seul programme, toutes les autres partitions sont inutilisées, ce qui gâche encore plus de mémoire. Et il a bien fallu trouver une solution pour éviter tout ce gâchis.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation">Les systèmes d&#039;exploitation</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Programmes systèmes vs programmes applicatifs
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">Mécanismes d&#039;abstraction des périphériques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
Programmes systèmes et applicatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
Rappel sur les interruptions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">Noyau d&#039;un OS</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
Notre mémoire tourne en rond !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
Principaux types de noyaux
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Si on utilisait plusieurs programmes ?
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">Ordonnancement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
Algorithmes d&#039;ordonnancement
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">Processus et threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
Processus et threads
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
Sections critiques
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Gestion de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">Allocation et protection mémoire avancée</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
Systémes mono-programmés
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
Partitions mémoires fixes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
Allocation dynamique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
Adressage mémoire : quelques subtilités
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
<span class="arrow"></span>
<span class="next">Systémes mono-programmés</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
<span class="next">Allocation dynamique</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Allocationdynamique"></a><h2>Allocation dynamique</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
<span class="arrow"></span>
<span class="next">Partitions mémoires fixes</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
<span class="next">Adressage mémoire : quelques subtilités</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-549008" data-claire-element-id="549008">Pour résoudre le problème vu au-dessus, on a trouve quelques solutions assez sympa. Mais toutes se basent sur le même principe : <strong>l'allocation de mémoire dynamique</strong>. Cela consiste à réserver juste ce qu'il faut de mémoire au lancement d'un programme, et augmenter ou diminuer la quantité de mémoire réservée à celui-ci suivant les besoins.</p><h2 id="r-allocation-memoire" data-claire-element-id="549011">Allocation mémoire</h2><p id="r-549009" data-claire-element-id="549009">Avant le lancement de l'OS, toute la mémoire est composée de deux portions : une partition qui est intégralement vide, et une autre qui stocke les programmes systèmes (le noyau). A chaque fois qu'on lance un programme applicatif, on va réserver une partie de la mémoire vide dans laquelle on va placer le programme à exécuter. On réserve juste ce qu'il faut pour stocker notre programme, et on ne réserve pas de mémoire supplémentaire au cas où. Notre système d'exploitation va ainsi utiliser autant de &quot;portions de mémoires&quot; que de programmes voulus, ces portions n'ayant jamais la même adresse de base (contrairement à la méthode des partitions fixes).</p><p id="r-549010" data-claire-element-id="549010">Si notre programme a besoin de plus de mémoire quand il est en train de s’exécuter, le programme peut alors demander au système d'exploitation un peu plus de mémoire, grâce à un appel système conçu pour. Bien sûr, quand un programme n'a plus besoin d'une portion de mémoire, il peut &quot;dé-réserver&quot; celle-ci et la rendre utilisable par notre système d'exploitation. On dit que notre programme libère la mémoire. Pour implémenter l'allocation mémoire, les concepteurs de systèmes d'exploitation ont d'abord pensé à utiliser des partitions mémoire variables.</p><h2 id="r-partitions-variables" data-claire-element-id="549024">Partitions variables</h2><p id="r-549012" data-claire-element-id="549012">Chacune de ces partitions n'a pas une adresse de base fixe : l'OS peut décider de placer une partition où bon lui semble dans la mémoire. C'est la première différence avec la méthode des partitions fixes, qui sont toujours placées au même endroit en mémoire. De plus, le nombre de partition est lui aussi variable. En gros, notre système d'exploitation va réserver pour chaque programme une partition qui contient juste ce qu'il faut de mémoire. Ces partitions seront réparties dans la mémoire de différentes manières suivant le système d'exploitation.</p><p id="r-549013" data-claire-element-id="549013">Et enfin, chaque partition peut voir sa taille se modifier : on peut ainsi augmenter ou diminuer la taille d'une partition suivant les besoins du programme contenu dans celle-ci. Si notre programme a besoin d'un peu plus de mémoire, La partition réservée au programme sera agrandie de façon à répondre à la demande du programme. Inversement, si notre programme cherche à libérer de la mémoire, une portion de la mémoire sera alors rendue au système d'exploitation.</p><h3 id="r-registres-limite-et-base" data-claire-element-id="549015">Registres limite et base</h3><p id="r-549014" data-claire-element-id="549014">Comme pour les partitions fixes, on ne peut pas se passer de protection mémoire. La solution la plus simple pour protéger la mémoire est de prendre deux registres : un <strong>registre de base</strong> et un <strong>registre limite</strong>. Le registre de base stocke l'adresse à laquelle commence la partition variable, et le registre limite stocke l'adresse à laquelle se termine la partition. Une implémentation naïve de la protection mémoire consiste à vérifier pour chaque accès mémoire que l'adresse à laquelle le programme veut lire est bien située entre l'adresse stockée dans le registre de base et l'adresse stockée dans le registre limite.</p><h3 id="r-desavantages-3" data-claire-element-id="549023">Désavantages</h3><p id="r-549016" data-claire-element-id="549016">Bien sûr, cette solution n'est pas miraculeuse. Imaginons le cas suivant : deux programmes sont lancés et sont stockés dans deux partitions en mémoire. Ces programmes vont alors régulièrement avoir besoin de mémoire et vont prendre de la mémoire. Imaginez qu'un programme aie tellement grossit qu'on en arrive à la situation suivante :</p><figure id="r-549018" data-claire-element-id="549019"><img id="r-549017" data-claire-element-id="549017" src="medias/uploads.siteduzero.com_files_330001_331000_330764.png" alt="Image utilisateur"/></figure><div id="r-549021" data-claire-element-id="549021" data-claire-semantic="question"><p id="r-549020" data-claire-element-id="549020">Imaginez maintenant que le programme N°1 aie besoin de plus de mémoire, que se passe-il ?</p></div><p id="r-549022" data-claire-element-id="549022">Je suppose que vous voyez bien qu'il y a un problème : il n'y a pas de mémoire libre à la suite du programme N°1. Pour le résoudre, notre système d’exploitation va devoir déplacer au moins programme et réorganiser la façon dont ceux-ci sont répartis en mémoire. Ce qui signifie que au moins un des deux programme sera déplacé.</p><h2 id="r-une-autre-solution" data-claire-element-id="549041">Une autre solution</h2><p id="r-549025" data-claire-element-id="549025">Un autre solution au problème vu plus haut existe : fragmenter notre programme en plusieurs morceaux ! Chaque demande supplémentaire de mémoire va créer une partition supplémentaire, elle aussi réservée à notre programme demandeur. Notre programme se retrouve donc dispersé dans la mémoire en plusieurs morceaux : un gros morceau alloué au lancement du programme, et des tas d'autres morceaux crée lorsque le système d'exploitation alloue de la mémoire.</p><p id="r-549026" data-claire-element-id="549026">Si l'on reprend notre exemple du dessus, notre programme va alors être répartit comme suit dans la mémoire.</p><figure id="r-549028" data-claire-element-id="549029"><img id="r-549027" data-claire-element-id="549027" src="medias/uploads.siteduzero.com_files_330001_331000_330772.png" alt="Image utilisateur"/></figure><p id="r-549030" data-claire-element-id="549030">Cela évite de devoir déplacer le programme N°2, ce qui aurait prit un temps fou. Cette technique est aussi plus simple pour gérer la libération de la mémoire.</p><h3 id="r-protection-memoire-2" data-claire-element-id="549032">Protection mémoire</h3><p id="r-549031" data-claire-element-id="549031">Le seul problème, c'est qu'on ne peut pas utiliser de registre limite dans cette situation, et il faut recourir à des méthodes de protection mémoire beaucoup plus évoluées.</p><h3 id="r-fragmentation-memoire" data-claire-element-id="549040">Fragmentation mémoire</h3><p id="r-549033" data-claire-element-id="549033">Mais le sort a décidé de s’acharner sur nous ! La méthode consistant à découper nos programmes en morceaux ne résout pas entièrement notre problème : elle génère de la <strong>fragmentation mémoire</strong>. Cela veut dire qu'a force d'allouer et de libérer des blocs de mémoire dispersés un peu partout dans la mémoire, la mémoire libre, qui n'est réservée à aucun processus, se présente sous forme de petits blocs dispersés dans la mémoire.</p><figure id="r-549035" data-claire-element-id="549036"><img id="r-549034" data-claire-element-id="549034" src="medias/uploads.siteduzero.com_files_330001_331000_330777.png" alt="Image utilisateur"/></figure><p id="r-549037" data-claire-element-id="549037">Et maintenant, dans la situation décrite par le schéma du dessus, imaginez qu'un des deux programmes aie besoin de 700 méga-octets de mémoire. On aura suffisamment de mémoire libre pour le caser : on a bel et bien 1.1 gigaoctet de libre. Mais aucun bloc de mémoire libre ne sera suffisamment gros pour répondre à la demande. Si aucun bloc de mémoire vide n'est suffisamment gros pour combler une demande d'un programme, notre système d'exploitation va devoir regrouper les morceaux de mémoire utilisés par les différents programmes et les déplacer pour créer des vides plus gros.</p><p id="r-549038" data-claire-element-id="549038">Sur certains ordinateurs, la situation est encore pire : la mémoire ne peut être allouée que par blocs de taille fixe, et on ne peut gérer l'occupation de la mémoire à l'octet prêt. Ainsi, une partition mémoire d'un processus sera constituée de blocs de mémoire ayant une taille impossible à modifier (4 kilo-octets par exemple). Ainsi, une partition mémoire voulant grandir va se faire réserver plusieurs blocs de 4kilo-octets (pas forcément dispersés dans la mémoire, et souvent regroupés ensembles). Une partie de la mémoire de ces blocs de taille fixe peut être inutilisée, ce qui gâche de la mémoire. C'est le retour de la fragmentation interne.</p><p id="r-549039" data-claire-element-id="549039">L'algorithme utilisé pour sélectionner la partition de mémoire vide dans laquelle allouer un processus ou de la mémoire a un rôle déterminant dans l'importance de cette fragmentation mémoire. Il en existe un grand nombre, et chacun d'eux a des avantages et des inconvénients. Certains sont plus rapides, d'autres ne gâchent pas de mémoire, etc.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation">Les systèmes d&#039;exploitation</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Programmes systèmes vs programmes applicatifs
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">Mécanismes d&#039;abstraction des périphériques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
Programmes systèmes et applicatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
Rappel sur les interruptions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">Noyau d&#039;un OS</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
Notre mémoire tourne en rond !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
Principaux types de noyaux
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Si on utilisait plusieurs programmes ?
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">Ordonnancement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
Algorithmes d&#039;ordonnancement
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">Processus et threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
Processus et threads
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
Sections critiques
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Gestion de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">Allocation et protection mémoire avancée</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
Systémes mono-programmés
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
Partitions mémoires fixes
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
Allocation dynamique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
Adressage mémoire : quelques subtilités
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
<span class="arrow"></span>
<span class="next">Partitions mémoires fixes</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
<span class="next">Adressage mémoire : quelques subtilités</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Adressagemmoirequelquessubtilits"></a><h2>Adressage mémoire : quelques subtilités</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
<span class="arrow"></span>
<span class="next">Allocation dynamique</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-549043" data-claire-element-id="549043">Avec la méthode des partitions variables et ses différentes améliorations, un détail important devrait vous sauter aux yeux. On ne peut pas savoir à quelle adresse commence un programme. En effet, l'adresse de base d'un programme dépend de l'allocation effectuée par le système d'exploitation, et celui-ci peut décider de placer notre programme n'importe où en mémoire.</p><p id="r-549044" data-claire-element-id="549044">Mine de rien, le problème est de taille : chaque accès à une donnée, chaque branchement, chaque instruction est localisée en mémoire, et vouloir y accéder signifie accéder à la bonne adresse. Hors, un programme ne sait pas à quelle adresse il va être placé en mémoire. Seulement, celui-ci doit utiliser des adresses mémoires et connaitre celle-ci dès sa conception.</p><div id="r-549046" data-claire-element-id="549046" data-claire-semantic="question"><p id="r-549045" data-claire-element-id="549045">Comment fait-donc notre programme pour manipuler des adresses mémoires ?</p></div><p id="r-549047" data-claire-element-id="549047">Il faut donc corriger les adresses utilisées par notre programme en fonction de l'adresse à laquelle celui-ci débute en mémoire. Nos programmes utiliseront de fausses adresses dans leur code source, qui seront transformées en adresses véritables à l’exécution. Ainsi, un programme sera programmé (ou compilé) de façon à utiliser de fausses adresses, nommées <strong>adresses statiques</strong>. Ces adresses statiques seront donc transformées en adresses correctes à l’exécution. On considère que nos programmes sont conçus de façon à croire que ceux-ci commencent à l'adresse 0. Ainsi, il suffit d'additionner l'adresse à laquelle notre programme débute dans la mémoire (l'adresse de sa première instruction machine en mémoire) à chaque adresse statique.</p><div id="r-549049" data-claire-element-id="549049" data-claire-semantic="question"><p id="r-549048" data-claire-element-id="549048">Et dans le cas ou le programme est découpé en blocs dans la mémoire ?</p></div><p id="r-549050" data-claire-element-id="549050">Dans ce cas, si on veut manipuler une donnée dans un des bloc de mémoire alloué par le programme, on additionne l'adresse de base du bloc de mémoire qu'on a réservé aux adresses mémoire. Bien sûr, si on ne manipule pas de donnée dans un de ces bloc, on continue d'utiliser l'adresse de base du programme. Mais cela ne peut se faire qu'a l’exécution, comme on le verra plus loin. Dans ce cas, on doit conserver l'adresse de début du bloc dans un registre pour faire l'addition voulue.</p><p id="r-549051" data-claire-element-id="549051">Maintenant, il existe deux grandes méthodes pour faire cette simple addition : la <strong>relocation</strong> et le <strong>position indépendant code</strong>.</p><h2 id="r-relocation-2" data-claire-element-id="549053">Relocation</h2><p id="r-549052" data-claire-element-id="549052">Avec la relocation, c'est très simple : lorsque l'on démarre un programme, chaque adresse statique présente dans le code de notre programme est remplacée par sa valeur adéquate. L'addition se fait donc au lancement du programme et pas lors de son exécution.</p><h2 id="r-position-independant-code" data-claire-element-id="549071">Position indépendant code</h2><p id="r-549054" data-claire-element-id="549054">Le <em>position indépendant code</em> consiste à ne pas modifier les adresses au lancement du programme, mais seulement au moment où on doit la manipuler. Il existe deux façon d'implémenter cette méthode, qui dépend fortement du jeu d'instruction du processeur utilisé.</p><h3 id="r-processeurs-sans-jeu-d-instruction-approprie" data-claire-element-id="549057">Processeurs sans jeu d'instruction approprié</h3><p id="r-549055" data-claire-element-id="549055">Sur ces processeurs, il faut conserver l'adresse à laquelle démarre notre programme en mémoire dans un registre. Vous aurez surement remarqué que le <strong>registre de base</strong>, mentionné plus haut fait parfaitement l'affaire. Avec cette méthode, on peut même se contenter d'utiliser un registre limite : on est certain que l'adresse du programme est supérieure au registre de base. Mais le fait est que certains processeurs n'incorporent pas de registre de base spécialisé, et que dans de nombreux cas, on doit utiliser un registre du processeur, qui aurait pu servir à autre chose.</p><p id="r-549056" data-claire-element-id="549056">Pour information, le système d'exploitation Linux utilise la technique du <em>position indépendant code</em>.</p><h3 id="r-self-relative-adressing-instruction-set" data-claire-element-id="549070">Self relative Adressing Instruction Set</h3><p id="r-549058" data-claire-element-id="549058">Il existe des processeurs permettant d'implémenter du <em>position indépendant code</em> en se passant de registre contenant l'adresse de base du programme en cours d’exécution. Ceux-ci supportent des modes d'adressages particuliers.</p><div id="r-549060" data-claire-element-id="549060" data-claire-semantic="question"><p id="r-549059" data-claire-element-id="549059">Holà manant, qu'est-ce donc que cette diablerie de mode d'adressage ?</p></div><p id="r-549061" data-claire-element-id="549061">C'est simplement la méthode utilisée par une instruction de notre processeur pour localiser les données que l'instruction machine doit manipuler. Ce mode d'adressage est une sorte de recette de cuisine capable de dire où se trouve la ou les données nécessaires pour exécuter une instruction. Certains modes d'adressage permettent de calculer directement l'adresse mémoire de la donnée voulue.</p><p id="r-549062" data-claire-element-id="549062">Dans le cas vu plus haut, on calculait cette adresse à partir d'une adresse statique (souvent constante) et du contenu d'un registre, ce qui définissait un mode d'adressage. Les processeurs qui se passent du contenu de ce registre supplémentaire pour exécuter du <em>position independent code</em> possèdent un mode d'adressage particulier : <strong>l'adressage relatif</strong>.</p><p id="r-549063" data-claire-element-id="549063">Ce mode d'adressage relatif permet de localiser une instruction ou une donnée par rapport à l'adresse de l'instruction en cours d’exécution. Pour rappel, l'adresse de l'instruction en cours d’exécution est toujours localisée dans un registre spécial du processeur, nommé le registre d'adresse d'instruction, aussi appelé <em>Program counter</em>. L'adresse mémoire à laquelle on veut lire/écrire est calculée en additionnant un <strong>offset</strong>, un décalage à l'adresse contenue dans le <em>Program counter</em>. Ainsi, au lieu de dire directement notre donnée/instruction est placée à l'adresse 0xFA9D12A3, ce mode d'adressage relatif nous permettra de dire que la donnée/instruction voulue est placée après l'adresse de l'instruction en cours d’exécution dans la mémoire, 50 instructions plus loin.</p><p id="r-549064" data-claire-element-id="549064">Avec ce mode d'adressage, les adresses mémoires sont calculées à l’exécution sans aucune perte de performances : ce calcul est fait en même temps qu'on exécute l'instruction machine qui a besoin de l'adresse mémoire calculée (les circuits du processeurs sont conçus pour), alors que sans ce mode d'adressage, on devrait calculer cette adresse en utilisant des instructions ou des registres supplémentaires. Plus besoin d'utiliser des adresses statiques &quot;codées en dur&quot; dans le code et de faire la conversion comme avec la relocation, et plus besoin d'utiliser un registre pour garder l'adresse de base du programme si l'on fait du <em>position independent code</em>.</p><p id="r-549065" data-claire-element-id="549065">Pour ceux qui veulent approfondir le sujet, voici quelques liens :</p><p id="r-549066" data-claire-element-id="549066"><a href="http://www.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf">Dynamic memory allocation : a survey and critical review</a></p><p id="r-549067" data-claire-element-id="549067">Et voilà, ce tutoriel est maintenant terminé.</p><p id="r-549068" data-claire-element-id="549068">Maintenant, vous savez à peu prêt ce qu'est un système d'exploitation et comment celui-ci fonctionne.</p><p id="r-549069" data-claire-element-id="549069">Je tiens à remercier particulièrement lucas-84, qui a participé au premier jet de ce tutoriel, pour son travail. Je vous invite d'ailleurs à aller lire son tutoriel sur <a href="http://www.siteduzero.com/tutoriel-3-385544-la-programmation-systeme-en-c-sous-unix.html">la programmation système en C sous Unix</a>, qui fera un bon complément à ce tutoriel théorique.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation">Les systèmes d&#039;exploitation</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Programmes systèmes vs programmes applicatifs
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/mecanismes-d-abstraction-des-peripheriques">Mécanismes d&#039;abstraction des périphériques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/programmes-systemes-et-applicatifs">
Programmes systèmes et applicatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/rappel-sur-les-interruptions-1">
Rappel sur les interruptions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/noyau-d-un-os">Noyau d&#039;un OS</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/notre-memoire-tourne-en-rond">
Notre mémoire tourne en rond !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/principaux-types-de-noyaux">
Principaux types de noyaux
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Si on utilisait plusieurs programmes ?
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/ordonnancement">Ordonnancement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/c-est-quoi-3">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/algorithmes-d-ordonnancement">
Algorithmes d&#039;ordonnancement
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads-1">Processus et threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/processus-et-threads">
Processus et threads
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/sections-critiques">
Sections critiques
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Gestion de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-et-protection-memoire-avancee">Allocation et protection mémoire avancée</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/systemes-mono-programmes">
Systémes mono-programmés
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/partitions-memoires-fixes">
Partitions mémoires fixes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
Allocation dynamique
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/adressage-memoire-quelques-subtilites">
Adressage mémoire : quelques subtilités
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-systemes-d-exploitation/allocation-dynamique-4">
<span class="arrow"></span>
<span class="next">Allocation dynamique</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/les-systemes-d-exploitation.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 06:51:09 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-systemes-d-exploitation.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:14:44 GMT -->
</html>
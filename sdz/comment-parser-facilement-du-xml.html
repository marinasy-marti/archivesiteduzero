<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/comment-parser-facilement-du-xml.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 11:22:48 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/comment-parser-facilement-du-xml.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:49:59 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Comment parser facilement du XML</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/comment-parser-facilement-du-xml.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Comment parser facilement du XML</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#CommentparserfacilementduXML">Comment parser facilement du XML</a><br/><a href="#Dfinitions">Définitions</a><br/><a href="#Lesbases">Les bases</a><br/><a href="#Programmezdansvosstylesheets">Programmez dans vos stylesheets !</a><br/><a href="#LeXPATH">Le XPATH</a><br/></div>
<a name="CommentparserfacilementduXML"></a><h2>Comment parser facilement du XML</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/definitions-6">
<span class="next">Définitions</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-341420" data-claire-element-id="341420">Bonjour à tous.<br/> Vous venez d'apprendre le XML, et vous ne savez pas à quoi ça va bien pouvoir vous servir ? Ou vous voulez une méthode simple pour lire un fichier XML comme si il s'agissait d'un fichier XHTML ?<br/> Eh bien vous êtes au bon endroit !<br/> Nous allons apprendre à « transformer » du XML très facilement.<br/> En avant !</p>
</div><a name="Dfinitions"></a><h2>Définitions</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/les-bases-10">
<span class="next">Les bases</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-341421" data-claire-element-id="341421">Dans cette rubrique, nous allons aborder la théorie, et LA technique utilisée pour parser simplement du XML.</p><h2 id="r-le-xml-2" data-claire-element-id="341423">Le XML</h2><p id="r-341422" data-claire-element-id="341422">Je ne vais pas parler du XML, considérant que vous avez déjà lu et compris <a href="http://www.siteduzero.com/tutoriel-3-33440-le-point-sur-xml.html">ce tuto</a> et <a href="http://www.siteduzero.com/tutoriel-3-34847-le-xml.html">celui-ci</a> (au moins la première partie).</p><h2 id="r-la-technique-1" data-claire-element-id="341432">La technique</h2><p id="r-341424" data-claire-element-id="341424">Nous allons utiliser un fichier pour parser (= transformer en un autre fichier) notre fichier XML. Oui, c'est vrai, ça peut paraître un peu bizarre de transformer un fichier en un autre fichier par un fichier... o_O</p><p id="r-341425" data-claire-element-id="341425">Ce fichier sera écrit dans un langage que vous devriez bien connaître, puisqu'il s'agit du... XML. :-° En effet, ce langage nommé « <em>stylesheet</em> » (« feuille de style » en anglais), ou XSLT (<em>eXtensible Stylesheet Language Transformation</em>) est totalement basé sur le XML.</p><p id="r-341426" data-claire-element-id="341426">Le XSLT est un langage définit par le W3C et qui sert tout spécialement à la transformation de fichiers XML en... d'autres fichiers XML... Or, comme certains langages que vous devez connaître (comme le xHTML par exemple) sont eux aussi basés sur le XML...</p><p id="r-341427" data-claire-element-id="341427">Pour « jumeler » la feuille de style avec un document XML, on place le code suivant juste après la toute première ligne XML :</p><pre id="r-341428" data-claire-element-id="341428"><code data-claire-semantic="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;&lt;!--Première ligne XML--&gt;
&lt;?xml-stylesheet type='text/xsl' href='nomStylesheet.xsl'?&gt;&lt;!--Ligne de jumelage--&gt;
&lt;!--Code--&gt;</code></pre><p id="r-341429" data-claire-element-id="341429">Ici, le fichier XML sera couplé avec le fichier « nomStylesheet.xsl ».</p><aside id="r-341431" data-claire-element-id="341431" data-claire-semantic="information"><p id="r-341430" data-claire-element-id="341430">Les <em>stylesheets</em> ont leur extension en .xsl, pensez-y lorsque vous enregistrerez votre fichier !</p></aside><h2 id="r-quelques-informations-supplementaires-1" data-claire-element-id="341434">Quelques informations supplémentaires</h2><p id="r-341433" data-claire-element-id="341433">Vous serez plus loin appelés à manier les signes « &lt; » et « &gt; ». Or, ceux-ci sont déjà utilisés pour les balises. Veillez donc à les remplacer par « &amp;lt; » pour « &lt; » (<em>Lower Than</em> ; plus petit que), et « &amp;gt; » pour « &gt; » (<em>Greater Than</em> ; plus grand que).<br/> Ainsi, un « &lt;= » se transforme en « &amp;lt;= ». Pensez-y : c'est la source de beaucoup d'erreurs !</p><h2 id="r-pour-ceux-qui-sont-decus" data-claire-element-id="341436">Pour ceux qui sont déçus</h2><p id="r-341435" data-claire-element-id="341435">Oui, je n'utilise pas le PHP. Mais il y a un tuto <a href="http://www.siteduzero.com/tutoriel-3-34939-dom-parser-du-xml---l-exemple-du-zcode.html">écrit justement pour ça</a>.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml">Comment parser facilement du XML</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/definitions-6">
Définitions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/les-bases-10">
Les bases
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/programmez-dans-vos-stylesheets">
Programmez dans vos stylesheets !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/le-xpath">
Le XPATH
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/les-bases-10">
<span class="next">Les bases</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesbases"></a><h2>Les bases</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/definitions-6">
<span class="arrow"></span>
<span class="next">Définitions</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/programmez-dans-vos-stylesheets">
<span class="next">Programmez dans vos stylesheets !</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-341438" data-claire-element-id="341438">Comme tout langage, il y a des bases. Autant vous dire qu'elles ne sont pas très difficiles. Sachez que nous utiliseront un <a href="http://www.siteduzero.com/tutoriel-3-33440-le-point-sur-xml.html#ss_part_5"><em>namespace</em></a> nommé « xsl ».</p><h2 id="r-le-code-de-base-2" data-claire-element-id="341445">Le code de base</h2><p id="r-341439" data-claire-element-id="341439">Il y a un code de base sans lequel le fichier ne servirait strictement à rien :</p><pre id="r-341440" data-claire-element-id="341440"><code data-claire-semantic="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!--Vous devez connaître :)--&gt;
&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;
    &lt;!--Vous vous en doutez : on mettra le code ici--&gt;
&lt;/xsl:stylesheet&gt;</code></pre><p id="r-341441" data-claire-element-id="341441">Analysons tout ça...<br/> D'abord, la balise XML que vous devez connaître.<br/> Ensuite, une balise XML qui permet de dire qu'il s'agit de XSLT (avec sa version) et de faire un lien vers le site W3C par lequel passera notre document pour être transformé.</p><p id="r-341442" data-claire-element-id="341442">Allons un peu plus loin : en effet, si vous compilez même avec une <em>stylesheet</em> correcte un fichier XML... ça ne marchera pas. Pourquoi ? Parce qu'on n'a pas défini les sorties !</p><pre id="r-341443" data-claire-element-id="341443"><code data-claire-semantic="xml">&lt;xsl:output 
  method=&quot;html&quot;
  encoding=&quot;ISO-8859-1&quot;
  doctype-public=&quot;-//W3C//DTD XHTML//EN&quot;
  doctype-system=&quot;http://www.w3.org/TR/2001/REC-xhtml11-20010531&quot;
  indent=&quot;yes&quot; /&gt;</code></pre><p id="r-341444" data-claire-element-id="341444">Je ne vais bien sûr pas détailler tous les paramètres. Sachez simplement que « <em>method</em> » est l'attribut de la méthode de transformation. Ici, c'est « html », mais cette valeur peut vouloir dire aussi « XHTML ». Vous pouvez tout mettre tant que vous connaissez <a href="http://www.w3.org/TR/">le <em>doctype</em> correspondant</a> (le lien de l'attribut 'doctype-system'). « <em>encoding</em> », c'est le type de caractère. Enfin, « <em>indent</em> » dit si les indentations du XHTML doivent être respectées (pour les paragraphes, les listes, etc.).</p><h2 id="r-les-balises-en-elles-memes" data-claire-element-id="341489">Les balises en elles-mêmes</h2><p id="r-341446" data-claire-element-id="341446">Bon, nous y voilà...<br/> Commençons par ce que je juge être l'essentiel :</p><pre id="r-341447" data-claire-element-id="341447"><code data-claire-semantic="xml">&lt;xsl:template match=&quot;nom_balise&quot;&gt;
    &lt;!--Ici on mettra le code qui remplacera la balise et son contenu--&gt;
&lt;/xsl:template&gt;</code></pre><p id="r-341448" data-claire-element-id="341448">Cette ci s'activera à chaque fois que, dans la lecture du fichier XML, le fichier rencontrera la balise &lt;nom_balise&gt;&lt;/nom_balise&gt;ou &lt;nom_balise /&gt;. À ce moment, le fichier va écrire dans le fichier de sortir le code qu'il y a entre les balises (en l'interprétant bien-sûr :) ).</p><div id="r-341450" data-claire-element-id="341450" data-claire-semantic="question"><p id="r-341449" data-claire-element-id="341449">Mais si je veux récupérer le contenu des attributs et balises ?</p></div><p id="r-341451" data-claire-element-id="341451">Petits impatients : :D La suite arrive !<br/> C'est vrai qu'avec ce code, le <em>parser</em> ne se pose pas de question : il remplace, un point c'est tout. Cependant, nous pouvons faire en sorte d'écrire le texte des attributs et du contenu de la balise :</p><pre id="r-341452" data-claire-element-id="341452"><code data-claire-semantic="xml">&lt;xsl:value-of select=&quot;truc&quot; /&gt;
&lt;!--Ne vous amusez pas à écrire ça si vous n'avez pas lu la suite !!!--&gt;</code></pre><p id="r-341453" data-claire-element-id="341453">Là il y a un truc (hahem :-° ). Entre les guillemets, il faut mettre une requête XPATH. Nous verrons ça en détail plus loin, en attendant voici quelques requêtes simples :</p><ul id="r-341458" data-claire-element-id="341458"><li id="r-341455" data-claire-element-id="341455"><p id="r-341454" data-claire-element-id="341454"><code>select=&quot;.&quot;</code> : récupère le contenu de la balise en cours de <em>parsage</em></p></li><li id="r-341457" data-claire-element-id="341457"><p id="r-341456" data-claire-element-id="341456"><code>select=&quot;@attribut&quot;</code> : récupère la valeur de l'attribut nommé « attribut ».</p></li></ul><p id="r-341459" data-claire-element-id="341459">Enfin, il nous reste une dernière balise à aborder dans cette partie :</p><pre id="r-341460" data-claire-element-id="341460"><code data-claire-semantic="xml">&lt;xsl:apply-templates select=&quot;nom_balise2&quot; /&gt;</code></pre><p id="r-341461" data-claire-element-id="341461">Cette balise permet d'appeler le <em>parsage</em> d'une autre balise, la balise &lt;nom_balise2&gt;&lt;/nom_balise2&gt; (ou &lt;nom_balise2 /&gt;), tant que cette balise est fille de la balise en cours de <em>parsage</em>. Sachez que vous devez mettre là aussi une requête XPATH. Pour appeler le <em>parsage</em> de toutes les balises filles, mettez simplement <code>select=&quot;*&quot;</code>.</p><aside id="r-341463" data-claire-element-id="341463" data-claire-semantic="information"><p id="r-341462" data-claire-element-id="341462">En fait, à chaque fois que dans une balise XSLT vous voyez l'attribut « &lt;italique&gt;select&lt;/itlaique&gt; », c'est que vous devez mettre une requête XPATH.</p></aside><p id="r-341464" data-claire-element-id="341464">Bon, un petit exemple ?</p><p id="r-341465" data-claire-element-id="341465">Le XML à <em>parser</em> :</p><pre id="r-341466" data-claire-element-id="341466"><code data-claire-semantic="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;
&lt;?xml-stylesheet type='text/xsl' href='parser.xsl'?&gt;
&lt;A&gt;
    &lt;B&gt;aaa&lt;/B&gt;
    &lt;C&gt;
        &lt;D att=&quot;1&quot;/&gt;
        &lt;D att=&quot;2&quot;/&gt;
    &lt;/C&gt;
    &lt;B&gt;bbb&lt;/B&gt;
&lt;/A&gt;</code></pre><p id="r-341467" data-claire-element-id="341467">et sa <em>stylesheet</em> :</p><pre id="r-341468" data-claire-element-id="341468"><code data-claire-semantic="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;

&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;

&lt;xsl:output 
  method=&quot;html&quot;
  encoding=&quot;ISO-8859-1&quot;
  doctype-public=&quot;-//W3C//DTD XHTML//EN&quot;
  doctype-system=&quot;http://www.w3.org/TR/2001/REC-xhtml11-20010531&quot;
  indent=&quot;yes&quot; /&gt;

&lt;xsl:template match=&quot;A&quot;&gt;
    &lt;html&gt;&lt;body&gt;
    	&lt;xsl:apply-templates select=&quot;*&quot; /&gt;
    &lt;/body&gt;&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;B&quot;&gt;
	&lt;xsl:value-of select=&quot;.&quot; /&gt;&lt;br /&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;C&quot;&gt;
	&lt;xsl:apply-templates select=&quot;D&quot; /&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;D&quot;&gt;
	&lt;xsl:value-of select=&quot;@att&quot; /&gt;&lt;br /&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</code></pre><p id="r-341469" data-claire-element-id="341469">Ici, la <em>stylesheet</em> est nommée « parser.xsl ».<br/> Vous remarquerez que j'ai mis des balises XHTML dans la <em>stylesheet</em>. On a tout à fait le droit ! C'est quand même notre premier but de transformer du XML en XHTML...</p><p id="r-341470" data-claire-element-id="341470">J'espère que vous avez tout reconnu !</p><aside id="r-341472" data-claire-element-id="341472" data-claire-semantic="information"><p id="r-341471" data-claire-element-id="341471">Pour lancer un document XML comme s'il s'agissait d'une page XHTML, il suffit de double-cliquer sur l'icone de votre document XML. Si le lien est bien fait, vous n'aurez aucun problème, sauf peut-être des erreurs dans votre code, qui seront alors indiquées à la place du document.</p></aside><p id="r-341473" data-claire-element-id="341473">Bon, un petit exercice... :diable:</p><p id="r-341474" data-claire-element-id="341474">Voilà mon code :</p><pre id="r-341475" data-claire-element-id="341475"><code data-claire-semantic="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;
&lt;!--Ici, la ligne de jumelage. Je vous laisse la faire--&gt;
&lt;tirelire nom=&quot;Ma tirelire&quot;&gt;
    &lt;billet5 nombre=&quot;10&quot;&gt;Allemandes&lt;/billet5&gt;
    &lt;billet10 nombre=&quot;5&quot;&gt;Autrichiennes&lt;/billet10&gt;
    &lt;piece2 nombre=&quot;12&quot;&gt;Françaises&lt;/piece2&gt;
    &lt;piece2 nombre=&quot;4&quot;&gt;Espagnoles&lt;/piece2&gt;
    &lt;cent50 nombre=&quot;6&quot;&gt;Italiennes&lt;/cent50&gt;
&lt;/tirelire&gt;</code></pre><p id="r-341476" data-claire-element-id="341476">Je veux que vous obteniez cela :</p><p id="r-341477" data-claire-element-id="341477"><cite>Citation : Ce que vous devez obtenir (ne tenez pas compte de la police, elle est automatique)</cite></p><blockquote id="r-341479" data-claire-element-id="341479"><p id="r-341478" data-claire-element-id="341478">Tirelire : Ma tirelire<br/> Billets de 5 euros : nombre = 10, nationalité = Allemandes<br/> Billets de 10 euros : nombre = 5, nationalité = Autrichiennes<br/> Pièces de 2 euros : nombre = 12, nationalité = Françaises<br/> Pièces de 2 euros : nombre = 4, nationalité = Espagnoles<br/> Pièces de 50 cents : nombre = 6, nationalité = Italiennes</p></blockquote><p id="r-341480" data-claire-element-id="341480">Et pas de tricherie ! Je veux un code qui <em>parse</em> quand même si on change le XML !!! :colere2:</p><p id="r-341481" data-claire-element-id="341481">Au travail !</p><p id="r-341482" data-claire-element-id="341482">...</p><p id="r-341483" data-claire-element-id="341483">...</p><p id="r-341484" data-claire-element-id="341484">C'est bon ? Voilà la correction :</p><p id="r-341485" data-claire-element-id="341485"></p><div id="r-341487" data-claire-element-id="341487"><pre id="r-341486" data-claire-element-id="341486"><code data-claire-semantic="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;

&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;

&lt;xsl:output 
  method=&quot;html&quot;
  encoding=&quot;ISO-8859-1&quot;
  doctype-public=&quot;-//W3C//DTD XHTML//EN&quot;
  doctype-system=&quot;http://www.w3.org/TR/2001/REC-xhtml11-20010531&quot;
  indent=&quot;yes&quot; /&gt;

&lt;xsl:template match=&quot;tirelire&quot;&gt;
	&lt;html&gt;&lt;body&gt;Tirelire : &lt;xsl:value-of select=&quot;@nom&quot; /&gt;&lt;br /&gt;
	&lt;xsl:apply-templates select=&quot;*&quot; /&gt;&lt;br /&gt;
	&lt;/body&gt;&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;billet10&quot;&gt;
	Billets de 10 euros : nombre = &lt;xsl:value-of select=&quot;@nombre&quot; /&gt;, nationalité = &lt;xsl:value-of select=&quot;.&quot; /&gt;&lt;br /&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;billet5&quot;&gt;
	Billets de 5 euros : nombre = &lt;xsl:value-of select=&quot;@nombre&quot; /&gt;, nationalité = &lt;xsl:value-of select=&quot;.&quot; /&gt;&lt;br /&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;piece2&quot;&gt;
	Pièces de 2 euros : nombre = &lt;xsl:value-of select=&quot;@nombre&quot; /&gt;, nationalité = &lt;xsl:value-of select=&quot;.&quot; /&gt;&lt;br /&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=&quot;cent50&quot;&gt;
	Pièces de 50 cents : nombre = &lt;xsl:value-of select=&quot;@nombre&quot; /&gt;, nationalité = &lt;xsl:value-of select=&quot;.&quot; /&gt;&lt;br /&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</code></pre></div><p id="r-341488" data-claire-element-id="341488">Il faut avouer qu'il était simple, mais répétitif. Attention cependant, ce n'est pas la seule solution qui existe !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml">Comment parser facilement du XML</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/definitions-6">
Définitions
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/les-bases-10">
Les bases
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/programmez-dans-vos-stylesheets">
Programmez dans vos stylesheets !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/le-xpath">
Le XPATH
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/definitions-6">
<span class="arrow"></span>
<span class="next">Définitions</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/programmez-dans-vos-stylesheets">
<span class="next">Programmez dans vos stylesheets !</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Programmezdansvosstylesheets"></a><h2>Programmez dans vos stylesheets !</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/les-bases-10">
<span class="arrow"></span>
<span class="next">Les bases</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/le-xpath">
<span class="next">Le XPATH</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-341491" data-claire-element-id="341491">Cette partie n'est pas vraiment indispensable, mais je vous la recommande vivement ! En effet, il est possible de programmer dans vos <em>stylesheets</em>... Allons-y ! ^^</p><h2 id="r-la-structure-if-et-choose" data-claire-element-id="341517">La structure if et choose</h2><p id="r-341492" data-claire-element-id="341492">Il existe dans ce langage des structures conditionnelles : <em>if</em> et <em>choose</em>. Ne vous méprenez pas, il n'y a pas de <em>else</em>...</p><h3 id="r-la-structure-if-1" data-claire-element-id="341510">La structure if</h3><p id="r-341493" data-claire-element-id="341493">Voici d'emblée le code :</p><pre id="r-341494" data-claire-element-id="341494"><code data-claire-semantic="xml">&lt;xsl:if test=&quot;a == b&quot;&gt;
    &lt;!--Le code--&gt;
&lt;/xsl:if&gt;</code></pre><p id="r-341495" data-claire-element-id="341495"><em>If</em> (= « si » en anglais) permet de tester une opération. Ici, il s'agit de « a=b ». Les opérations booléennes sont les mêmes que pour n'importe quel langage de programmation :</p><ul id="r-341508" data-claire-element-id="341508"><li id="r-341497" data-claire-element-id="341497"><p id="r-341496" data-claire-element-id="341496">'&lt;' pour « si ... inférieur à ... ».</p></li><li id="r-341499" data-claire-element-id="341499"><p id="r-341498" data-claire-element-id="341498">'&gt;' pour l'inverse.</p></li><li id="r-341501" data-claire-element-id="341501"><p id="r-341500" data-claire-element-id="341500">'&lt;=' pour « ... inférieur ou égal ... ».</p></li><li id="r-341503" data-claire-element-id="341503"><p id="r-341502" data-claire-element-id="341502">'&gt;=' pour « ... supérieur ou égal ... ».</p></li><li id="r-341505" data-claire-element-id="341505"><p id="r-341504" data-claire-element-id="341504">'==' pour « ... égal ... » (attention il y a deux signes « égal »).</p></li><li id="r-341507" data-claire-element-id="341507"><p id="r-341506" data-claire-element-id="341506">'!=' pour « ... différent de ... ».</p></li></ul><p id="r-341509" data-claire-element-id="341509">Cette structure est pratique, si on utilise une fonction pour la canaliser. On apprendra ça plus tard.</p><h3 id="r-la-structure-choose" data-claire-element-id="341516">La structure choose</h3><p id="r-341511" data-claire-element-id="341511">Étant donné que le « <em>else</em> » (sinon) n'existe pas dans la structure <em>if</em>, une autre structure a été développée. Il s'agit d'une structure où il existe des « cas » selon la valeur d'entrée :</p><pre id="r-341512" data-claire-element-id="341512"><code data-claire-semantic="xml">&lt;xsl:choose&gt;
    &lt;xsl:when test=&quot;test = a&quot;&gt;
        &lt;!--Code--&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test=&quot;test = b&quot;&gt;
        &lt;!--Code--&gt;
    &lt;/xsl:when&gt;
             ...
&lt;/xsl:choose&gt;</code></pre><p id="r-341513" data-claire-element-id="341513">Ici, le code ne sert à rien. Il est encore une fois préférable de l'utiliser dans une fonction.</p><p id="r-341514" data-claire-element-id="341514">Notez qu'il existe une condition nulle, c'est-à-dire appelée si aucun des cas ne correspond à la valeur d'entrée. Cette balise est :</p><pre id="r-341515" data-claire-element-id="341515"><code data-claire-semantic="xml">&lt;xsl:otherwise&gt;
    &lt;!--Code--&gt;
&lt;/xsl:otherwise&gt;</code></pre><h2 id="r-les-fonctions-20" data-claire-element-id="341537">Les fonctions</h2><p id="r-341518" data-claire-element-id="341518">Enfin les voilà !<br/> Vous allez voir, c'est très simple. Pour déclarer une fonction, on utilise cette balise :</p><pre id="r-341519" data-claire-element-id="341519"><code data-claire-semantic="xml">&lt;xsl:template name=&quot;nomFonction&quot;&gt;
    &lt;!--Le code de votre fonction--&gt;
&lt;/xsl:template&gt;</code></pre><p id="r-341520" data-claire-element-id="341520">Alors, ça ne vous rappelle rien ?<br/> Et pour l'appeler, on utilise celle-là :</p><pre id="r-341521" data-claire-element-id="341521"><code data-claire-semantic="xml">&lt;xsl:call-template name=&quot;nomFonction&quot; /&gt;</code></pre><p id="r-341522" data-claire-element-id="341522">Dans les deux cas, « nomFonction » désigne le nom de votre fonction (vous pouvez le changer si vous le voulez). Je pense que ça paraît logique, mais il faut <strong>toujours</strong> déclarer une fonction avant de l'appeler.</p><aside id="r-341524" data-claire-element-id="341524" data-claire-semantic="error"><p id="r-341523" data-claire-element-id="341523">Faites attention : <em>call-template</em> n'est pas pareil que <em>apply-templates</em>, ne vous trompez pas ou vous aurez de graves erreurs !</p></aside><p id="r-341525" data-claire-element-id="341525">Bon ben on a fini, salut.</p><div id="r-341527" data-claire-element-id="341527" data-claire-semantic="question"><p id="r-341526" data-claire-element-id="341526">Eh attends ! Où sont les paramètres ?</p></div><p id="r-341528" data-claire-element-id="341528">Il vous faut toujours quelque chose !<br/> Bon allez... Je suis sympa.<br/> Il suffit juste de modifier un peu le code de la fonction :</p><pre id="r-341529" data-claire-element-id="341529"><code data-claire-semantic="xml">&lt;xsl:template name=&quot;nomFonction&quot;&gt;
   &lt;xsl:param name=&quot;parametre&quot; select=&quot;0&quot; /&gt;
&lt;/xsl:template&gt;</code></pre><p id="r-341530" data-claire-element-id="341530">Et pour l'appeller :</p><pre id="r-341531" data-claire-element-id="341531"><code data-claire-semantic="xml">&lt;xsl:call-template name=&quot;NomFonction&quot;&gt;
    &lt;xsl:with-param name=&quot;parametre&quot; select=&quot;375&quot; /&gt;
&lt;/xsl:call-template&gt;</code></pre><p id="r-341532" data-claire-element-id="341532">Pour utiliser une variable dans une fonction, on inscrit (dans une chaîne de caractères) le symbole « $ » juste devant le nom de la variable, comme cela :</p><pre id="r-341533" data-claire-element-id="341533"><code data-claire-semantic="xml">&lt;xsl:template name=&quot;afficherVariale&quot;&gt;
    &lt;xsl:param name=&quot;variable&quot; /&gt;

    &lt;xsl:if test=&quot;$variable &lt; 25&quot;&gt;
        &lt;xsl:value-of select=&quot;$variable&quot; /&gt;&lt;!--On a le droit de faire ça !--&gt;
    &lt;/xsl:if&gt;
&lt;/xsl:template&gt;</code></pre><p id="r-341534" data-claire-element-id="341534">Et voilà le travail ! :magicien: En plus ça vous montre comment utiliser « xsl:if » dans une fonction. Une précision toutefois, la balise « xsl:with-param » peut s'écrire de deux façons :</p><pre id="r-341535" data-claire-element-id="341535"><code data-claire-semantic="xml">&lt;xsl:with-param name=&quot;parametre&quot; select=&quot;123&quot; /&gt;
&lt;!--Ou alors--&gt;
&lt;xsl:with-param name=&quot;parametre&quot;&gt;123&lt;/xsl:with-param&gt;</code></pre><p id="r-341536" data-claire-element-id="341536">C'est toujours pratique si on veut mettre un « &lt;xsl:value-of /&gt; » entre les balises !</p><h2 id="r-la-balise-for-each" data-claire-element-id="341539">La balise <em>for-each</em></h2><p id="r-341538" data-claire-element-id="341538">Cette balise est un peu spéciale... Il s'agit d'une boucle, mais ça n'en est pas vraiment une. En fait, cette balise va appeler le <em>parsage</em> de toutes les balises présentes dans la requête de l'attribut du <em>for-each</em>...<br/> Ouais je sais : c'est difficile à avaler. Le plus dur, c'est cette histoire de requête XPATH... on verra ça plus loin...</p><h2 id="r-conclusion-31" data-claire-element-id="341541">Conclusion</h2><p id="r-341540" data-claire-element-id="341540">Il faut garder à l'esprit qu'il existe sûrement d'autres balises dans le XSLT. Je vous ai présenté celles que je juge être les plus importantes. Abordons un point plus difficile maintenant : le XPATH.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml">Comment parser facilement du XML</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/definitions-6">
Définitions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/les-bases-10">
Les bases
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/programmez-dans-vos-stylesheets">
Programmez dans vos stylesheets !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/le-xpath">
Le XPATH
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/les-bases-10">
<span class="arrow"></span>
<span class="next">Les bases</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/le-xpath">
<span class="next">Le XPATH</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="LeXPATH"></a><h2>Le XPATH</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/programmez-dans-vos-stylesheets">
<span class="arrow"></span>
<span class="next">Programmez dans vos stylesheets !</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-341543" data-claire-element-id="341543">Le XPATH n'est pas <em>vraiment</em> un langage. C'est juste une manière d'écrire pour accéder aux divers n%u0153uds d'un arbre XML. Tout d'abord, un arbre est un document XML, dans le sens où il y a des balises mères et des balises filles. On peut donc construire un arbre avec toutes ces balises. Dans ce code :</p><pre id="r-341544" data-claire-element-id="341544"><code data-claire-semantic="xml">&lt;AAA&gt;
    &lt;BBB&gt;&lt;/BBB&gt;
    &lt;CCC&gt;&lt;/CCC&gt;
    &lt;BBB&gt;
        &lt;HHH att=&quot;1&quot; /&gt;
        &lt;HHH att=&quot;2&quot; /&gt;
        &lt;HHH fromage=&quot;guda&quot; /&gt;
        &lt;HHH /&gt;
        &lt;HHH /&gt;
    &lt;/BBB&gt;
    &lt;BCC&gt;
        &lt;BCD&gt;
            &lt;CDB /&gt;
        &lt;/BCD&gt;
    &lt;/BCC&gt;
    &lt;DDD&gt;
        &lt;EEE /&gt;
        &lt;FFF /&gt;
        &lt;EFG /&gt;
    &lt;/DDD&gt;
    &lt;GGG&gt;
        &lt;BBB&gt;&lt;/BBB&gt;
    &lt;/GGG&gt;
    &lt;III&gt;
        &lt;JJJ nom=&quot;jjj&quot; /&gt;
        &lt;JJJ nom=&quot; jjj&quot; /&gt;
    &lt;/III&gt;
&lt;/AAA&gt;</code></pre><p id="r-341545" data-claire-element-id="341545">Si on part de la balise BCC :</p><ul id="r-341556" data-claire-element-id="341556"><li id="r-341547" data-claire-element-id="341547"><p id="r-341546" data-claire-element-id="341546">On peut dire que BCC est un enfant.</p></li><li id="r-341549" data-claire-element-id="341549"><p id="r-341548" data-claire-element-id="341548">On peut dire que BCC possède deux descendants : BCD et CBD, mais il ne possède qu'un enfant : BCD.</p></li><li id="r-341551" data-claire-element-id="341551"><p id="r-341550" data-claire-element-id="341550">On peut dire que BCC est parent de BCD.</p></li><li id="r-341553" data-claire-element-id="341553"><p id="r-341552" data-claire-element-id="341552">On peut dire que BCC possède un ancêtre : AAA.</p></li><li id="r-341555" data-claire-element-id="341555"><p id="r-341554" data-claire-element-id="341554">On peut dire que BCC a 6 frères : BBB, CCC, BBB, DDD, GGG et III.</p></li></ul><p id="r-341557" data-claire-element-id="341557">Et grâce au XPATH, on peut se déplacer de balise en balise à l'aide de ces notions.<br/> C'est ce code que j'utiliserai durant tout le reste de cette sous-partie.</p><aside id="r-341559" data-claire-element-id="341559" data-claire-semantic="warning"><p id="r-341558" data-claire-element-id="341558">Faites attention, le code XPATH se rapporte toujours à la balise en cours de <em>parsage</em> !</p></aside><h2 id="r-les-requetes-1" data-claire-element-id="341589">Les requêtes</h2><p id="r-341560" data-claire-element-id="341560">Le XPATH, comme le SQL, utilise la notion de requêtes : on demande quelque chose.<br/> Les voici :</p><h3 id="r-la-syntaxe-de-base" data-claire-element-id="341569">La syntaxe de base</h3><p id="r-341561" data-claire-element-id="341561">On peut apparenter le XPATH aux chemins de fichiers comme C:\Blable\Blibli\...<br/> Ainsi, la syntaxe /nomBalise correspond à la balise nommée « nomBalise » qui se trouve être mère mais pas fille. Dans le fichier XML ci-dessus, si on fait /AAA, alors une sorte de curseur (virtuel bien sûr) va se positionner dans la balise AAA. S'il y a plusieurs balises du même nom, il y aura plusieurs curseurs, chacun traité dans l'ordre.</p><aside id="r-341563" data-claire-element-id="341563" data-claire-semantic="error"><p id="r-341562" data-claire-element-id="341562">Attention : dans les chemins de fichiers, on utilise l'antislash : \. Ici, seul le slash : / est autorisé !</p></aside><p id="r-341564" data-claire-element-id="341564">À partir de là, on peut accéder à des sous-balises simplement comme avec /AAA/CCC, qui placera le curseur dans la balise CCC qui se trouve dans la balise AAA. On peut continuer ainsi de balise en sous-balise...</p><aside id="r-341566" data-claire-element-id="341566" data-claire-semantic="information"><p id="r-341565" data-claire-element-id="341565">Si il y a un <em>slash</em> avant le AAA, c'est pour commencer de la racine, c'est-à-dire le document qui « héberge » l'arbre.</p></aside><aside id="r-341568" data-claire-element-id="341568" data-claire-semantic="warning"><p id="r-341567" data-claire-element-id="341567">Cela signifie que s'il y a une balise CCC dans une balise BBB, elle ne sera pas prise en compte !</p></aside><h3 id="r-tous-les-elements-d-un-type" data-claire-element-id="341572">Tous les éléments d'un type</h3><p id="r-341570" data-claire-element-id="341570">Avec le double <em>slash</em> (//), toute balise du nom suivi seront prises en compte : mère comme fille. Donc si je fais //BBB, toutes les balises « BBB » seront prises en compte, que ce soit dans la balise AAA, ou dans les autres balises.</p><p id="r-341571" data-claire-element-id="341571">Donc avec //DDD/EEE, toutes les balises EEE filles de DDD seront sélectionnées.</p><h3 id="r-l-asterisque" data-claire-element-id="341576">L'astérisque</h3><p id="r-341573" data-claire-element-id="341573">L'astérisque (*) après un chemin désigne toutes les balises se trouvant après le début du chemin. Si je fais /AAA/DDD/*, alors les balises EEE, FFF et EFG seront prises en compte.</p><p id="r-341574" data-claire-element-id="341574">Et ça marche dans l'autre sens !<br/> Avec ce code : /*/*/EEE, je sélectionne toutes les balises s'appelant EEE et qui ont deux ancêtres (mère et grand-mère) ! Cela veut dire qu'une balise EEE qui a un ou trois ou plus d'ancêtres ne sera pas prises en compte.</p><p id="r-341575" data-claire-element-id="341575">Encore une astuce : //*, si on est logique, ce code sélectionne toutes les balises !</p><h3 id="r-les-crochets" data-claire-element-id="341579">Les crochets</h3><p id="r-341577" data-claire-element-id="341577">Une expression suivie d'un numéro entre crochets désigne l'énième élément d'une balise. Ainsi, l'élément /AAA/BBB/HHH[1] sera la première balise HHH dans une balise BBB, elle-même dans une balise AAA.</p><p id="r-341578" data-claire-element-id="341578">Notez que /AAA[last()] sélectionne le dernier élément nommé AAA.</p><h3 id="r-arobase" data-claire-element-id="341586">Arobase</h3><p id="r-341580" data-claire-element-id="341580">L'arobase (@) désigne un attribut d'une balise ou d'un document en général. Si je fais //@att, alors tous les attributs nommés « att » seront sélectionnés. Si je veux toutes les balises possédant un attribut nommé « att », il suffit de mettre l'arobase et le nom de l'attribut entre crochets : /AAA/HHH[@att], ce code va sélectionner toutes les balises HHH possédant un attribut nommé « att ».</p><p id="r-341581" data-claire-element-id="341581">Si on suit la logique, //HHH[@*] désigne toutes les balises HHH possédant un attribut. Et encore une astuce : //HHH[not(@*)] désigne toutes les balises ne possédant pas d'attribut.</p><p id="r-341582" data-claire-element-id="341582">On peut sélectionner encore plus durement : en indiquant que l'on ne considère que les balises HHH possédant un attribut fromage égal à « guda » comme ici : //HHH[@fromage='guda'].</p><aside id="r-341584" data-claire-element-id="341584" data-claire-semantic="information"><p id="r-341583" data-claire-element-id="341583">Notez ici que l'on utilise des <em>quotes</em> et non des guillemets !</p></aside><p id="r-341585" data-claire-element-id="341585">Il y a bien sûr un problème : si je fais //JJJ[@nom='jjj'], alors seule la balise &lt;JJJ nom=&quot;jjj&quot; /&gt; sera sélectionnée mais pas l'autre !<br/> Une seule fonction dans ce cas : la fonction « <em>normalize-space</em> » : elle va enlever les espaces avant et après la valeur de l'attribut, et va confondre les espaces consécutives : //JJJ[normalize-space(@nom)='jjj'], ce code sélectionne toutes les balises JJJ possédant un attribut « nom » qui contient « jjj » une fois qu'on lui a enlevé les espaces avant et après (si toutefois il y en a).</p><h3 id="r-combinons-des-chemins" data-claire-element-id="341588">Combinons des chemins</h3><p id="r-341587" data-claire-element-id="341587">Avec la barre (|), on peut combiner des chemins :<br/>//CCC|//BBB, ce code sélectionne toutes les balises nommées BBB ou CCC. Et vous pouvez mettre autant de barres que vous voulez, avec des dizaines de chemins différents !</p><h2 id="r-quelques-fonctions" data-claire-element-id="341597">Quelques fonctions</h2><p id="r-341590" data-claire-element-id="341590">Nous avons vu précédemment des fonctions comme « not() » ou « normalize-space() ». En voilà quelques autres pour affiner vos requêtes.</p><h3 id="r-la-fonction-count" data-claire-element-id="341592">La fonction count()</h3><p id="r-341591" data-claire-element-id="341591">Pour ceux qui ne le sauraient pas, « <em>count</em> » veut dire « compte » en anglais. Cette fonction compte le nombre de balises qui ont l'enfant mis en paramètre, et le nombre d'enfant(s) mis après le symbole « égal » :<br/>//*[count(JJJ)=1], ce code va sélectionner toutes les balises ayant un seul et unique enfant JJJ.<br/>//*[count(*)=5], ce code va sélectionner toutes les balises ayant 5 enfants.</p><h3 id="r-la-fonction-name" data-claire-element-id="341594">La fonction name()</h3><p id="r-341593" data-claire-element-id="341593">Voilà une fonction intéressante : cette fonction va sélectionner toutes les balise du nom passé en paramètre et les balises enfantes du chemin :<br/>//*[name()='GGG'], ce code va sélectionner toutes les balises GGG.<br/> Plus fort : //*[start-with(name(), 'B')], ce code va sélectionner toutes les balises dont le nom commence par un B.<br/> Encore plus fort : //*[contains(name(), 'G')], ce code sélectionne toutes les balises dont le nom contient un G.</p><h3 id="r-la-fonction-string-length" data-claire-element-id="341596">La fonction string-length()</h3><p id="r-341595" data-claire-element-id="341595">Cette fonction va sélectionner des balises avec des nombres de caractères.<br/>//*[string-length(name())=3], ce code sélectionne toutes les balises dont le nom comporte 3 caractères.<br/> Vous pouvez utiliser inférieur à (&lt;) et supérieur à (&gt;), mais en respectant les normes W3C.</p><h2 id="r-les-axes" data-claire-element-id="341614">Les &quot;axes&quot;</h2><p id="r-341598" data-claire-element-id="341598">En XPATH, il existe des « axes ». Il s'agit en fait d'une sorte de sélection de balises qui repose uniquement sur la notion d'enfants, d'ancêtres, de descendants, etc.</p><p id="r-341599" data-claire-element-id="341599">On marque un axe comme ceci :<br/>//AAA/ancestor::CCC, où « <em>ancestor</em> » est le nom d'un axe.</p><h3 id="r-l-axe-descendant" data-claire-element-id="341601">L'axe « <em>descendant</em> »</h3><p id="r-341600" data-claire-element-id="341600">L'axe « <em>descendant</em> » sélectionne tous les descendants de la balise précédente du chemin. Si je fais /AAA/descendant::*, alors je sélectionne tous les éléments descendants de AAA. Si je fais /AAA/descendant::BBB, alors je sélectionne tous les éléments descendants de AAA, et nommés BBB.</p><h3 id="r-l-axe-parent" data-claire-element-id="341603">L'axe « <em>parent</em> »</h3><p id="r-341602" data-claire-element-id="341602">L'axe « <em>parent</em> » sélectionne les parents directs de la balise précédente du chemin, si toutefois il y en a un. Si je fais //BBB/parent::*, alors je sélectionne tous les parents directs de BBB, comme AAA, et GGG. Si je fais //BBB/parent::GGG, alors je sélectionne tous les parents de BBB nommés GGG.</p><h3 id="r-l-axe-ancestor" data-claire-element-id="341605">L'axe « <em>ancestor</em> »</h3><p id="r-341604" data-claire-element-id="341604">L'axe « <em>ancestor</em> » sélectionne tous les éléments ancêtres de la balise précédente dans le chemin. Si je fais //BCD/ancestor::*, alors toutes les balises ancêtres de BCD seront sélectionnées, comme BCC et AAA. Je ne vous explique pas ce qui se passe si on indique une balise à la place de l'astérisque (pour rappel, la signification de l'astérisque, qui est aussi valable ici, est détaillée plus haut ;) )...</p><h3 id="r-les-axes-following-et-preceding" data-claire-element-id="341608">Les axes « <em>following</em> » et « <em>preceding</em> »</h3><p id="r-341606" data-claire-element-id="341606">L'axe « <em>following</em> » sélectionne tous les éléments suivant la balise précédente dans le chemin, sauf les éléments descendants de celle-ci. Si je fais /AAA/DDD/following::*, alors tous les éléments situés après l'élément DDD seront sélectionnés, sauf les descendants de DDD.</p><p id="r-341607" data-claire-element-id="341607">L'axe « <em>preceding</em> », quant à lui, sélectionne tous les éléments précédant la balise précédente dans le chemin, sauf les éléments descendants de celle-ci. Si je fais /AAA/DDD/preceding::*, alors tous les éléments situés avant l'élément DDD seront sélectionnés, sauf les descendants de DDD.</p><h3 id="r-les-axes-following-sibling-et-preceding-sibling" data-claire-element-id="341611">Les axes « <em>following-sibling</em> » et « <em>preceding-sibling</em> »</h3><p id="r-341609" data-claire-element-id="341609">L'axe « <em>following-sibling</em> » sélectionne tous les éléments frères suivant la balise précédente dans le chemin. Si je fais /AAA/BCC/following-sibling::*, alors je ne sélectionne que les balises DDD, GGG, et III.</p><p id="r-341610" data-claire-element-id="341610">L'axe « <em>preceding-sibling</em> », quant à lui, sélectionne tous les éléments frères précédant la balise précédente dans le chemin. Si je fais /AAA/BCC/preceding-sibling::*, alors je ne sélectionne que les balises BBB, CCC et un autre élément BBB.</p><h3 id="r-l-axe-self" data-claire-element-id="341613">L'axe « <em>self</em> »</h3><p id="r-341612" data-claire-element-id="341612">L'axe « <em>self</em> » sélectionne tous les éléments du même nom que celui de la balise précédente dans le chemin. Si je fais /AAA/BBB/self::*, alors tous les éléments nommés BBB seront sélectionnés.</p><h2 id="r-quelques-precisions-1" data-claire-element-id="341616">Quelques précisions</h2><p id="r-341615" data-claire-element-id="341615">Le XPATH n'est peut-être pas un langage, cela n'en fait pas une branche facile du XML. Retenez les termes utilisés pour un arbre, comme ancêtre, enfant, fille, etc.<br/> Gardez à l'esprit que l'on peut mettre un nom de balise à la place de l'astérisque, et que cela signifie que les éléments sélectionnés porteront tous le nom de la balise en question.</p><h2 id="r-comment-utiliser-tout-ca" data-claire-element-id="341626">Comment utiliser tout ça...</h2><p id="r-341617" data-claire-element-id="341617">Un exemple vaut mieux qu'un laïus, alors :</p><pre id="r-341618" data-claire-element-id="341618"><code data-claire-semantic="xml">&lt;AAA&gt;
    &lt;BBB&gt;&lt;/BBB&gt;
    &lt;CCC&gt;&lt;/CCC&gt;
    &lt;BBB&gt;
        &lt;HHH att=&quot;1&quot; /&gt;
        &lt;HHH att=&quot;2&quot; /&gt;
        &lt;HHH fromage=&quot;guda&quot; /&gt;
        &lt;HHH /&gt;
        &lt;HHH /&gt;
    &lt;/BBB&gt;
    &lt;BCC&gt;
        &lt;BCD&gt;
            &lt;CDB /&gt;
        &lt;/BCD&gt;
    &lt;/BCC&gt;
    &lt;DDD&gt;
        &lt;EEE /&gt;
        &lt;FFF /&gt;
        &lt;EFG /&gt;
    &lt;/DDD&gt;
    &lt;GGG&gt;
        &lt;BBB&gt;&lt;/BBB&gt;
    &lt;/GGG&gt;
    &lt;III&gt;
        &lt;JJJ nom=&quot;jjj&quot; /&gt;
        &lt;JJJ nom=&quot; jjj&quot; /&gt;
    &lt;/III&gt;
&lt;/AAA&gt;</code></pre><p id="r-341619" data-claire-element-id="341619">Oui je sais : je suis très original...</p><p id="r-341620" data-claire-element-id="341620">Imaginons que je veuille <em>parser</em> seulement les balises JJJ avec un attribut « nom » dont la valeur est « jjj », sans compter les espaces, et filles de III lorsque je rencontre la balise AAA :</p><pre id="r-341621" data-claire-element-id="341621"><code data-claire-semantic="xml">&lt;xsl:template match=&quot;AAA&quot;&gt;
    &lt;xsl:for-each select=&quot;//III/JJJ[normalize-space(@nom)='jjj']&quot;&gt;
        &lt;em&gt;Attribut : &lt;/em&gt;&lt;xsl:value-of select=&quot;@nom&quot; /&gt;
    &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</code></pre><div id="r-341623" data-claire-element-id="341623" data-claire-semantic="question"><p id="r-341622" data-claire-element-id="341622">Mais t'as pas parlé du point !</p></div><p id="r-341624" data-claire-element-id="341624">C'est vrai. Mais vous savez à quoi il sert. Donc pourquoi rabâcher ce que je vous ai déjà dit. Vous êtes des Zéros, certes, mais des Zéros intelligents (enfin j'espère ! ^^ ) !</p><p id="r-341625" data-claire-element-id="341625">Et voilà ! :magicien: <br/> Vous êtes devenus (presque) maîtres dans l'art de la <em>stylesheet</em>. Alors à vos marques, prêts, <em>parsez</em> !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml">Comment parser facilement du XML</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/definitions-6">
Définitions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/les-bases-10">
Les bases
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/programmez-dans-vos-stylesheets">
Programmez dans vos stylesheets !
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/le-xpath">
Le XPATH
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/comment-parser-facilement-du-xml/programmez-dans-vos-stylesheets">
<span class="arrow"></span>
<span class="next">Programmez dans vos stylesheets !</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/comment-parser-facilement-du-xml.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 11:22:48 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/comment-parser-facilement-du-xml.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:49:59 GMT -->
</html>
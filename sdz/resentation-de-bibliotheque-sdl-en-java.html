<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/resentation-de-bibliotheque-sdl-en-java.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 09:00:48 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/resentation-de-bibliotheque-sdl-en-java.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:36:37 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Présentation de bibliothèque SDL en Java</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Présentation de bibliothèque SDL en Java</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#PrsentationdebibliothqueSDLenJava">Présentation de bibliothèque SDL en Java</a><br/><a href="#Lesbasesdesdljava">Les bases de sdljava</a><br/><a href="#Notionsintermdiaires">Notions intermédiaires</a><br/><a href="#Annexes">Annexes</a><br/></div>
<a name="PrsentationdebibliothqueSDLenJava"></a><h2>Présentation de bibliothèque SDL en Java</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/les-bases-de-sdljava">
<span class="next">Les bases de sdljava</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-338656" data-claire-element-id="338656">Bonjour à tous,</p><p id="r-338657" data-claire-element-id="338657">Aujourd'hui nous allons découvrir et utiliser la librairie <a href="http://sdljava.sourceforge.net/"><em>sdljava</em></a>. Comme vous devez le savoir, la librairie SDL (« lib SDL » pour les intimes ;) ) est principalement utilisée pour créer des jeux vidéos en 2D voire en 3D si on l'utilise avec OpenGL. Pour être capable de suivre ce tutoriel, il est recommandé de connaître suffisamment Java, c'est-à-dire :</p><ul id="r-338667" data-claire-element-id="338668"><li id="r-338659" data-claire-element-id="338659"><p id="r-338658" data-claire-element-id="338658">gestion d'un projet ;</p></li><img id="r-338660" data-claire-element-id="338660" src="medias/uploads.siteduzero.com_files_127001_128000_127738.gif" alt="Image utilisateur"/><li id="r-338662" data-claire-element-id="338662"><p id="r-338661" data-claire-element-id="338661">gestion des exceptions ;</p></li><li id="r-338664" data-claire-element-id="338664"><p id="r-338663" data-claire-element-id="338663">transtypage (<em>cast</em>) ;</p></li><li id="r-338666" data-claire-element-id="338666"><p id="r-338665" data-claire-element-id="338665">approche objet.</p></li></ul><p id="r-338669" data-claire-element-id="338669">La lecture du tutoriel <a href="http://www.siteduzero.com/tuto-3-2000-0-programmation-en-java.html">« Programmation en Java »</a> est donc vivement conseillée. Je ne vous en dis pas plus, c'est parti !<br/> La lecture du tutoriel <a href="http://www.siteduzero.com/tuto-3-8-0-apprenez-a-programmer-en-c.html#part_1544">« Apprenez à programmer en C », partie III</a><strong>peut</strong> être un plus.</p>
</div><a name="Lesbasesdesdljava"></a><h2>Les bases de sdljava</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/notions-intermediaires">
<span class="next">Notions intermédiaires</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-338670" data-claire-element-id="338670">Dans cette partie, nous verrons les principes fondamentaux pour utiliser la SDL avec Java. J'utiliserai l'EDI Eclipse pour l'installation et la configuration du projet, ce n'est pas très différent avec les autres EDI, mais je n'en parlerai pas. L'installation sera vraiment pas à pas, ainsi, les personnes n'ayant jamais travaillé avec des librairies externes ne seront pas perdues :) .</p><aside id="r-338672" data-claire-element-id="338672" data-claire-semantic="warning"><p id="r-338671" data-claire-element-id="338671">Utilisateurs de systèmes 64 bits : vous devez avoir une machine virtuelle Java 32 bits, ainsi que les différents fichiers (.dll ou .a) en version 32 bits, sinon ça ne fonctionnera pas correctement. En effet <em>sdljava</em> est compilée pour les système 32 bits.</p></aside><h2 id="r-installation-et-preparation-du-projet" data-claire-element-id="338688">Installation et préparation du projet</h2><p id="r-338673" data-claire-element-id="338673">Voici la première étape de l'utilisation de <strong>sdljava</strong> : l'installation et la configuration. Mais avant cela, j'ai des choses à vous dire concernant cette bibliothèque car comme toutes les bibliothèques elle a des avantages, mais aussi des inconvénients. Je ne suis pas là pour vous les donner, mais je vous dirai ce que vous pourrez faire et ce que vous ne pourrez pas faire.</p><p id="r-338674" data-claire-element-id="338674">Pour installer cette bibliothèque, vous aurez besoin :</p><ul id="r-338683" data-claire-element-id="338683"><li id="r-338676" data-claire-element-id="338676"><p id="r-338675" data-claire-element-id="338675">d'un <a href="http://java.sun.com/javase/downloads/index.jsp">JDK</a> 1.4 (minimum) ;</p></li><li id="r-338678" data-claire-element-id="338678"><p id="r-338677" data-claire-element-id="338677">de l'EDI<a href="http://www.eclipse.org/downloads/">Eclipse</a> ;</p></li><li id="r-338680" data-claire-element-id="338680"><p id="r-338679" data-claire-element-id="338679">ou de l'EDI<a href="http://netbeans.org/downloads/index.html">Netbeans</a> ;</p></li><li id="r-338682" data-claire-element-id="338682"><p id="r-338681" data-claire-element-id="338681">de la <a href="http://www.libsdl.org/">bibliothèque SDL</a> version C (Linux ou Windows).</p></li></ul><aside id="r-338685" data-claire-element-id="338685" data-claire-semantic="warning"><p id="r-338684" data-claire-element-id="338684">Si vous utilisez une JVM 64 bit, vous pourrez rencontrer des problèmes ; je vous encourage donc à utiliser une JVM 32 bit. Que vous utilisiez un système 64 bits Linux ou Windows, l'installation d'une JVM en 32 bits reste possible à moins que vous soyez sur un système entièrement en 64 bits qui ne prend pas en charge l'exécution de code 32 bits.</p></aside><p id="r-338686" data-claire-element-id="338686">C'est tout. :) Allez, on y va !</p><h3 id="r-le-binding-sdljava" data-claire-element-id="338687">Le binding sdljava</h3><h2 id="r-binding" data-claire-element-id="338695">Binding ?</h2><p id="r-338689" data-claire-element-id="338689">Nous allons bientôt commencer l'installation, mais avant je voudrais vous parler de cette bibliothèque.<br/> Comme vous le savez la <em>librairy</em> SDL est, à l'origine, programmée en langage C puis est compilée pour fonctionner avec ce dernier (et avec le C++). C'est là qu'intervient le mot <strong>binding</strong>. Un <em>binding</em>, c'est, en gros, un portage de bibliothèque d'un langage A vers un langage B. Dans <em>binding</em>, vous avez <em>bind</em> qui signifie en anglais &quot;lier&quot; ; c'est donc une liaison. C'est d'ailleurs pour cela qu'on aura besoin des fichiers libSDLmain.a ou SDL.dll de la bibliothèque standard C pour faire fonctionner notre application.</p><p id="r-338690" data-claire-element-id="338690"><cite>Citation : Wikipedia</cite></p><blockquote id="r-338694" data-claire-element-id="338694"><p id="r-338691" data-claire-element-id="338691">Un binding (qui est un terme anglais désignant l'action de lier des éléments entre eux) signifie en informatique le fait de permettre l'utilisation d'une bibliothèque logicielle dans un autre langage de programmation que celui avec lequel elle a été écrite.</p><p id="r-338692" data-claire-element-id="338692">Nombre de bibliothèques sont écrites dans des langages proches de la machine comme le C ou le C++. Pour utiliser ces bibliothèques dans un langage de plus haut niveau, il est donc nécessaire de réaliser un binding.</p><p id="r-338693" data-claire-element-id="338693">La conception d'un binding peut être motivée par le fait de profiter des performances offertes par l'utilisation d'un langage bas niveau que l'on ne peut obtenir avec un langage de plus haut niveau. La réutilisation de code éprouvé peut également être une autre source de motivation.</p></blockquote><h2 id="r-contenu-de-sdljava" data-claire-element-id="338706">Contenu de sdljava</h2><p id="r-338696" data-claire-element-id="338696">La <em>librairy</em> sdljava contient tous les éléments de la bibliothèque originale SDL (c'est déjà pas mal :p ), mais contient aussi des extensions. En voici quelques-unes :</p><ul id="r-338705" data-claire-element-id="338705"><li id="r-338698" data-claire-element-id="338698"><p id="r-338697" data-claire-element-id="338697">SDL_image : permettra de manipuler plusieurs formats d'image ;</p></li><li id="r-338700" data-claire-element-id="338700"><p id="r-338699" data-claire-element-id="338699">SDL_mixer : permettra d'ajouter du son et de la musique dans nos applications ;</p></li><li id="r-338702" data-claire-element-id="338702"><p id="r-338701" data-claire-element-id="338701">SDL_ttf : permettra d'écrire dans notre fenêtre ;</p></li><li id="r-338704" data-claire-element-id="338704"><p id="r-338703" data-claire-element-id="338703">OpenGL : permettra d'utiliser l'accélération matérielle pour l'affichage.</p></li></ul><h2 id="r-ce-que-vous-devez-savoir-avant-de-commencer" data-claire-element-id="338716">Ce que vous devez savoir avant de commencer</h2><p id="r-338707" data-claire-element-id="338707">Cette bibliothèque :</p><ul id="r-338714" data-claire-element-id="338714"><li id="r-338709" data-claire-element-id="338709"><p id="r-338708" data-claire-element-id="338708">est un <em>binding</em>, c'est-à-dire que vous devrez distribuer les fichiers .a ou/et .dll avec votre application ;</p></li><li id="r-338711" data-claire-element-id="338711"><p id="r-338710" data-claire-element-id="338710">n'existe pas en binaire pour Mac OS X, et la compilation est assez complexe (je n'y suis pas arrivé) ;</p></li><li id="r-338713" data-claire-element-id="338713"><p id="r-338712" data-claire-element-id="338712">dont la version &quot;stable&quot; 0.9.1 date de 2005, et dont la version <em>cvs</em> n'a pas été modifiée depuis fin 2006.</p></li></ul><h3 id="r-preparation-de-l-installation-1" data-claire-element-id="338715">Préparation de l'installation</h3><h2 id="r-telechargement-de-sdljava" data-claire-element-id="338727">Téléchargement de sdljava</h2><p id="r-338717" data-claire-element-id="338717">Nous allons maintenant télécharger la bibliothèque pour l'utiliser avec Eclipse ou Netbeans. Vous avez deux solutions : soit vous téléchargez les binaires (donc déjà compilée), soit les sources (c'est à vous de compiler). Nous allons privilégier la première méthode si ça ne vous dérange pas. :) Rendez-vous sur <a href="http://sourceforge.net/project/showfiles.php?group_id=124821">la page de téléchargement</a> de sourceforge pour récupérer la version que vous voulez (Linux ou Windows).</p><ul id="r-338724" data-claire-element-id="338724"><li id="r-338719" data-claire-element-id="338719"><p id="r-338718" data-claire-element-id="338718"><a href="http://downloads.sourceforge.net/sdljava/sdljava-0.9.1-linux-2.6-bin.tar.gz?modtime=1109021226&amp;amp%3Bamp%3Bbig_mirror=0">Version Linux</a> ;</p></li><li id="r-338721" data-claire-element-id="338721"><p id="r-338720" data-claire-element-id="338720"><a href="http://downloads.sourceforge.net/sdljava/sdljava-0.9.1-win32-bin.zip?modtime=1109021067&amp;amp%3Bamp%3Bbig_mirror=0">Version Windows</a> ;</p></li><li id="r-338723" data-claire-element-id="338723"><p id="r-338722" data-claire-element-id="338722">Pour les suicidaires : <a href="http://sourceforge.net/project/downloading.php?group_id=124821&amp;amp%3Bamp%3Buse_mirror=kent&amp;amp%3Bamp%3Bfilename=sdljava-0.9.1-src.zip&amp;amp%3Bamp%3B29964127">les sources</a>. :-°</p></li></ul><p id="r-338725" data-claire-element-id="338725">Bien sûr, nous utilisons un binding, donc comme je vous l'ai expliqué nous devons aussi avoir les fichiers libSDLmain.a ou SDL.dll de SDL version C pour utiliser sdljava.<br/> En avant pour le site officiel de <a href="http://www.libsdl.org/">SDL</a> !</p><p id="r-338726" data-claire-element-id="338726">Nous n'avons pas besoin de prendre les versions de développement, contrairement au <a href="http://www.siteduzero.com/tuto-3-8-0-apprenez-a-programmer-en-c.html#part_1544">tutoriel de M@teo21</a> sur le SDL en langage C ; les <em>runtime library</em> feront l'affaire. :) Je tiens à préciser pour les utilisateurs de Linux que le site ne propose que des paquets RPM : suivant votre distribution, il faudra donc rechercher le fichier SDL correspondant. L'idéal serait une compilation de la bibliothèque et c'est ce que nous allons voir tout de suite. Les utilisateurs de Windows peuvent passer cette étape.</p><h2 id="r-recuperation-du-fichier-libsdlmain-a-sous-linux" data-claire-element-id="338750">Récupération du fichier libSDLmain.a sous Linux</h2><p id="r-338728" data-claire-element-id="338728">La récupération de libSDLmain.a peut se faire de différentes manières. Par exemple, si vous avez déjà SDL d'installé sur votre machine, vous devriez pouvoir retrouver ce fichier. Mais ici, pour que tout le monde soit sur un même pied d'égalité, nous compilerons les sources de SDL puis nous récupérerons notre fichier libSDLmain.a (tout ça pour un fichier, mais ça en vaut la peine :) ).</p><aside id="r-338730" data-claire-element-id="338730" data-claire-semantic="warning"><p id="r-338729" data-claire-element-id="338729">Assurez-vous d'avoir installé les outils de développement.</p></aside><p id="r-338731" data-claire-element-id="338731">Normalement, si vous avez déjà libsdl installé sur votre machine, vous devriez trouver libSDLmain.a dans <code data-claire-semantic="bash">/usr/lib </code>.</p><aside id="r-338733" data-claire-element-id="338733" data-claire-semantic="information"><p id="r-338732" data-claire-element-id="338732">Si vous avez déjà SDL installé mais que vous ne trouvez pas le fichier, vous pouvez suivre ce qui suit, jusqu'à la récupération du fichier. L'installation ne sera pas obligatoire pour vous.</p></aside><ul id="r-338741" data-claire-element-id="338741"><li id="r-338735" data-claire-element-id="338735"><p id="r-338734" data-claire-element-id="338734">Téléchargez les sources de SDL <a href="http://www.libsdl.org/release/SDL-1.2.13.tar.gz">ici</a>.</p></li><li id="r-338737" data-claire-element-id="338737"><p id="r-338736" data-claire-element-id="338736">Décompressez l'archive dans votre répertoire de travail par exemple.</p></li><li id="r-338740" data-claire-element-id="338740"><p id="r-338738" data-claire-element-id="338738">Ouvrez un terminal, entrez dans le répertoire nouvellement décompressé et tapez :</p><pre id="r-338739" data-claire-element-id="338739"><code data-claire-semantic="console">./configure
make</code></pre></li></ul><p id="r-338742" data-claire-element-id="338742">Vous avez votre bibliothèque compilée, mais pas installée. Vous pouvez déjà aller dans le répertoire build du répertoire SDL et vous y trouverez... un fichier nommé libSDLmain.a. :magicien:</p><p id="r-338743" data-claire-element-id="338743">Mettez-le de côté pour l'instant. Si vous avez déjà SDL installée, vous pouvez passer la prochaine étape. À partir de maintenant, vous n'avez plus qu'à vous mettre en super-utilisateur dans le terminal (commande <code data-claire-semantic="console">su</code> suivie de votre mot de passe ou <code data-claire-semantic="console">sudo</code> si vous êtes sous debian-like) et à taper <code data-claire-semantic="console">make install</code>.</p><p id="r-338744" data-claire-element-id="338744"><strong>Récapitulatif des commandes</strong></p><p id="r-338745" data-claire-element-id="338745">Pour distribution non debian-like (Slackware, Mandriva, Fedora, OpenSuse...) :</p><pre id="r-338746" data-claire-element-id="338746"><code data-claire-semantic="console">./configure
make
su # saisie du mot de passe
make install</code></pre><p id="r-338747" data-claire-element-id="338747">Pour distribution debian-like avec sudo (Debian, Ubuntu et dérivés...) :</p><pre id="r-338748" data-claire-element-id="338748"><code data-claire-semantic="console">./configure
make
sudo make install
# saisie du mot de passe</code></pre><p id="r-338749" data-claire-element-id="338749">Voilà ! SDL version C est installée sur votre système et nous avons notre fichier libSDLmain.a. :p On peut donc passer à la suite !</p><h2 id="r-le-fichier-sdl-dll-sous-windows" data-claire-element-id="338754">Le fichier SDL.dll sous Windows</h2><p id="r-338751" data-claire-element-id="338751">Rendez-vous <a href="http://www.libsdl.org/release/SDL-1.2.13-win32.zip">ici</a> et téléchargez l'archive, puis décompressez son contenu dans un dossier que vous mettrez de côté.</p><aside id="r-338753" data-claire-element-id="338753" data-claire-semantic="information"><p id="r-338752" data-claire-element-id="338752">Je n'ai pas donné de lien pour la version Mac Os X car comme je vous l'ai dit, je n'ai pas réussi à la compiler (les binaires n'existant pas &gt;_ ), mais si j'arrive à faire quelque chose le tutoriel sera actualisé. Si vous êtes sous Mac Os X et que cela vous intéresse, vous pouvez me contacter.</p></aside><h2 id="r-preparation-de-l-installation-2" data-claire-element-id="338765">Préparation de l'installation</h2><p id="r-338755" data-claire-element-id="338755">Bien qu'on ne puisse pas vraiment parler d'installation, car nous ferons uniquement de la copie, il y a des choses à faire dans l'ordre !<br/> Tout d'abord, vous allez décompresser l'archive de sdljava.</p><p id="r-338756" data-claire-element-id="338756">Vous pouvez constater qu'il y a plusieurs dossiers. Nous n'en utiliserons que deux, dont un obligatoire, et un vivement conseillé. Nous garderons donc les répertoires : lib et docs.</p><ul id="r-338761" data-claire-element-id="338761"><li id="r-338758" data-claire-element-id="338758"><p id="r-338757" data-claire-element-id="338757">lib : contient le jar de sdljava ainsi que les fichiers .so ou .dll qui lui sont propres ;</p></li><li id="r-338760" data-claire-element-id="338760"><p id="r-338759" data-claire-element-id="338759">docs : contient la javadoc de sdljava ; elle est réellement indispensable !</p></li></ul><p id="r-338762" data-claire-element-id="338762">Vous pouvez donc les mettre de côté avec le fichier libSDLmain.a / SDL.dll et passer à la dernière étape. :soleil:</p><h3 id="r-creation-du-projet-avec-eclipse" data-claire-element-id="338764">Création du projet avec Eclipse</h3><p id="r-338763" data-claire-element-id="338763">Nous allons maintenant créer notre projet sous Eclipse. L'avantage est qu'Eclipse est multi plates-formes donc en utilisant la même version sous Linux ou Windows, le résultat sera exactement le même. :)</p><h2 id="r-creation-du-projet-7" data-claire-element-id="338787">Création du projet</h2><p id="r-338766" data-claire-element-id="338766">Lancez Eclipse comme vous en avez pris l'habitude. Ensuite, créez un nouveau projet Java, puis un nouveau package et pour finir une nouvelle classe, qui contient une méthode <code>main</code> (n'oubliez pas de cocher la case public static void main(...). Pour notre exemple, j'ai créé un projet qui se nomme <em>TutorielJavaSDL</em>, puis un package que j'ai appelé <em>configuration</em> et enfin une classe <em>installation</em>.<br/> Nous allons maintenant installer la lib' sdljava. Pour cela, rien de plus simple, mais je vais vous faire un petit rappel sur l'architecture d'un projet avec Eclipse.</p><h3 id="r-les-projets-sous-eclipse" data-claire-element-id="338776">Les projets sous Eclipse</h3><p id="r-338767" data-claire-element-id="338767">Quand vous créez un nouveau projet, celui-ci est copié dans le <em>workspace</em> (espace de travail), ce dernier est placé par défaut dans <code>$HOME/workspace</code> sous Linux et <code>C:\Documents and Settings\(utilisateur)\workspace</code> sous Windows 2000/XP (<code>C:\Utilisateurs\(utilisateur)\workspace</code> sous Vista). Si vous consultez le <em>workspace</em>, vous constatez qu'il y a un répertoire par projet et que ces derniers se composent eux-même de répertoires (bin &amp;amp;amp; src).</p><p id="r-338768" data-claire-element-id="338768">En résumé dans le <em>workspace</em></p><p id="r-338769" data-claire-element-id="338769">Il y a un répertoire qui porte le nom de votre projet. Ce dernier en contient deux autres :</p><ul id="r-338774" data-claire-element-id="338774"><li id="r-338771" data-claire-element-id="338771"><p id="r-338770" data-claire-element-id="338770">bin : contient les fichiers compilés .class ;</p></li><li id="r-338773" data-claire-element-id="338773"><p id="r-338772" data-claire-element-id="338772">src : contient les fichiers sources .java ;</p></li></ul><p id="r-338775" data-claire-element-id="338775">Si on s'intéresse à un de ces répertoires, on constate qu'il contient encore un répertoire ! &gt;_ Ce sont les packages (par défaut il n'y en a pas) et enfin dans ce répertoire (package), il y a vos sources !</p><h3 id="r-les-conventions-de-nommage-pour-ce-tutoriel" data-claire-element-id="338786">Les conventions de nommage pour ce tutoriel</h3><aside id="r-338785" data-claire-element-id="338785" data-claire-semantic="information"><p id="r-338777" data-claire-element-id="338777">Je nommerai :</p><ul id="r-338784" data-claire-element-id="338784"><li id="r-338779" data-claire-element-id="338779"><p id="r-338778" data-claire-element-id="338778">Répertoire racine : le répertoire qui contient bin &amp;amp;amp; src ;</p></li><li id="r-338781" data-claire-element-id="338781"><p id="r-338780" data-claire-element-id="338780">Répertoire source : le répertoire qui contient vos sources, c'est-à-dire l'intérieur du package ;</p></li><li id="r-338783" data-claire-element-id="338783"><p id="r-338782" data-claire-element-id="338782">Même chose pour les binaires !</p></li></ul></aside><h2 id="r-installation-de-la-bibliotheque" data-claire-element-id="338792">Installation de la bibliothèque</h2><p id="r-338788" data-claire-element-id="338788">Cette partie est très simple : vous allez copier le dossier lib de sdljava à la racine de votre projet avec le fichier libSDLmain.a ou SDL.dll (selon votre OS). Votre racine doit ressembler à cela :</p><figure id="r-338790" data-claire-element-id="338791"><img id="r-338789" data-claire-element-id="338789" src="medias/uploads.siteduzero.com_files_127001_128000_127734.jpg" alt="Image utilisateur"/></figure><h2 id="r-configuration-d-eclipse" data-claire-element-id="338811">Configuration d'Eclipse</h2><p id="r-338793" data-claire-element-id="338793">Faites un clic-droit sur votre projet puis sélectionnez Properties (Propriétés). Une fenêtre s'affiche.</p><figure id="r-338795" data-claire-element-id="338796"><img id="r-338794" data-claire-element-id="338794" src="medias/uploads.siteduzero.com_files_127001_128000_127735.jpg" alt="Image utilisateur"/></figure><p id="r-338797" data-claire-element-id="338797">Sélectionnez Java Build Path : c'est dans cette partie que nous allons indiquer à Eclipse où est sdljava (car Eclipse ne peut pas le deviner tout seul). Cliquez sur Add External JARs.</p><figure id="r-338799" data-claire-element-id="338800"><img id="r-338798" data-claire-element-id="338798" src="medias/uploads.siteduzero.com_files_127001_128000_127736.jpg" alt="Image utilisateur"/></figure><p id="r-338801" data-claire-element-id="338801">Vous devez sélectionner le fichier sdljava.jar qui se situe dans le répertoire lib de votre projet. Validez, puis cliquez sur la petite flèche noire à gauche de sdljava.jar dans la liste (voir screen).</p><figure id="r-338803" data-claire-element-id="338804"><img id="r-338802" data-claire-element-id="338802" src="medias/uploads.siteduzero.com_files_127001_128000_127730.jpg" alt="Image utilisateur"/></figure><p id="r-338805" data-claire-element-id="338805">Cliquez deux fois sur Source attachement et choisissez l'option External File... : vous devez sélectionner encore une fois sdljava.jar (qui, je le rappelle, est présent dans le dossier lib de votre projet).<br/> Cliquez deux fois sur Native library location et choisissez l'option External Folder... : cette fois, vous devez indiquer dans quel répertoire se trouve sdljava ; c'est donc simple, il suffit d'indiquer le répertoire lib de votre projet.</p><p id="r-338806" data-claire-element-id="338806">Voilà ce que vous devez avoir après ces étapes :</p><figure id="r-338808" data-claire-element-id="338809"><img id="r-338807" data-claire-element-id="338807" src="medias/uploads.siteduzero.com_files_127001_128000_127732.jpg" alt="Image utilisateur"/></figure><p id="r-338810" data-claire-element-id="338810">L'installation est terminée ! Si, je vous assure. :) Nous allons exécuter un programme de test pour vérifier que tout fonctionne correctement. Si vous avez un souci avec le programme de test, recommencez l'installation : une chose vous a peut-être échappé.</p><h2 id="r-programme-de-test" data-claire-element-id="338816">Programme de test</h2><pre id="r-338812" data-claire-element-id="338812"><code data-claire-semantic="java">package configuration;

import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.*;

public class Installation {
	
	private SDLSurface screen = null;
	
	public Installation() throws SDLException, InterruptedException {
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		
		screen = SDLVideo.setVideoMode(640, 480, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;Ma première fenêtre avec sdljava&quot;, null);
		
		Thread.sleep(1000);
		screen.freeSurface();
		SDLMain.quit();
	}

	public static void main(String[] args) throws SDLException, InterruptedException {
		new Installation();
	}

}</code></pre><p id="r-338813" data-claire-element-id="338813">N'essayez pas de comprendre ce code pour l'instant. Vous devez simplement voir une fenêtre s'ouvrir, puis se refermer et c'est normal ! En tout cas, toutes mes félicitations : la sdljava est opérationnelle. :) On va pouvoir passer aux choses sérieuses (enfin, on va rester simple quand même).</p><p id="r-338814" data-claire-element-id="338814">Dans le prochain chapitre, nous verrons comment créer des fenêtres et comment utiliser les modes vidéo...</p><p id="r-338815" data-claire-element-id="338815">À tout de suite ! :)</p><h2 id="r-les-fenetres-et-les-modes-video" data-claire-element-id="338819">Les fenêtres et les modes vidéo</h2><p id="r-338817" data-claire-element-id="338817">Dans la vraie vie, quand vous parlez avec une personne vous commencez par lui dire &quot;bonjour&quot;, ensuite vous parlez avec elle et enfin vous lui dites &quot;au revoir&quot; puis vous partez. Eh bien avec <strong>SDL</strong> c'est le même principe ! Pour travailler avec, vous devez l'initialiser (lui dire &quot;bonjour&quot;), puis à partir de ce moment vous avez le droit de travailler (parler avec elle), et quand vous avez fini, vous la quittez (vous lui dites &quot;au revoir&quot;).</p><h3 id="r-initialisation-de-sdljava" data-claire-element-id="338818">Initialisation de sdljava</h3><h2 id="r-initialisation-7" data-claire-element-id="338846">Initialisation</h2><p id="r-338820" data-claire-element-id="338820">On commence par importer les classes dont nous aurons besoin pour travailler. Pour l'instant trois suffiront, mais vous verrez qu'on va vite en importer encore et encore. o_O</p><pre id="r-338821" data-claire-element-id="338821"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.video.SDLVideo;</code></pre><ul id="r-338828" data-claire-element-id="338828"><li id="r-338823" data-claire-element-id="338823"><p id="r-338822" data-claire-element-id="338822">La première va nous permettre de gérer les exceptions, car beaucoup de méthodes sont susceptibles de lever une exception !</p></li><li id="r-338825" data-claire-element-id="338825"><p id="r-338824" data-claire-element-id="338824">La deuxième va nous permettre d'initialiser SDL et ses composants, elle contient tout un paquet de constantes, ainsi que la méthode <code data-claire-semantic="java">init(constante) </code> ;</p></li><li id="r-338827" data-claire-element-id="338827"><p id="r-338826" data-claire-element-id="338826">La troisième nous permettra de créer une fenêtre (lui donner un titre, une icône, ...).</p></li></ul><p id="r-338829" data-claire-element-id="338829">Les imports faits, nous pouvons commencer. On initialise <strong>sdljava</strong> avec la méthode statique <code data-claire-semantic="java">SDLMain.init(constante) </code>. Cette méthode prend en paramètres une ou plusieurs constantes, qui nous serviront à activer certains modules comme la vidéo ou le son par exemple. Voici quelques constantes :</p><ul id="r-338840" data-claire-element-id="338840"><li id="r-338831" data-claire-element-id="338831"><p id="r-338830" data-claire-element-id="338830"><code data-claire-semantic="java">SDLMain.SDL_INIT_VIDEO </code> : initialise le mode vidéo ;</p></li><li id="r-338833" data-claire-element-id="338833"><p id="r-338832" data-claire-element-id="338832"><code data-claire-semantic="java">SDLMain.SDL_INIT_AUDIO </code> : initialise le son ;</p></li><li id="r-338835" data-claire-element-id="338835"><p id="r-338834" data-claire-element-id="338834"><code data-claire-semantic="java">SDLMain.SDL_INIT_JOYSTICK </code> : initialise la prise en charge du joystick ;</p></li><li id="r-338837" data-claire-element-id="338837"><p id="r-338836" data-claire-element-id="338836"><code data-claire-semantic="java">SDLMain.SDL_INIT_CDROM </code> : initialise la prise en charge des lecteurs CD/DVD ;</p></li><li id="r-338839" data-claire-element-id="338839"><p id="r-338838" data-claire-element-id="338838"><code data-claire-semantic="java">SDLMain.SDL_INIT_EVERYTHING </code> : remplace TOUTES les constantes.</p></li></ul><p id="r-338841" data-claire-element-id="338841">On pourra par exemple initialiser la vidéo et le son de cette manière :</p><pre id="r-338842" data-claire-element-id="338842"><code data-claire-semantic="java">SDLMain.init(SDLMain.SDL_INIT_VIDEO | SDL_INIT_AUDIO);</code></pre><p id="r-338843" data-claire-element-id="338843">Le symbole <strong>|</strong> aussi appelé &quot;pipe&quot; permet de faire la séparation entre les constantes. Vous pouvez l'utiliser plusieurs fois pour charger plusieurs composants ; bien sûr si vous n'avez qu'une chose à initialiser vous n'aurez pas besoin de ce symbole. Si vous avez besoin de travailler avec tout (CDROM, AUDIO, VIDEO, etc.) vous pouvez tout initialiser d'un coup avec <code data-claire-semantic="java">SDL_INIT_EVERYTHING </code>, ce qui donne :</p><pre id="r-338844" data-claire-element-id="338844"><code data-claire-semantic="java">SDLMain.init(SDLMain.SDL_INIT_EVERYTHING);</code></pre><p id="r-338845" data-claire-element-id="338845">Il y a encore d'autres constantes, et si cela vous intéresse (et je l'espère bien !), je vous invite à consulter la javadoc de sdljava (dossier <strong>doc</strong> vous vous souvenez ?).</p><h2 id="r-fermeture" data-claire-element-id="338850">Fermeture</h2><p id="r-338847" data-claire-element-id="338847">Nous allons nous intéresser à la fermeture (le &quot;au revoir&quot; si vous préférez). Pour quitter SDL, c'est très simple, vous n'avez qu'à utiliser la méthode statique <code data-claire-semantic="java">quit() </code> de la classe <code data-claire-semantic="java">SDLMain </code>.</p><pre id="r-338848" data-claire-element-id="338848"><code data-claire-semantic="java">SDLMain.quit();</code></pre><p id="r-338849" data-claire-element-id="338849">Ce code va libérer la mémoire et fermer SDL : vous ne pourrez donc plus travailler avec après cette étape.</p><h2 id="r-le-programme-final-1" data-claire-element-id="338856">Le programme final</h2><p id="r-338851" data-claire-element-id="338851">Avant de vous montrer le programme final, il faut que je vous dise que les méthodes de sdljava peuvent lever des exceptions. Nous ne les traiterons pas directement au début, mais ça viendra et j'espère que vous êtes bien au point là-dessus, sinon faites un tour <a href="http://www.siteduzero.com/tuto-3-11599-1-les-exceptions.html">ici</a>.</p><pre id="r-338852" data-claire-element-id="338852"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.video.SDLVideo;

public class ModeVideo {

	public static void main(String[] args) throws SDLException {
		
		// Initialisation de la SDL avec le mode video
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		
		// Notre futur code !
		
		
		// On quitte la SDL et on libère la mémoire
		SDLMain.quit();
	}

}</code></pre><p id="r-338853" data-claire-element-id="338853">Voilà qui est fait. :) Passons à la suite, je vois que vous en mourez d'envie.</p><h3 id="r-les-surfaces-introduction" data-claire-element-id="338855">Les surfaces : introduction</h3><p id="r-338854" data-claire-element-id="338854">Nous avons créé une fenêtre noire avec un titre. Ce n'est pas encore super, donc nous allons mettre un peu de couleurs. ^^ Et pour cela nous devons étudier les <code data-claire-semantic="java">SDLSurface </code> !</p><h2 id="r-les-surfaces-avec-sdl" data-claire-element-id="338880">Les surfaces avec SDL</h2><p id="r-338857" data-claire-element-id="338857">Une surface est une forme géométrique sur laquelle on dessine des choses... Votre écran est une surface, la fenêtre que vous venez de créer est une surface (une <code data-claire-semantic="java">SDLSurface </code> en réalité ^^ ). On peut donc conclure qu'une surface avec sdljava sera rectangulaire.</p><div id="r-338859" data-claire-element-id="338859" data-claire-semantic="question"><p id="r-338858" data-claire-element-id="338858">Elles vont nous servir à quoi tes <code data-claire-semantic="java">SDLSurface </code> ?</p></div><p id="r-338860" data-claire-element-id="338860">Pour faire simple, elle nous serviront à :</p><ul id="r-338867" data-claire-element-id="338867"><li id="r-338862" data-claire-element-id="338862"><p id="r-338861" data-claire-element-id="338861">afficher une fenêtre ;</p></li><li id="r-338864" data-claire-element-id="338864"><p id="r-338863" data-claire-element-id="338863">afficher une image ;</p></li><li id="r-338866" data-claire-element-id="338866"><p id="r-338865" data-claire-element-id="338865">afficher du texte.</p></li></ul><p id="r-338868" data-claire-element-id="338868">De plus, on pourra noter que chaque <code data-claire-semantic="java">SDLSurface </code> aura des propriétés qui lui seront propres, comme :</p><ul id="r-338879" data-claire-element-id="338879"><li id="r-338870" data-claire-element-id="338870"><p id="r-338869" data-claire-element-id="338869">la taille ;</p></li><li id="r-338872" data-claire-element-id="338872"><p id="r-338871" data-claire-element-id="338871">la position ;</p></li><li id="r-338874" data-claire-element-id="338874"><p id="r-338873" data-claire-element-id="338873">la couleur de fond ;</p></li><li id="r-338876" data-claire-element-id="338876"><p id="r-338875" data-claire-element-id="338875">la couleur de transparence (canal Alpha) ;</p></li><li id="r-338878" data-claire-element-id="338878"><p id="r-338877" data-claire-element-id="338877">et d'autres...</p></li></ul><h2 id="r-utilisation-d-une-sdlsurface" data-claire-element-id="338896">Utilisation d'une <code data-claire-semantic="java">SDLSurface</code></h2><p id="r-338881" data-claire-element-id="338881">On doit importer la classe <code data-claire-semantic="java">SDLSurface </code> qui est dans le package <code data-claire-semantic="java">sdljava.SDLVideo </code>, puis créer un nouvel objet de ce type comme ceci :</p><pre id="r-338882" data-claire-element-id="338882"><code data-claire-semantic="java">SDLSurface screen = null;</code></pre><p id="r-338883" data-claire-element-id="338883">J'ai volontairement nommé la surface <strong>screen</strong>, car nous allons l'utiliser pour l'affichage de la fenêtre. Ce que je ne vous avais pas dit, c'est que la méthode <code data-claire-semantic="java">SDLVideo.setVideoMode(...) </code> renvoie une SDLSurface, ce qui nous permet de travailler avec cette dernière par la suite (ajout de couleurs par exemple).</p><p id="r-338884" data-claire-element-id="338884">Voilà à quoi va ressembler notre nouveau code :</p><pre id="r-338885" data-claire-element-id="338885"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;

public class ModeVideo {

	public static void main(String[] args) throws SDLException, InterruptedException {
		
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		
		/*
		 * Initialisation du mode vidéo
		 * 1 - screen est une SDLSurface qui ne fait référence à rien
		 * 2 - screen est maintenant la SDLSurface principale de l'écran :p
		 *     - Elle contient les méthodes pour changer de couleur
		 *     - Elle contient toutes les méthodes d'affichage (flippe de l'écran par exemple)
		 * 3 - On change le titre de la fenêtre 
		 */
		SDLSurface screen = null;
		screen = SDLVideo.setVideoMode(400, 200, 32, SDLVideo.SDL_HWSURFACE | SDLVideo.SDL_DOUBLEBUF);
		SDLVideo.wmSetCaption(&quot;Ma deuxième fenêtre en java avec SDL&quot;, null);
		

		Thread.sleep(2000);
		SDLMain.quit();
	}

}</code></pre><p id="r-338886" data-claire-element-id="338886">Le code est suffisamment commenté, et il n'a rien de complexe.</p><ul id="r-338891" data-claire-element-id="338891"><li id="r-338888" data-claire-element-id="338888"><p id="r-338887" data-claire-element-id="338887">On commence par créer une <code data-claire-semantic="java">SDLSurface </code> que l'on initialise à <code data-claire-semantic="java">null </code> ;</p></li><li id="r-338890" data-claire-element-id="338890"><p id="r-338889" data-claire-element-id="338889">La surface <code data-claire-semantic="java">screen </code> fait maintenant référence à la surface de l'affichage principal.</p></li></ul><p id="r-338892" data-claire-element-id="338892">Vous pouvez aussi initialiser le mode vidéo comme ceci :</p><pre id="r-338893" data-claire-element-id="338893"><code data-claire-semantic="java">SDLSurface screen = SDLVideo.setVideoMode(320, 240, 32, SDLVideo.SDL_HWSURFACE | SDLVideo.SDL_DOUBLEBUF);</code></pre><p id="r-338894" data-claire-element-id="338894">Il nous reste un dernier point à aborder avant de nous amuser à colorier notre fenêtre : c'est la libération de la mémoire avec la méthode <code data-claire-semantic="java">freeSurface() </code>. En effet, lorsque vous avez fini d'utiliser une surface, il faut la détruire pour libérer la mémoire. Ici, c'est la surface qui correspond à la fenêtre principale. Vous me direz sûrement : &quot;oui, mais quand le programme arrive à l'instruction <code data-claire-semantic="java">SDLMain.quit() </code> la mémoire est libérée !&quot; ; eh bien c'est vrai, mais c'est une bonne habitude à prendre, surtout si vous travaillez avec une autre surface que celle de l'affichage. Nous n'avons qu'à rajouter <code data-claire-semantic="java">screen.freeSurface() </code> juste avant <code data-claire-semantic="java">SDLMain.quit() </code> et le tour est joué. ^^</p><p id="r-338895" data-claire-element-id="338895">Maintenant que ce point est éclairci, nous allons donner un peu de couleurs à cette fenêtre toute triste. ;)</p><h2 id="r-changer-la-couleur-de-fond" data-claire-element-id="338973">Changer la couleur de fond</h2><p id="r-338897" data-claire-element-id="338897">Nous utiliserons trois nouvelles méthodes, qui font partie de la surface screen. Les voici :</p><ul id="r-338904" data-claire-element-id="338904"><li id="r-338899" data-claire-element-id="338899"><p id="r-338898" data-claire-element-id="338898"><code data-claire-semantic="java">fillRect(long couleur) </code> ;</p></li><li id="r-338901" data-claire-element-id="338901"><p id="r-338900" data-claire-element-id="338900"><code data-claire-semantic="java">mapRGB(int rouge, int vert, int bleu) </code> ;</p></li><li id="r-338903" data-claire-element-id="338903"><p id="r-338902" data-claire-element-id="338902"><code data-claire-semantic="java">flip() </code>.</p></li></ul><ul id="r-338911" data-claire-element-id="338911"><li id="r-338906" data-claire-element-id="338906"><p id="r-338905" data-claire-element-id="338905">La méthode <code data-claire-semantic="java">fillRect(long couleur) </code> permet de changer la couleur de fond de la surface qui l'appelle. Elle prend en paramètre un nombre (<code data-claire-semantic="java">long </code>), mais utiliser cette méthode comme cela n'est pas efficace car on ne sait pas quelle couleur correspond à quel nombre... C'est pour cela qu'on l'utilisera avec la prochaine méthode.</p></li><li id="r-338908" data-claire-element-id="338908"><p id="r-338907" data-claire-element-id="338907">La méthode <code data-claire-semantic="java">mapRGB(int rouge, int vert, int bleu) </code> renvoie un nombre de type <code data-claire-semantic="java">long </code> et prend en paramètres trois entiers (<code data-claire-semantic="java">int </code>) représentatifs des couleurs : rouge, vert et bleu. L'utilisation de la méthode précédente avec celle-ci sera donc particulièrement efficace !</p></li><li id="r-338910" data-claire-element-id="338910"><p id="r-338909" data-claire-element-id="338909">La méthode <code data-claire-semantic="java">flip() </code> permet d'appliquer les changements à l'écran. Cette méthode est donc à appeler à la fin de toutes nos manipulations.</p></li></ul><h3 id="r-red-green-and-blue" data-claire-element-id="338925">Red, Green and Blue</h3><p id="r-338912" data-claire-element-id="338912">La méthode <code data-claire-semantic="java">mapRGB() </code> prend en paramètres trois <code data-claire-semantic="java">int </code> comme nous l'avons vu. Ces valeurs varient entre 0 et 255. Par exemple, si vous voulez une couleur noire, il faut mettre toutes les valeurs à 0, car quand on les mélange, cela donne du noir ; l'inverse pour le blanc, c'est-à-dire 255 partout. Essayez donc de faire vos <em>&quot;mix perso&quot;</em>. ^^ Si vous ne comprenez pas, l'idéal, c'est de prendre le temps d'essayer chaque cas de figure ; vous verrez c'est vraiment tout bête à comprendre. Vous pouvez trouver une couleur avec son code RGB (red, green, blue) dans les logiciels d'édition d'images, comme <em>The Gimp</em> ou <em>Paint</em>.</p><p id="r-338913" data-claire-element-id="338913">Dans <em>The Gimp</em>, vous trouverez l'outil de couleurs dans le panneau de droite (à l'origine).</p><figure id="r-338915" data-claire-element-id="338916"><img id="r-338914" data-claire-element-id="338914" src="medias/uploads.siteduzero.com_files_129001_130000_129539.jpg" alt="Image utilisateur"/></figure><p id="r-338917" data-claire-element-id="338917">Vous voyez bien R pour Rouge, V pour Vert et B pour Bleu. C'est un bon moyen de se repérer et croyez-moi, nous aurons besoin de savoir avec quelle couleur travailler (quand on verra la transparence Alpha par exemple :-° ).</p><p id="r-338918" data-claire-element-id="338918">Voilà le code qui va changer la couleur de fond de votre fenêtre en... bleu !</p><pre id="r-338919" data-claire-element-id="338919"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;

public class ModeVideo {

	public static void main(String[] args) throws SDLException, InterruptedException {
		
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		
		// Mode Video initialisé
		SDLSurface screen = SDLVideo.setVideoMode(400, 200, 32, SDLVideo.SDL_HWSURFACE | SDLVideo.SDL_DOUBLEBUF);
		SDLVideo.wmSetCaption(&quot;Ma Troisième fenêtre en java avec SDL =)&quot;, null);
				
		/*
		 * Changement de couleur
		 * 1 - Une variable couleur est créée et elle fait référence à la couleur
		 * 	   renvoyée par la méthode mapRGB()
		 * 2 - La méthode fillRect prend en paramètre la couleur que l'on vient de définir
		 * 3 - On fait un &quot;flip&quot; de l'écran | On affiche les changements
		 */
		long couleur = screen.mapRGB(0, 0, 255);
		screen.fillRect(couleur);
		screen.flip();
		
		Thread.sleep(2000);
                screen.freeSurface();
		SDLMain.quit();
	}

}</code></pre><p id="r-338920" data-claire-element-id="338920">Et voilà le résultat :</p><figure id="r-338922" data-claire-element-id="338923"><img id="r-338921" data-claire-element-id="338921" src="medias/uploads.siteduzero.com_files_129001_130000_129553.png" alt="Image utilisateur"/></figure><p id="r-338924" data-claire-element-id="338924">S'il y a quelque chose qui vous échappe, prenez le temps de bien relire le tutoriel dans le calme. Sinon, vous pouvez passer à la suite.</p><h3 id="r-les-modes-video" data-claire-element-id="338930">Les modes vidéo</h3><div id="r-338927" data-claire-element-id="338927" data-claire-semantic="question"><p id="r-338926" data-claire-element-id="338926">T'es bien gentil mais elle est où ma première fenêtre avec sdljava ?</p></div><p id="r-338928" data-claire-element-id="338928">On y arrive, ne vous en faites pas ! :p C'est d'ailleurs le but de cette partie : nous allons tout de suite passer à la création d'une fenêtre !</p><p id="r-338929" data-claire-element-id="338929">Pour créer une fenêtre, on utilise la classe <code data-claire-semantic="java">SDLVideo </code> avec la méthode <code data-claire-semantic="java">setVideoMode() </code> ; pour lui donner un titre, on utilise la méthode <code data-claire-semantic="java">wmSetCaption() </code>.</p><h3 id="r-setvideomode" data-claire-element-id="338943">setVideoMode</h3><p id="r-338931" data-claire-element-id="338931"><code data-claire-semantic="java">SDLVideo </code> contient plusieurs méthodes et plusieurs constantes. Nous les étudierons au fur et à mesure.</p><p id="r-338932" data-claire-element-id="338932">Pour initialiser la vidéo, nous ferons comme suit :</p><pre id="r-338933" data-claire-element-id="338933"><code data-claire-semantic="java">SDLVideo.setVideoMode(640, 480, 32, Constante1 | constante2 | ....);</code></pre><p id="r-338934" data-claire-element-id="338934">Je vous détaille rapidement les trois premiers paramètres, puis les constantes.</p><ul id="r-338941" data-claire-element-id="338941"><li id="r-338936" data-claire-element-id="338936"><p id="r-338935" data-claire-element-id="338935">Le 1er paramètre est la largeur de l'écran en pixels ;</p></li><li id="r-338938" data-claire-element-id="338938"><p id="r-338937" data-claire-element-id="338937">Le 2ème paramètre est la hauteur de l'écran en pixels ;</p></li><li id="r-338940" data-claire-element-id="338940"><p id="r-338939" data-claire-element-id="338939">Le 3ème paramètre est la profondeur de l'écran (le nombre de couleurs).</p></li></ul><p id="r-338942" data-claire-element-id="338942">Donc ici, nous sommes en 640x480 32 Bits, rien de bien compliqué à comprendre.</p><h3 id="r-les-constantes-6" data-claire-element-id="338968">Les constantes</h3><ul id="r-338960" data-claire-element-id="338960"><li id="r-338945" data-claire-element-id="338945"><p id="r-338944" data-claire-element-id="338944"><code data-claire-semantic="java">SDL_DISABLE </code> : cache le curseur de la souris ;</p></li><li id="r-338947" data-claire-element-id="338947"><p id="r-338946" data-claire-element-id="338946"><code data-claire-semantic="java">SDL_DOUBLEBUF </code> : active le <em>Double Buffering</em> ;</p></li><li id="r-338949" data-claire-element-id="338949"><p id="r-338948" data-claire-element-id="338948"><code data-claire-semantic="java">SDL_ENABLE </code> : affiche le curseur de la souris (actif d'origine) ;</p></li><li id="r-338951" data-claire-element-id="338951"><p id="r-338950" data-claire-element-id="338950"><code data-claire-semantic="java">SDL_FULLSCREEN </code> : affiche la fenêtre en plein écran ;</p></li><li id="r-338953" data-claire-element-id="338953"><p id="r-338952" data-claire-element-id="338952"><code data-claire-semantic="java">SDL_HWACCEL </code> : utilisation de l'accélération matérielle ;</p></li><li id="r-338955" data-claire-element-id="338955"><p id="r-338954" data-claire-element-id="338954"><code data-claire-semantic="java">SDL_HWSURFACE </code> : les surfaces sont stockées dans la mémoire vidéo (plus rapide) ;</p></li><li id="r-338957" data-claire-element-id="338957"><p id="r-338956" data-claire-element-id="338956"><code data-claire-semantic="java">SDL_OPENGL </code> : vous avez deviné non ? :) Initialisation de <strong>OpenGL</strong> ;</p></li><li id="r-338959" data-claire-element-id="338959"><p id="r-338958" data-claire-element-id="338958"><code data-claire-semantic="java">SDL_SWSURFACE </code> : les surfaces sont stockées dans la mémoire système (plus lent).</p></li></ul><p id="r-338961" data-claire-element-id="338961">Il y a encore beaucoup d'autres constantes et encore une fois... consultez la doc. :) De toute façon, si vous ne le faites pas vous n'avancerez pas. :pirate: <br/> Généralement, on utilisera le <em>double buffering</em> et le <em>hardware surface</em> comme ceci :</p><pre id="r-338962" data-claire-element-id="338962"><code data-claire-semantic="java">SDLVideo.setVideoMode(640, 480, 32, SDLVideo.SDL_HWSURFACE | SDLVideo.SDL_DOUBLEBUF);</code></pre><div id="r-338964" data-claire-element-id="338964" data-claire-semantic="question"><p id="r-338963" data-claire-element-id="338963">C'est quoi le <em>Double Buffering</em> ?</p></div><p id="r-338965" data-claire-element-id="338965">En voilà une question intéressante !</p><p id="r-338966" data-claire-element-id="338966">C'est une technique utilisée principalement dans les jeux vidéo, pour éviter les scintillements de l'écran lorsqu'on affiche des éléments sur celui-ci. En gros c'est comme si vous aviez deux écrans (on parle en réalité de deux <em>buffers</em>) : votre écran physique, et un autre écran virtuel. L'écran virtuel dessine une image, puis la donne à l'écran physique. Pendant ce temps l'écran virtuel va redessiner une autre image (le temps que l'écran physique affiche la 1ère image), puis quand l'écran physique aura terminé avec la 1ère image, l'écran virtuel lui donnera la deuxième et ainsi de suite. Cela évite que l'écran physique soit seul à afficher les images, car il devrait alors préparer l'image puis l'afficher, puis l'effacer, puis préparer la deuxième, pour l'afficher... Vous comprenez l'avantage de cette technique ? Bien sûr pour afficher une fenêtre ça ne sert à rien, mais quand on affichera plusieurs images qui se déplaceront, cette technique nous montrera toute sa puissance !</p><p id="r-338967" data-claire-element-id="338967">Si vous voulez plus d'informations sur cette technique je vous conseille d'aller faire un petit tour <a href="http://www.alaide.com/dico.php?ix=5419&amp;amp%3Bamp%3Bq=Double%2Bbuffer">ici</a>.</p><h3 id="r-wmsetcaption" data-claire-element-id="338972">wmSetCaption</h3><p id="r-338969" data-claire-element-id="338969">On va maintenant donner un titre à notre fenêtre !</p><pre id="r-338970" data-claire-element-id="338970"><code data-claire-semantic="java">SDLVideo.wmSetCaption(&quot;Ma première fenêtre SDL en Java !&quot;, null);</code></pre><p id="r-338971" data-claire-element-id="338971">Ce code permet de donner un titre à la fenêtre. Le premier paramètre est une chaîne de caractères (<code data-claire-semantic="java">String </code>) qui est le nom de la fenêtre, le deuxième paramètre est l'icône que vous voulez lui attribuer. Ici, nous ne voulons pas d'icônes, donc nous lui passons la référence <code data-claire-semantic="java">null </code>.</p><h2 id="r-le-code-final-2" data-claire-element-id="338996">Le code final</h2><pre id="r-338974" data-claire-element-id="338974"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.video.SDLVideo;

public class ModeVideo {

	public static void main(String[] args) throws SDLException, InterruptedException {
		
		// Initialisation du mode vidéo
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		/*
		  * Création d'une fenêtre de 320x240
		  *Avec une profondeur de 32 bits
		  * On utilise le mode Hardware Surface
		 */
		SDLVideo.setVideoMode(320, 240, 32, SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;Ma première fenêtre en java avec SDL&quot;, null);
		// On met en pause le Thread Principal pour que vous puissiez admirer votre fenêtre
		Thread.sleep(1000);
		// On quitte / Libération de la mémoire
		SDLMain.quit();
	}
}</code></pre><p id="r-338975" data-claire-element-id="338975">Et voilà, c'est fait ! Elle est pas belle la vie fenêtre ? :p</p><h3 id="r-exercice-changement-de-couleurs-dynamique" data-claire-element-id="338995">Exercice : changement de couleurs dynamique</h3><p id="r-338976" data-claire-element-id="338976">Il le faut et c'est pour votre bien. :) Je vais vous mettre en garde maintenant : si vous ne lisez pas la doc et si vous ne pratiquez pas (ou peu), vous ne développerez pas de jeux ou d'applications qui vous rendront fiers. sdljava est une <em>librairy</em> simple et accessible et on programme en Java, alors profitez-en, ne vous limitez pas à ce tutoriel. :)</p><p id="r-338977" data-claire-element-id="338977">Le sujet : je vous demande de créer une fenêtre de la taille que vous voulez, dans laquelle nous changerons la couleur de fond 5 fois de suite.</p><ul id="r-338988" data-claire-element-id="338988"><li id="r-338979" data-claire-element-id="338979"><p id="r-338978" data-claire-element-id="338978">1ère fois : le fond est noir ;</p></li><li id="r-338981" data-claire-element-id="338981"><p id="r-338980" data-claire-element-id="338980">2ème fois : le fond est rouge ;</p></li><li id="r-338983" data-claire-element-id="338983"><p id="r-338982" data-claire-element-id="338982">3ème fois : le fond est vert ;</p></li><li id="r-338985" data-claire-element-id="338985"><p id="r-338984" data-claire-element-id="338984">4ème fois : le fond est bleu ;</p></li><li id="r-338987" data-claire-element-id="338987"><p id="r-338986" data-claire-element-id="338986">5ème fois : le fond est blanc.</p></li></ul><p id="r-338989" data-claire-element-id="338989">Après ça, le programme se termine normalement. Pour réaliser cet exercice, vous avez plusieurs solutions (structures répétitives, alternatives, ...). Le but recherché est le suivant : la fenêtre affiche un fond noir, puis au bout d'un moment (que je vous laisse choisir), la couleur change et ainsi de suite. N'oubliez pas que nos amis les <code data-claire-semantic="java">Thread </code> sont là ! (une seul méthode de la classe <code data-claire-semantic="java">Thread </code> suffit, et elle ne devrait pas vous être méconnue, ... enfin je l'espère :p ).</p><p id="r-338990" data-claire-element-id="338990">En avant la correction ! Qui, bien entendu, peut varier selon les implémentations de chacun. Ce n'est donc pas LA correction absolue, c'est UNE correction qui fonctionne.</p><p id="r-338991" data-claire-element-id="338991"></p><div id="r-338993" data-claire-element-id="338993"><pre id="r-338992" data-claire-element-id="338992"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;

public class ModeVideo {

	public static void main(String[] args) throws SDLException, InterruptedException {
		
		int compteur = 0; // Variable de boucle
		/* Initialisation de SDL et de la Vidéo */
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLSurface screen = SDLVideo.setVideoMode(400, 200, 32, SDLVideo.SDL_HWSURFACE | SDLVideo.SDL_DOUBLEBUF);
		SDLVideo.wmSetCaption(&quot;Ma Quatrième fenêtre en java avec SDL =)&quot;, null);
				
		while(compteur &lt;= 4) {
			/* On teste chaque valeur de compteur et on agit en conséquence */
			switch( compteur ) {
				case 0: screen.fillRect(screen.mapRGB(0, 0, 0)); // Noir
					break;
				case 1: screen.fillRect(screen.mapRGB(255, 0, 0)); // Rouge
					break;
				case 2: screen.fillRect(screen.mapRGB(0, 255, 0)); // Vert
					break;
				case 3: screen.fillRect(screen.mapRGB(0, 0, 255)); // Bleu
					break;
				case 4: screen.fillRect(screen.mapRGB(255, 255, 255)); // Blanc
					break;
			}
			
			screen.flip();
			Thread.sleep(1500);
			compteur++;
		}			
		SDLMain.quit();
	}
}</code></pre></div><p id="r-338994" data-claire-element-id="338994">Vous avez appris pas mal de choses, et il est peut-être temps de faire le point et de vous reposer un moment. Allez prendre un café ou une pizza (je m'en fiche :p ) et revenez quand vous serez prêts, car nous attaquons les deux derniers chapitres de base et il faut que vous soyez motivés (il n'y a rien de compliqué si ça peut vous rassurer). :lol:</p><h2 id="r-les-surfaces" data-claire-element-id="339012">Les surfaces</h2><p id="r-338997" data-claire-element-id="338997">Résumons un peu :</p><ul id="r-339008" data-claire-element-id="339008"><li id="r-338999" data-claire-element-id="338999"><p id="r-338998" data-claire-element-id="338998">Vous avez installé sdljava ;</p></li><li id="r-339001" data-claire-element-id="339001"><p id="r-339000" data-claire-element-id="339000">Vous savez créer une fenêtre ;</p></li><li id="r-339003" data-claire-element-id="339003"><p id="r-339002" data-claire-element-id="339002">Vous savez changer la couleur de fond de cette dernière ;</p></li><li id="r-339005" data-claire-element-id="339005"><p id="r-339004" data-claire-element-id="339004">Vous savez lui ajouter un titre ;</p></li><li id="r-339007" data-claire-element-id="339007"><p id="r-339006" data-claire-element-id="339006">Vous connaissez les différents modes vidéo.</p></li></ul><p id="r-339009" data-claire-element-id="339009">Je vous ai fait une brève introduction sur les <code data-claire-semantic="java">SDLSurface </code> et nous allons maintenant les voir de plus près (près comment monsieur ? T'inquiètes pas pour ça bonhomme :D ). Dans un premier temps, nous allons en créer une nouvelle, puis la placer où nous le voulons sur la fenêtre, puis nous en placerons plusieurs. Une fois ce mécanisme compris, vous serez prêt à lire le chapitre de cette partie 1. Allez, on est parti. :diable:</p><h3 id="r-votre-premiere-sdlsurface" data-claire-element-id="339011">Votre première SDLSurface</h3><p id="r-339010" data-claire-element-id="339010">En réalité, ce ne sera pas votre première <code data-claire-semantic="java">SDLSurface </code>, puisque nous avons eu l'occasion d'en avoir un bref aperçu dans le chapitre précédent. Dans ce chapitre, nous allons utiliser plusieurs surfaces dans la fenêtre ; cela consistera au début à avoir un rectangle d'une couleur rouge par exemple dans la fenêtre, puis d'en avoir deux, trois... vous me suivez ? Nous allons aussi voir comment les positionner en fin de chapitre. Vous comprendrez aussi l'utilité de la constante <code data-claire-semantic="java">SDLVideo.SDL_HWSURFACE </code> qui nous servira donc à utiliser la mémoire de la carte graphique plutôt que la mémoire système, ce sera bien plus rapide. ^^</p><h2 id="r-les-sdlsurface" data-claire-element-id="339087">Les SDLSurface</h2><p id="r-339013" data-claire-element-id="339013">Une surface, dans notre cas, est une forme géométrique en 2 dimensions de forme rectangulaire. On peut en créer à l'aide de <code data-claire-semantic="java">SDLSurface maSurface </code>, mais bien sûr une fois créée, il faut bien qu'elle fasse référence à quelque chose, car dans le chapitre précédent, la surface que nous avons créée faisait référence à l'écran. Ici on utilisera la méthode <code data-claire-semantic="java">SDLVideo.createRGBSurface(...) </code>. Cette dernière prend 8 paramètres, mais ne vous en faites pas c'est très simple, les voici :</p><ul id="r-339024" data-claire-element-id="339024"><li id="r-339015" data-claire-element-id="339015"><p id="r-339014" data-claire-element-id="339014">Le mode vidéo. Dans notre cas : hardware ;</p></li><li id="r-339017" data-claire-element-id="339017"><p id="r-339016" data-claire-element-id="339016">La largeur de la surface ;</p></li><li id="r-339019" data-claire-element-id="339019"><p id="r-339018" data-claire-element-id="339018">La hauteur de la surface ;</p></li><li id="r-339021" data-claire-element-id="339021"><p id="r-339020" data-claire-element-id="339020">Le nombre de couleurs : on utilisera 32 bits comme pour la fenêtre ;</p></li><li id="r-339023" data-claire-element-id="339023"><p id="r-339022" data-claire-element-id="339022">Quatre paramètres de type <code data-claire-semantic="java">long </code> qui correspondent aux couleurs RGBA de mask. Pour des raisons de simplicité, nous les mettrons tous à 0.</p></li></ul><p id="r-339025" data-claire-element-id="339025">On pourra donc créer une surface comme suit :</p><pre id="r-339026" data-claire-element-id="339026"><code data-claire-semantic="java">rectangle = SDLVideo.createRGBSurface(SDLVideo.SDL_HWSURFACE, 200, 150, 32, 0, 0, 0, 0);</code></pre><p id="r-339027" data-claire-element-id="339027">Ici nous initialisons notre <code data-claire-semantic="java">SDLSurface </code> pour qu'elle soit utilisée dans la mémoire de la carte graphique, ensuite nous définissons les paramètres de largeur, de hauteur ainsi que de profondeur (nombre de couleurs). Les quatre derniers paramètres sont à 0 comme indiqué plus haut.</p><p id="r-339028" data-claire-element-id="339028">Le problème est qu'en écrivant juste ce code, ça ne va pas fonctionner ! Si vous touchez un peu à AWT/Swing, vous savez que quand on crée un <code data-claire-semantic="java">JButton </code>, il faut dans un premier temps le créer, puis l'attacher à la fenêtre, puis demander à la fenêtre de s'afficher. Eh bien une surface, c'est exactement pareil ! Et pour cela, on utilise la méthode <code data-claire-semantic="java">blitSurface(SDLSurface parent) </code> où <code>parent</code> est une <code data-claire-semantic="java">SDLSurface </code> et en l'occurrence la fenêtre principale, mais rien ne vous empêche de bliter une surface sur une autre. :p</p><p id="r-339029" data-claire-element-id="339029">Voici un code avec <strong>Swing</strong> pour que vous puissiez comparer :</p><pre id="r-339030" data-claire-element-id="339030"><code data-claire-semantic="java">// votre code d'initialisation 
....
// On fabrique un bouton
JButton monBouton = new JButton(&quot;bonjour&quot;);
// On attache le bouton sur la zone d'affichage
getContentPane().add(monBouton);
// On affiche la fenêtre
setVisible(true);</code></pre><p id="r-339031" data-claire-element-id="339031">Et le code en SDL :</p><pre id="r-339032" data-claire-element-id="339032"><code data-claire-semantic="java">// Code d'initialisation SDL, création des SDLSuface, etc...
....
// On crée un nouveau rectangle
rectangle = SDLVideo.createRGBSurface(SDLVideo.SDL_HWSURFACE, 200, 150, 32, 0, 0, 0, 0);
// On attache le rectangle sur la fenêtre (qui est une SDLSurface du doux nom de screen)
rectangle.blitSurface(screen);
// On affiche le tout ! C'est la fenêtre qui contient la surface rectangle, donc c'est elle qu'on flip
screen.flip();</code></pre><p id="r-339033" data-claire-element-id="339033">Si vous rajoutez ce code comme ça, vous ne verrez rien et savez-vous pourquoi ? Vous vous souvenez de la couleur de fond d'origine de la fenêtre ? Elle est noire. ;) Et vous souvenez-vous que la fenêtre est une <code data-claire-semantic="java">SDLSurface </code> ? Vous en avez donc sûrement déduit que notre surface rectangle sera, elle aussi, noire. Pour remédier à ce problème, nous pouvons changer la couleur exactement de la même manière que pour l'écran, c'est-à-dire avec les méthodes <code data-claire-semantic="java">fillRect(...) </code> et <code data-claire-semantic="java">mapRGB(...) </code>.</p><p id="r-339034" data-claire-element-id="339034">Ce qui va nous donner quelque chose comme cela (avouez ! Vous avez senti venir l'exercice hein :D ).</p><pre id="r-339035" data-claire-element-id="339035"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;

public class Surface {
	public static void main(String[] args) throws SDLException, InterruptedException {
		
		SDLSurface screen = null, 
				   rectangle = null;
		
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		screen = SDLVideo.setVideoMode(640, 480, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;Les SDLSurface avec SDL en Java&quot;, null);
		
		rectangle = SDLVideo.createRGBSurface(SDLVideo.SDL_HWSURFACE, 200, 150, 32, 0, 0, 0, 0);
		rectangle.fillRect(rectangle.mapRGB(255, 0, 0));
		rectangle.blitSurface(screen);
		screen.flip();
		
		Thread.sleep(2000);
		rectangle.freeSurface();
                screen.freeSurface();
		SDLMain.quit();
		
	}
}</code></pre><h3 id="r-positionner-une-surface" data-claire-element-id="339059">Positionner une surface</h3><p id="r-339036" data-claire-element-id="339036">Comme vous avez pu le constater, la surface que nous avons créée s'est positionnée dans le coin en haut à gauche, mais comment faire pour la positionner en plein milieu de l'écran par exemple ? Ou ailleurs même ? On utilisera une nouvelle classe : <code data-claire-semantic="java">SDLRect </code>. Nous allons procéder par étapes comme nous en avons pris l'habitude. ^^</p><p id="r-339037" data-claire-element-id="339037">1. Importer la classe <code data-claire-semantic="java">SDLRect </code> :</p><pre id="r-339038" data-claire-element-id="339038"><code data-claire-semantic="java">import sdljava.video.SDLRect;</code></pre><p id="r-339039" data-claire-element-id="339039">2. Créer un objet de ce type :</p><pre id="r-339040" data-claire-element-id="339040"><code data-claire-semantic="java">SDLRect posRectangle = new SDLRect();

// Ou bien

SDLRect posRectangle = new SDLRect(int x, int y);</code></pre><p id="r-339041" data-claire-element-id="339041">Vous remarquez qu'on peut initialiser notre objet de deux manières :</p><ul id="r-339046" data-claire-element-id="339046"><li id="r-339043" data-claire-element-id="339043"><p id="r-339042" data-claire-element-id="339042">En utilisant un constructeur sans paramètres ;</p></li><li id="r-339045" data-claire-element-id="339045"><p id="r-339044" data-claire-element-id="339044">En utilisant un constructeur avec paramètres.</p></li></ul><p id="r-339047" data-claire-element-id="339047">Le deuxième constructeur prend en paramètres deux <code data-claire-semantic="java">int </code> qui représentent les coordonnées en X et en Y. Dans le cas du premier constructeur, il faudra, à l'aide des méthodes <code data-claire-semantic="java">setX(int x) </code> et <code data-claire-semantic="java">setY(int y) </code>, fournir ces valeurs.</p><p id="r-339048" data-claire-element-id="339048">Voilà par exemple le code pour centrer une surface à l'écran :</p><pre id="r-339049" data-claire-element-id="339049"><code data-claire-semantic="java">// Taille de la fenêtre
int width = 640, height = 480;
// Taille de la surface rectangle
int rectX = 200, rectY = 150;
// Position du rectangle centré
SDLRect posRectangle = new SDLRect();
posRectangle.setX((width / 2) - (rectX / 2));
posRectangle.setY((height / 2 ) - (rectY / 2));
	
/*
 * On pourrait aussi faire comme ça :)
 * 
 * SDLRect posRectangle = new SDLRect(((width / 2) - (rectX / 2)), ((height / 2 ) - (rectY / 2)));
 */</code></pre><p id="r-339050" data-claire-element-id="339050">Si vous écrivez ça, encore une fois ça ne fonctionne pas, et je sais que vous savez pourquoi. ^^ Il faut maintenant lier notre <code data-claire-semantic="java">SDLSurface </code> rectangle avec notre <code data-claire-semantic="java">SDLRect </code> posRectangle. On utilisera pour cela une méthode que vous connaissez (si si je vous assure), et d'ailleurs la voilà :</p><pre id="r-339051" data-claire-element-id="339051"><code data-claire-semantic="java">blitSurface(SDLSurface maSurface, SDLRect positionMaSurface);</code></pre><p id="r-339052" data-claire-element-id="339052">Comme vous pouvez le voir, la méthode <strong>blitSurface</strong> peut prendre plusieurs paramètres. Je ne pense pas que vous ayez besoin de plus d'explications, voilà le code qui va centrer notre surface :</p><pre id="r-339053" data-claire-element-id="339053"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.video.SDLRect;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;

class Surface {
	public static void main(String[] args) throws SDLException, InterruptedException {
		
		// Taille de la fenêtre
		int width = 640, height = 480;
		// Taille de la surface rectangle
		int rectX = 200, rectY = 150;
		// Position du rectangle centré
		SDLRect posRectangle = new SDLRect();
		posRectangle.setX((width / 2) - (rectX / 2));
		posRectangle.setY((height / 2 ) - (rectY / 2));
		
		/*
		 * On pourrait aussi faire comme ça :)
		 * 
		 * SDLRect posRectangle = new SDLRect(((width / 2) - (rectX / 2)), ((height / 2 ) - (rectY / 2)));
		 */
		
		 // Initialisation SDL et Vidéo
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLSurface screen = SDLVideo.setVideoMode(width, height, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;Les SDLSurface avec SDL en Java&quot;, null);
		
		// Création d'une SDLSurface rectangle
		SDLSurface rectangle = SDLVideo.createRGBSurface(SDLVideo.SDL_HWSURFACE,
				rectX, rectY, 32, 0, 0, 0, 0);
		// Changement de couleur en rouge
		rectangle.fillRect(rectangle.mapRGB(255, 0, 0));
		// On blit sur l'écran la surface rectangle avec ses coordonnées (via SDLRect)
		rectangle.blitSurface(screen, posRectangle);
		screen.flip();
		
		Thread.sleep(2000);
		
		rectangle.freeSurface();
		screen.freeSurface();
		SDLMain.quit();
		
	}
}</code></pre><p id="r-339054" data-claire-element-id="339054">Et voilà le travail !</p><figure id="r-339056" data-claire-element-id="339057"><img id="r-339055" data-claire-element-id="339055" src="medias/uploads.siteduzero.com_files_134001_135000_134473.jpg" alt="surface centre"/></figure><p id="r-339058" data-claire-element-id="339058">Faites des tests et essayez de changer les valeurs de <code data-claire-semantic="java">SDLRect </code> pour voir.</p><h3 id="r-gerer-plusieurs-surfaces" data-claire-element-id="339071">Gérer plusieurs surfaces</h3><p id="r-339060" data-claire-element-id="339060">Nous allons voir très rapidement comment utiliser plusieurs <code data-claire-semantic="java">SDLSurface </code> dans notre programme.</p><p id="r-339061" data-claire-element-id="339061">Nous avons déjà créé deux <code data-claire-semantic="java">SDLSurface </code> : la <code data-claire-semantic="java">SDLSurface </code> qui correspond à l'écran et la <code data-claire-semantic="java">SDLSurface </code> qui correspond au rectangle. Maintenant pour en créer d'autres, c'est très simple : il faut faire pareil que pour le rectangle, c'est-à-dire :</p><ul id="r-339070" data-claire-element-id="339070"><li id="r-339063" data-claire-element-id="339063"><p id="r-339062" data-claire-element-id="339062">Créer une <code data-claire-semantic="java">SDLSurface </code> ;</p></li><li id="r-339065" data-claire-element-id="339065"><p id="r-339064" data-claire-element-id="339064">Positionner cette <code data-claire-semantic="java">SDLSurface </code> avec <code data-claire-semantic="java">SDLRect </code> ;</p></li><li id="r-339067" data-claire-element-id="339067"><p id="r-339066" data-claire-element-id="339066">Donner une couleur ;</p></li><li id="r-339069" data-claire-element-id="339069"><p id="r-339068" data-claire-element-id="339068">Bliter cette dernière sur la surface écran.</p></li></ul><h3 id="r-petit-exercice-5" data-claire-element-id="339086">Petit exercice</h3><p id="r-339072" data-claire-element-id="339072">Vous allez créer un programme qui affiche 4 <code data-claire-semantic="java">SDLSurface </code> (carrés ou rectangles comme vous voulez).</p><p id="r-339073" data-claire-element-id="339073">Prenez votre temps pour faire cet exercice (bien qu'il ne soit vraiment pas dur). S'il le faut, utilisez une feuille de papier et un crayon (ou un stylo c'est vous qui voyez ;) ) et dessinez ce qui doit être affiché, cela vous aidera beaucoup croyez-moi.</p><p id="r-339074" data-claire-element-id="339074">Allez voilà la correction, j'espère que vous avez réussi. :)</p><p id="r-339075" data-claire-element-id="339075">Version 1 : Les mauvaises habitudes.</p><pre id="r-339076" data-claire-element-id="339076"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.video.SDLRect;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;

class Surface {
	public static void main(String[] args) throws SDLException, InterruptedException {
		
		// Taille de la fenêtre
		int width = 320, height = 240;
		
		// Taille des surfaces
		int carre1X = 60, carre1Y = 60,
			carre2X = 60, carre2Y = 60,
			carre3X = 60, carre3Y = 60,
			carre4X = 60, carre4Y = 60;
		
		// Position des surfaces
		SDLRect posCarre1 = new SDLRect(30, 30);
		SDLRect posCarre2 = new SDLRect(200, 30);
		SDLRect posCarre3 = new SDLRect(30, 120);
		SDLRect posCarre4 = new SDLRect(200, 120);
		
				
		 // Initialisation SDL et Vidéo
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLSurface screen = SDLVideo.setVideoMode(width, height, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;4 SDLSurface !&quot;, null);
		
		// Création des surfaces
		SDLSurface carre1 = SDLVideo.createRGBSurface(SDLVideo.SDL_HWSURFACE, carre1X, carre1Y, 32, 0, 0, 0, 0);
		SDLSurface carre2 = SDLVideo.createRGBSurface(SDLVideo.SDL_HWSURFACE, carre2X, carre2Y, 32, 0, 0, 0, 0);
		SDLSurface carre3 = SDLVideo.createRGBSurface(SDLVideo.SDL_HWSURFACE, carre3X, carre3Y, 32, 0, 0, 0, 0);
		SDLSurface carre4 = SDLVideo.createRGBSurface(SDLVideo.SDL_HWSURFACE, carre4X, carre4Y, 32, 0, 0, 0, 0);
		
		// On donne des couleurs différentes à chaques surfaces
		screen.fillRect(screen.mapRGB(0, 45, 78));
		carre1.fillRect(carre1.mapRGB(255, 125, 135));
		carre2.fillRect(carre2.mapRGB(0, 89, 32));
		carre3.fillRect(carre3.mapRGB(25, 20, 65));
		carre4.fillRect(carre4.mapRGB(55, 240, 12));
		
		// On blit tout ça sur l'écran :)
		carre1.blitSurface(screen, posCarre1);
		carre2.blitSurface(screen, posCarre2);
		carre3.blitSurface(screen, posCarre3);
		carre4.blitSurface(screen, posCarre4);
		
		// On flip et on regarde ce que ça donne ;)
		screen.flip();
			
		Thread.sleep(5000);
		
		// On quitte 
		carre1.freeSurface();
		carre2.freeSurface();
		carre3.freeSurface();
		carre4.freeSurface();
		screen.freeSurface();
		SDLMain.quit();
		
	}
}</code></pre><p id="r-339077" data-claire-element-id="339077">Ce code est moche, on pourrait utiliser des tableaux pour stocker les surfaces, les positions et les couleurs.</p><p id="r-339078" data-claire-element-id="339078">Version 2 : un code plus &quot;propre&quot; et plus court !</p><pre id="r-339079" data-claire-element-id="339079"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.video.SDLRect;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;

class Surface {
	public static void main(String[] args) throws SDLException, InterruptedException {
		
		// Taille de la fenêtre
		int width = 320, height = 240;
		
		
		/*
		 * Positions des surfaces
		 * 
		 * Les surfaces n'ont pas la même position, on remplit donc à la main les positions
		 * avec les méthode setX(int x) et setY(int y)
		 */
		
		SDLRect posCarre[] = new SDLRect[4];
		posCarre[0] = new SDLRect(30 , 30);
		posCarre[1] = new SDLRect(200, 30);
		posCarre[2] = new SDLRect(30, 120);
		posCarre[3] = new SDLRect(200, 120);
		
				
		 // Initialisation SDL et Vidéo
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLSurface screen = SDLVideo.setVideoMode(width, height, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;4 SDLSurface !&quot;, null);
		
		// Création des surfaces	
		SDLSurface carre[] = new SDLSurface[4];
		for (int i = 0 ; i &lt; 4 ; i++) {
			carre[i] = SDLVideo.createRGBSurface(SDLVideo.SDL_HWSURFACE, 60, 60, 32, 0, 0, 0, 0);
		}
		
		/*
		 * On donne des couleurs pour chaques surfaces
		 * 
		 * Vue que chaque surface a des couleurs différentes, on n'utilise pas de boucle for
		 * On peut utiliser une boucle for pour qu'elles soient toutes de la même couleur
		 * ou en utilisant des variables R, G, B que l'on incrémente à chaque passage de boucle
		 */
		screen.fillRect(screen.mapRGB(0, 45, 78));
		carre[0].fillRect(carre[0].mapRGB(255, 125, 135));
		carre[1].fillRect(carre[1].mapRGB(0, 89, 32));
		carre[2].fillRect(carre[2].mapRGB(25, 20, 65));
		carre[3].fillRect(carre[3].mapRGB(55, 240, 12));
		
		// On blit tout ça sur l'écran :)
		for (int i = 0 ; i &lt; 4 ; i++) {
			carre[i].blitSurface(screen, posCarre[i]);
		}
		
		// On flip et on regarde ce que ça donne ;)
		screen.flip();
			
		Thread.sleep(5000);
		
		// On quitte 	
		for (int i = 0 ; i &lt; 4 ; i++) {
			carre[i].freeSurface();
		}
		
		screen.freeSurface();
		SDLMain.quit();
		
	}
}</code></pre><p id="r-339080" data-claire-element-id="339080">Et voilà le travail !</p><figure id="r-339082" data-claire-element-id="339083"><img id="r-339081" data-claire-element-id="339081" src="medias/uploads.siteduzero.com_files_134001_135000_134481.jpg" alt="4 SDLSurfaces"/></figure><p id="r-339084" data-claire-element-id="339084">Lisez bien les commentaires pour comprendre ce que j'ai fait. Comme vous pouvez le constater, ce code est plus clair, plus light et pourtant, il fait exactement la même chose ! L'utilisation des tableaux est très importante si vous voulez créer des jeux (que ce soit en 2D ou en 3D) car ils permettent d'avoir un code lisible et ils sont à la base de beaucoup de choses comme les sprites, les maps, etc.</p><p id="r-339085" data-claire-element-id="339085">Si ce que vous avez vu vous a paru compliqué, je vous conseille vivement de pratiquer et de relire cette partie. Sinon, je vous invite à passer au dernier chapitre. Un chapitre concernant les images ! Mais je ne vous en dis pas plus, à tout de suite. ^^</p><h2 id="r-les-images-10" data-claire-element-id="339099">Les images</h2><p id="r-339088" data-claire-element-id="339088">Nous allons maintenant nous intéresser au chargement d'images et à leur manipulation, nous verrons :</p><ul id="r-339095" data-claire-element-id="339095"><li id="r-339090" data-claire-element-id="339090"><p id="r-339089" data-claire-element-id="339089">le chargement,</p></li><li id="r-339092" data-claire-element-id="339092"><p id="r-339091" data-claire-element-id="339091">la couleur de transparence (canal Alpha),</p></li><li id="r-339094" data-claire-element-id="339094"><p id="r-339093" data-claire-element-id="339093">comment rendre l'image transparente.</p></li></ul><p id="r-339096" data-claire-element-id="339096">Une image n'est qu'une <code data-claire-semantic="java">SDLSurface </code> sans couleur sur laquelle on à posé une image (je simplifie ^^ ), donc ce chapitre ne sera pas très long, mais sera riche en nouvelles connaissances !</p><p id="r-339097" data-claire-element-id="339097">Je ferai aussi une brève présentation des événements avec SDL, ce qui nous évitera d'avoir recours à la méthode <code data-claire-semantic="java">sleep() </code> de la classe <code data-claire-semantic="java">Thread </code>. Mais avant toute chose, nous devrons parler de &quot;l'installation&quot; de SDL_image.</p><h3 id="r-installation-et-configuration-de-sdl-image" data-claire-element-id="339098">Installation et configuration de SDL_image</h3><h2 id="r-installation-sous-linux" data-claire-element-id="339150">Installation sous Linux</h2><p id="r-339100" data-claire-element-id="339100">Amis linuxiens, nous avons du travail ! En effet par rapport à l'installation sous Windows, nous aurons quelques manipulations de plus à effectuer, mais ne vous en faites pas ce n'est pas très compliqué.</p><p id="r-339101" data-claire-element-id="339101">Mis à part le fichier libSDL_image.a nous aurons besoin d'autres bibliothèques qui doivent normalement être installées ; si ce n'est pas le cas, il faudra aller télécharger les sources et les installer. Vous devez donc avoir ces bibliothèques :</p><ul id="r-339110" data-claire-element-id="339110"><li id="r-339103" data-claire-element-id="339103"><p id="r-339102" data-claire-element-id="339102"><a href="http://www.ijg.org/files/">libjpeg</a>,</p></li><li id="r-339105" data-claire-element-id="339105"><p id="r-339104" data-claire-element-id="339104"><a href="http://www.libpng.org/pub/png/libpng.html">libpng</a>,</p></li><li id="r-339107" data-claire-element-id="339107"><p id="r-339106" data-claire-element-id="339106"><a href="http://www.remotesensing.org/libtiff/">libtiff</a>,</p></li><li id="r-339109" data-claire-element-id="339109"><p id="r-339108" data-claire-element-id="339108"><a href="http://www.zlib.net/">zlib</a>.</p></li></ul><p id="r-339111" data-claire-element-id="339111">Regardez plus bas pour savoir si vous les avez.</p><h3 id="r-si-la-bibliotheque-sdl-ainsi-que-ses-extensions-sont-deja-installees-sur-votre-machine" data-claire-element-id="339126">Si la bibliothèque SDL <strong>ainsi</strong> que ses extensions sont déjà installées sur votre machine</h3><p id="r-339112" data-claire-element-id="339112">Allez dans le répertoire <code data-claire-semantic="bash">/usr/lib </code> et recherchez les fichiers suivants :</p><ul id="r-339123" data-claire-element-id="339123"><li id="r-339114" data-claire-element-id="339114"><p id="r-339113" data-claire-element-id="339113">libjpeg.a ;</p></li><li id="r-339116" data-claire-element-id="339116"><p id="r-339115" data-claire-element-id="339115">libpng12.a ;</p></li><li id="r-339118" data-claire-element-id="339118"><p id="r-339117" data-claire-element-id="339117">libSDL_image.a ;</p></li><li id="r-339120" data-claire-element-id="339120"><p id="r-339119" data-claire-element-id="339119">libtiff.a ;</p></li><li id="r-339122" data-claire-element-id="339122"><p id="r-339121" data-claire-element-id="339121">libz.a.</p></li></ul><p id="r-339124" data-claire-element-id="339124">Si vous avez compilé SDL_image à la main, il est fort probable que le fichier libSDL_image.a se trouve dans <code data-claire-semantic="bash">/usr/local/lib </code>. Une fois que vous avez ces fichiers copiez-les simplement à la racine de votre répertoire de projet (à coté de libSDLmain.a).</p><p id="r-339125" data-claire-element-id="339125">Voila c'est fini. ^^ Profitez-en donc pour créer un nouveau dossier que vous nommerez par exemple images. Il contiendra les images que nous utiliserons dans 5 minutes. ;)</p><h3 id="r-si-la-bibliotheque-ainsi-que-ses-extensions-ne-sont-pas-installees-sur-votre-machine" data-claire-element-id="339149">Si la bibliothèque ainsi que ses extensions ne sont pas installées sur votre machine</h3><p id="r-339127" data-claire-element-id="339127">Allez dans le répertoire <code data-claire-semantic="bash">/usr/lib </code> et recherchez les fichiers suivants :</p><ul id="r-339136" data-claire-element-id="339136"><li id="r-339129" data-claire-element-id="339129"><p id="r-339128" data-claire-element-id="339128">libjpeg.a ;</p></li><li id="r-339131" data-claire-element-id="339131"><p id="r-339130" data-claire-element-id="339130">libpng12.a ;</p></li><li id="r-339133" data-claire-element-id="339133"><p id="r-339132" data-claire-element-id="339132">libtiff.a ;</p></li><li id="r-339135" data-claire-element-id="339135"><p id="r-339134" data-claire-element-id="339134">libz.a.</p></li></ul><p id="r-339137" data-claire-element-id="339137">Une fois que vous les avez, copiez-les à la racine de votre répertoire projet (à coté de libSDLmain.a). On peut passer à la suite. Rendez-vous sur le site de <a href="http://www.libsdl.org/projects/SDL_image/">SDL_image</a> pour y télécharger les sources. Décompressez les sources dans un dossier approprié (personnellement j'utilise <code data-claire-semantic="bash">$HOME/Sources </code>), puis ouvrez un terminal et compilez la bibliothèque comme ceci :</p><p id="r-339138" data-claire-element-id="339138"><em>Sur les distributions type Mandriva, Fedora, OpenSuse, etc.</em></p><pre id="r-339139" data-claire-element-id="339139"><code data-claire-semantic="bash">./configure
make
su
#Entrez votre mot de passe
make install</code></pre><p id="r-339140" data-claire-element-id="339140"><em>Sur les distributions type Debian, Ubuntu, etc.</em></p><pre id="r-339141" data-claire-element-id="339141"><code data-claire-semantic="bash">./configure
make
sudo make install
# Entrez votre mot de passe</code></pre><p id="r-339142" data-claire-element-id="339142">Rendez-vous ensuite dans <code data-claire-semantic="bash">/usr/local/lib </code> et récupérez-y le fichier libSDL_image.a et enfin copiez-le avec les autres bibliothèques, à la racine de votre répertoire de projet. Je vous invite à créer un dossier images, qui contiendra les images que nous utiliserons dans 5 minutes. ;)</p><p id="r-339143" data-claire-element-id="339143"><em>Voilà à quoi doit ressembler votre répertoire :</em></p><figure id="r-339145" data-claire-element-id="339146"><img id="r-339144" data-claire-element-id="339144" src="medias/uploads.siteduzero.com_files_134001_135000_134550.jpg" alt="recapitulatif install linux"/></figure><aside id="r-339148" data-claire-element-id="339148" data-claire-semantic="information"><p id="r-339147" data-claire-element-id="339147">Suivant votre distribution et le type d'installation que vous avez fait de la bibliothèque SDLJava, vous n'aurez besoin que de libSDL_image.a</p></aside><h2 id="r-installation-sous-windows-3" data-claire-element-id="339242">Installation sous Windows</h2><p id="r-339151" data-claire-element-id="339151">Comme sous Linux vous aurez besoin de plusieurs fichiers dll, la bonne nouvelle est que l'on va récupérer une archive qui contient toutes ces dll. ^^ Vous devez vous rendre sur le site de <a href="http://www.libsdl.org/projects/SDL_image/">SDL_image</a> pour y télécharger SDL_image-1.2.xx-win32.zip. Une fois cette archive téléchargée, vous devez décompresser son contenu (plusieurs fichiers .dll) à la racine de votre répertoire projet (à coté de SDL.dll).</p><p id="r-339152" data-claire-element-id="339152">L'installation est terminée, profitez-en pour créer un nouveau dossier que vous pourrez nommer images, qui contiendra les images que nous utiliserons dans 5 minutes.</p><p id="r-339153" data-claire-element-id="339153">Voilà à quoi doit ressembler votre répertoire projet (en vert le nouveau dossier images, et en rouge les nouveaux fichiers dll) :</p><figure id="r-339155" data-claire-element-id="339156"><img id="r-339154" data-claire-element-id="339154" src="medias/uploads.siteduzero.com_files_134001_135000_134499.jpg" alt="recapitulatif install windows"/></figure><h3 id="r-charger-une-image-1" data-claire-element-id="339172">Charger une image</h3><p id="r-339157" data-claire-element-id="339157">Pour charger une image c'est facile, vous vous souvenez des surfaces ? Eh bien figurez-vous qu'une image sera vue par la SDL comme une <code data-claire-semantic="java">SDLSurface </code>, ce qui veut dire que pour charger et afficher une image on a juste une méthode qui change !</p><p id="r-339158" data-claire-element-id="339158">Tout d'abord nous devons importer la classe <code data-claire-semantic="java">SDLImage </code>comme nous en avons pris l'habitude :</p><pre id="r-339159" data-claire-element-id="339159"><code data-claire-semantic="java">import sdljava.image.SDLImage;</code></pre><p id="r-339160" data-claire-element-id="339160">Ensuite il nous faut une image, oui mais quel format ? Eh bien je risque peut-être d'en décevoir certains, mais les formats jpeg et tif sont très mal pris en charge, nous pourrons par contre utiliser des images aux formats gif, png et bmp. Pour notre exemple je prendrai une image de 640x480 au format png. Cette image devra se trouver dans le répertoire images que nous avons créé plus haut.</p><p id="r-339161" data-claire-element-id="339161">Nous devons maintenant créer une nouvelle surface que l'on nommera image, mais à la différence d'une surface classique, nous l'initialiserons avec la méthode <code data-claire-semantic="java">load(&quot;images/monImage.png&quot;); </code> de la classe <code data-claire-semantic="java">SDLImage </code>.</p><p id="r-339162" data-claire-element-id="339162">Une fois l'initialisation faite, c'est exactement comme une <code data-claire-semantic="java">SDLSurface </code>, donc on blit et on flip. ;)</p><div id="r-339164" data-claire-element-id="339164" data-claire-semantic="question"><p id="r-339163" data-claire-element-id="339163">Mais attend ! Et la taille de l'image on la définit pas ? o_O</p></div><p id="r-339165" data-claire-element-id="339165">Eh bien non, la méthode qui charge l'image va créer une <code data-claire-semantic="java">SDLSurface </code> de la taille de l'image, ce qui est très pratique, donc pas besoin de se soucier de la taille de l'image (juste le format).</p><p id="r-339166" data-claire-element-id="339166">Voici un code qui charge une image et qui l'affiche sur l'écran, par contre j'ai volontairement enlevé <code data-claire-semantic="java">Thread.sleep() </code> pour le remplacer par un gestionnaire d'événements, que nous verrons dans le prochain chapitre. Ne prenez donc pas peur si vous ne comprenez pas (bien que ça ne soit pas compliqué du tout), mais en gros ce code permet de laisser la fenêtre ouverte tant que vous ne cliquez pas sur la croix dans la barre de tâche. Voilà tout est dit, place au code. :)</p><pre id="r-339167" data-claire-element-id="339167"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.event.SDLEvent;
import sdljava.video.SDLRect;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
import sdljava.image.SDLImage;

public class Images {

	public static void main(String[] args) throws SDLException {
		
		// Gestion des evenements 1/2
		SDLEvent event = null;
		boolean boucle = true;
		
		// Initialisation de SDL et de l'affichage
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLVideo.wmSetCaption(&quot;Des images avec sdljava&quot;, null);
		SDLSurface screen = SDLVideo.setVideoMode(640, 480, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		
		// Chargement d'une image
		SDLSurface image = SDLImage.load(&quot;images/aerith.png&quot;);
		SDLRect imagePos = new SDLRect(0, 0);
		
		
		/*
		 *  Gestion des événement 2/2
		 *  
		 *  Boucle Principale
		 *  
		 *  Le code est exécuté TANT QUE la variable booléene boucle est vrai
		 *  SI l'événement SDL_QUIT est vrai ALORS la variable boucle est fausse et donc on sort de la boucle
		 */
		while (boucle)
		{
			event = SDLEvent.waitEvent();
			if (event.getType() == SDLEvent.SDL_QUIT)
				boucle = false;
			
			image.blitSurface(screen, imagePos);
			screen.flip();
		}
		
		// On quitte :: Libération de la mémoire
		image.freeSurface();
		screen.freeSurface();
		SDLMain.quit();
	}

}</code></pre><p id="r-339168" data-claire-element-id="339168">Tadaaa, elle est pas belle Aeris la vie ?</p><figure id="r-339170" data-claire-element-id="339171"><img id="r-339169" data-claire-element-id="339169" src="medias/uploads.siteduzero.com_files_134001_135000_134576.jpg" alt="aeris image"/></figure><h3 id="r-un-petit-mot-sur-les-evenements" data-claire-element-id="339180">Un petit mot sur les événements</h3><p id="r-339173" data-claire-element-id="339173">Bon, c'est bien parce que c'est vous, :p on commence par créer un objet de type <code data-claire-semantic="java">SDLEvent </code> (bien qu'en réalité on dirait qu'on crée un objet qui fait référence à un objet de type <code data-claire-semantic="java">SDLEvent </code>) et une variable booléenne qui vaut VRAI. L'objet <code data-claire-semantic="java">event </code>une fois initialisé nous informera des événements reçus par le programme. La variable <code data-claire-semantic="java">boucle </code> permet de lancer la boucle principale du programme (nous reviendrons sur la &quot;boucle principale&quot; dans le prochain chapitre), on aurait aussi pu écrire <code data-claire-semantic="java">while(true) </code> et quitter la boucle avec une instruction <code data-claire-semantic="java">break </code>, mais c'est plus &quot;sale&quot;.</p><p id="r-339174" data-claire-element-id="339174">L'initialisation de l'objet <code data-claire-semantic="java">event </code> se fait grâce à la méthode <code data-claire-semantic="java">waitEvent() </code> de la classe <code data-claire-semantic="java">SDLEvent </code> (nous verrons qu'il existe plusieurs types d'événements). <code data-claire-semantic="java">waitEvent() </code> va mettre le programme en pause tant qu'il n'y a pas d'événements.</p><p id="r-339175" data-claire-element-id="339175">On teste ensuite l'événement (on utilisera des <code data-claire-semantic="java">switch </code> dans le prochain chapitre, car ils seront plus adaptés). <code data-claire-semantic="java">SDLEvent.SDL_QUIT </code> est une constante qui correspond au clic sur la croix de fermeture de la fenêtre.</p><p id="r-339176" data-claire-element-id="339176">Ensuite on blit l'image et on flip l'écran.</p><div id="r-339178" data-claire-element-id="339178" data-claire-semantic="question"><p id="r-339177" data-claire-element-id="339177">Pourquoi on blit et on flip dans la boucle ?</p></div><p id="r-339179" data-claire-element-id="339179">Car si on blit ou flip après la boucle, le programme se termine donc on ne voit rien :lol: et de plus quand on déplacera des surfaces, il faudra que ce soit à chaque passage de boucle, je vous montre donc comment on fait dès le début !</p><h3 id="r-ajout-d-une-autre-image" data-claire-element-id="339188">Ajout d'une autre image</h3><p id="r-339181" data-claire-element-id="339181">C'est exactement pareil que d'afficher plusieurs <code data-claire-semantic="java">SDLSurface </code> sur la fenêtre, on charge, on donne les coordonnées, on blit et on flip. ;) Bon pour vous montrer je vais ajouter une personne qui tiendra compagnie à Aeris...</p><pre id="r-339182" data-claire-element-id="339182"><code data-claire-semantic="java">public class Images {

	public static void main(String[] args) throws SDLException {
		
		// Gestion des événements 1/2
		SDLEvent event = null;
		boolean boucle = true;
		
		// Initialisation de SDL et de l'affichage
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLVideo.wmSetCaption(&quot;Des images avec sdljava&quot;, null);
		SDLSurface screen = SDLVideo.setVideoMode(640, 480, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		
		// Chargement des images
		SDLSurface aeris = SDLImage.load(&quot;images/aerith.png&quot;);
		SDLSurface zack = SDLImage.load(&quot;images/zack.png&quot;);
		SDLRect aerisPos = new SDLRect(0, 0);
		SDLRect zackPos = new SDLRect(300, 50);
		
		
		while (boucle)
		{
			event = SDLEvent.waitEvent();
			if (event.getType() == SDLEvent.SDL_QUIT)
				boucle = false;
			
			aeris.blitSurface(screen, aerisPos);
			zack.blitSurface(screen, zackPos);
			screen.flip();
		}
		
		// On quitte :: Libération de la mémoire
		aeris.freeSurface();
		zack.freeSurface();
		screen.freeSurface();
		SDLMain.quit();
	}

}</code></pre><p id="r-339183" data-claire-element-id="339183">Ce qui nous donne :</p><figure id="r-339185" data-claire-element-id="339186"><img id="r-339184" data-claire-element-id="339184" src="medias/uploads.siteduzero.com_files_134001_135000_134582.jpg" alt="aeris et zack non travaillé"/></figure><p id="r-339187" data-claire-element-id="339187">:( Mais c'est horrible ! Oui il fraudait que l'image ne soit pas rectangulaire, et qu'elle ait la forme de Zack... Bon pas de panique on va voir ça. ;)</p><h3 id="r-couleur-de-transparence" data-claire-element-id="339213">Couleur de transparence</h3><p id="r-339189" data-claire-element-id="339189">La bibliothèque SDL permet de définir une couleur de transparence, qui ne sera donc pas affichée. Vous avez vu que l'image que j'ai ajoutée a un fond rose, qui correspond au code de couleur 255, 0, 255 : on va donc dire à SDL de la rendre transparente, ce qui aura pour effet l'affichage correct de la deuxième image. Pour réaliser cela nous devrons utiliser UNE nouvelle méthode (oui juste une), la méthode <code data-claire-semantic="java">setColorKey() </code>qui prendra deux paramètres :</p><ul id="r-339194" data-claire-element-id="339194"><li id="r-339191" data-claire-element-id="339191"><p id="r-339190" data-claire-element-id="339190">une constante,</p></li><li id="r-339193" data-claire-element-id="339193"><p id="r-339192" data-claire-element-id="339192">la couleur à rendre transparente.</p></li></ul><p id="r-339195" data-claire-element-id="339195">Pour le choix de la constante nous utiliserons <code data-claire-semantic="java">SDLVideo.SDL_SRCCOLORKEY </code>, elle indique à SDL qu'il faut rendre une couleur transparente. Pour la couleur on l'indiquera avec la méthode <code data-claire-semantic="java">mapRGP(int r, int g, int b) </code>.</p><p id="r-339196" data-claire-element-id="339196">Il faudra donc ajouter ce code avant la boucle principale (avant de bliter cela va de soit ;) ) :</p><pre id="r-339197" data-claire-element-id="339197"><code data-claire-semantic="java">// Affichage avec transparence
zack.setColorKey(SDLVideo.SDL_SRCCOLORKEY, zack.mapRGB(255, 0, 255));</code></pre><p id="r-339198" data-claire-element-id="339198">Vous pouvez essayer ça fonctionne, mais il y a encore un autre moyen qui évite l'usage de <code data-claire-semantic="java">setColorKey </code> : l'utilisation d'une image au format png, qui inclue un canal alpha !</p><div id="r-339200" data-claire-element-id="339200" data-claire-semantic="question"><p id="r-339199" data-claire-element-id="339199">C'est quoi un canal Alpha ?</p></div><p id="r-339201" data-claire-element-id="339201">Pour faire simple c'est une couleur de transparence, qui est généralement représentée par des damiers.</p><figure id="r-339203" data-claire-element-id="339204"><img id="r-339202" data-claire-element-id="339202" src="medias/uploads.siteduzero.com_files_134001_135000_134681.jpg" alt="tranparence the gimp"/></figure><p id="r-339205" data-claire-element-id="339205">La transparence dans The Gimp.</p><p id="r-339206" data-claire-element-id="339206">Il faut donc que votre image contienne un canal alpha avec cette couleur (les damiers) et qu'elle soit au format png. Lorsque vous la chargerez, SDL comprendra tout de suite que cette image contient un canal alpha et l'appliquera automatiquement (merci SDL_image).</p><p id="r-339207" data-claire-element-id="339207">Voilà le résultat :</p><figure id="r-339209" data-claire-element-id="339210"><img id="r-339208" data-claire-element-id="339208" src="medias/uploads.siteduzero.com_files_134001_135000_134682.jpg" alt="transparence fini"/></figure><p id="r-339211" data-claire-element-id="339211">C'est bon cette fois-ci. :)</p><p id="r-339212" data-claire-element-id="339212">Je ne vous redonne pas tout le code, car il y a juste une méthode à ajouter avant la boucle <code data-claire-semantic="java">while </code>, donc je pense que vous vous en sortirez sans problème.</p><h3 id="r-donner-de-la-transparence-a-l-image" data-claire-element-id="339241">Donner de la transparence à l'image</h3><p id="r-339214" data-claire-element-id="339214">Nous allons voir comment donner de la transparence à une image avec la méthode <code data-claire-semantic="java">setColorKey() </code>. Cette méthode prend deux paramètres qui sont :</p><ul id="r-339219" data-claire-element-id="339219"><li id="r-339216" data-claire-element-id="339216"><p id="r-339215" data-claire-element-id="339215">une constante,</p></li><li id="r-339218" data-claire-element-id="339218"><p id="r-339217" data-claire-element-id="339217">le taux de transparence, compris entre 0 et 255.</p></li></ul><p id="r-339220" data-claire-element-id="339220">La constante sert à activer le mode Alpha, cela va en quelque sorte fondre l'image sur le fond d'écran, nous utiliserons donc pour cela <code data-claire-semantic="java">SDLVideo.SDL_SRCCOLORKEY </code>. Sachez que si à la place de cette constante vous mettez 0, cela aura pour effet de ne pas activer la couleur Alpha. Pour ce qui est de la transparence, une valeur de 0 rendra votre image complètement transparente, une valeur de 255 la rendra complètement visible. Vous pouvez donc essayer ce code :</p><pre id="r-339221" data-claire-element-id="339221"><code data-claire-semantic="java">// Chargement d'une image et position
SDLSurface jim = SDLImage.load(&quot;images/jim.bmp&quot;);
jim.setColorKey(SDLVideo.SDL_SRCCOLORKEY, jim.mapRGB(255, 0, 255));
SDLRect jimPos = new SDLRect(120, 50);
		
// Gestion de la transparence
jim.setAlpha(SDLVideo.SDL_SRCALPHA, 15);</code></pre><p id="r-339222" data-claire-element-id="339222">Commentons se code : jim est le nom de l'image et le nom de mon objet de type <code data-claire-semantic="java">SDLSurface </code>. J'applique dans un premier temps la couleur de transparence de l'image avec <code data-claire-semantic="java">jim.setColorKey(...); </code>, puis je définis une position sur la fenêtre. Ensuite j'applique un taux de transparence à mon image de 15 (on ne voit presque pas l'image).</p><p id="r-339223" data-claire-element-id="339223">Voilà quelques exemples :</p><figure id="r-339225" data-claire-element-id="339226"><img id="r-339224" data-claire-element-id="339224" src="medias/uploads.siteduzero.com_files_134001_135000_134740.jpg" alt="tranparence alpha15"/></figure><p id="r-339227" data-claire-element-id="339227">Taux de transparence : 15</p><figure id="r-339229" data-claire-element-id="339230"><img id="r-339228" data-claire-element-id="339228" src="medias/uploads.siteduzero.com_files_134001_135000_134741.jpg" alt="tranparence alpha80"/></figure><p id="r-339231" data-claire-element-id="339231">Taux de transparence : 80</p><figure id="r-339233" data-claire-element-id="339234"><img id="r-339232" data-claire-element-id="339232" src="medias/uploads.siteduzero.com_files_134001_135000_134742.jpg" alt="tranparence alpha200"/></figure><p id="r-339235" data-claire-element-id="339235">Taux de transparence : 200</p><p id="r-339236" data-claire-element-id="339236">Voici le code qui a permis de réaliser ces captures d'écran :</p><pre id="r-339237" data-claire-element-id="339237"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.event.SDLEvent;
import sdljava.image.SDLImage;
import sdljava.video.SDLRect;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;

public class Alpha {

	public static void main(String[] args) throws SDLException {
		
		// Evenements 1/2
		SDLEvent event = null;
		boolean boucle = true;
		
		// Initialisation de SDL et de l'affichage
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLVideo.wmSetCaption(&quot;Gestion de la transparence&quot;, null);
		SDLSurface screen = SDLVideo.setVideoMode(320, 240, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		
		// Chargement d'une image et position
		SDLSurface jim = SDLImage.load(&quot;images/jim.bmp&quot;);
		jim.setColorKey(SDLVideo.SDL_SRCCOLORKEY, jim.mapRGB(255, 0, 255));
		SDLRect jimPos = new SDLRect(120, 50);
		
		// Gestion de la transparence
		jim.setAlpha(SDLVideo.SDL_SRCALPHA, 15);
		
		// Evénements 2/2
		while (boucle)
		{
			event = SDLEvent.waitEvent();
			if (event.getType() == SDLEvent.SDL_QUIT)
				boucle = false;
			
			screen.fillRect(screen.mapRGB(20, 150, 78));
			jim.blitSurface(screen, jimPos);
			screen.flip();
		}

		// Fin du programme
		jim.freeSurface();
		screen.freeSurface();
		SDLMain.quit();
	}

}</code></pre><p id="r-339238" data-claire-element-id="339238">Cette partie est terminée, je vous avais dit que c'était court, mais avouez que vous avez appris plein de nouvelles choses non ?</p><p id="r-339239" data-claire-element-id="339239">On a enfin fini ! Vous êtes donc capables (rapidement normalement) de créer une petite application SDL qui affiche des formes et / ou des images.</p><p id="r-339240" data-claire-element-id="339240">La première partie est terminée. Faites une pause histoire de bien tout assimiler (le bourrage de crâne n'est pas une bonne solution ^^ ).</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java">Présentation de bibliothèque SDL en Java</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/les-bases-de-sdljava">
Les bases de sdljava
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/notions-intermediaires">
Notions intermédiaires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/annexes-26">
Annexes
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/notions-intermediaires">
<span class="next">Notions intermédiaires</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Notionsintermdiaires"></a><h2>Notions intermédiaires</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/les-bases-de-sdljava">
<span class="arrow"></span>
<span class="next">Les bases de sdljava</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/annexes-26">
<span class="next">Annexes</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-339244" data-claire-element-id="339244">Dans cette partie nous verrons (en partie) comment fonctionnent les événements, mais aussi comment ajouter du son, de la musique et comment écrire sur la fenêtre. Vous l'avez compris, nous n'allons pas nous ennuyer. ^^ Je vous proposerai aussi une introduction à OpenGL, ainsi qu'un petit TP pour clôturer cette partie.</p><h2 id="r-les-evenements-12" data-claire-element-id="339300">Les événements</h2><p id="r-339245" data-claire-element-id="339245">Nous voilà dans une partie riche, car c'est ici que nous allons communiquer avec notre fenêtre et par la même occasion lui donner un peu de vie. Dans un premier temps nous verrons la boucle d'événement avec les différents événements, puis nous nous intéresserons aux événements clavier, qui nous permettrons par exemple de déplacer un sprite sur l'écran. Sachez qu'après ce chapitre vous pourrez tenter de réaliser <a href="http://www.siteduzero.com/tutoriel-3-14130-tp-mario-sokoban.html">le jeu Mario Sokoban</a> proposé par M@teo21 dans son tutoriel <a href="http://www.siteduzero.com/tutoriel-3-14189-apprenez-a-programmer-en-c.html#part_14186">C/SDL</a>. Mais je vois que vous salivez déjà, alors c'est parti !</p><h3 id="r-les-bases-8" data-claire-element-id="339297">Les bases</h3><p id="r-339246" data-claire-element-id="339246">La lib SDL met à notre disposition un mécanisme assez simple pour gérer les événements, on distinguera d'ailleurs deux types d'événements dans ce tutoriel :</p><ul id="r-339251" data-claire-element-id="339251"><li id="r-339248" data-claire-element-id="339248"><p id="r-339247" data-claire-element-id="339247"><code data-claire-semantic="java">SDLEvent.waitEvent()</code></p></li><li id="r-339250" data-claire-element-id="339250"><p id="r-339249" data-claire-element-id="339249"><code data-claire-semantic="java">SDLEvent.pollEvent()</code></p></li></ul><p id="r-339252" data-claire-element-id="339252"><code data-claire-semantic="java">SDLEvent.waitEvent() </code> permet d'attendre qu'un événement se soit produit pour continuer ; dans le cas où il n'y a pas d'événement, cette méthode bloque le programme en attendant qu'elle en reçoive un, alors que <code data-claire-semantic="java">SDLEvent.pollEvent() </code> n'attend pas qu'un événement se soit produit et permet au programme de continuer ses traitements. Donc <code data-claire-semantic="java">SDLEvent.waitEvent() </code> utilisera moins de ressources processeur, alors que <code data-claire-semantic="java">SDLEvent.pollEvent() </code> utilisera plus de ressources processeur.</p><div id="r-339254" data-claire-element-id="339254" data-claire-semantic="question"><p id="r-339253" data-claire-element-id="339253">Dans quel cas les utiliser ?</p></div><p id="r-339255" data-claire-element-id="339255">Eh bien prenons le cas du jeu Mario Sokoban : si le joueur ne touche pas aux commandes, rien ne se passe à l'écran, le personnage ne bouge pas et le décor non plus ; en revanche, dès que le joueur utilise le clavier pour contrôler le personnage, celui-ci se déplace et le décor peut être amené à changer. On peut aussi penser au jeu d'échec, etc.</p><p id="r-339256" data-claire-element-id="339256">Maintenant prenons l'exemple du jeu Snake (non pas Metal Gears), ce bon vieux serpent doit se déplacer tout le temps quoi qu'il arrive, et si on utilise un événement de type <code data-claire-semantic="java">SDLEvent.waitEvent() </code>, alors celui-ci ne se déplacera que quand le joueur utilisera son clavier (sa souris ou sa manette).</p><p id="r-339257" data-claire-element-id="339257"><strong>Pour résumer</strong> : avec <code data-claire-semantic="java">SDLEvent.waitEvent() </code> l'affichage est mis à jour uniquement si un événement est détecté, et avec <code data-claire-semantic="java">SDLEvent.pollEvent() </code>, l'affichage est mis à jour tout le temps.</p><p id="r-339258" data-claire-element-id="339258">Nous utiliserons dans un premier temps les événements de type <code data-claire-semantic="java">SDLEvent.waitEvent() </code>. Pour gérer les événements vous devrez importer une nouvelle classe : <code data-claire-semantic="java">sdljava.event.SDLEvent </code>, et aussi créer ce que l'on appellera la <em>boucle principale</em> du programme.</p><p id="r-339259" data-claire-element-id="339259">Voilà comment vont se dérouler les opérations :ninja: :</p><pre id="r-339260" data-claire-element-id="339260"><code>Importation des classes

Début du programme principal
    Initialisation de sdljava
    Variable Running -&gt; true : boolean
    TantQue Running = true Faire
        Détecter les événements
        Si événements Faire
            Traitements
        Mettre à jour l'affichage
     FinTantQue
Fin du programme principal</code></pre><p id="r-339261" data-claire-element-id="339261">C'est le schéma typique d'un programme avec SDL. Si vous avez bien suivi ce que j'ai dit à propos de <code data-claire-semantic="java">SDLEvent.waitEvent() </code>, l'affichage ne sera mis à jour que si un événement est détecté. Passons aux choses sérieuses.</p><p id="r-339262" data-claire-element-id="339262">Le package <code data-claire-semantic="java">sdljava.event.*; </code> contient des méthodes static qui permettent de mettre en place le gestionnaire d'événements, mais aussi tout un tas de constantes très utiles comme <code data-claire-semantic="java">SDLEvent.SDL_QUIT </code> qui représente la fermeture de la fenêtre lorsque l'on clique sur la croix en haut à droite.</p><p id="r-339263" data-claire-element-id="339263">Voici tout de suite un exemple (vous avez assez patienté :lol: ) :</p><pre id="r-339264" data-claire-element-id="339264"><code data-claire-semantic="java">import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.*;
import sdljava.event.SDLEvent;


public class TutorielEvent {

	public static void main(String[] args) throws SDLException, InterruptedException {
			
		// Initialisation de notre contexte SDL
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLSurface screen = SDLVideo.setVideoMode(800, 600, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;Les événements avec SDLJava&quot;, null);

		// Variable de boucle
		boolean Running = true;
		
		while (Running) {
			
			SDLEvent event = SDLEvent.waitEvent();
			if (event.getType() == SDLEvent.SDL_QUIT)	Running = false;
			// Mise à jour de l'affichage
			screen.flip();
		}
		screen.freeSurface();
		SDLMain.quit();
	}
}</code></pre><p id="r-339265" data-claire-element-id="339265">Vous constaterez que ce code respecte à la lettre le schéma que j'ai indiqué plus haut. La boucle <code data-claire-semantic="java">while </code> va permettre de récupérer les événements <strong>TantQue</strong> la variable <code data-claire-semantic="java">Running </code> est vraie. Pour cela on initialise un objet de type <code data-claire-semantic="java">SDLEvent </code> nommé ici <code data-claire-semantic="java">event </code>, avec la méthode static<code data-claire-semantic="java">SDLEvent.waitEvent() </code>. Une fois celle-ci opérationnelle, nous testons si un événement a eu lieu ou non. On utilise par exemple une structure conditionnelle <code data-claire-semantic="java">if </code>, mais vous verrez qu'un <code data-claire-semantic="java">switch </code> sera beaucoup plus efficace tout à l'heure. ^^</p><p id="r-339266" data-claire-element-id="339266">L'événement généré peut être de plusieurs types, et je vous invite à consulter la documentation sur <a href="http://sdljava.sourceforge.net/docs/api/">SDLEvent</a> pour plus d'informations. Grâce à la méthode <code data-claire-semantic="java">getEvent() </code> nous pouvons donc récupérer le type d'événement. On le compare ensuite à une des constantes ; ici il s'agit de la constante chargée de fermer le fenêtre qui nous intéresse, soit <code data-claire-semantic="java">SDLEvent.SDL_QUIT </code>, donc lorsque celle-ci sera détectée la variable <code data-claire-semantic="java">Running </code> sera fausse, et la boucle principale sera terminée, ce qui terminera notre programme.</p><p id="r-339267" data-claire-element-id="339267">Voici une petite liste de constantes :</p><table id="r-339295" data-claire-element-id="339295"><thead id="r-339273" data-claire-element-id="339273"><tr id="r-339272" data-claire-element-id="339272"><th id="r-339269" data-claire-element-id="339269"><p id="r-339268" data-claire-element-id="339268">Constante</p></th><th id="r-339271" data-claire-element-id="339271"><p id="r-339270" data-claire-element-id="339270">Déclenchement</p></th></tr></thead><tbody id="r-339294" data-claire-element-id="339294"><tr id="r-339278" data-claire-element-id="339278"><td id="r-339275" data-claire-element-id="339275"><p id="r-339274" data-claire-element-id="339274"><code data-claire-semantic="java">SDLEvent.SDL_QUIT</code></p></td><td id="r-339277" data-claire-element-id="339277"><p id="r-339276" data-claire-element-id="339276">Lorsque l'utilisateur clique sur la croix de fermeture de la fenêtre.</p></td></tr><tr id="r-339283" data-claire-element-id="339283"><td id="r-339280" data-claire-element-id="339280"><p id="r-339279" data-claire-element-id="339279"><code data-claire-semantic="java">SDLEvent.SDL_KEYDOWN</code></p></td><td id="r-339282" data-claire-element-id="339282"><p id="r-339281" data-claire-element-id="339281">Lorsqu'une touche est enfoncée.</p></td></tr><tr id="r-339288" data-claire-element-id="339288"><td id="r-339285" data-claire-element-id="339285"><p id="r-339284" data-claire-element-id="339284"><code data-claire-semantic="java">SDLEvent.SDL_KEYUP</code></p></td><td id="r-339287" data-claire-element-id="339287"><p id="r-339286" data-claire-element-id="339286">Lorsqu'une touche n'est pas enfoncée.</p></td></tr><tr id="r-339293" data-claire-element-id="339293"><td id="r-339290" data-claire-element-id="339290"><p id="r-339289" data-claire-element-id="339289"><code data-claire-semantic="java">SDLEvent.SDL_VIDEORESIZE</code></p></td><td id="r-339292" data-claire-element-id="339292"><p id="r-339291" data-claire-element-id="339291">Lorsque l'utilisateur modifie la taille de la fenêtre.</p></td></tr></tbody></table><p id="r-339296" data-claire-element-id="339296">Il y en a d'autres, et vous les trouverez toutes dans la <a href="http://sdljava.sourceforge.net/docs/api/">documentation</a>.</p><h3 id="r-les-evenements-clavier" data-claire-element-id="339299">Les événements clavier</h3><p id="r-339298" data-claire-element-id="339298">Le titre parle de lui-même, nous allons voir tout de suite comment détecter des événement venant du clavier, en particulier lorsque l'utilisateur va appuyer sur une touche. Nous utiliserons dans un premier temps un événement de type <code data-claire-semantic="java">SDLEvent.waitEvent() </code>, puis nous verrons ensuite comment fonctionne <code data-claire-semantic="java">SDLEvent.pollEvent() </code>.</p><h2 id="r-avec-sdlevent-waitevent" data-claire-element-id="339314">Avec SDLEvent.waitEvent()</h2><p id="r-339301" data-claire-element-id="339301">Pour gérer le clavier nous devons en premier lieu savoir si une touche a été pressée : si c'est le cas, nous devrons aviser en conséquence, sinon le programme continuera son exécution normale (c'est le principe de la boucle d'événements si vous vous souvenez). <br/> Nous devons importer deux nouvelles classes pour cela : <code data-claire-semantic="java">sdljava.event.SDLKeyboardEvent </code> et <code data-claire-semantic="java">sdljava.event.SDLKey </code>. Ensuite il faudra créer un nouvel objet de type <code data-claire-semantic="java">SDLKeyboardEvent </code> pour interagir avec le clavier, et enfin utiliser les constantes de <code data-claire-semantic="java">SDLKey </code> pour attribuer un traitement à une touche.</p><p id="r-339302" data-claire-element-id="339302">Voici un exemple qui utilise les événements clavier. Dans ce dernier, vous pouvez fermer la fenêtre avec la croix en haut à droite (<code data-claire-semantic="java">SDLEvent.SDL_QUIT </code>), mais vous pouvez aussi fermer l'application en appuyant sur la touche <em>Echap</em> (<code data-claire-semantic="java">SDLKey.SDLK_ESCAPE </code>).</p><pre id="r-339303" data-claire-element-id="339303"><code data-claire-semantic="java">import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.*;
import sdljava.event.SDLEvent;
import sdljava.event.SDLKeyboardEvent;
import sdljava.event.SDLKey;


public class TutorielEvent {

	public static void main(String[] args) throws SDLException, InterruptedException {
			
		// Initialisation de notre contexte SDL
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLSurface screen = SDLVideo.setVideoMode(800, 600, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;Les événements avec SDLJava&quot;, null);

		// Variable de boucle
		boolean Running = true;
		
		while (Running) {
			
			SDLEvent event = SDLEvent.waitEvent();
			
			if (event.getType() == SDLEvent.SDL_QUIT)	Running = false;
			// Si l'utilisateur presse une touche
			if (event.getType() == SDLEvent.SDL_KEYDOWN)
			{
				// On génère un nouvel événement de type SDLKeyboardEvent
				// Attention au cast !
				SDLKeyboardEvent eventK = (SDLKeyboardEvent) event;
				
				// Les méthodes getType() et getSym() se ressemblent sur le principe d'utilisation
				switch (eventK.getSym()) {
				
				// Si la touche espace est pressée 
				case SDLKey.SDLK_ESCAPE:	Running = false;        break;
				}
			}
			// Mise à jour de l'affichage
			screen.flip();
		}
		screen.freeSurface();
		SDLMain.quit();
	}
}</code></pre><p id="r-339304" data-claire-element-id="339304">Je pense que vous avez compris comment fonctionnent les événements clavier, mais je vais reprendre quelques points car de nouveaux éléments sont apparus. :magicien:</p><p id="r-339305" data-claire-element-id="339305"><code data-claire-semantic="java">if (event.getType() == SDLEvent.SDL_KEYDOWN)</code></p><p id="r-339306" data-claire-element-id="339306">Ici, on effectue un test pour voir si une touche (n'importe laquelle) a été pressée.</p><p id="r-339307" data-claire-element-id="339307"><code data-claire-semantic="java">SDLKeyboardEvent eventK = (SDLKeyboardEvent) event;</code></p><p id="r-339308" data-claire-element-id="339308">Quel code barbare vous ne trouvez pas ? :soleil: L'objet <code data-claire-semantic="java">event </code> créé tout à l'heure ne peut pas gérer les touches du clavier, il faut donc faire appel à un autre objet de type <code data-claire-semantic="java">SDLKeyboardEvent </code> pour effectuer ce traitement. Ce nouvel objet est initialisé avec l'objet <code data-claire-semantic="java">event </code> précédent, sauf que celui-ci sera vu comme un événement de type <code data-claire-semantic="java">SDLKeyboardEvent </code>. Voilà pourquoi on fait un cast (ou conversion explicite).</p><p id="r-339309" data-claire-element-id="339309"><code data-claire-semantic="java">switch (eventK.getSym())</code></p><p id="r-339310" data-claire-element-id="339310">J'ai utilisé une instruction <code data-claire-semantic="java">switch </code>, mais j'aurais pu utiliser une instruction <code data-claire-semantic="java">if </code> comme tout à l'heure. D'ailleurs pourquoi le <code data-claire-semantic="java">switch </code> ? Eh bien ici, aucun intérêt, mais plus bas vous comprendrez pourquoi. En effet, lorsque vous aurez plusieurs touches à gérer, cette méthode sera particulièrement efficace. On utilise la méthode <code data-claire-semantic="java">getSym() </code> qui nous permet de savoir quelle touche a été enfoncée ; cette méthode est comparable à <code data-claire-semantic="java">getType() </code>.</p><p id="r-339311" data-claire-element-id="339311"><code data-claire-semantic="java">case SDLKey.SDLK_ESCAPE: Running = false;</code></p><p id="r-339312" data-claire-element-id="339312">Et c'est ici, grâce à la constante <code data-claire-semantic="java">SDLKey.SDLK_ESCAPE </code> que l'on passe notre variable <code data-claire-semantic="java">Running </code> à la valeur <code data-claire-semantic="java">false </code>, ce qui aura pour effet de fermer l'application.</p><p id="r-339313" data-claire-element-id="339313">Nous voilà au point sur les événements clavier de type <code data-claire-semantic="java">waitEvent() </code>, mais qu'en est-il avec <code data-claire-semantic="java">pollEvent </code> ?</p><h2 id="r-avec-sdlevent-pollevent" data-claire-element-id="339368">Avec SDLEvent.pollEvent()</h2><p id="r-339315" data-claire-element-id="339315">Voici le même code avec une gestion des événements de type <code data-claire-semantic="java">pollEvent </code> :</p><pre id="r-339316" data-claire-element-id="339316"><code data-claire-semantic="java">import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.*;
import sdljava.event.SDLEvent;
import sdljava.event.SDLKeyboardEvent;
import sdljava.event.SDLKey;


public class TutorielEvent {

	public static void main(String[] args) throws SDLException, InterruptedException {
			
		// Initialisation de notre contexte SDL
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLSurface screen = SDLVideo.setVideoMode(800, 600, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;Les événements avec SDLJava&quot;, null);

		// Variable de boucle
		boolean Running = true;
		
		while (Running) {
			
			// On utilise pollEvent() comme gestionnaire d'événements
			SDLEvent event = SDLEvent.pollEvent();
			
			// Si un événement de type SDLEvent est détecté faire
			if (event instanceof SDLEvent ) {
				switch (event.getType()) {
				case SDLEvent.SDL_QUIT:		Running = false;	break;
				}
			}
			
			// Si un événement de type SDLKeyboardEvent est détecté faire
			if (event instanceof SDLKeyboardEvent ) {
				SDLKeyboardEvent eventK = (SDLKeyboardEvent) event;
				
				switch (eventK.getSym()) {
				
				case SDLKey.SDLK_ESCAPE:	Running = false;	break;
				}
			}
			// Mise à jour de l'affichage
			screen.flip();
		}
		screen.freeSurface();
		SDLMain.quit();
	}
}</code></pre><aside id="r-339318" data-claire-element-id="339318" data-claire-semantic="warning"><p id="r-339317" data-claire-element-id="339317">Wahoo, les choses ont changé, ça ne fonctionne plus pareil !</p></aside><p id="r-339319" data-claire-element-id="339319">En effet, comme <code data-claire-semantic="java">pollEvent() </code> n'attend pas qu'un événement se soit produit pour rendre la main au programme principal, la détection n'est plus la même, mais cela ne doit pas vous faire peur pour autant. Si vous voulez plus d'informations sur l'opérateur <code data-claire-semantic="java">instanceof </code>, je vous invite à consulter <a href="http://www.labo-sun.com/catalog-definitions-instanceof.htm">ce lien</a>. Reprenons quelques lignes ensemble :</p><p id="r-339320" data-claire-element-id="339320"><code data-claire-semantic="java">if (event instanceof SDLEvent )</code></p><p id="r-339321" data-claire-element-id="339321">Si je traduis littéralement, cela nous donne quelque chose comme : <em>« Si l'objet event est de type SDLEvent alors... »</em>. La suite vous la connaissez, car elle est identique aux deux types de gestion des événements.</p><p id="r-339322" data-claire-element-id="339322">Voilà qui conclut cette partie, nous allons voir maintenant quelques petits trucs sympathiques et utiles.</p><h3 id="r-la-gestion-du-temps-1" data-claire-element-id="339329">La gestion du temps</h3><p id="r-339323" data-claire-element-id="339323">Maintenant que vous connaissez la différence entre <code data-claire-semantic="java">pollEvent() </code> et <code data-claire-semantic="java">waitEvent() </code> et tout ce qui est relatif à l'affichage, nous allons nous intéresser au temps.</p><p id="r-339324" data-claire-element-id="339324">Souvenez-vous, <code data-claire-semantic="java">pollEvent() </code> n'attend pas qu'il y ait un événement déclenché pour rendre la main au programme, alors que <code data-claire-semantic="java">waitEvent() </code> est dite « bloquante », car elle attend qu'un événement soit déclenché. Cela veut dire que dans un cas, on aura un programme qui ne consommera presque pas de ressources quand l'utilisateur ne fera rien, mais que dans un autre cas, si on ne maîtrise pas le temps, notre programme va monopoliser toutes les ressources processeur !</p><p id="r-339325" data-claire-element-id="339325">Nous allons commencer tout de suite avec deux exemples, un avec <code data-claire-semantic="java">pollEvent() </code> et un autre <code data-claire-semantic="java">waitEvent() </code> ; vous comprendrez ensuite où je veux en venir.</p><aside id="r-339327" data-claire-element-id="339327" data-claire-semantic="warning"><p id="r-339326" data-claire-element-id="339326">Voici les règles du jeu :</p></aside><p id="r-339328" data-claire-element-id="339328">Je vous demande simplement d'exécuter l'application et de ne <strong>RIEN</strong> faire ni <strong>RIEN</strong> bouger de façon à ne pas déclencher d'événements. Au bout de 20 secondes ou plus vous appuierez sur la touche <em>Echap </em>pour quitter et vous lirez les informations dans la console.</p><h3 id="r-avec-waitevent" data-claire-element-id="339336">Avec waitEvent()</h3><pre id="r-339330" data-claire-element-id="339330"><code data-claire-semantic="java">import java.io.IOException;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.*;
import sdljava.event.SDLEvent;
import sdljava.event.SDLKeyboardEvent;
import sdljava.event.SDLKey;

public class TutorielEvent {

	public static void main(String[] args) throws SDLException, IOException {
			
		// Initialisation de notre contexte SDL
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLSurface screen = SDLVideo.setVideoMode(800, 600, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;La gestion du temps avec SDL&quot;, null);

		// Temps d'initialisation : on divise par 1000 pour avoir une valeur en secondes
		long lastFrame = System.currentTimeMillis() / 1000;
		
		long i = 0;
		
		// Variable de boucle
		boolean Running = true;
		
		while (Running) {
			
			SDLEvent event = SDLEvent.waitEvent();
			
			switch (event.getType()) {
			
				case SDLEvent.SDL_QUIT:		Running = false;	break;
			
				case SDLEvent.SDL_KEYDOWN:	
					SDLKeyboardEvent kev = (SDLKeyboardEvent) event;
					switch (kev.getSym()) {
					
						case SDLKey.SDLK_ESCAPE:	Running = false;	break;
				}
			}
			
			// Mise à jour de l'affichage
			screen.flip();
			i++;
		}
		
		long frame = System.currentTimeMillis() / 1000;
		System.out.println(&quot;Temps passé avant la fermeture : &quot; + (frame - lastFrame) + &quot; secondes&quot;);
		System.out.println(&quot;L'affichage a été mis à jour : &quot; + i + &quot; fois&quot;);
		
		screen.freeSurface();
		SDLMain.quit();	
	}
}</code></pre><p id="r-339331" data-claire-element-id="339331">En effectuant le test 33 secondes, voici ce que j'obtiens :</p><pre id="r-339332" data-claire-element-id="339332"><code data-claire-semantic="console">Temps passé avant la fermeture : 33 secondes
L'affichage a été mis à jour : 3 fois</code></pre><div id="r-339334" data-claire-element-id="339334" data-claire-semantic="question"><p id="r-339333" data-claire-element-id="339333">Qu'est-ce que ça veut dire docteur ? Je croyais que la méthode <code data-claire-semantic="java">waitEvent() </code> était bloquante !</p></div><p id="r-339335" data-claire-element-id="339335">C'est normal, lorsque vous ne faites rien, l'affichage n'est pas mis à jour. Par contre quand vous avez appuyé sur la touche <em>Echap</em>, il y a un temps pour que l'application se termine. Maintenant voyons ce que ce même code donne avec l'autre type d'événement... (les règles sont identiques ^^ ).</p><h3 id="r-avec-pollevent" data-claire-element-id="339366">Avec pollEvent()</h3><pre id="r-339337" data-claire-element-id="339337"><code data-claire-semantic="java">import java.io.IOException;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.*;
import sdljava.event.SDLEvent;
import sdljava.event.SDLKeyboardEvent;
import sdljava.event.SDLKey;

public class TutorielEvent {

	public static void main(String[] args) throws SDLException, IOException {
			
		// Initialisation de notre contexte SDL
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLSurface screen = SDLVideo.setVideoMode(800, 600, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;La gestion du temps avec SDL&quot;, null);

		// Temps d'initialisation : on divise par 1000 pour avoir une valeur en secondes
		long lastFrame = System.currentTimeMillis() / 1000;
		
		long i = 0;
		
		// Variable de boucle
		boolean Running = true;
		
		while (Running) {
			
			// On utilise pollEvent() comme gestionnaire d'événement
			SDLEvent event = SDLEvent.pollEvent();
			
			// Si un événement de de type SDLEvent est détecté faire
			if (event instanceof SDLEvent ) {
				switch (event.getType()) {
				case SDLEvent.SDL_QUIT:		Running = false;	break;
				}
			}
			
			// Si un événement de de type SDLKeyboardEvent est détecté faire
			if (event instanceof SDLKeyboardEvent ) {
				SDLKeyboardEvent eventK = (SDLKeyboardEvent) event;
				
				switch (eventK.getSym()) {
				
				case SDLKey.SDLK_ESCAPE:	Running = false;	break;
				}
			}

			
			// Mise à jour de l'affichage
			screen.flip();
			i++;
		}
		
		long frame = System.currentTimeMillis() / 1000;
		System.out.println(&quot;Temps passé avant la fermeture : &quot; + (frame - lastFrame) + &quot; secondes&quot;);
		System.out.println(&quot;L'affichage a été mis à jour : &quot; + i + &quot; fois&quot;);
		
		screen.freeSurface();
		SDLMain.quit();	
	}
}</code></pre><p id="r-339338" data-claire-element-id="339338">En effectuant le test 19 secondes, voici ce que j'obtiens :</p><pre id="r-339339" data-claire-element-id="339339"><code data-claire-semantic="console">Temps passé avant la fermeture : 19 secondes
L'affichage a été mis à jour : 50028 fois</code></pre><aside id="r-339341" data-claire-element-id="339341" data-claire-semantic="warning"><p id="r-339340" data-claire-element-id="339340">Wahoooo l'affichage est mis à jour 50028 fois !!!</p></aside><p id="r-339342" data-claire-element-id="339342">Oui, et si vous avez suivi ce que j'ai dit jusqu'ici, c'est tout à fait normal car la méthode n'est pas bloquante. Je vous laisse donc imaginer l'impact sur les performances si on ne gère pas le temps...</p><div id="r-339344" data-claire-element-id="339344" data-claire-semantic="question"><p id="r-339343" data-claire-element-id="339343">Tu as une solution ?</p></div><p id="r-339345" data-claire-element-id="339345">Bien sûr ! :p SDLJava nous propose une classe <code data-claire-semantic="java">Timer </code> qui permet de faire deux choses (notez que la version C permet de faire plus de choses, mais nous avons un binding inachevé :( ) :</p><ul id="r-339350" data-claire-element-id="339350"><li id="r-339347" data-claire-element-id="339347"><p id="r-339346" data-claire-element-id="339346">Mettre le programme en pause <strong>n</strong><strong>milisecondes</strong> avec <code data-claire-semantic="java">SDLTimer.delay(long ms) </code> ;</p></li><li id="r-339349" data-claire-element-id="339349"><p id="r-339348" data-claire-element-id="339348">Récupérer le temps passé depuis l'initialisation du programme avec <code data-claire-semantic="java">SDLTimer.getTicks() </code>.</p></li></ul><div id="r-339352" data-claire-element-id="339352" data-claire-semantic="question"><p id="r-339351" data-claire-element-id="339351">Mais dis-moi, Java n'a pas déjà des fonctions similaires ?</p></div><p id="r-339353" data-claire-element-id="339353">Si, et vous les connaissez bien justement, puisque nous les avons déjà utilisées. ^^ Une dans la 1ère partie qui est <code data-claire-semantic="java">Thread.sleep(long ms) </code> et une autre dans cette partie qui est <code data-claire-semantic="java">System.currentTimeMillis() </code>.</p><p id="r-339354" data-claire-element-id="339354">Pour ce tutoriel, j'utiliserai donc les méthodes incluses directement dans Java, car c'est exactement la même chose. Si vous voulez utiliser les méthodes de SDLJava, il vous faudra importer le package <code data-claire-semantic="java">sdljava.SDLTimer; </code> et dans les deux cas il vous faudra gérer ou pas l'exception <code data-claire-semantic="java">InterruptedException </code>.</p><div id="r-339356" data-claire-element-id="339356" data-claire-semantic="question"><p id="r-339355" data-claire-element-id="339355">Bon c'est très bien tout ça mais si j'ai à utiliser <code data-claire-semantic="java">pollEvent() </code> comment dois-je faire ? o_O</p></div><aside id="r-339358" data-claire-element-id="339358" data-claire-semantic="information"><p id="r-339357" data-claire-element-id="339357">En limitant le taux de mise à jour de l'affichage bien sûr !</p></aside><p id="r-339359" data-claire-element-id="339359">Pour cela il existe plusieurs méthodes, comme détecter le nombre de frames par secondes, et de limiter en conséquence. Mais une solution assez simple est de placer un <code data-claire-semantic="java">Thread.sleep(15) </code> après la mise à jour de l'affichage.</p><p id="r-339360" data-claire-element-id="339360">Voici un exemple :</p><pre id="r-339361" data-claire-element-id="339361"><code data-claire-semantic="java">import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.*;
import sdljava.event.SDLEvent;
import sdljava.event.SDLKeyboardEvent;
import sdljava.event.SDLKey;


public class TutorielEvent {

	public static void main(String[] args) throws SDLException, InterruptedException {
			
		// Initialisation de notre contexte SDL
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLSurface screen = SDLVideo.setVideoMode(800, 600, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;La gestion du temps avec SDL&quot;, null);

		// Temps d'initialisation : on divise par 1000 pour avoir une valeur en secondes
		long lastTime = System.currentTimeMillis() / 1000;
		
		// Variables pour compter le nombre d'itérations
		long i = 0;
		
		// Variable de boucle
		boolean Running = true;
		
		while (Running) {
			
			// On utilise pollEvent() comme gestionnaire d'événement
			SDLEvent event = SDLEvent.pollEvent();
			
			// Si un événement de type SDLEvent est détecté faire
			if (event instanceof SDLEvent ) {
				switch (event.getType()) {
				case SDLEvent.SDL_QUIT:		Running = false;	break;
				}
			}
			
			// Si un événement de type SDLKeyboardEvent est détecté faire
			if (event instanceof SDLKeyboardEvent ) {
				SDLKeyboardEvent eventK = (SDLKeyboardEvent) event;
				
				switch (eventK.getSym()) {
				
				case SDLKey.SDLK_ESCAPE:	Running = false;	break;
				}
			}
			
			// Mise à jour de l'affichage
			screen.flip();
			i++;
			Thread.sleep(10);
			
		}
		
		long time = System.currentTimeMillis() / 1000;
		System.out.println(&quot;Temps écoulé : &quot; + (time - lastTime) + &quot; secondes&quot;);
		System.out.println(&quot;L'affichage a été mis à jour : &quot; + i + &quot; fois&quot;);
		System.out.println(&quot;Soit une moyenne de : &quot; + i / (time - lastTime) + &quot; frames par secondes&quot;);
		
		screen.freeSurface();
		SDLMain.quit();	
	}
}</code></pre><p id="r-339362" data-claire-element-id="339362">Et le résultat console :</p><pre id="r-339363" data-claire-element-id="339363"><code data-claire-semantic="console">Temps écoulé : 10 secondes
L'affichage a été mis à jour : 1055 fois
Soit une moyenne de : 105 frames par secondes</code></pre><p id="r-339364" data-claire-element-id="339364">Vous constatez qu'il y a moins de mises à jour de l'affichage, et c'est normal, nous sommes maintenant dans de bonnes conditions pour gérer l'affichage avec <code data-claire-semantic="java">pollEvent() </code>. :)</p><p id="r-339365" data-claire-element-id="339365">Passons maintenant à un exercice, histoire de voir si vous avez retenu la leçon... :pirate:</p><h3 id="r-exercice-diriger-un-sprite-a-l-ecran" data-claire-element-id="339367">Exercice : diriger un sprite à l'écran !</h3><h2 id="r-le-sujet-4" data-claire-element-id="339386">Le sujet</h2><p id="r-339369" data-claire-element-id="339369">Nous y voilà... vous allez enfin pouvoir charger un objet et le déplacer sur la fenêtre. ^^ Pour ce petit exercice je vais vous fournir un sprite à déplacer (bien que vous puissiez utiliser celui que vous voulez). Le but est de déplacer un petit avion dans quatre directions en gérant la vitesse de déplacement. Si on appuie sur la <strong>touche Shift Gauche</strong> lors du déplacement alors l'avion se déplace deux fois plus vite, sinon il se déplace à sa vitesse normale.</p><p id="r-339370" data-claire-element-id="339370">Voici le sprite en question :</p><figure id="r-339372" data-claire-element-id="339373"><img id="r-339371" data-claire-element-id="339371" src="medias/uploads.siteduzero.com_files_164001_165000_164998.gif" alt="plane"/></figure><aside id="r-339375" data-claire-element-id="339375" data-claire-semantic="information"><p id="r-339374" data-claire-element-id="339374">Quelques indications avant de commencer.</p></aside><p id="r-339376" data-claire-element-id="339376">Pour contrôler la vitesse de déplacement vous devrez créer une variable de type <code data-claire-semantic="java">boolean </code> d'état qui vaudra <code data-claire-semantic="java">true </code> si vous avez appuyé sur la touche gauche shift, ou <code data-claire-semantic="java">false </code> dans le cas où vous n'appuyez plus sur cette touche.</p><p id="r-339377" data-claire-element-id="339377">Vous devrez donc tester si un événement de type <code data-claire-semantic="java">SDLEvent.SDL_KEYUP </code> a été déclenché et traiter la variable en conséquence (ne la brutalisez pas non plus, hein ? :-° ).</p><p id="r-339378" data-claire-element-id="339378">Avant la boucle principale je vous conseille d'appeler la méthode <code data-claire-semantic="java">SDLEvent.enableKeyRepeat(long delay, long intervale) </code> où sont exprimés en millisecondes :</p><ul id="r-339383" data-claire-element-id="339383"><li id="r-339380" data-claire-element-id="339380"><p id="r-339379" data-claire-element-id="339379"><code data-claire-semantic="java">long delay </code> : le temps que doit rester enfoncée une touche pour activer la répétition des touches ;</p></li><li id="r-339382" data-claire-element-id="339382"><p id="r-339381" data-claire-element-id="339381"><code data-claire-semantic="java">intervale </code> : l'intervalle entre deux générations d'événements.</p></li></ul><p id="r-339384" data-claire-element-id="339384">Personnellement je fixe les valeurs à 10 toutes les deux, essayez de les changer, vous verrez le déplacement sera plus ou moins rapide.</p><p id="r-339385" data-claire-element-id="339385">Je vous ai tout dit, à vous de jouer !</p><h2 id="r-correction-114" data-claire-element-id="339390">Correction</h2><pre id="r-339387" data-claire-element-id="339387"><code data-claire-semantic="java">import sdljava.SDLException;
import sdljava.SDLMain;
import sdljava.event.SDLEvent;
import sdljava.event.SDLKey;
import sdljava.event.SDLKeyboardEvent;
import sdljava.image.SDLImage;
import sdljava.video.SDLRect;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;

public class ExerciceEvent {

	
	public static void main(String[] args) throws SDLException {
		
		// Initialisation de SDL
		SDLMain.init(SDLMain.SDL_INIT_VIDEO);
		SDLSurface screen = SDLVideo.setVideoMode(640, 480, 32, SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_HWSURFACE);
		SDLVideo.wmSetCaption(&quot;My Java Shoot Them Up Baby ;)&quot;, null);
		
		// Création de l'objet joueur
		SDLSurface plane = SDLImage.load(&quot;plane.gif&quot;);
		int positionPlaneX = screen.getWidth() / 2 - plane.getWidth() / 2;
		int positionPlaneY = screen.getHeight() / 2 - plane.getHeight() / 2;
		boolean acceleration = false;
		
		boolean isRunning = true;
		SDLEvent.enableKeyRepeat(10, 10);
		
		do
		{
			SDLEvent event = SDLEvent.waitEvent();
			
			if (event.getType() == SDLEvent.SDL_QUIT)		
				isRunning = false;
			
			// Si la touche Shift de gauche n'est pas pressée,
			// pas d'accélération
			if (event.getType() == SDLEvent.SDL_KEYUP) {
				
				SDLKeyboardEvent keyEventUp = (SDLKeyboardEvent) event;	
				
				if ( keyEventUp.getSym() == SDLKey.SDLK_LSHIFT )
					acceleration = false;
			}
			
			if (event.getType() == SDLEvent.SDL_KEYDOWN) {
				
				SDLKeyboardEvent keyEvent = (SDLKeyboardEvent) event;
				
				switch (keyEvent.getSym()) {
				
				case SDLKey.SDLK_LSHIFT:
					acceleration = true;	break;
				
				case SDLKey.SDLK_ESCAPE:	
					isRunning = false;		break;
				
				// On gère le déplacement avec ou sans accélération
				case SDLKey.SDLK_UP:
					if (acceleration)
						positionPlaneY -= 4;
					else
						positionPlaneY -= 2;
					break;
					
				case SDLKey.SDLK_DOWN:
					if (acceleration)
						positionPlaneY += 4;
					else
						positionPlaneY += 2;
					break;
					
				case SDLKey.SDLK_LEFT:	
					if (acceleration)
						positionPlaneX -= 4;
					else
						positionPlaneX -= 2;
					break;
					
				case SDLKey.SDLK_RIGHT:
					if (acceleration)
						positionPlaneX += 4;
					else
						positionPlaneX += 2;
					break;
				}
			}
			
			// On met à jour l'affichage
			screen.fillRect(screen.mapRGB(255, 255, 255));
			blit.blitSurface(positionPlaneX, positionPlaneY, plane, screen);
			screen.flip();
			
		} while (isRunning);
			
		// Libération de la mémoire
		plane.freeSurface();
		screen.freeSurface();
		SDLMain.quit();
	}
}

/*
 * Cette méthode permet de bliter une SDLSurface sans avoir besoin de créer
 * plusieurs objets SDLRect. Dans le cas de cet exemple elle n'est pas très utile
 * mais dans le cas où vous avez plusieurs SDLSurfaces à bliter, elle montrera toute
 * son efficacité !
 */

class blit {
	static void blitSurface(int x, int y, SDLSurface src, SDLSurface dst) throws SDLException {
		SDLRect temp = new SDLRect(x, y);
		src.blitSurface(dst, temp);
	}
}</code></pre><p id="r-339388" data-claire-element-id="339388">Ce n'était pas trop dur, mais ne vous en faites pas, le but n'était pas de vous piéger, mais de vous faire pratiquer un peu. ;)</p><p id="r-339389" data-claire-element-id="339389">Eh bien nous avons vu pas mal de choses mine de rien. ;) J'espère que cette partie vous aura plu, car c'est la plus importante du tutoriel. En effet à partir de maintenant vous pouvez laisser libre cours à votre imagination et créer des petits jeux. J'ai tout de même une recommandation concernant les blocs <code data-claire-semantic="java">try... catch </code> : n'en abusez pas, car si vous faites un jeu utilisant de multiples classes, etc. ceux-ci vous limiteront et vous causeront bien des erreurs.</p><h2 id="r-jouez-du-son-et-de-la-musique" data-claire-element-id="339496">Jouez du son et de la musique</h2><p id="r-339391" data-claire-element-id="339391">Je vous l'annonce tout de suite : le plus dur est passé (quoique ?) ! Dans ce chapitre et le suivant nous allons aborder des points très faciles à comprendre et à mettre en place. ;) Comme l'indique le titre du chapitre, nous allons jouer de la musique et des sons avec SDL. Pour cela nous utiliserons les bibliothèques fournies avec SDLJava, j'ai nommé : SDL_audio et <a href="http://www.libsdl.org/projects/SDL_mixer/">SDL_mixer</a>.</p><h3 id="r-installation-de-sdl-mixer" data-claire-element-id="339393">Installation de SDL_mixer</h3><p id="r-339392" data-claire-element-id="339392">Comme vous devez vous en douter, <em>SDL_mixer</em> ne fait pas partie de <em>SDL </em>à l'origine, c'est une bibliothèque tierce, tout comme <em>SDL_image</em>. SDL_mixer permet d'apporter une couche au-dessus de <em>sdl_audio</em> (qui elle fait partie de SDL). Nous allons donc dans un premier temps récupérer les fichiers à ajouter à la racine de votre projet. Cependant je ne détaillerai pas l'installation cette fois-ci, car je l'ai déjà fait pour <em>SDL</em> et <em>SDL_image</em>, donc vous devez vous douter que les choses ne changent pas pour <em>SDL_mixer</em>.</p><h3 id="r-recuperer-les-bons-fichiers" data-claire-element-id="339427">Récupérer les bons fichiers</h3><p id="r-339394" data-claire-element-id="339394">Si vous vous rendez sur la page dédiée à <a href="http://www.libsdl.org/projects/SDL_mixer/">SDL_mixer</a>, vous avez le choix entre télécharger les sources, ou les fichiers binaires. Si vous êtes sous Linux et que vous n'avez pas installé libsdl-mixer, vous pouvez au choix, compiler les sources et récupérer comme nous l'avons fait le fichier .so ou bien installer le paquet qui correspond à votre distribution. Sous Windows vous avez juste à télécharger la version normale (celle qui n'est pas suffixée par -devel).</p><p id="r-339395" data-claire-element-id="339395">Dans tout les cas vous devrez copier les fichiers dans votre répertoire de projet.</p><aside id="r-339397" data-claire-element-id="339397" data-claire-semantic="information"><p id="r-339396" data-claire-element-id="339396">Et les fichiers, parlons-en !</p></aside><p id="r-339398" data-claire-element-id="339398">Sous Linux vous devez avoir :</p><ul id="r-339409" data-claire-element-id="339409"><li id="r-339400" data-claire-element-id="339400"><p id="r-339399" data-claire-element-id="339399">libSDL_mixer.a</p></li><li id="r-339402" data-claire-element-id="339402"><p id="r-339401" data-claire-element-id="339401">libogg.a</p></li><li id="r-339404" data-claire-element-id="339404"><p id="r-339403" data-claire-element-id="339403">libvorbis.a</p></li><li id="r-339406" data-claire-element-id="339406"><p id="r-339405" data-claire-element-id="339405">libvorbisfile.a</p></li><li id="r-339408" data-claire-element-id="339408"><p id="r-339407" data-claire-element-id="339407">libsmepg.a</p></li></ul><aside id="r-339411" data-claire-element-id="339411" data-claire-semantic="warning"><p id="r-339410" data-claire-element-id="339410">Pour pouvoir lire des fichiers midi, vous aurez besoin d'installer le paquet <a href="http://timidity.klik.atekon.de/">timidity</a>. De plus j'ai constaté que sur certaines distributions la lecture des fichiers midi était impossible (la faute à SDLJava pas à Linux).</p></aside><aside id="r-339413" data-claire-element-id="339413" data-claire-semantic="information"><p id="r-339412" data-claire-element-id="339412">Suivant votre distribution et le type d'installation que vous avez fait de la bibliothèque SDLJava, vous n'aurez besoin que de libSDL_mixer.a.</p></aside><p id="r-339414" data-claire-element-id="339414">Sous Windows vous devez avoir :</p><ul id="r-339425" data-claire-element-id="339425"><li id="r-339416" data-claire-element-id="339416"><p id="r-339415" data-claire-element-id="339415">libogg-0.dll</p></li><li id="r-339418" data-claire-element-id="339418"><p id="r-339417" data-claire-element-id="339417">libvorbis-0.dll</p></li><li id="r-339420" data-claire-element-id="339420"><p id="r-339419" data-claire-element-id="339419">libvorbisfile-3.dll</p></li><li id="r-339422" data-claire-element-id="339422"><p id="r-339421" data-claire-element-id="339421">SDL_mixer.dll</p></li><li id="r-339424" data-claire-element-id="339424"><p id="r-339423" data-claire-element-id="339423">smpeg.dll</p></li></ul><p id="r-339426" data-claire-element-id="339426">Maintenant que vous avez ces fichiers copiés, vous êtes prêt à travailler, alors passons à la suite.</p><h3 id="r-jouons-du-son-et-de-la-musique" data-claire-element-id="339495">Jouons du son et... de la musique</h3><p id="r-339428" data-claire-element-id="339428">Je ne sais pas si vous vous en souvenez, mais lorsque l'on initialise SDL avec la méthode <code data-claire-semantic="java">SDLMain.init() </code>, il faut spécifier des <code data-claire-semantic="java">flags </code> (drapeaux), et pour l'instant nous initialisions SDL uniquement en mode vidéo. Eh bien cela va changer, puisque nous allons maintenant initialiser en plus le son avec la constante <code data-claire-semantic="java">SDLMain.SDL_INIT_AUDIO </code>.</p><p id="r-339429" data-claire-element-id="339429">De plus nous devons importer plusieurs nouvelles classes, donc dans un souci de simplicité nous ferons un import... de groupe. ^^</p><pre id="r-339430" data-claire-element-id="339430"><code data-claire-semantic="java">import sdljava.audio.*;
import sdljava.mixer.*;</code></pre><p id="r-339431" data-claire-element-id="339431">La classe <code data-claire-semantic="java">SDLAudio </code> contient des constantes que nous utiliserons pour initialiser le son. Quant à la classe <code data-claire-semantic="java">SDLMixer </code>, elle contient des méthodes <code data-claire-semantic="java">static </code> pour jouer des sons et de la musique.</p><p id="r-339432" data-claire-element-id="339432">Concernant les formats, vous pouvez charger du wave, mp3, ogg, midi. Pour une liste plus complète consultez la <a href="http://jcatki.no-ip.org:8080/SDL_mixer/">documentation</a>.</p><p id="r-339433" data-claire-element-id="339433">Vous en mourez d'envie, eh bien voilà un exemple qui permet avec les touches du pavé numérique de jouer un son et une musique. Nous commenterons cet exemple plus bas ne vous en faites pas. ;)</p><pre id="r-339434" data-claire-element-id="339434"><code data-claire-semantic="java">import sdljava.SDLMain;
import sdljava.SDLException;

import sdljava.audio.*;
import sdljava.mixer.*;
import sdljava.event.*;
import sdljava.video.*;

public class Son {
	public static void main(String [] args) throws SDLException {
		
		// On initialise en plus la constante SDL_INIT_AUDIO
		SDLMain.init(SDLMain.SDL_INIT_VIDEO | SDLMain.SDL_INIT_AUDIO);
		SDLSurface screen = SDLVideo.setVideoMode(320, 240, 32, SDLVideo.SDL_HWSURFACE | SDLVideo.SDL_DOUBLEBUF);
		SDLVideo.wmSetCaption(&quot;Du son avec SDL_mixer en Java&quot;, null);
		
		// Initialisation de SDLMixer
		SDLMixer.openAudio(44100, SDLAudio.AUDIO_S16SYS, 2 , 1024);
		// On passe le nombre de canaux de mixage à 32
		int result = SDLMixer.allocateChannels(32);
		if (result != 32) throw new SDLException(&quot;Impossible d'allouer 32 canaux de mixage&quot;);
		
		// Un objet de type MixChunk est utilisé pour charger un son
		MixChunk monSon = SDLMixer.loadWAV(&quot;beep.wav&quot;);
		// Un objet de type MixMusix est utilisé pour charger une musique
		MixMusic maMusique = SDLMixer.loadMUS(&quot;earth.ogg&quot;);
		
		boolean Running = true;
		
		do 
		{
			SDLEvent event = SDLEvent.waitEvent();
			
			if (event.getType() == SDLEvent.SDL_QUIT) Running = false;
			if (event.getType() == SDLEvent.SDL_KEYDOWN) 
			{
				SDLKeyboardEvent keyEvent = (SDLKeyboardEvent) event;
				
				switch (keyEvent.getSym())
				{
				case SDLKey.SDLK_ESCAPE:	Running = false;			break;
				case SDLKey.SDLK_KP1:		SDLMixer.playChannel(-1, monSon, 0);	break;
				case SDLKey.SDLK_KP2:		SDLMixer.playMusic(maMusique, 0);	break;
				case SDLKey.SDLK_KP3:		SDLMixer.pauseMusic();			break;
				case SDLKey.SDLK_KP4:		SDLMixer.resumeMusic();			break;
				case SDLKey.SDLK_KP5:		SDLMixer.haltMusic();			break;
				}
			}
		} while (Running);
		
		screen.freeSurface();
                // Libération des sons et musiques de la mémoire
                SDLMixer.freeChunk(monSon);
		SDLMixer.freeMusic(maMusique);
		SDLMixer.close();
		SDLMain.quit();
	}
}</code></pre><p id="r-339435" data-claire-element-id="339435">Certaines parties vous ont fait peur ? Mais non ! :p Vous allez voir c'est très simple, étudions un peu ce code :</p><pre id="r-339436" data-claire-element-id="339436"><code data-claire-semantic="java">SDLMain.init(SDLMain.SDL_INIT_VIDEO | SDLMain.SDL_INIT_AUDIO);</code></pre><p id="r-339437" data-claire-element-id="339437">Ici rien de bien nouveau, on utilise le « pipe » (opérateur OU bits à bits) pour ajouter une constante à l'initialisation, ici la vidéo et le son.</p><pre id="r-339438" data-claire-element-id="339438"><code data-claire-semantic="java">SDLMixer.openAudio(44100, SDLAudio.AUDIO_S16SYS, 2 , 1024);</code></pre><p id="r-339439" data-claire-element-id="339439">Voilà enfin un peu d'action de nouveauté. :D On utilise cette méthode (qui est <code data-claire-semantic="java">static </code> pour changer) pour initialiser SDLMixer, car on a dit à SDL d'initialiser la partie audio, mais nous n'avons pas initialisé la bibliothèque tierce SDL_mixer. La méthode <code data-claire-semantic="java">openAudio() </code> prend 4 paramètres de type entier <code data-claire-semantic="java">int </code> (rien que ça :p ) qui sont :</p><p id="r-339440" data-claire-element-id="339440">La fréquence : suivant la qualité de vos sons et musiques vous pouvez utiliser la fréquence que vous voulez. Il faut savoir que 44100 Hz est la fréquence utilisée par les CD audio.</p><p id="r-339441" data-claire-element-id="339441">Le format de sortie : suivant votre carte son vous pouvez utiliser les modes 8 et 16 bits. Vous noterez qu'il y a le suffixe SYS, qui correspond à Système. En fait suivant les systèmes et les cartes son, les formats de sorties sont codés en « little-endian » ou LSD (bit de poids faible) ou en « big-endian » ou MSB (bit de poids faible), le suffixe SYS prend le format de sortie du système sur lequel le programme s'exécute, vous n'avez donc pas à vous soucier de ça. Merci qui ? :-°</p><p id="r-339442" data-claire-element-id="339442">Le nombre de canaux sonores : suivant votre configuration, 1 pour du son mono, 2 pour du stéréo, etc.</p><p id="r-339443" data-claire-element-id="339443">La taille du buffer de sortie : c'est la taille à allouer au buffer de sortie tout simplement, vous pouvez augmenter la valeur du buffer si vous sollicitez beaucoup les sons/musiques, une valeur de 1024 par défaut fonctionne dans la plupart des cas.</p><pre id="r-339444" data-claire-element-id="339444"><code data-claire-semantic="java">int result = SDLMixer.allocateChannels(32);
if (result != 32) throw new SDLException(&quot;Impossible d'allouer 32 canaux de mixage&quot;);</code></pre><p id="r-339445" data-claire-element-id="339445">Cette méthode permet de choisir le nombre de canaux de mixage. On fixe généralement cette valeur à 32 avec les cartes son actuelles, mais si vous avez une Sound Blaster ou autre monstre de puissance sonore, vous pouvez augmenter cette valeur. On récupère dans une variable un code de retour. Si celui-ci est différent du nombre de canaux de mixage désiré, on lance une exception (cela veut bien entendu dire que l'allocation a échoué). Vous noterez que cette étape est facultative, en effet SDLMixer initialise lui-même avec des valeurs par défaut le nombre de canaux de mixage.</p><pre id="r-339446" data-claire-element-id="339446"><code data-claire-semantic="java">MixChunk monSon = SDLMixer.loadWAV(&quot;beep.wav&quot;);
MixMusic maMusique = SDLMixer.loadMUS(&quot;earth.ogg&quot;);</code></pre><p id="r-339447" data-claire-element-id="339447">Vous devez vous en douter, il faut bien créer de nouveaux objets pour « contenir » nos sons et musiques. Les objets de type MixChunk permettent donc de stocker des sons aux formats wave et ogg. Les objets de type MixMusic permettent eux de « stocker » (une musique est un flux on ne la stocke pas vraiment) les musiques aux formats wave, ogg, mp3 et midi.</p><aside id="r-339449" data-claire-element-id="339449" data-claire-semantic="information"><p id="r-339448" data-claire-element-id="339448">Les fichiers mp3 peuvent être longs à lancer (ce n'est pas une généralité).<br/> Les fichiers midi sont mal gérés.</p></aside><pre id="r-339450" data-claire-element-id="339450"><code data-claire-semantic="java">SDLMixer.freeChunk(monSon);
SDLMixer.freeMusic(maMusique);</code></pre><p id="r-339451" data-claire-element-id="339451">Vous noterez qu'à la fin de la boucle principale, à l'endroit où habituellement on libère les ressources comme les images, on libère maintenant les sons et musiques, ce qui est totalement logique non ?</p><p id="r-339452" data-claire-element-id="339452">On finit avec les méthodes (oui vous le savez mais je le répète :lol: <code>static...</code>) :</p><pre id="r-339453" data-claire-element-id="339453"><code data-claire-semantic="java">SDLMixer.playChannel(-1, monSon, 0);	
SDLMixer.playMusic(maMusique, 0);		
SDLMixer.pauseMusic();					
SDLMixer.resumeMusic();					
SDLMixer.haltMusic();</code></pre><p id="r-339454" data-claire-element-id="339454">La méthode <code data-claire-semantic="java">SDLMixer.playChannel() </code> permet de jouer un son, elle prend 3 paramètres :</p><ul id="r-339461" data-claire-element-id="339461"><li id="r-339456" data-claire-element-id="339456"><p id="r-339455" data-claire-element-id="339455">un numéro de canal pour y jouer le son ;</p></li><li id="r-339458" data-claire-element-id="339458"><p id="r-339457" data-claire-element-id="339457">un objet de type <code data-claire-semantic="java">MixChunk </code> (donc votre son) ;</p></li><li id="r-339460" data-claire-element-id="339460"><p id="r-339459" data-claire-element-id="339459">le nombre de répétitions (loop).</p></li></ul><p id="r-339462" data-claire-element-id="339462">Le numéro de canal a été fixé à -1, cela veut dire qu'on utilisera tous les canaux disponibles (dans notre exemple : 2 canaux).<br/> La méthode <code data-claire-semantic="java">SDLMixer.playMusic(maMusique, 0) </code> permet de jouer une musique, elle prend en paramètre un objet de type <code data-claire-semantic="java">MixMusic </code> (votre musique), ainsi que le nombre de répétitions (loop).</p><p id="r-339463" data-claire-element-id="339463">Les autres méthodes parlent d'elles-même je pense, pas vous ? Vous constaterez quand même qu'on ne peut contrôler qu'une musique à la fois avec cette structure, ce qui est normal. Par contre je vous invite à consulter la documentation de <a href="http://jcatki.no-ip.org:8080/SDL_mixer/">SDL_mixer</a> (version native) ainsi que celle de SDLJava pour voir le nombre de méthodes qu'il existe pour contrôler le son.</p><p id="r-339464" data-claire-element-id="339464">Vous pouvez par exemple :</p><table id="r-339492" data-claire-element-id="339492"><thead id="r-339470" data-claire-element-id="339470"><tr id="r-339469" data-claire-element-id="339469"><th id="r-339466" data-claire-element-id="339466"><p id="r-339465" data-claire-element-id="339465">Méthode</p></th><th id="r-339468" data-claire-element-id="339468"><p id="r-339467" data-claire-element-id="339467">Effet</p></th></tr></thead><tbody id="r-339491" data-claire-element-id="339491"><tr id="r-339475" data-claire-element-id="339475"><td id="r-339472" data-claire-element-id="339472"><p id="r-339471" data-claire-element-id="339471"><code data-claire-semantic="java">haltChannel(int channel)</code></p></td><td id="r-339474" data-claire-element-id="339474"><p id="r-339473" data-claire-element-id="339473">Stoppe un canal en particulier (peut être pratique pour jouer des effets à gauche ou à droite).</p></td></tr><tr id="r-339480" data-claire-element-id="339480"><td id="r-339477" data-claire-element-id="339477"><p id="r-339476" data-claire-element-id="339476"><code data-claire-semantic="java">setMusicPosition(double position)</code></p></td><td id="r-339479" data-claire-element-id="339479"><p id="r-339478" data-claire-element-id="339478">Permet de vous « déplacer » dans la musique (avancer ou reculer ;) ).</p></td></tr><tr id="r-339485" data-claire-element-id="339485"><td id="r-339482" data-claire-element-id="339482"><p id="r-339481" data-claire-element-id="339481"><code data-claire-semantic="java">volume(int channel, int volume)</code></p></td><td id="r-339484" data-claire-element-id="339484"><p id="r-339483" data-claire-element-id="339483">Permet de changer le volume général (son et musique).</p></td></tr><tr id="r-339490" data-claire-element-id="339490"><td id="r-339487" data-claire-element-id="339487"><p id="r-339486" data-claire-element-id="339486"><code data-claire-semantic="java">volumeMusic(int volume)</code></p></td><td id="r-339489" data-claire-element-id="339489"><p id="r-339488" data-claire-element-id="339488">Permet de ne changer le volume que des musiques (voir <code data-claire-semantic="java">volumeChunk(MixChunk chunk, int volume) </code> pour les sons).</p></td></tr></tbody></table><p id="r-339493" data-claire-element-id="339493">Étant donné que le chapitre n'est pas très long mais qu'il y a des éléments essentiels, je vous propose de finir sur un QCM. ;)</p><p id="r-339494" data-claire-element-id="339494">Voilà vous savez tout. ;) Nous allons dans le prochain chapitre écrire sur la fenêtre avec la bibliothèque <a href="http://www.libsdl.org/projects/SDL_ttf/">SDL_ttf</a>, vous verrez, c'est encore plus simple. :lol:</p><h2 id="r-du-texte-dans-votre-programme" data-claire-element-id="339590">Du texte dans votre programme</h2><p id="r-339497" data-claire-element-id="339497">Nous allons maintenant voir comment afficher du texte dans une fenêtre. Cela sera pratique pour afficher un menu, écrire un score ou afficher des informations diverses par exemple. Pour cela nous allons utiliser la bibliothèque <a href="http://www.libsdl.org/projects/SDL_ttf/">SDL_ttf</a>. Il vous faudra dans un premier temps procéder à l'installation de <em>SDL_ttf</em>, puis en dernier lieu télécharger des <em>fonts</em> pour les utiliser dans vos programmes.</p><h3 id="r-installation-et-preparation" data-claire-element-id="339498">Installation et préparation</h3><h3 id="r-installation-35" data-claire-element-id="339519">Installation</h3><p id="r-339499" data-claire-element-id="339499">Nous revoilà dans notre phase d'installation (c'est cool, non ? :D ). Dans un premier temps direction <a href="http://www.libsdl.org/projects/SDL_ttf">le site officiel de SDL_ttf</a>, pour y récupérer le paquet binaire contenant les fichiers dll dont nous avons besoin. Pour nos confrères Linuxiens les manipulations restent les mêmes. Copiez les fichiers dans votre répertoire de projet et vous êtes fin prêt pour commencer. ^^</p><p id="r-339500" data-claire-element-id="339500">Pour résumer un peu, voici les nouveaux fichiers que vous devez avoir :</p><p id="r-339501" data-claire-element-id="339501">Sous Linux vous devez avoir les fichiers suivants :</p><ul id="r-339508" data-claire-element-id="339508"><li id="r-339503" data-claire-element-id="339503"><p id="r-339502" data-claire-element-id="339502">libSDL_ttf.a ;</p></li><li id="r-339505" data-claire-element-id="339505"><p id="r-339504" data-claire-element-id="339504">libz.a ;</p></li><li id="r-339507" data-claire-element-id="339507"><p id="r-339506" data-claire-element-id="339506">vous devez avoir freetype installé.</p></li></ul><aside id="r-339510" data-claire-element-id="339510" data-claire-semantic="information"><p id="r-339509" data-claire-element-id="339509">Suivant votre distribution et le type d'installation que vous avez faite de la bibliothèque SDLJava, vous n'aurez besoin que de libSDL_ttf.</p></aside><p id="r-339511" data-claire-element-id="339511">Sous Windows vous devez avoir les fichiers suivants :</p><ul id="r-339518" data-claire-element-id="339518"><li id="r-339513" data-claire-element-id="339513"><p id="r-339512" data-claire-element-id="339512">SDL_ttf.dll ;</p></li><li id="r-339515" data-claire-element-id="339515"><p id="r-339514" data-claire-element-id="339514">libfreetype-6.dll ;</p></li><li id="r-339517" data-claire-element-id="339517"><p id="r-339516" data-claire-element-id="339516">zlib1.dll.</p></li></ul><h3 id="r-preparation-9" data-claire-element-id="339527">Préparation</h3><aside id="r-339521" data-claire-element-id="339521" data-claire-semantic="information"><p id="r-339520" data-claire-element-id="339520">Savez-vous ce qu'est un font ?</p></aside><p id="r-339522" data-claire-element-id="339522">Un font est un fichier de police d'écriture, c'est exactement comme quand sous OpenOffice vous sélectionnez une police d'écriture : c'est ce qu'on appelle un font. Dans ce tutoriel nous allons utiliser la bibliothèque tierce TrueTypeFont, et grâce à un fichier font au format .ttf nous pourrons afficher du texte sur la fenêtre. Si vous désirez plus d'informations sur ce format je vous recommande de visiter la page de <a href="http://fr.wikipedia.org/wiki/TrueType">Wikipédia</a>.</p><div id="r-339524" data-claire-element-id="339524" data-claire-semantic="question"><p id="r-339523" data-claire-element-id="339523">Bon c'est cool tout ça, mais les fichiers de font on les récupère où ?</p></div><p id="r-339525" data-claire-element-id="339525">Une recherche sur Google vous donnera bien des réponses (comme souvent), mais je vous propose un site qui est vraiment très complet, il s'appelle <a href="http://www.dafont.com/fr/">dafont</a> et vous y trouverez vraiment tout ce que vous voulez comme style d'écriture ! Du moderne au gothique en passant par le techno. Pour nos exemples, j'en utiliserai trois différents pour que vous puissiez voir les différences entre plusieurs fonts.</p><p id="r-339526" data-claire-element-id="339526">Vous avez téléchargé votre font ? Vous êtes prêt ? Alors <em>let's rock</em> !</p><h3 id="r-afficher-du-texte-6" data-claire-element-id="339529">Afficher du texte</h3><p id="r-339528" data-claire-element-id="339528">Je vous le dis tout de suite, un texte <strong>est</strong> une <code data-claire-semantic="java">SDLSurface </code>, donc nous utiliserons les même méthodes pour afficher du texte que pour afficher une image ou autre chose. Voyons un peu de quoi nous allons avoir besoin dans notre code.</p><h3 id="r-les-imports" data-claire-element-id="339533">Les imports</h3><p id="r-339530" data-claire-element-id="339530">Vous devez dans un premier temps importer deux nouvelles classes contenues dans le package <code data-claire-semantic="java">sdljava.ttf </code>.</p><p id="r-339531" data-claire-element-id="339531"><code data-claire-semantic="java">sdljava.ttf.SDLTTF </code> contient des méthodes (vous le savez pas vrai ? <code data-claire-semantic="java">static </code> :D ) qui permettent d'initialiser la bibliothèque, de la fermer, d'instancier des objets de type <code data-claire-semantic="java">SDLTrueTypeFont </code> en chargeant des fonts, et quelques autres qui ne nous seront pas utiles (mais rien ne vous empêche d'aller jeter un coup d'œil à la documentation).</p><p id="r-339532" data-claire-element-id="339532"><code data-claire-semantic="java">sdljava.ttf.TrueTypeFont </code> va nous permettre de choisir le type de rendu, ainsi que la couleur du texte à afficher.</p><h3 id="r-deroulement-des-operations" data-claire-element-id="339589">Déroulement des opérations</h3><ul id="r-339550" data-claire-element-id="339550"><li id="r-339535" data-claire-element-id="339535"><p id="r-339534" data-claire-element-id="339534">Initialiser <em>SDL_ttf</em> ;</p></li><li id="r-339537" data-claire-element-id="339537"><p id="r-339536" data-claire-element-id="339536">Créer un objet de type <code data-claire-semantic="java">SDLTrueTypeFont </code> ;</p></li><li id="r-339539" data-claire-element-id="339539"><p id="r-339538" data-claire-element-id="339538">Créer une <code data-claire-semantic="java">SDLSurface </code> et l'instancier avec la méthode adéquate ;</p></li><li id="r-339541" data-claire-element-id="339541"><p id="r-339540" data-claire-element-id="339540">Afficher la <code data-claire-semantic="java">SDLSurface </code> dans la boucle principale ;</p></li><li id="r-339543" data-claire-element-id="339543"><p id="r-339542" data-claire-element-id="339542">Libérer la <code data-claire-semantic="java">SDLSurface </code> ;</p></li><li id="r-339545" data-claire-element-id="339545"><p id="r-339544" data-claire-element-id="339544">Libérer l'objet <code data-claire-semantic="java">SDLTrueTypeFont </code> ;</p></li><li id="r-339547" data-claire-element-id="339547"><p id="r-339546" data-claire-element-id="339546">Fermer <em>SDL_ttf</em> ;</p></li><li id="r-339549" data-claire-element-id="339549"><p id="r-339548" data-claire-element-id="339548">... c'est fini ! ^^</p></li></ul><p id="r-339551" data-claire-element-id="339551">Ça fait un paquet de choses à faire, mais c'est nécessaire. Voyons tout de suite quelques méthodes clés, puis passons à l'exemple. :soleil: Nous commencerons dans l'ordre de la liste.</p><p id="r-339552" data-claire-element-id="339552">Pour initialiser SDL_ttf nous utiliserons la méthode (ok j'ai compris je m'en vais avec mes static :-° ) <code data-claire-semantic="java">SDLTTF.init() </code>. Pour la quitter nous utiliserons la méthode <code data-claire-semantic="java">SDLTTF.quit() </code>, les choses ne sont pas bien faites ? Exactement comme pour <code data-claire-semantic="java">SDLMain </code>. ^^</p><p id="r-339553" data-claire-element-id="339553">Ensuite il faudra créer un ou plusieurs objet(s) de type <code data-claire-semantic="java">SDLTrueTypeFont </code> que nous initialiserons avec la méthode <code data-claire-semantic="java">SDLTTF.openFont() </code>. Intéressons-nous 30 secondes à cette méthode. <code data-claire-semantic="java">SDLTTF.openFont() </code> prend en paramètres : un fichier font (c'est le fichier .ttf que vous avez récupéré tout à l'heure), et un entier représentatif de la taille du texte. On pourra donc créer un objet font comme suit :</p><pre id="r-339554" data-claire-element-id="339554"><code data-claire-semantic="java">SDLTrueTypeFont monFont = SDLTTF.openFont(&quot;sega.ttf&quot;, 24);</code></pre><p id="r-339555" data-claire-element-id="339555">À partir de là, vous êtes prêt à créer une <code data-claire-semantic="java">SDLSurface </code> qui va accueillir votre texte, et justement parlons-en. Pour créer un texte nous procéderons de cette manière :</p><pre id="r-339556" data-claire-element-id="339556"><code data-claire-semantic="java">SDLSurface monTexteSolid = monFont.renderTextSolid(&quot;Salut les zero&quot;, new SDLColor(0, 255, 0);</code></pre><p id="r-339557" data-claire-element-id="339557">La méthode <code data-claire-semantic="java">renderTextSolid(String texte, SDLColor couleur) </code> permet donc de créer une <code data-claire-semantic="java">SDLSurface </code> qui affichera votre texte, avec la couleur désirée. Vous noterez que pour la couleur j'ai utilisé la classe <code data-claire-semantic="java">SDLColor </code>, qui prend en paramètres trois entiers de 0 à 255, représentant votre couleur au format RGB. La classe <code data-claire-semantic="java">SDLColor </code> est à importer à partir du package <code data-claire-semantic="java">sdljava.SDLVideo </code>. Vous pouvez si vous le désirez créer des objets <code data-claire-semantic="java">SDLColor </code> avant, ce qui vous permettra dans le cas où vous avez à utiliser une couleur souvent de ne pas réécrire <code data-claire-semantic="java">new SDLColor(...) </code>.</p><p id="r-339558" data-claire-element-id="339558">Pour finir vous n'avez plus qu'à blitter avec la méthode <code data-claire-semantic="java">blitSurface() </code>.</p><div id="r-339560" data-claire-element-id="339560" data-claire-semantic="question"><p id="r-339559" data-claire-element-id="339559">Tu nous a parlé des types de rendu tout à l'heure, non ?</p></div><p id="r-339561" data-claire-element-id="339561">Oui, c'est vrai, et si votre éditeur comporte l'autocomplétion vous vous serez aperçu qu'il y a trois types de rendu de texte différents. Prenons un exemple :</p><pre id="r-339562" data-claire-element-id="339562"><code data-claire-semantic="java">SDLColor rouge = new SDLColor(255, 0, 0);
SDLColor vert = new SDLColor(0, 255, 0);
SDLColor bleu = new SDLColor(0, 0, 255);

SDLSurface monTexteSolid = monFont.renderTextSolid(&quot;Salut les zeros&quot;, bleu);
SDLSurface monTexteShaded = monFontCute.renderTextShaded(&quot;comment ca va&quot;, bleu, vert);
SDLSurface monTexteBlended = monFontPlainBlackWide.renderTextBlended(&quot;???&quot;, rouge);</code></pre><p id="r-339563" data-claire-element-id="339563">Comme vous le constatez, il y a 3 méthodes différentes pour choisir le type de rendu. La 1re est la plus simple, elle affiche du texte rapidement et simplement (pas de filtrage, rien), par contre la qualité n'est pas des meilleures. La deuxième par contre permet d'afficher le texte avec une couleur d'avant-plan (<em>foreground</em>) et une couleur d'arrière-plan (<em>background</em>) et est plus jolie, par contre elle est plus lente à afficher. Quant à la dernière elle est encore plus lente à afficher, mais c'est elle qui est la plus propre.</p><div id="r-339565" data-claire-element-id="339565" data-claire-semantic="question"><p id="r-339564" data-claire-element-id="339564">Mais qu'entends-tu par rapide, lent ?</p></div><p id="r-339566" data-claire-element-id="339566">Tout est relatif, mais un texte à rendu solid sera plus rapide à afficher qu'un texte à rendu blended. Faites donc le test avec <code data-claire-semantic="java">System.currentTimeMillis() </code> par exemple, mais de toute façon ça ne sera pas visible à l'œil nu (à part si votre programme ne fait qu'afficher du texte et surtout s'il en affiche abondamment !).</p><p id="r-339567" data-claire-element-id="339567">Et pour finir voici le code complet qui permet d'obtenir cette belle fenêtre ^^ :</p><figure id="r-339569" data-claire-element-id="339570"><img id="r-339568" data-claire-element-id="339568" src="medias/uploads.siteduzero.com_files_166001_167000_166640.jpg" alt="Image utilisateur"/></figure><pre id="r-339571" data-claire-element-id="339571"><code data-claire-semantic="java">import sdljava.SDLMain;
import sdljava.SDLException;

import sdljava.video.*;
import sdljava.event.*;

import sdljava.ttf.SDLTTF;
import sdljava.ttf.SDLTrueTypeFont;


public class Affichage {

	public static void main(String[] args) throws SDLException {

		SDLMain.init(SDLMain.SDL_INIT_VIDEO | SDLMain.SDL_INIT_AUDIO);
		SDLSurface screen = SDLVideo.setVideoMode(320, 240, 32, SDLVideo.SDL_HWSURFACE | SDLVideo.SDL_DOUBLEBUF);
		SDLVideo.wmSetCaption(&quot;Ecrivons avec sdl_ttf&quot;, null);

        // Initialisation de la bibliothèque SDL_ttf
        SDLTTF.init();
        // Ouverture d'un font
        SDLTrueTypeFont monFont = SDLTTF.openFont(&quot;data/sega.ttf&quot;, 24);
        SDLTrueTypeFont monFontCute = SDLTTF.openFont(&quot;data/cute.ttf&quot;, 36);
        SDLTrueTypeFont monFontPlainBlackWide = SDLTTF.openFont(&quot;data/plainblackwide.ttf&quot;, 36);


        SDLColor rouge = new SDLColor(255, 0, 0);
        SDLColor vert = new SDLColor(0, 255, 0);
        SDLColor bleu = new SDLColor(0, 0, 255);


        // Un texte à l'écran n'est qu'une SDLSurface
        SDLSurface monTexteSolid = monFont.renderTextSolid(&quot;Salut les zero&quot;, bleu);
        SDLSurface monTexteShaded = monFontCute.renderTextShaded(&quot;comment ca va&quot;, bleu, vert);
        SDLSurface monTexteBlended = monFontPlainBlackWide.renderTextBlended(&quot;???&quot;, rouge);

		boolean Running = true;

		do
		{
			SDLEvent event = SDLEvent.waitEvent();

			if (event.getType() == SDLEvent.SDL_QUIT) Running = false;
			
			// On efface l'écran
            screen.fillRect(screen.mapRGB(0, 0, 0));
           
            // On blit ;)
            Util.blit(10, 10, monTexteSolid, screen);
            Util.blit(50, 100, monTexteShaded, screen);
            Util.blit(200, 200, monTexteBlended, screen);

			screen.flip();
            
		} while (Running);

        monTexteSolid.freeSurface();
        monTexteBlended.freeSurface();
        monTexteShaded.freeSurface();
        // Attention 2 nouvelles ressources à libérer en plus des SDLSurface !
        monFont.closeFont();
        screen.freeSurface();
		SDLTTF.quit();
		SDLMain.quit();
	}

}
/**
 * Classe Util
 * Une classe à toujours avoir sous la main !
 */
final class Util {
    public static void blit(int x, int y, SDLSurface source, SDLSurface destination) throws SDLException {
        SDLRect position = new SDLRect(x, y);
        source.blitSurface(destination, position);
    }
}</code></pre><p id="r-339572" data-claire-element-id="339572">Ce chapitre n'était pas très dur mais je vous l'avais dit. Faisons le point, vous devez normalement savoir :</p><ul id="r-339583" data-claire-element-id="339583"><li id="r-339574" data-claire-element-id="339574"><p id="r-339573" data-claire-element-id="339573">Installer SDLJava, ainsi que ses dépendances ;</p></li><li id="r-339576" data-claire-element-id="339576"><p id="r-339575" data-claire-element-id="339575">Écrire un programme à base de <code data-claire-semantic="java">SDLSurface </code> ;</p></li><li id="r-339578" data-claire-element-id="339578"><p id="r-339577" data-claire-element-id="339577">Gérer les événements avec le clavier ;</p></li><li id="r-339580" data-claire-element-id="339580"><p id="r-339579" data-claire-element-id="339579">Rendre votre application plus vivante avec du son et de la musique ;</p></li><li id="r-339582" data-claire-element-id="339582"><p id="r-339581" data-claire-element-id="339581">Afficher les bonnes informations au bon endroit.</p></li></ul><p id="r-339584" data-claire-element-id="339584">Nous allons donc voir dans le prochain chapitre comment utiliser OpenGL pour le rendu graphique de votre application. Vous verrez qu'il n'y a pas grand-chose à changer.</p><aside id="r-339586" data-claire-element-id="339586" data-claire-semantic="warning"><p id="r-339585" data-claire-element-id="339585">Je ne ferai pas un cours sur OpenGL, pour ça vous avez plusieurs tutoriels disponibles sur ce site, dont celui de <a href="http://www.siteduzero.com/membres-294-5.html">Kayl</a> qui <a href="http://www.siteduzero.com/tutoriel-3-5014-creez-des-programmes-en-3d-avec-opengl.html">introduit OpenGL</a> en C avec SDL.</p></aside><p id="r-339587" data-claire-element-id="339587">Cependant j'aborderai certaines notions fondamentales, qui sont assez mal expliquées dans plusieurs tutoriels et que je me dois de vous exposer à ma façon (peut-être comprendrez-vous mieux ^^ ).</p><p id="r-339588" data-claire-element-id="339588">Vous en voulez encore ? Eh bien il ne vous reste plus qu'à pratiquer, et à laisser libre cours à votre imagination. ;) La consultation des annexes est vivement conseillée.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java">Présentation de bibliothèque SDL en Java</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/les-bases-de-sdljava">
Les bases de sdljava
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/notions-intermediaires">
Notions intermédiaires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/annexes-26">
Annexes
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/les-bases-de-sdljava">
<span class="arrow"></span>
<span class="next">Les bases de sdljava</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/annexes-26">
<span class="next">Annexes</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Annexes"></a><h2>Annexes</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/notions-intermediaires">
<span class="arrow"></span>
<span class="next">Notions intermédiaires</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-339592" data-claire-element-id="339592">Dans cette partie, vous trouverez un complément indispensable à votre apprentissage de sdljava, mais aussi diverses ressources pour vos futures créations.</p><h2 id="r-se-documenter-avec-sdljava" data-claire-element-id="339603">Se documenter avec SDLJava</h2><p id="r-339593" data-claire-element-id="339593">Voici une petite partie sur la documentation et les exemples que vous pouvez trouver sur internet pour vous aider dans votre développement. Comme vous le verrez nous avons à notre disposition trois sources d'informations principales :</p><ul id="r-339600" data-claire-element-id="339600"><li id="r-339595" data-claire-element-id="339595"><p id="r-339594" data-claire-element-id="339594">La documentation C de SDL</p></li><li id="r-339597" data-claire-element-id="339597"><p id="r-339596" data-claire-element-id="339596">La Javadoc de sdljava</p></li><li id="r-339599" data-claire-element-id="339599"><p id="r-339598" data-claire-element-id="339598">Les exemples du dépôt CVS</p></li></ul><h3 id="r-la-documentation-officielle-sdljava" data-claire-element-id="339602">La documentation Officielle SDLJava</h3><p id="r-339601" data-claire-element-id="339601">Je vais vous présenter rapidement la documentation officielle qui n'est en fait que la javadoc. Il n'existe à ma connaissance aucun tutoriels traitent du sujet de sdljava en particulier, mais pas de panique ! Vous allez voir qu'avec sdljava c'est exactement comme SDL en C et même OpenGL ! Un tutoriel C/C++ fait l'affaire ;) bien sur il vous faudra chercher par vous même le comportement de certaines fonctions (par exemple le type <code data-claire-semantic="cpp">unsigned byte</code> n'existe pas en Java, donc il sera remplacé par un équivalent, etc...).</p><h2 id="r-le-site-officiel-de-sdljava" data-claire-element-id="339764">Le site officiel de sdljava</h2><p id="r-339604" data-claire-element-id="339604">Alors rendez vous sur le site officiel, rubrique <a href="http://sdljava.sourceforge.net/documentation.html">documentation</a>. Vous aurez alors trois choix (c'est peux je sais :-° )</p><ul id="r-339611" data-claire-element-id="339611"><li id="r-339606" data-claire-element-id="339606"><p id="r-339605" data-claire-element-id="339605"><a href="http://www.libsdl.org/">SDL API</a></p></li><li id="r-339608" data-claire-element-id="339608"><p id="r-339607" data-claire-element-id="339607"><a href="http://sdljava.sourceforge.net/docs/api">Javadoc API Docs</a></p></li><li id="r-339610" data-claire-element-id="339610"><p id="r-339609" data-claire-element-id="339609"><a href="http://byteschreck.blogspot.com/2005/11/this-is-simple-step-by-step-tutorial.html">Tutorials : How to setup Eclipse on Windows</a></p></li></ul><p id="r-339612" data-claire-element-id="339612">Celui qui va nous intéresser pour le moment sera le deuxième : <a href="http://sdljava.sourceforge.net/docs/api">Javadoc API Docs</a>. J'espère que la javadoc ne vous est pas étrangère, si c'est le cas il existe plusieurs ressources sur internet traitant du sujet. Nous avons donc acces à toutes les méthodes et constantes de sdljava, au passage vous remarquerez qu'il y a un module <code data-claire-semantic="java">sdljavax.gui</code>qui permet de créer des IHM.</p><p id="r-339613" data-claire-element-id="339613">Je vous présente rapidement le contenu des packages :</p><table id="r-339691" data-claire-element-id="339691"><thead id="r-339619" data-claire-element-id="339619"><tr id="r-339618" data-claire-element-id="339618"><th id="r-339615" data-claire-element-id="339615"><p id="r-339614" data-claire-element-id="339614">Package</p></th><th id="r-339617" data-claire-element-id="339617"><p id="r-339616" data-claire-element-id="339616">Contenu</p></th></tr></thead><tbody id="r-339690" data-claire-element-id="339690"><tr id="r-339624" data-claire-element-id="339624"><td id="r-339621" data-claire-element-id="339621"><p id="r-339620" data-claire-element-id="339620">opengl</p></td><td id="r-339623" data-claire-element-id="339623"><p id="r-339622" data-claire-element-id="339622">Pour un rendu avec OpenGL (contient GL, GLU, Glew, ftgl, etc...)</p></td></tr><tr id="r-339629" data-claire-element-id="339629"><td id="r-339626" data-claire-element-id="339626"><p id="r-339625" data-claire-element-id="339625">sdljava</p></td><td id="r-339628" data-claire-element-id="339628"><p id="r-339627" data-claire-element-id="339627">Constantes d'initialisation ainsi que les Timer, mais aussi tous les autres packages</p></td></tr><tr id="r-339634" data-claire-element-id="339634"><td id="r-339631" data-claire-element-id="339631"><p id="r-339630" data-claire-element-id="339630">audio</p></td><td id="r-339633" data-claire-element-id="339633"><p id="r-339632" data-claire-element-id="339632">Méthodes relatives à sdl_audio</p></td></tr><tr id="r-339639" data-claire-element-id="339639"><td id="r-339636" data-claire-element-id="339636"><p id="r-339635" data-claire-element-id="339635">cdrom</p></td><td id="r-339638" data-claire-element-id="339638"><p id="r-339637" data-claire-element-id="339637">Méthodes relatives aux accès CD-ROM</p></td></tr><tr id="r-339644" data-claire-element-id="339644"><td id="r-339641" data-claire-element-id="339641"><p id="r-339640" data-claire-element-id="339640">event</p></td><td id="r-339643" data-claire-element-id="339643"><p id="r-339642" data-claire-element-id="339642">Méthodes relatives aux événements avec les constantes etc...</p></td></tr><tr id="r-339649" data-claire-element-id="339649"><td id="r-339646" data-claire-element-id="339646"><p id="r-339645" data-claire-element-id="339645">image</p></td><td id="r-339648" data-claire-element-id="339648"><p id="r-339647" data-claire-element-id="339647">Méthode <code data-claire-semantic="java">load()</code> pour charger les images</p></td></tr><tr id="r-339654" data-claire-element-id="339654"><td id="r-339651" data-claire-element-id="339651"><p id="r-339650" data-claire-element-id="339650">joystick</p></td><td id="r-339653" data-claire-element-id="339653"><p id="r-339652" data-claire-element-id="339652">Gestion du joystick dans les événements</p></td></tr><tr id="r-339659" data-claire-element-id="339659"><td id="r-339656" data-claire-element-id="339656"><p id="r-339655" data-claire-element-id="339655">mixer</p></td><td id="r-339658" data-claire-element-id="339658"><p id="r-339657" data-claire-element-id="339657">Méthodes relatives à sdl_mixer</p></td></tr><tr id="r-339664" data-claire-element-id="339664"><td id="r-339661" data-claire-element-id="339661"><p id="r-339660" data-claire-element-id="339660">ttf</p></td><td id="r-339663" data-claire-element-id="339663"><p id="r-339662" data-claire-element-id="339662">Méthodes relatives à sdl_ttf</p></td></tr><tr id="r-339669" data-claire-element-id="339669"><td id="r-339666" data-claire-element-id="339666"><p id="r-339665" data-claire-element-id="339665">util</p></td><td id="r-339668" data-claire-element-id="339668"><p id="r-339667" data-claire-element-id="339667">Permet de créer des buffers pour utiliser les utiliser avec des flux</p></td></tr><tr id="r-339674" data-claire-element-id="339674"><td id="r-339671" data-claire-element-id="339671"><p id="r-339670" data-claire-element-id="339670">video</p></td><td id="r-339673" data-claire-element-id="339673"><p id="r-339672" data-claire-element-id="339672">Constantes et méthode pour la gestion de la vidéo</p></td></tr><tr id="r-339679" data-claire-element-id="339679"><td id="r-339676" data-claire-element-id="339676"><p id="r-339675" data-claire-element-id="339675">sdljavax.swig</p></td><td id="r-339678" data-claire-element-id="339678"><p id="r-339677" data-claire-element-id="339677">Swig est l'outil qui permet de faire les binding</p></td></tr><tr id="r-339684" data-claire-element-id="339684"><td id="r-339681" data-claire-element-id="339681"><p id="r-339680" data-claire-element-id="339680">sdljavax.gfx</p></td><td id="r-339683" data-claire-element-id="339683"><p id="r-339682" data-claire-element-id="339682">Méthodes pour faire des rotations etc... (sdl_gfx)</p></td></tr><tr id="r-339689" data-claire-element-id="339689"><td id="r-339686" data-claire-element-id="339686"><p id="r-339685" data-claire-element-id="339685">sdljavax.gui</p></td><td id="r-339688" data-claire-element-id="339688"><p id="r-339687" data-claire-element-id="339687">Permet de créer des interfaces graphiques personnalisée avec OpenGL</p></td></tr></tbody></table><p id="r-339692" data-claire-element-id="339692">Ouf ! qu'est ce que c'est lourd à lire pas vrai (mais efficace tout de même non ?) ! en plus nous ce que l'on aimerais c'est des exemples ! et bien vous allez être servie (enfin tout est relatif hein ^^ )</p><h3 id="r-le-depot-cvs-de-sdljava" data-claire-element-id="339740">Le dépôt CVS de sdljava</h3><p id="r-339693" data-claire-element-id="339693">Mais non ne partez pas ! Vous allez voir que c'est encore plus parlant, et que grâce à lui vous serez capable de vite vous débrouiller dans cette jungle qu'est la documentation. Donc rendez vous sur <a href="http://sdljava.cvs.sourceforge.net/sdljava/">le dépôt CVS</a> (que je vous conseil de mettre en marque page). Nous avons deux répertoires, un qui contient le site de sdljava (si, si) et l'autre qui contient les sources de sdljava, allez y justement, vous vous retrouvez à la racine des sources (wahoo, ça fait peur un peu...), pas de panique, voila comment ça se passe :</p><table id="r-339736" data-claire-element-id="339736"><thead id="r-339699" data-claire-element-id="339699"><tr id="r-339698" data-claire-element-id="339698"><th id="r-339695" data-claire-element-id="339695"><p id="r-339694" data-claire-element-id="339694">Répertoire</p></th><th id="r-339697" data-claire-element-id="339697"><p id="r-339696" data-claire-element-id="339696">Contenu</p></th></tr></thead><tbody id="r-339735" data-claire-element-id="339735"><tr id="r-339704" data-claire-element-id="339704"><td id="r-339701" data-claire-element-id="339701"><p id="r-339700" data-claire-element-id="339700">bin</p></td><td id="r-339703" data-claire-element-id="339703"><p id="r-339702" data-claire-element-id="339702">Des exemples compilés</p></td></tr><tr id="r-339709" data-claire-element-id="339709"><td id="r-339706" data-claire-element-id="339706"><p id="r-339705" data-claire-element-id="339705">docs</p></td><td id="r-339708" data-claire-element-id="339708"><p id="r-339707" data-claire-element-id="339707">La documentation</p></td></tr><tr id="r-339714" data-claire-element-id="339714"><td id="r-339711" data-claire-element-id="339711"><p id="r-339710" data-claire-element-id="339710">etc</p></td><td id="r-339713" data-claire-element-id="339713"><p id="r-339712" data-claire-element-id="339712">Divers fichiers de configuration</p></td></tr><tr id="r-339719" data-claire-element-id="339719"><td id="r-339716" data-claire-element-id="339716"><p id="r-339715" data-claire-element-id="339715">lib</p></td><td id="r-339718" data-claire-element-id="339718"><p id="r-339717" data-claire-element-id="339717">Le jar de sdljava</p></td></tr><tr id="r-339724" data-claire-element-id="339724"><td id="r-339721" data-claire-element-id="339721"><p id="r-339720" data-claire-element-id="339720">src</p></td><td id="r-339723" data-claire-element-id="339723"><p id="r-339722" data-claire-element-id="339722">Les sources du binding</p></td></tr><tr id="r-339729" data-claire-element-id="339729"><td id="r-339726" data-claire-element-id="339726"><p id="r-339725" data-claire-element-id="339725">testdata</p></td><td id="r-339728" data-claire-element-id="339728"><p id="r-339727" data-claire-element-id="339727">Des tests que font les développeurs sur le binding pour voir si il est stable</p></td></tr><tr id="r-339734" data-claire-element-id="339734"><td id="r-339731" data-claire-element-id="339731"><p id="r-339730" data-claire-element-id="339730">testsrc</p></td><td id="r-339733" data-claire-element-id="339733"><p id="r-339732" data-claire-element-id="339732">Le répertoire qui nous intéresse</p></td></tr></tbody></table><p id="r-339737" data-claire-element-id="339737">Entrons dans ce nouveau <a href="http://sdljava.cvs.sourceforge.net/viewvc/sdljava/sdljava/testsrc/">répertoire</a> et qu'avons nous la ? Encore des répertoires o_O</p><p id="r-339738" data-claire-element-id="339738">Alors vous vous souvenez les packages que je vous aient décrit tout à l'heure ? et bien à chaque répertoire contient des sources d'exemple de ces packages ! sauf pour jsdl qui est l'ancien nom du binding, donc n'y allez pas (sauf si vous êtes très très curieux, mais ça ne sert à rien, puisqu'on ne s'en servira jamais on utilise le binding actuel).</p><p id="r-339739" data-claire-element-id="339739">Par exemple si vous voulez voir un exemple d'utilisation des méthodes qui permettent de gérer le CD-ROM, rendez vous dans /sdljava/testsrc/sdljava/cdrom et vous trouverez un fichier java <code data-claire-semantic="java">SDLCdromTest.java</code>. Vous n'avez plus qu'a examiner les sources pour comprendre comment elles fonctionne et les adapter dans votre programme.</p><h3 id="r-la-documentation-officiel-sdl" data-claire-element-id="339755">La documentation Officiel SDL</h3><p id="r-339741" data-claire-element-id="339741">Comme je vous l'est déjà signalé, les exemples C/C++ sont facilement transformables pour être utilisés avec java, et justement ce qui est bien, c'est que <a href="http://www.libsdl.org/">le site de SDL</a>, contient une documentation assez bien faites (dont une en français s'il vous plais), ainsi que des exemples.</p><p id="r-339742" data-claire-element-id="339742">Dans un premier temps je vous recommande de consulter <a href="http://www.libsdl.org/intro.fr/tocfr.html">la documentation d'introduction à SDL en Français</a>, vous pouvez d'ailleurs la télécharger à <a href="http://www.libsdl.org/archives/SDL-1.0-french-intro.zip">cette adresse</a>.</p><p id="r-339743" data-claire-element-id="339743">Vous avez ensuite à votre disposition <a href="http://www.libsdl.org/tutorials.php">les tutoriels officiels SDL</a> pour SDL, qui je vous le rappel sont facilement transformables, car bien que SDL soit programmée en C, le nom des fonction est dans la major partie des cas identique.</p><p id="r-339744" data-claire-element-id="339744">Et enfin <a href="http://www.libsdl.org/cgi/docwiki.cgi">Le wiki</a>, qui contient des ressources, tutoriels, et j'en passe.</p><p id="r-339745" data-claire-element-id="339745">Je vous conseil aussi de consulter les documentations de :</p><ul id="r-339754" data-claire-element-id="339754"><li id="r-339747" data-claire-element-id="339747"><p id="r-339746" data-claire-element-id="339746"><a href="http://jcatki.no-ip.org:8080/SDL_image/">sdl_image</a></p></li><li id="r-339749" data-claire-element-id="339749"><p id="r-339748" data-claire-element-id="339748"><a href="http://jcatki.no-ip.org:8080/SDL_mixer/">sdl_mixer</a></p></li><li id="r-339751" data-claire-element-id="339751"><p id="r-339750" data-claire-element-id="339750"><a href="http://jcatki.no-ip.org:8080/SDL_ttf/">sdl_ttf</a></p></li><li id="r-339753" data-claire-element-id="339753"><p id="r-339752" data-claire-element-id="339752"><a href="http://www.ferzkopp.net/joomla/content/view/19/14/">sdl_gfx</a></p></li></ul><h3 id="r-les-autres-ressources-1" data-claire-element-id="339763">Les autres ressources</h3><p id="r-339756" data-claire-element-id="339756">Je vous propose maintenant quelques liens sur SDL, qui vous permettrons d'avancer encore un peu plus, par contre je vous préviens, certains liens sont en anglais, et je pense que vous avez compris que comprendre l'anglais technique en programmation est essentiel quand on veut avancer.</p><p id="r-339757" data-claire-element-id="339757">Le tutoriel de M@teo21 : <a href="http://www.siteduzero.com/tutoriel-3-14189-apprenez-a-programmer-en-c.html#part_14186">Création de jeux 2D en SDL</a> (fr)</p><p id="r-339758" data-claire-element-id="339758">La <a href="http://jeux.developpez.com/tutoriels/?page=prog2d#sdl">section SDL</a> du site <a href="http://www.developpez.com/">developpez.com</a> (fr)</p><p id="r-339759" data-claire-element-id="339759">La <a href="http://jeux.developpez.com/faq/sdl/">FAQ SDL</a> du site <a href="http://www.developpez.com/">developpez.com</a> (fr)</p><p id="r-339760" data-claire-element-id="339760">Le <a href="http://www.sdltutorials.com/">site sdltutorials</a> qui regorge de tutoriels et d'exemples en tout genre (us)</p><p id="r-339761" data-claire-element-id="339761"><a href="http://gpwiki.org/index.php/C:SDL_tutorials">The game programming wiki</a> : Vous y trouverez pas mal de ressources</p><p id="r-339762" data-claire-element-id="339762">Et bien voila qui clôture cette première annexe, j'espère que vous ne manquerez pas de documentations ^^ . Si vous trouvez d'autres ressources intéréssentes qui auraient une place dans cette annexe, n'hésitez pas à me contacter par MP.</p><h2 id="r-installation-d-une-lib-en-dur-dans-la-jvm" data-claire-element-id="339767">Installation d'une lib en dur dans la JVM</h2><p id="r-339765" data-claire-element-id="339765">Dans ce tutoriel vous avez à chaque projet créer un répertoire lib qui contenais les fichiers jar et dll de sdljava, cependant il existe une autre méthode qui consiste à copier directement ces fichiers dans la JVM. Certains trouverons cette méthode inadaptée, d'autres au contraire la trouverons beaucoup plus pratique. Pour ma part je fonctionne désormais comme cela et pour chaque grosse lib. Le résultat est exactement le même, sauf qu'a la redistribution de votre application l'utilisateur devra soit lui aussi copier ces fichiers dans sa JVM (on peut par exemple utiliser un installeur qui le fait automatiquement), soit il faudra distribuer les fichiers à la racine du répertoire de l'application. C'est une méthode comme une autre et je vous la propose tout de suite. Cette méthode fonctionne bien évidement sur Linux et Windows.</p><h3 id="r-le-repertoire-de-la-jvm-et-du-jdk" data-claire-element-id="339766">Le répertoire de la JVM et du JDK</h3><h2 id="r-localisation-des-repertoires" data-claire-element-id="339786">Localisation des répertoires</h2><aside id="r-339769" data-claire-element-id="339769" data-claire-semantic="information"><p id="r-339768" data-claire-element-id="339768">Petite piqure de rappel :</p></aside><p id="r-339770" data-claire-element-id="339770"><strong>JRE</strong> : Java Runtime Environment --&gt; c'est la machine virtuelle java qui permet d'exécuter vos programmes<br/><strong>JDK</strong> : Java Development Kit --&gt; Ce sont les outils qui permettent de compiler des fichiers java et faire d'autre choses</p><h3 id="r-sous-linux-15" data-claire-element-id="339783">Sous Linux</h3><p id="r-339771" data-claire-element-id="339771">Suivant votre distribution, vous aurez plusieurs possibilités, par exemple sur les dérivées de Debian, la JVM et le JDK, lorsqu'ils ont été installés via apt-get se trouvent dans <code data-claire-semantic="console">/usr/lib/jvm&quot;</code>, pour d'autres distributions ce sera dans <code data-claire-semantic="console">/opt/</code>, vous devrez donc chercher vous même où vous avez installé la JVM ainsi que le JDK, vous noterez aussi que parfois la JVM et le JDK peuvent être dans le même répertoire, dans ce cas, l'installation sera plus rapide.</p><p id="r-339772" data-claire-element-id="339772">Pour ma part ils se trouvent dans <code data-claire-semantic="console">/usr/lib/jvm</code>, et comme je suis sur un système 64 bits j'ai plusieurs versions de java :</p><ul id="r-339779" data-claire-element-id="339779"><li id="r-339774" data-claire-element-id="339774"><p id="r-339773" data-claire-element-id="339773">ia32-java-6-sun-1.6.0.10 : la machine virtuel java 32 bits (JVM)</p></li><li id="r-339776" data-claire-element-id="339776"><p id="r-339775" data-claire-element-id="339775">java-6-openjdk : la machine virtuel avec le plugins de l'OpenJDK 64 bits (une autre JVM)</p></li><li id="r-339778" data-claire-element-id="339778"><p id="r-339777" data-claire-element-id="339777">java-6-sun-1.6.0.10 : ma JVM et mon JRE en 64 bits (dans le même répertoire)</p></li></ul><p id="r-339780" data-claire-element-id="339780">Donc si vous n'avez qu'un répertoire ET que vous avez installé la JVM et le JDK, pas de panique, référencez vous aux explications pour l'installation sur le JDK.</p><aside id="r-339782" data-claire-element-id="339782" data-claire-semantic="warning"><p id="r-339781" data-claire-element-id="339781">Nous aurons à copier des fichiers dans ces répertoires, si vous travaillez en mode graphique, assurez vous d'être en mode super-utilisateur (par exemple <code data-claire-semantic="bash">sudo dolphin </code> pour KDE 4 ou <code>sudo nautilus</code> pour gnome</p></aside><h3 id="r-sous-windows-21" data-claire-element-id="339785">Sous Windows</h3><p id="r-339784" data-claire-element-id="339784">L'installation par défaut de Java est dans <code data-claire-semantic="console">c:\program files\java\</code> pour un système 32 bits et dans <code data-claire-semantic="console">c:\program files(x86)\java\</code>pour un système 64 bits. Vous aurez normalement deux répertoires qui seront d'une part celui de la JVM nommé jre6 et d'autre part, celui du JDK nommé suivant sa version jdk1.x_u.</p><h2 id="r-structure-des-repertoires" data-claire-element-id="339803">Structure des répertoires</h2><p id="r-339787" data-claire-element-id="339787">Ce qui suis est valable aussi bien sous Linux que sous Windows et fonctionne avec n'importe quelle version de Java, même avec <a href="http://openjdk.java.net/">OpenJDK</a>.</p><p id="r-339788" data-claire-element-id="339788">Nous commencerons par analyser le répertoire de la JVM, il contient deux répertoires (bin et lib). Le répertoire bin contient les fichiers exécutables de java tandis que lib contient les bibliothèques, ressources et autres fichiers de configurations. Nous nous intéresserons uniquement au répertoire lib pour la JVM. Rendez vous dans lib et localisez les répertoires <strong>ext</strong> et <strong>i386</strong></p><figure id="r-339790" data-claire-element-id="339791"><img id="r-339789" data-claire-element-id="339789" src="medias/uploads.siteduzero.com_files_156001_157000_156575.jpg" alt="Image utilisateur"/></figure><p id="r-339792" data-claire-element-id="339792">Laissez cette fenêtre de coté, nous allons faire de même avec celle du JDK. Rendez vous ou vous avez installé le JDK et listez son contenu. Il y a beaucoup plus d'éléments que pour la JVM et c'est bien normal, la JVM sert à exécuter le bytecode, alors que le JDK sert à compiler ET exécuter le bytecode (et à faire aussi d'autres choses, mais c'est hors de ce tutoriel). Le JDK permet comme je vous l'ai dit d'exécuter du bytecode, donc il contient lui aussi une JVM ! Et bien figurez vous qu'en sélectionnant le répertoire jre vous tomber... sur un nouveau jre avec les même répertoires, donc vous savez lesquelles utiliser ;)</p><figure id="r-339794" data-claire-element-id="339795"><img id="r-339793" data-claire-element-id="339793" src="medias/uploads.siteduzero.com_files_156001_157000_156578.jpg" alt="Image utilisateur"/></figure><h3 id="r-copie-des-fichiers" data-claire-element-id="339802">Copie des fichiers</h3><p id="r-339796" data-claire-element-id="339796">Maintenant, il n'y a rien de compliqué, vous devez copier :</p><p id="r-339797" data-claire-element-id="339797">Tous les fichiers <code data-claire-semantic="java">*.jar </code> dans les répertoires <code data-claire-semantic="console">ext</code></p><p id="r-339798" data-claire-element-id="339798">Tous les fichiers <code data-claire-semantic="java">*.so ou *.dll </code> dans les répertoires <code data-claire-semantic="console">i386</code></p><p id="r-339799" data-claire-element-id="339799">Une fois que cela est fait, votre installation en dur est terminée, vous pouvez créer un nouveau projet dans eclipse, en sélectionnant bien le jdk qui est installé sur votre machine (et pas le compilateur intégré à Eclipse), vous n'aurez alors qu'a copier les fichiers dll relatif à la lib SDL native à la racine de votre projet. Aprés compilation et lancement de votre projet :magicien: plus de répertoire lib.</p><p id="r-339800" data-claire-element-id="339800">Voila qui est fait ! Si vous avez plusieurs projets à gérer en même temps cette méthode se révélera bien plus pratique.</p><p id="r-339801" data-claire-element-id="339801">Le tutoriel <strong>n'est pas</strong> terminé, n'hésitez pas à revenir de temps en temps pour voir son évolution, et si vous avez des questions, n'hésitez pas à les poster sur le <a href="http://www.siteduzero.com/forum-81-305-langage-java.html">forum Java</a>. Un grand merci à la zCorrection, ainsi qu'aux personnes qui m'ont encouragé à rédiger ce tutoriel.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java">Présentation de bibliothèque SDL en Java</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/les-bases-de-sdljava">
Les bases de sdljava
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/notions-intermediaires">
Notions intermédiaires
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/annexes-26">
Annexes
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/presentation-de-bibliotheque-sdl-en-java/notions-intermediaires">
<span class="arrow"></span>
<span class="next">Notions intermédiaires</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/resentation-de-bibliotheque-sdl-en-java.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 09:01:13 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/resentation-de-bibliotheque-sdl-en-java.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:36:42 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/-la-poo-en-pratique-avec-zstring.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 03:04:43 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/-la-poo-en-pratique-avec-zstring.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:40:58 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : TP : La POO en pratique avec ZString</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : TP : La POO en pratique avec ZString</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#TPLaPOOenpratiqueavecZString">TP : La POO en pratique avec ZString</a><br/><a href="#Notreobjectif">Notre objectif</a><br/><a href="#Quelquesprparatifs">Quelques préparatifs</a><br/><a href="#Constructeursetdestructeur">Constructeurs et destructeur</a><br/><a href="#Lasurchargedesoprateurs">La surcharge des opérateurs</a><br/><a href="#Rcapitulatif">Récapitulatif</a><br/><a href="#Allerencoreplusloin">Aller (encore) plus loin</a><br/></div>
<a name="TPLaPOOenpratiqueavecZString"></a><h2>TP : La POO en pratique avec ZString</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/notre-objectif-2">
<span class="next">Notre objectif</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-555817" data-claire-element-id="555817">Vous avez dû vous en rendre compte en lisant le cours de C++ : la programmation orientée objet n'est pas simple à comprendre. Il faut un temps avant d'arriver à imaginer que l'on manipule des &quot;<strong>objets</strong>&quot;. Les objets sont des sortes de boîtes qui contiennent un ensemble de variables et de fonctions qui modifient ces variables.</p><p id="r-555818" data-claire-element-id="555818">On peut voir la POO de 2 côtés :</p><ul id="r-555823" data-claire-element-id="555823"><li id="r-555820" data-claire-element-id="555820"><p id="r-555819" data-claire-element-id="555819"><strong>Le côté utilisateur</strong> : cela correspond à utiliser les classes en créant des objets. C'est là que la POO se révèle simple et agréable.</p></li><li id="r-555822" data-claire-element-id="555822"><p id="r-555821" data-claire-element-id="555821"><strong>Le côté créateur</strong> : cela correspond à créer les classes. C'est le plus délicat car il faut bien réfléchir avant de se lancer à coder.</p></li></ul><p id="r-555824" data-claire-element-id="555824">Nous avons déjà vu la POO côté utilisateur avec l'exemple de la classe string fournie avec la bibliothèque standard du C++.<br/> Ce que je vous propose dans ce TP, c'est de voir maintenant le côté créateur en pratique. <strong>Nous allons recréer la classe string</strong>.</p><p id="r-555825" data-claire-element-id="555825">Vous vous demandez peut-être : pourquoi refaire la classe string si elle existe déjà ? Tout simplement parce que c'est un très bon exercice et que ça va beaucoup vous faire progresser.</p><p id="r-555826" data-claire-element-id="555826">Comme je sais que la POO n'est pas simple à appréhender quand on débute, je ne vous laisserai pas vous débrouiller tous seuls dans ce TP. Au contraire, je vais vous aider tout au long de la création de notre classe.</p><aside id="r-555828" data-claire-element-id="555828" data-claire-semantic="information"><p id="r-555827" data-claire-element-id="555827">Ce qui compte, c'est de lire, comprendre, et essayer de programmer. Si vous n'arrivez pas à programmer comme il faut du premier coup, ce n'est pas grave.<br/> Si vous vous dites &quot;<em>Jamais je n'aurais pu deviner qu'il fallait faire comme ça</em>&quot;, ce n'est pas grave non plus. C'est le métier qui rentre. Faites l'effort de comprendre comment j'ai fait, et ce sera déjà très bien :)</p></aside>
</div><a name="Notreobjectif"></a><h2>Notre objectif</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/quelques-preparatifs">
<span class="next">Quelques préparatifs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-555829" data-claire-element-id="555829">Notre objectif est de recréer la classe string de la bibliothèque standard du C++.<br/> C'est une classe qui gère les chaînes de caractères. Nous allons donc beaucoup manipuler les chaînes de caractères dans ce chapitre.</p><aside id="r-555831" data-claire-element-id="555831" data-claire-semantic="error"><p id="r-555830" data-claire-element-id="555830">Il est important que vous soyez au point vis à vis des chaînes de caractères. Si vous ne vous souvenez plus qu'une chaîne de caractères se termine par un \0 de fin de chaîne par exemple, je vous invite à <a href="tuto-3-4144-1-les-chaines-de-caracteres.html"><strong>relire le chapitre sur les chaînes de caractères</strong></a> vu dans le cours de C.<br/><strong>C'est important, j'insiste</strong>. Prenez le temps de revoir ce chapitre si vous en avez besoin.</p></aside><p id="r-555832" data-claire-element-id="555832">Vous avez déjà appris à <a href="tuto-3-13435-1-la-magie-de-la-poo-par-l-exemple-string.html">utiliser la classe &quot;string&quot;</a> dans un chapitre précédent de ce cours. Vous avez vu à quel point c'était simple : c'est la classe qui gère tout pour nous. Plus besoin de créer un tableau de la bonne taille, c'est la classe qui s'en occupe. Si la taille de la chaîne change, le tableau de caractères est automatiquement réalloué par la classe.</p><pre id="r-555833" data-claire-element-id="555833"><code data-claire-semantic="cpp">string maChaine = &quot;Bonjour&quot;; // Crée un tableau de caractères de 8 cases (\0 compris)
maChaine = &quot;Bonjour Mateo&quot;; // Change automatiquement la taille du tableau : 14 cases</code></pre><p id="r-555834" data-claire-element-id="555834">Un objet string n'est au final rien d'autre qu'<strong>un objet qui contient un tableau de char</strong> (pour stocker la chaîne de caractères). La particularité c'est que c'est la classe qui gère la taille de ce tableau, l'utilisateur n'a pas à s'en soucier.</p><p id="r-555835" data-claire-element-id="555835">Quand vous modifiez le contenu de la chaîne, le tableau de char que l'objet <em>maChaine </em>contient est réalloué pour s'adapter à la nouvelle taille. Schématiquement il se passe donc ceci :</p><figure id="r-555837" data-claire-element-id="555838"><img id="r-555836" data-claire-element-id="555836" src="medias/uploads.siteduzero.com_files_107001_108000_107347.png" alt="Réallocation dans un string"/></figure><p id="r-555839" data-claire-element-id="555839">D'autre part, on bénéficie des outils puissants du C++ comme la surcharge des opérateurs. Cela nous permet d'écrire des choses intuitives comme :</p><pre id="r-555840" data-claire-element-id="555840"><code data-claire-semantic="cpp">string message = &quot;Bonjour&quot;;
string maChaine = message + &quot; Mateo&quot;; // Vaudra &quot;Bonjour Mateo&quot;</code></pre><p id="r-555841" data-claire-element-id="555841">C'est ce genre de choses que je veux que l'on arrive à refaire. On va y aller méthodiquement en commençant par écrire les constructeurs, le destructeur, puis on rajoutera des fonctionnalités à la classe en créant de nouvelles méthodes (comme une méthode pour connaître la longueur de la chaîne actuelle). On verra enfin la surcharge des opérateurs en dernier.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring">TP : La POO en pratique avec ZString</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/notre-objectif-2">
Notre objectif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/quelques-preparatifs">
Quelques préparatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/constructeurs-et-destructeur-1">
Constructeurs et destructeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/la-surcharge-des-operateurs-1">
La surcharge des opérateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/recapitulatif-18">
Récapitulatif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/aller-encore-plus-loin-1">
Aller (encore) plus loin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/quelques-preparatifs">
<span class="next">Quelques préparatifs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Quelquesprparatifs"></a><h2>Quelques préparatifs</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/notre-objectif-2">
<span class="arrow"></span>
<span class="next">Notre objectif</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/constructeurs-et-destructeur-1">
<span class="next">Constructeurs et destructeur</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-555843" data-claire-element-id="555843">Bon assez bavardé, on a du pain sur la planche pour arriver à faire tout ça.</p><h2 id="r-choisir-un-nom" data-claire-element-id="555847">Choisir un nom</h2><p id="r-555844" data-claire-element-id="555844">Il va falloir commencer par donner un nom à notre classe qui imite &quot;string&quot;. On ne peut pas l'appeler &quot;string&quot; puisqu'il existe déjà une classe de ce nom dans la bibliothèque standard.<br/> Je vous propose de l'appeler ZString, pour &quot;Zéro String&quot; ;)</p><aside id="r-555846" data-claire-element-id="555846" data-claire-semantic="information"><p id="r-555845" data-claire-element-id="555845">Par convention, la plupart des programmeurs mettent au moins la première lettre du nom de leurs classes en majuscules. C'est ce que je fais ici. Bon j'ai mis aussi la seconde lettre pour faire joli, j'avoue.<br/> La classe &quot;string&quot; de la bibliothèque standard est un mauvais exemple à ne pas suivre :p</p></aside><h2 id="r-creer-un-nouveau-projet-8" data-claire-element-id="555859">Créer un nouveau projet</h2><p id="r-555848" data-claire-element-id="555848">Pour faire ce TP, vous allez devoir créer un nouveau projet. Utilisez l'IDE que vous voulez, moi pour ma part vous savez que j'utilise Code::Blocks ;)</p><p id="r-555849" data-claire-element-id="555849">Demandez à créer un <strong>nouveau projet console C++</strong>.<br/> Ce projet sera constitué de 3 fichiers que vous pouvez déjà créer :</p><ul id="r-555856" data-claire-element-id="555856"><li id="r-555851" data-claire-element-id="555851"><p id="r-555850" data-claire-element-id="555850"><strong>main.cpp</strong> : ce fichier contiendra uniquement la fonction main. Dans la fonction main, nous créerons des objets basés sur notre classe ZString pour tester son fonctionnement. C'est le côté utilisateur.</p></li><li id="r-555853" data-claire-element-id="555853"><p id="r-555852" data-claire-element-id="555852"><strong>ZString.h</strong> : ce fichier contiendra la définition de notre classe ZString avec la liste de ses attributs et les prototypes de ses méthodes. C'est une partie du côté créateur.</p></li><li id="r-555855" data-claire-element-id="555855"><p id="r-555854" data-claire-element-id="555854"><strong>ZString.cpp</strong> : ce fichier contiendra l'implémentation des méthodes de la classe ZString, c'est-à-dire le &quot;code&quot; à l'intérieur des méthodes. C'est l'autre partie du côté créateur.</p></li></ul><aside id="r-555858" data-claire-element-id="555858" data-claire-semantic="warning"><p id="r-555857" data-claire-element-id="555857">Faites attention aux noms des fichiers et en particulier aux majuscules et minuscules. Les fichiers ZString.h et ZString.cpp commencent par 2 lettres majuscules, si vous écrivez &quot;zstring&quot; ou encore &quot;Zstring&quot; ça ne marchera pas et vous aurez des problèmes.</p></aside><h2 id="r-le-code-de-base-de-chaque-fichier" data-claire-element-id="555877">Le code de base de chaque fichier</h2><p id="r-555860" data-claire-element-id="555860">Nous allons écrire un peu de code dans chacun de ces fichiers. Juste le strict minimum pour pouvoir commencer.</p><h3 id="r-main-cpp-13" data-claire-element-id="555866">main.cpp</h3><p id="r-555861" data-claire-element-id="555861">Ce fichier va contenir la fonction main, ainsi que les includes de iostream (pour faire des cout) et de ZString.h (pour pouvoir utiliser la classe ZString !).</p><pre id="r-555862" data-claire-element-id="555862"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &quot;ZString.h&quot;
 
using namespace std;
 
int main()
{
    ZString chaine; // Crée un objet de type ZString (appel du constructeur par défaut)
    return 0;
}</code></pre><p id="r-555863" data-claire-element-id="555863">Comme vous pouvez le voir, le main se contentera dans un premier temps de créer un objet de type ZString appelé &quot;chaine&quot;. Les objets commencent par une lettre minuscule par convention.</p><p id="r-555864" data-claire-element-id="555864">Ce code provoquera l'appel du constructeur par défaut de la classe ZString. Le constructeur est la méthode qui est appelée à chaque fois que l'on crée un nouvel objet, et là on parle de constructeur par défaut car on n'envoie aucun paramètre.</p><p id="r-555865" data-claire-element-id="555865">Le main est court mais on le complètera par la suite pour tester notre classe au fur et à mesure qu'on lui rajoutera des possibilités.</p><h3 id="r-zstring-h" data-claire-element-id="555872">ZString.h</h3><p id="r-555867" data-claire-element-id="555867">Ce fichier contiendra la définition de la classe ZString. Il fait aussi un include de iostream pour nos besoins futurs (nous aurons besoin de faire des cout dans la classe les premiers temps, ne serait-ce que pour débugger notre classe).</p><pre id="r-555868" data-claire-element-id="555868"><code data-claire-semantic="cpp">#ifndef DEF_ZSTRING
#define DEF_ZSTRING
 
#include &lt;iostream&gt;
 
class ZString
{
    public:
 
    private:
 
};
 
#endif</code></pre><p id="r-555869" data-claire-element-id="555869">Vous noterez que je n'ai pas oublié de faire un #ifndef pour vérifier que le header n'a pas été inclus plusieurs fois. C'est une <a href="tuto-3-4200-1-le-preprocesseur.html#ss_part_4">technique de protection</a> que nous avons vue dans le cours de C et que je vous recommande d'utiliser dans chacun de vos headers.</p><p id="r-555870" data-claire-element-id="555870">La classe ZString est pour l'instant vide. Je l'ai séparée en deux : la partie publique et la partie privée.<br/> La partie publique est accessible de l'extérieur de la classe (par l'utilisateur) et la partie privée n'est accessible qu'à l'intérieur de la classe elle-même.</p><p id="r-555871" data-claire-element-id="555871">Je vous rappelle que la règle d'or est que <strong>tous les attributs d'une classe doivent être privés</strong>. C'est le principe d'<strong>encapsulation</strong>.<br/> Les méthodes, elles, peuvent être soit publiques soit privées selon les cas (elles sont souvent publiques, mais il arrive qu'on ait besoin de créer des méthodes privées).</p><h3 id="r-zstring-cpp" data-claire-element-id="555876">ZString.cpp</h3><p id="r-555873" data-claire-element-id="555873">Ce fichier doit contenir l'implémentation des méthodes de la classe. Pour l'instant, nous n'avons écrit aucune méthode, mais nous allons au moins faire un include de ZString.h, c'est le strict minimum ^^</p><pre id="r-555874" data-claire-element-id="555874"><code data-claire-semantic="cpp">#include &quot;ZString.h&quot;</code></pre><p id="r-555875" data-claire-element-id="555875">C'est tout !</p><h2 id="r-de-quels-attributs-notre-classe-a-t-elle-besoin" data-claire-element-id="555899">De quels attributs notre classe a-t-elle besoin ?</h2><p id="r-555878" data-claire-element-id="555878">Comme vous le savez, une classe est constituée d'attributs et de méthodes.<br/> Les attributs sont des variables. Les méthodes interagissent sur ces variables.</p><p id="r-555879" data-claire-element-id="555879">De quels attributs notre classe ZString doit-elle être constituée, vous en avez pas une petite idée hmm ?</p><p id="r-555880" data-claire-element-id="555880">Réfléchissez, le but de notre classe est de gérer de manière intelligente une chaîne de caractères. Or, vous savez qu'une chaîne de caractères se présente en mémoire sous la forme d'un <strong>tableau de char</strong>, terminé par un \0 qui signifie &quot;fin de chaîne&quot; (j'espère que vous savez tout ça, sinon il est grand temps d'aller relire le <a href="tuto-3-4144-1-les-chaines-de-caracteres.html">chapitre sur les chaînes de caractères</a> !).</p><p id="r-555881" data-claire-element-id="555881">Nous aurons donc besoin au moins d'un tableau de char en attribut.<br/> En plus de cela, il me semble nécessaire de mettre la <strong>taille de la chaîne de caractères (un int)</strong> en attribut aussi. Vous me direz : on peut toujours la recalculer (il suffit de compter le nombre de caractères jusqu'à l'\0), mais je pense que c'est une bonne idée de garder la taille de la chaîne en mémoire pour éviter d'avoir à la recalculer à chaque fois.</p><p id="r-555882" data-claire-element-id="555882">Nous allons donc modifier notre ZString.h pour y ajouter ces 2 attributs :</p><pre id="r-555883" data-claire-element-id="555883"><code data-claire-semantic="cpp">#ifndef DEF_ZSTRING
#define DEF_ZSTRING
 
#include &lt;iostream&gt;
 
class ZString
{
    public:
 
    private:
        char *m_chaine; // Tableau de caractères (contiendra la chaîne)
        int m_longueur; // Longueur de la chaîne
};
 
#endif</code></pre><p id="r-555884" data-claire-element-id="555884">Nos attributs commencent toujours par le préfixe &quot;m_&quot;. C'est une bonne habitude de programmation que je vous ai enseignée dans les chapitres précédents ;) <br/> Cela nous permettra par la suite de savoir si on est en train de manipuler un attribut de la classe ou une simple variable &quot;locale&quot; à une méthode.</p><div id="r-555886" data-claire-element-id="555886" data-claire-semantic="question"><p id="r-555885" data-claire-element-id="555885">Hé ! Tu avais dit qu'il fallait créer un tableau de char pour gérer la chaîne ! Or là je ne vois qu'un pointeur de char, pourquoi as-tu fait ça ?</p></div><p id="r-555887" data-claire-element-id="555887">J'attendais une question de ce genre :D</p><p id="r-555888" data-claire-element-id="555888">Je vais vous répondre par une autre question : quelle taille vous donneriez à ce tableau de char vu que vous ne connaissez pas la taille de la chaîne à stocker ?</p><p id="r-555889" data-claire-element-id="555889">Vous pourriez certes me dire &quot;<em>Bah il suffit de créer un très grand tableau de char, par exemple m_chaine[10000]</em>&quot;.<br/> Mais ce serait mauvais. Non, ce serait même carrément nul :</p><ul id="r-555896" data-claire-element-id="555896"><li id="r-555891" data-claire-element-id="555891"><p id="r-555890" data-claire-element-id="555890">Rien ne vous dit que personne ne dépassera jamais les 10 000 caractères.</p></li><li id="r-555893" data-claire-element-id="555893"><p id="r-555892" data-claire-element-id="555892">Ca fait beaucoup de mémoire inutilisée pour rien.</p></li><li id="r-555895" data-claire-element-id="555895"><p id="r-555894" data-claire-element-id="555894">Notre but est justement d'allouer un tableau en mémoire qui fasse pile la taille nécessaire.</p></li></ul><p id="r-555897" data-claire-element-id="555897">Donc comme on ne sait pas la taille que fera le tableau dans la suite du programme, on crée juste un pointeur sur char. C'est nous qui allouerons la taille nécessaire par la suite, dans le constructeur (c'est son rôle, initialiser les attributs).</p><p id="r-555898" data-claire-element-id="555898">D'ailleurs en parlant de constructeur, je crois qu'il est temps de s'en occuper maintenant que nous nous sommes mis d'accord sur les attributs que la classe allait manipuler :)</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring">TP : La POO en pratique avec ZString</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/notre-objectif-2">
Notre objectif
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/quelques-preparatifs">
Quelques préparatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/constructeurs-et-destructeur-1">
Constructeurs et destructeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/la-surcharge-des-operateurs-1">
La surcharge des opérateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/recapitulatif-18">
Récapitulatif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/aller-encore-plus-loin-1">
Aller (encore) plus loin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/notre-objectif-2">
<span class="arrow"></span>
<span class="next">Notre objectif</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/constructeurs-et-destructeur-1">
<span class="next">Constructeurs et destructeur</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Constructeursetdestructeur"></a><h2>Constructeurs et destructeur</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/quelques-preparatifs">
<span class="arrow"></span>
<span class="next">Quelques préparatifs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/la-surcharge-des-operateurs-1">
<span class="next">La surcharge des opérateurs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-555901" data-claire-element-id="555901">Nous allons commencer par écrire les méthodes les plus importantes d'une classe : les constructeurs et le destructeur.</p><p id="r-555902" data-claire-element-id="555902">J'ai bien dit LES constructeurs, car on peut surcharger le constructeur (en faire plusieurs versions), et LE destructeur, car celui-ci ne peut pas être surchargé.</p><p id="r-555903" data-claire-element-id="555903">Je vous propose de créer 3 constructeurs et le destructeur pour commencer :</p><ul id="r-555912" data-claire-element-id="555912"><li id="r-555905" data-claire-element-id="555905"><p id="r-555904" data-claire-element-id="555904"><strong>Le constructeur par défaut</strong> (celui qui ne prend pas de paramètre). Si l'utilisateur se sert de ce constructeur, la chaîne sera vide : &quot;&quot;.</p></li><li id="r-555907" data-claire-element-id="555907"><p id="r-555906" data-claire-element-id="555906"><strong>Un autre constructeur</strong> (une surcharge) qui prendra en paramètre une chaîne de caractères pour initialiser la ZString avec une chaîne. La ZString contiendra donc dès le départ la chaîne qu'on lui aura envoyée.<br/> Ce constructeur recevra en paramètre un tableau de char (un char *) correspondant à la chaîne envoyée par l'utilisateur pour initialiser la ZString.</p></li><li id="r-555909" data-claire-element-id="555909"><p id="r-555908" data-claire-element-id="555908"><strong>Le constructeur de copie</strong> : quelle que soit la classe qu'on écrit, il est toujours conseillé d'écrire le constructeur de copie car il est souvent nécessaire. C'est un constructeur qui prend une référence vers un objet du même type (un const ZString &amp;).</p></li><li id="r-555911" data-claire-element-id="555911"><p id="r-555910" data-claire-element-id="555910"><strong>Le destructeur</strong> pour supprimer le tableau de char <em>m_chaine</em> avant que l'objet ne soit lui-même supprimé. Cela permet d'éviter les fuites de mémoire.</p></li></ul><p id="r-555913" data-claire-element-id="555913">On créera d'autres constructeurs par la suite, mais pour l'instant nous commençons simplement :)</p><p id="r-555914" data-claire-element-id="555914">Commençons par ajouter les prototypes de nos méthodes dans <strong>ZString.h</strong> :</p><pre id="r-555915" data-claire-element-id="555915"><code data-claire-semantic="cpp">#ifndef DEF_ZSTRING
#define DEF_ZSTRING
 
#include &lt;iostream&gt;
 
class ZString
{
    public:
        ZString(); // Constructeur par défaut (crée une chaîne vide &quot;&quot;)
        ZString(const char *chaine); // Constructeur surchargé (crée la chaîne envoyée)
        ZString(const ZString &amp;chaine); // Constructeur de copie
        ~ZString(); // Destructeur (détruit le tableau de char pour libérer la mémoire)
 
    private:
        char *m_chaine;
        int m_longueur;
};
 
#endif</code></pre><p id="r-555916" data-claire-element-id="555916">Bien, voilà qui est fait.<br/> Il faut maintenant implémenter ces méthodes, rendez-vous dans le fichier ZString.cpp.</p><h2 id="r-le-constructeur-par-defaut-zstring" data-claire-element-id="555929">Le constructeur par défaut ZString()</h2><p id="r-555917" data-claire-element-id="555917">On commence par implémenter le constructeur par défaut. Je vous rappelle que le but d'un constructeur est d'initialiser les attributs de la classe. La question est : <em>quelle valeur on va leur mettre</em> ? o_O</p><p id="r-555918" data-claire-element-id="555918">Comme on travaille sur le constructeur par défaut, vous pouvez voir que celui-ci ne prend pas de paramètre. C'est le constructeur qui est appelé lorsqu'on crée un nouvel objet de type ZString sans préciser de paramètre.</p><p id="r-555919" data-claire-element-id="555919">C'est précisément ce que l'on a fait dans le main.cpp que je vous ai donné plus haut :</p><pre id="r-555920" data-claire-element-id="555920"><code data-claire-semantic="cpp">ZString chaine; // Appel du constructeur par défaut (aucun paramètre envoyé)</code></pre><p id="r-555921" data-claire-element-id="555921">Que doit contenir la chaîne lorsqu'on n'envoie rien ?<br/> Bah... rien :p <br/> Si l'utilisateur n'envoie aucun texte, nous n'allons rien mettre dans l'attribut m_chaine. Il est donc inutile d'allouer un tableau de char (y'a rien à stocker !).</p><p id="r-555922" data-claire-element-id="555922">Ce qu'on va faire en revanche, c'est mettre le pointeur <em>m_chaine</em> à NULL pour indiquer qu'il ne pointe sur rien pour le moment.<br/> Quant à la longueur de la chaîne <em>m_longueur</em>, bah elle vaudra 0 vu que pour l'instant notre objet ne contiendra aucune chaîne en mémoire :p</p><p id="r-555923" data-claire-element-id="555923">On peut donc écrire dans <strong>ZString.cpp</strong> :</p><pre id="r-555924" data-claire-element-id="555924"><code data-claire-semantic="cpp">ZString::ZString()
{
    m_chaine = NULL;
    m_longueur = 0;
}</code></pre><aside id="r-555928" data-claire-element-id="555928" data-claire-semantic="information"><p id="r-555925" data-claire-element-id="555925">Notez que, comme je vous l'avais expliqué, on peut aussi initialiser les attributs avec une liste d'initialisation, comme ceci :</p><pre id="r-555926" data-claire-element-id="555926"><code data-claire-semantic="cpp">ZString::ZString() : m_chaine(NULL), m_longueur(0)
{
 
}</code></pre><p id="r-555927" data-claire-element-id="555927">Ce code revient au même que celui que je vous ai donné plus haut. Le seul problème de la liste d'initialisation est qu'elle ne convient pas dans tous les cas, comme on le verra plus loin.</p></aside><h2 id="r-le-constructeur-zstring-const-char" data-claire-element-id="555976">Le constructeur ZString(const char *)</h2><p id="r-555930" data-claire-element-id="555930">Le constructeur par défaut était simple.<br/> Les choses se corsent quand l'utilisateur envoie un paramètre lorsqu'il crée la chaîne dans main.cpp :</p><pre id="r-555931" data-claire-element-id="555931"><code data-claire-semantic="cpp">ZString chaine(&quot;Bonjour&quot;);</code></pre><p id="r-555932" data-claire-element-id="555932">... ou encore (ça revient au même) :</p><pre id="r-555933" data-claire-element-id="555933"><code data-claire-semantic="cpp">ZString chaine = &quot;Bonjour&quot;;</code></pre><p id="r-555934" data-claire-element-id="555934">Lorsqu'un objet est créé de cette façon, cela appelle automatiquement le constructeur qui correspond à la signature ZString(const char *) car le fait d'écrire un texte entre guillemets dans le code source provoque la création d'un tableau de char par le compilateur.</p><p id="r-555935" data-claire-element-id="555935">Il va falloir écrire le code de ce constructeur dans ZString.cpp...<br/> Mais là les choses se corsent, suivez-moi bien.</p><p id="r-555936" data-claire-element-id="555936">Notre but est d'initialiser nos attributs <em>m_chaine</em> et <em>m_longueur</em> correctement, on est bien d'accord ? C'est le but du constructeur d'initialiser des attributs.</p><p id="r-555937" data-claire-element-id="555937">Le problème c'est que :</p><ul id="r-555942" data-claire-element-id="555942"><li id="r-555939" data-claire-element-id="555939"><p id="r-555938" data-claire-element-id="555938"><strong>Pour m_longueur</strong> : on ne connaît pas la taille de la chaîne qu'on nous envoie ! Impossible d'initialiser m_longueur si on ne connaît pas la taille de la chaîne. On pourrait utiliser la fonction strlen de la bibliothèque C, mais notre but est que notre classe ZString soit autonome et qu'elle n'ait pas besoin de la bibliothèque du C (on est en C++ que diable !). Solution : il va falloir réécrire la fonction strlen() pour pouvoir calculer la longueur de la chaîne.</p></li><li id="r-555941" data-claire-element-id="555941"><p id="r-555940" data-claire-element-id="555940"><strong>Pour m_chaine</strong> : on nous envoie un tableau de char (appelé chaine), mais il ne faut surtout pas écrire m_chaine = chaine; ! Pourquoi ? Parce que en faisant cela, vous faites pointer notre attribut m_chaine vers un tableau qui nous a été envoyé par l'utilisateur. Qu'est-ce qui vous dit que l'utilisateur ne va pas supprimer ce tableau par la suite ? Dans un tel cas, votre pointeur m_chaine pointerait sur un tableau qui n'existe plus ! Solution : copier le tableau qu'on nous envoie et affecter m_chaine à ce tableau pour s'assurer que personne d'autre ne pourra supprimer ce tableau.</p></li></ul><p id="r-555943" data-claire-element-id="555943">Pour le problème de l'initialisation de m_longueur je pense que vous avez compris : on ne connaît pas la longueur de la chaîne et il va nous falloir écrire une fonction qui la calcule manuellement en comptant le nombre de caractères.</p><p id="r-555944" data-claire-element-id="555944">Par contre, je pense que le problème de l'initialisation de m_chaine mérite plus d'explications (et même un schéma en fait).</p><p id="r-555945" data-claire-element-id="555945">Tout d'abord, il faut savoir que lorsqu'on envoie au constructeur une chaîne de caractères entre guillemets, un tableau de char est automatiquement créé en mémoire. Celui-ci est ensuite passé en paramètre au constructeur :</p><figure id="r-555947" data-claire-element-id="555948"><img id="r-555946" data-claire-element-id="555946" src="medias/uploads.siteduzero.com_files_107001_108000_107735.png" alt="Schema constructeur ZString"/></figure><p id="r-555949" data-claire-element-id="555949">L'erreur qu'on serait tenté de faire, c'est d'assigner l'attribut m_chaine directement au tableau chaine qu'on nous envoie, avec un code comme ceci :</p><pre id="r-555950" data-claire-element-id="555950"><code data-claire-semantic="cpp">ZString::ZString(const char *chaine)
{
    m_chaine = chaine; // Très mauvaise idée !
}</code></pre><p id="r-555951" data-claire-element-id="555951">Pourquoi ? Parce qu'en faisant pointer notre attribut m_chaine vers le tableau de char qu'on nous a envoyé, on prend le risque que ce tableau de char soit supprimé par le main !<br/> Dans ce cas, si le tableau est supprimé par le main, notre attribut m_chaine ne pointera plus sur rien et on perdra la chaîne !</p><figure id="r-555953" data-claire-element-id="555954"><img id="r-555952" data-claire-element-id="555952" src="medias/uploads.siteduzero.com_files_107001_108000_107736.png" alt="Schema constructeur ZString"/></figure><p id="r-555955" data-claire-element-id="555955">La solution ?<br/> Comme on l'a vu dans un des chapitres précédents, il faut copier la chaîne (en appelant une fonction de copie que l'on écrirera) et faire pointer m_chaine vers cette copie.</p><pre id="r-555956" data-claire-element-id="555956"><code data-claire-semantic="cpp">ZString::ZString(const char *chaine)
{
    m_chaine = copie(chaine); // Bonne idée : copier la chaîne pour en avoir une version propre à la classe
}</code></pre><figure id="r-555958" data-claire-element-id="555959"><img id="r-555957" data-claire-element-id="555957" src="medias/uploads.siteduzero.com_files_107001_108000_107737.png" alt="Schema constructeur ZString"/></figure><p id="r-555960" data-claire-element-id="555960">Comme notre classe sera la seule à connaître la copie, elle sera sûre que personne d'autre ne la supprimera dans le programme !</p><aside id="r-555962" data-claire-element-id="555962" data-claire-semantic="information"><p id="r-555961" data-claire-element-id="555961">Si j'insiste pour faire une copie du tableau, ce n'est pas pour rien. Il faut vraiment être sûr de travailler sur une version du tableau que nous sommes les seuls à connaître dans la classe, car sinon on prend le risque que quelqu'un d'autre la supprime sans notre autorisation.</p></aside><p id="r-555963" data-claire-element-id="555963">Je vous propose d'écrire ce constructeur :</p><pre id="r-555964" data-claire-element-id="555964"><code data-claire-semantic="cpp">ZString::ZString(const char *chaine)
{
    m_chaine = copie(chaine);
    m_longueur = longueur(chaine);
}</code></pre><p id="r-555965" data-claire-element-id="555965">Pour que ce constructeur marche, il nous faut écrire 2 fonctions :</p><ul id="r-555970" data-claire-element-id="555970"><li id="r-555967" data-claire-element-id="555967"><p id="r-555966" data-claire-element-id="555966"><strong>copie </strong>: qui copie un tableau de char et renvoie un pointeur vers la copie (équivalent de strcpy du C).</p></li><li id="r-555969" data-claire-element-id="555969"><p id="r-555968" data-claire-element-id="555968"><strong>longueur </strong>: qui calcule la longueur du tableau de char qu'on lui envoie (équivalent de strlen du C).</p></li></ul><p id="r-555971" data-claire-element-id="555971">Ce sont des fonctions que vous avez déjà peut-être écrites si vous avez suivi mon cours de C. C'est un bon exercice que d'essayer de les réécrire.</p><p id="r-555972" data-claire-element-id="555972">Je vous donne la solution, sans l'expliquer, parce que ça ça ne devrait pas être nouveau pour vous (ou alors faut revoir votre cours de C sur les chaînes de caractères !) :</p><pre id="r-555973" data-claire-element-id="555973"><code data-claire-semantic="cpp">int ZString::longueur(const char *chaine)
{
    int i = 0;
 
    while (chaine[i] != '\0')
    {
        i++;
    }
 
    return i;
}
 
char *ZString::copie(const char *chaine)
{
    int taille = longueur(chaine);
    char *chaineCopie = new char[taille + 1]; // +1 pour stocker \0
 
 
    for (int i = 0 ; i &lt; taille ; i++)
    {
        chaineCopie[i] = chaine[i];
    }
    chaineCopie[taille] = '\0';
 
    return chaineCopie;
}</code></pre><aside id="r-555975" data-claire-element-id="555975" data-claire-semantic="information"><p id="r-555974" data-claire-element-id="555974">Pensez à ajouter le prototype de ces méthodes dans ZString.h</p></aside><h2 id="r-le-constructeur-de-copie-zstring-const-zstring" data-claire-element-id="555991">Le constructeur de copie ZString(const ZString &amp;)</h2><p id="r-555977" data-claire-element-id="555977">Le constructeur de copie est un constructeur très utile qui est appelé dans plusieurs cas par le compilateur. Je ne reviens pas sur ces cas mais je vous invite en revanche à relire la <a href="tuto-3-16953-1-classes-et-pointeurs.html#ss_part_3">partie sur le constructeur de copie</a> dans les chapitres précédents.</p><p id="r-555978" data-claire-element-id="555978">Le constructeur de copie est un constructeur qui prend en paramètre une référence vers un autre objet du même type.<br/> Voici le constructeur de copie de notre classe ZString :</p><pre id="r-555979" data-claire-element-id="555979"><code data-claire-semantic="cpp">ZString::ZString(const ZString &amp;chaine)
{
    m_chaine = copie(chaine.m_chaine);
    m_longueur = chaine.m_longueur;
}</code></pre><p id="r-555980" data-claire-element-id="555980">Ce constructeur est à peu de choses près identique au constructeur qu'on vient d'écrire il y a 2 minutes.<br/> La seule différence est qu'il prend en entrée une ZString appelée <em>chaine</em>. Pour récupérer le tableau de char de la ZString, il suffit d'écrire <em>chaine.m_chaine</em>. Cela nous permet d'envoyer le tableau de char que les méthodes copie et longueur attendent.</p><p id="r-555981" data-claire-element-id="555981">Vous vous demandez peut-être pourquoi on n'a pas tout simplement écrit par exemple :<br/>m_chaine = copie(chaine);<br/> La réponse est simple. Dans ce constructeur :</p><ul id="r-555986" data-claire-element-id="555986"><li id="r-555983" data-claire-element-id="555983"><p id="r-555982" data-claire-element-id="555982"><em>chaine </em>est de type ZString (regardez le paramètre d'entrée)</p></li><li id="r-555985" data-claire-element-id="555985"><p id="r-555984" data-claire-element-id="555984"><em>chaine.m_chaine</em> est de type char *</p></li></ul><p id="r-555987" data-claire-element-id="555987">Or nos méthodes copie et longueur attendent un char *, voilà pourquoi il faut dans ce cas envoyer <em>chaine.m_chaine</em>.</p><div id="r-555989" data-claire-element-id="555989" data-claire-semantic="question"><p id="r-555988" data-claire-element-id="555988">Comment peut-on avoir le droit d'écrire <em>chaine.m_chaine</em> ? Je croyais que <em>m_chaine</em> était un attribut privé, et donc qu'on ne pouvait pas y accéder ?<br/> Il n'aurait pas fallu créer une méthode accesseur <em>getChaine()</em> plutôt à la place ?</p></div><p id="r-555990" data-claire-element-id="555990">En effet, on aurait très bien pu créer une méthode accesseur <em>getChaine()</em>. Faites-le si vous voulez d'ailleurs.<br/>Normalement, on n'a pas le droit d'accéder aux membres privés d'une classe. Mais là nous sommes dans une exception, car nous travaillons dans la même classe (nous sommes dans la classe ZString et nous essayons d'accéder à un attribut privé d'un autre objet de type ZString, ce qui est autorisé).</p><h2 id="r-le-destructeur-zstring" data-claire-element-id="555997">Le destructeur ~ZString()</h2><p id="r-555992" data-claire-element-id="555992">On arrive maintenant au destructeur. Son rôle est de détruire les attributs alloués dynamiquement en mémoire avant que l'objet ne soit supprimé (je vous rappelle que le destructeur est automatiquement appelé lorsqu'un objet va être supprimé).</p><p id="r-555993" data-claire-element-id="555993">Le seul attribut alloué dynamiquement (avec un new[]), c'est m_chaine. Il faut penser à le supprimer avec un delete[].</p><p id="r-555994" data-claire-element-id="555994">Notre destructeur sera tout simple :</p><pre id="r-555995" data-claire-element-id="555995"><code data-claire-semantic="cpp">ZString::~ZString()
{
    delete[] m_chaine;
}</code></pre><p id="r-555996" data-claire-element-id="555996">Si on ne fait pas ça, le tableau de char m_chaine persistera en mémoire après la suppression de l'objet. Du coup, des tableaux &quot;perdus&quot; risqueraient de se ballader en mémoire et on assisterait à ce qu'on appelle des &quot;fuites de mémoire&quot;. Votre programme prendrait beaucoup de place en mémoire parce qu'il aurait oublié de supprimer la mémoire dont il n'a plus besoin !</p><h2 id="r-tester-le-code" data-claire-element-id="556018">Tester le code</h2><p id="r-555998" data-claire-element-id="555998">Il est grand temps de compiler pour vérifier qu'on n'a pas fait d'erreur. Pour le moment, on va lancer le main que je vous ai donné au tout début, ce qui va provoquer l'appel du constructeur par défaut :</p><pre id="r-555999" data-claire-element-id="555999"><code data-claire-semantic="cpp">int main()
{
    ZString chaine;
    return 0;
}</code></pre><p id="r-556000" data-claire-element-id="556000">Compilez, lancez. La console n'affichera rien (c'est normal, tout se passe dans la mémoire) mais si vous n'avez pas de plantage c'est que c'est bon signe déjà :D</p><p id="r-556001" data-claire-element-id="556001">Testons le constructeur qui prend en paramètre un tableau de char pour initialiser la chaîne (celui qu'on a eu tant de mal à écrire, ne me dites pas que vous l'avez déjà oublié :D ) :</p><pre id="r-556002" data-claire-element-id="556002"><code data-claire-semantic="cpp">int main()
{
    ZString chaine(&quot;Bonjour&quot;);
    return 0;
}</code></pre><p id="r-556003" data-claire-element-id="556003">Compilez, lancez. Toujours pas d'erreur ? C'est très bien, c'est qu'on est sur la bonne voie :)</p><div id="r-556005" data-claire-element-id="556005" data-claire-semantic="question"><p id="r-556004" data-claire-element-id="556004">Hé ! J'ai essayé de faire un cout de ma chaîne et ça ne marche pas ! Pourquoi ?</p></div><p id="r-556006" data-claire-element-id="556006">Supposons que vous essayiez le code suivant :</p><pre id="r-556007" data-claire-element-id="556007"><code data-claire-semantic="cpp">int main()
{
    ZString chaine(&quot;Bonjour&quot;);
    cout &lt;&lt; chaine;
 
    return 0;
}</code></pre><p id="r-556008" data-claire-element-id="556008">Le compilateur vous répondra qu'il ne peut pas exécuter le cout car cout ne sait pas lire les objets de type ZString (pour lui c'est comme une boîte noire, il ne sait pas ce qu'il y a à l'intérieur). Il va falloir le lui apprendre en surchargeant l'opérateur &lt;&lt; comme on l'a appris dans le chapitre sur la surcharge des opérateurs.<br/> On verra ça un peu plus loin.</p><div id="r-556010" data-claire-element-id="556010" data-claire-semantic="question"><p id="r-556009" data-claire-element-id="556009">Ok, mais en attendant comment je fais pour afficher ce que contient ma chaine de type ZString ?</p></div><p id="r-556011" data-claire-element-id="556011">Comme surcharger l'opérateur &lt;&lt; est un peu délicat et compliqué, on ne le verra que plus loin.<br/> En attendant par contre, vous pouvez écrire une méthode afficher() dans la classe ZString qui affichera la chaîne :</p><pre id="r-556012" data-claire-element-id="556012"><code data-claire-semantic="cpp">void ZString::afficher()
{
    cout &lt;&lt; m_chaine &lt;&lt; endl;
}</code></pre><p id="r-556013" data-claire-element-id="556013">Tout ce que la méthode afficher() fait, c'est afficher la chaîne de caractères qu'elle stocke. Ca consiste à faire un cout de m_chaine. C'est tout bête, mais si vous ne le dites pas à l'ordinateur il ne pourra pas deviner :p</p><p id="r-556014" data-claire-element-id="556014">Dans le main, vous pouvez maintenant afficher votre chaîne !</p><pre id="r-556015" data-claire-element-id="556015"><code data-claire-semantic="cpp">int main()
{
    ZString chaine(&quot;Bonjour&quot;);
    chaine.afficher();
 
    return 0;
}</code></pre><p id="r-556016" data-claire-element-id="556016">Résultat :</p><pre id="r-556017" data-claire-element-id="556017"><code data-claire-semantic="console">Bonjour</code></pre>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring">TP : La POO en pratique avec ZString</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/notre-objectif-2">
Notre objectif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/quelques-preparatifs">
Quelques préparatifs
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/constructeurs-et-destructeur-1">
Constructeurs et destructeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/la-surcharge-des-operateurs-1">
La surcharge des opérateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/recapitulatif-18">
Récapitulatif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/aller-encore-plus-loin-1">
Aller (encore) plus loin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/quelques-preparatifs">
<span class="arrow"></span>
<span class="next">Quelques préparatifs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/la-surcharge-des-operateurs-1">
<span class="next">La surcharge des opérateurs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lasurchargedesoprateurs"></a><h2>La surcharge des opérateurs</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/constructeurs-et-destructeur-1">
<span class="arrow"></span>
<span class="next">Constructeurs et destructeur</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/recapitulatif-18">
<span class="next">Récapitulatif</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-556020" data-claire-element-id="556020">Nous avons écrit des constructeurs, un destructeur et une méthode afficher().<br/> Avec ça, nous pouvons créer des chaînes de type ZString et les afficher. Cool. Mais c'est pas encore bien passionnant.</p><p id="r-556021" data-claire-element-id="556021">Les choses vont commencer à devenir intéressantes à partir de maintenant. Nous allons faire quelques surcharges d'opérateurs pour profiter de toute la puissance du C++.</p><p id="r-556022" data-claire-element-id="556022">Nous allons surcharger les opérateurs suivants :</p><ul id="r-556029" data-claire-element-id="556029"><li id="r-556024" data-claire-element-id="556024"><p id="r-556023" data-claire-element-id="556023"><strong>L'opérateur =</strong> : c'est l'opérateur d'affectation qui permet d'affecter une nouvelle valeur à la chaîne après sa création.</p></li><li id="r-556026" data-claire-element-id="556026"><p id="r-556025" data-claire-element-id="556025"><strong>L'opérateur +</strong> : on va s'en servir pour combiner 2 chaînes de caractères (très pratique).</p></li><li id="r-556028" data-claire-element-id="556028"><p id="r-556027" data-claire-element-id="556027"><strong>L'opérateur &lt;&lt;</strong> : nous allons surcharger l'opérateur &lt;&lt; pour que cout soit capable d'afficher des ZString.</p></li></ul><p id="r-556030" data-claire-element-id="556030">Au boulot !</p><h2 id="r-surcharger-l-operateur" data-claire-element-id="556060">Surcharger l'opérateur =</h2><p id="r-556031" data-claire-element-id="556031">Si on souhaite changer la chaîne après la création de la ZString, il faut surcharger l'opérateur =.<br/> Je vous propose de surcharger l'opérateur = 2 fois :</p><ul id="r-556038" data-claire-element-id="556038"><li id="r-556034" data-claire-element-id="556034"><p id="r-556032" data-claire-element-id="556032">Une fois pour prendre en paramètre un tableau de char (char *).</p><pre id="r-556033" data-claire-element-id="556033"><code data-claire-semantic="cpp">ZString chaine(&quot;Bonjour&quot;); // Vaudra &quot;Bonjour&quot;
chaine = &quot;Salut&quot;; // Vaudra &quot;Salut&quot; : appel de operator=(char *)</code></pre></li><li id="r-556037" data-claire-element-id="556037"><p id="r-556035" data-claire-element-id="556035">Une autre fois pour prendre en paramètre une autre ZString.</p><pre id="r-556036" data-claire-element-id="556036"><code data-claire-semantic="cpp">ZString chaine(&quot;Bonjour&quot;); // Vaudra &quot;Bonjour&quot;
ZString autreChaine;
 
autreChaine = chaine; // Vaudra &quot;Bonjour&quot; : appel de operator=(ZString &amp;)</code></pre></li></ul><h3 id="r-operator-char" data-claire-element-id="556050">operator=(char *)</h3><p id="r-556039" data-claire-element-id="556039">Commençons par le cas le plus simple : celui où on nous envoie un char * (un texte entre guillemets par exemple).</p><p id="r-556040" data-claire-element-id="556040">Comme vous l'avez appris dans le chapitre sur la surcharge des opérateurs (je n'y reviens pas), le prototype de la méthode devra être le suivant :</p><pre id="r-556041" data-claire-element-id="556041"><code data-claire-semantic="cpp">ZString operator=(const char *chaine);</code></pre><p id="r-556042" data-claire-element-id="556042">A nous d'implémenter la méthode. Le but de l'opérateur = est de mettre dans l'objet la chaîne qu'on lui envoie en paramètre.<br/> Pour des raisons techniques que je ne détaillerai pas ici, il faudra que l'objet se renvoie lui-même à la fin de la méthode (via un return *this;).</p><pre id="r-556043" data-claire-element-id="556043"><code data-claire-semantic="cpp">ZString ZString::operator=(const char *chaine)
{
    delete[] m_chaine;
    m_chaine = copie(chaine);
    m_longueur = longueur(chaine);
 
    return *this;
}</code></pre><p id="r-556044" data-claire-element-id="556044">On doit dans un premier temps supprimer le tableau de char m_chaine que contenait notre objet. En effet, nous allons affecter une nouvelle chaîne à notre objet qui va &quot;écraser&quot; l'ancienne. Il faut bien penser à supprimer l'ancienne d'abord, sinon l'ancienne chaîne va persister en mémoire et va consommer de la mémoire pour rien !</p><p id="r-556045" data-claire-element-id="556045">Vous noterez qu'à part ça et le return, c'est exactement le même code que le constructeur qu'on a écrit tout à l'heure. Et c'est logique, le but de cette méthode est le même (sauf qu'elle ne s'exécute pas au même moment) : il lui faut copier la chaîne qu'on lui envoie pour en avoir une propre à notre classe, et adapter l'attribut m_longueur pour qu'il indique la bonne longueur de chaîne.</p><p id="r-556046" data-claire-element-id="556046">Le return *this, je ne reviens pas dessus, c'est comme ça que tout operator= doit terminer, point barre ;)</p><p id="r-556047" data-claire-element-id="556047">On peut maintenant tester ce code dans le main et admirer comme c'est beau quand ça marche :D</p><pre id="r-556048" data-claire-element-id="556048"><code data-claire-semantic="cpp">int main()
{
    ZString chaine(&quot;Bonjour&quot;);
    chaine.afficher();
 
    chaine = &quot;Salut&quot;;
    chaine.afficher();
 
    return 0;
}</code></pre><pre id="r-556049" data-claire-element-id="556049"><code data-claire-semantic="console">Bonjour
Salut</code></pre><h3 id="r-operator-const-zstring" data-claire-element-id="556059">operator=(const ZString &amp;)</h3><p id="r-556051" data-claire-element-id="556051">Nous avons réussi à surcharger l'opérateur = pour qu'il accepte les tableaux de char, maintenant nous allons faire en sorte qu'il accepte aussi les ZString (pour pouvoir affecter une ZString par une autre ZString).</p><p id="r-556052" data-claire-element-id="556052">Le code de cette méthode sera quasiment le même, il faut juste s'adapter au fait que l'on reçoit une référence vers une ZString au lieu d'un tableau de char :</p><pre id="r-556053" data-claire-element-id="556053"><code data-claire-semantic="cpp">ZString ZString::operator=(const ZString &amp;chaine)
{
    delete[] m_chaine;
    m_chaine = copie(chaine.m_chaine);
    m_longueur = chaine.m_longueur;
 
    return *this;
}</code></pre><p id="r-556054" data-claire-element-id="556054">Voici un main pour tester cet opérateur :</p><pre id="r-556055" data-claire-element-id="556055"><code data-claire-semantic="cpp">int main()
{
    ZString chaine(&quot;Bonjour&quot;);
    ZString autreChaine;
 
    autreChaine = chaine; // Vaudra &quot;Bonjour&quot; : appel de operator=(ZString &amp;)
 
    // Vérifions que les chaînes soient les mêmes
    chaine.afficher();
    autreChaine.afficher();
 
    return 0;
}</code></pre><p id="r-556056" data-claire-element-id="556056">Si tout va bien, les deux affichages devraient produire le même résultat :</p><pre id="r-556057" data-claire-element-id="556057"><code data-claire-semantic="console">Bonjour
Bonjour</code></pre><p id="r-556058" data-claire-element-id="556058">Parfait :) <br/> On peut maintenant affecter une ZString avec une autre ZString.</p><h2 id="r-surcharger-l-operateur-1" data-claire-element-id="556088">Surcharger l'opérateur +</h2><p id="r-556061" data-claire-element-id="556061">Passons à la surcharge de l'opérateur +, qui va nous permettre d'assembler 2 chaînes de caractères. Là encore, je pense qu'il serait bien d'écrire 2 versions de cette méthode :</p><ul id="r-556068" data-claire-element-id="556068"><li id="r-556064" data-claire-element-id="556064"><p id="r-556062" data-claire-element-id="556062">Une fois pour prendre en paramètre un tableau de char (char *).</p><pre id="r-556063" data-claire-element-id="556063"><code data-claire-semantic="cpp">ZString chaine(&quot;Bonjour&quot;); // Vaudra &quot;Bonjour&quot;
ZString resultat;
 
resultat = chaine + &quot; Mateo&quot;; // Vaudra &quot;Bonjour Mateo&quot; : appel de operator+(char *)</code></pre></li><li id="r-556067" data-claire-element-id="556067"><p id="r-556065" data-claire-element-id="556065">Une autre fois pour prendre en paramètre une autre ZString.</p><pre id="r-556066" data-claire-element-id="556066"><code data-claire-semantic="cpp">ZString chaine(&quot;Bonjour&quot;), nom(&quot; Mateo&quot;);
ZString resultat;
 
resultat = chaine + nom; // Vaudra &quot;Bonjour Mateo&quot; : appel de operator+(ZString &amp;)</code></pre></li></ul><h3 id="r-operator-char-1" data-claire-element-id="556082">operator+(char *)</h3><p id="r-556069" data-claire-element-id="556069">Un opérateur + ne doit pas modifier l'objet lui-même mais retourner un résultat correspondant à la somme des objets qu'on additionne (ouf ! :D ).<br/> Cela veut dire qu'il ne faut pas trop se calquer sur l'opérateur = car ça fonctionne différemment.</p><p id="r-556070" data-claire-element-id="556070">L'écriture de cette méthode est assez délicate (il faut un peu réfléchir quoi :-°).<br/> Voilà comment je vous propose d'additionner les 2 chaînes :</p><pre id="r-556071" data-claire-element-id="556071"><code data-claire-semantic="cpp">ZString ZString::operator+(const char *chaine)
{
    int tailleTotale = m_longueur + longueur(chaine);
    char *sommeChaines = new char[tailleTotale + 1];
 
    for (int i = 0 ; i &lt; m_longueur ; i++)
    {
        sommeChaines[i] = m_chaine[i];
    }
 
    for (int i = m_longueur ; i &lt; tailleTotale ; i++)
    {
        sommeChaines[i] = chaine[i - m_longueur];
    }
    sommeChaines[tailleTotale] = '\0';
 
    ZString resultat(sommeChaines);
    delete[] sommeChaines;
    return resultat;
}</code></pre><p id="r-556072" data-claire-element-id="556072">Ce qu'il faut bien comprendre, c'est qu'on travaille sur 2 chaînes :</p><ul id="r-556077" data-claire-element-id="556077"><li id="r-556074" data-claire-element-id="556074"><p id="r-556073" data-claire-element-id="556073"><em>m_chaine</em> : correspondant à la chaîne de l'objet <strong>dans </strong>lequel on est (ici &quot;Bonjour&quot;).</p></li><li id="r-556076" data-claire-element-id="556076"><p id="r-556075" data-claire-element-id="556075"><em>chaine </em>: qui est la chaîne qu'on ajoute (ici &quot; Mateo&quot;).</p></li></ul><p id="r-556078" data-claire-element-id="556078">Vous noterez qu'on se sert ici de l'attribut m_longueur de notre objet pour éviter d'avoir à recalculer la longueur de la chaîne contenue dans notre objet.<br/> Après le reste, ben c'est un algorithme. On crée une chaîne <em>sommeChaines </em>de la taille correspondant à la somme des 2 chaînes, puis on fait une première boucle pour y ajouter m_chaine, et une seconde boucle pour y ajouter chaine.</p><p id="r-556079" data-claire-element-id="556079">Enfin, on crée un objet de type ZString (car il faut retourner une ZString impérativement) et on lui envoie la somme des chaînes pour que notre nouvelle ZString contienne &quot;Bonjour Mateo&quot;.<br/> Enfin, on n'oublie pas de supprimer le tableau de char <em>sommeChaines </em>qu'on avait alloué dynamiquement et qui ne nous sert plus à rien maintenant.</p><aside id="r-556081" data-claire-element-id="556081" data-claire-semantic="information"><p id="r-556080" data-claire-element-id="556080">Pour information, avant d'arriver à faire marcher cette méthode j'y ai passé facilement une bonne heure. Mon programme plantait pour diverses raisons.<br/> Tout ça pour vous dire que j'écris pas le bon algorithme du premier coup, qu'il m'arrive de faire des erreurs et de passer du temps à chercher pourquoi ça plante. Je suis un humain tout comme vous :p</p></aside><h3 id="r-operator-zstring" data-claire-element-id="556087">operator+(ZString &amp;)</h3><p id="r-556083" data-claire-element-id="556083">Cette surcharge fonctionne de la même manière mais prend en entrée une autre ZString. Il suffit d'adapter un peu le code, le plus dur ayant déjà été fait.</p><p id="r-556084" data-claire-element-id="556084">Et hop !</p><pre id="r-556085" data-claire-element-id="556085"><code data-claire-semantic="cpp">ZString ZString::operator+(const ZString &amp;chaine)
{
    int tailleTotale = m_longueur + chaine.m_longueur;
    char *sommeChaines = new char[tailleTotale + 1];
 
    for (int i = 0 ; i &lt; m_longueur ; i++)
    {
        sommeChaines[i] = m_chaine[i];
    }
 
    for (int i = m_longueur ; i &lt; tailleTotale ; i++)
    {
        sommeChaines[i] = chaine.m_chaine[i - m_longueur];
    }
    sommeChaines[tailleTotale] = '\0';
 
    ZString resultat(sommeChaines);
    delete[] sommeChaines;
    return resultat;
}</code></pre><p id="r-556086" data-claire-element-id="556086">Le principe est le même. On profite du fait que l'élément qu'on nous envoie est une ZString pour utiliser son attribut m_longueur (ce qui nous évite d'avoir à recalculer la longueur de sa chaîne).</p><h2 id="r-surcharger-l-operateur-2" data-claire-element-id="556106">Surcharger l'opérateur &lt;&lt;</h2><p id="r-556089" data-claire-element-id="556089">Nous souhaitons maintenant pouvoir faire des <em>cout </em>sur des ZString.<br/> C'est un peu délicat, car il faut en théorie modifier la classe qui est derrière l'objet <em>cout</em>.</p><p id="r-556090" data-claire-element-id="556090">En effet, faire :</p><pre id="r-556091" data-claire-element-id="556091"><code data-claire-semantic="cpp">ZString chaine;
 
cout &lt;&lt; chaine;</code></pre><p id="r-556092" data-claire-element-id="556092">... revient à écrire comme vous le savez maintenant :</p><pre id="r-556093" data-claire-element-id="556093"><code data-claire-semantic="cpp">ZString chaine;
 
cout.operator&lt;&lt;(chaine);</code></pre><p id="r-556094" data-claire-element-id="556094">Il faudrait donc surcharger la méthode operator&lt;&lt; de la classe qui gère l'objet cout, à savoir la classe <em>ostream</em>.</p><p id="r-556095" data-claire-element-id="556095">Le problème, <a href="tuto-3-16681-1-la-surcharge-d-operateurs.html#ss_part_5">comme je vous l'avais déjà expliqué</a>, c'est qu'on ne peut pas modifier la classe ostream, on n'y a pas accès.<br/> En revanche, on peut tricher en créant une simple fonction (comme en C !) de cette forme-là :</p><pre id="r-556096" data-claire-element-id="556096"><code data-claire-semantic="cpp">ostream &amp;operator&lt;&lt;( ostream &amp;out, ZString &amp;chaine )
{
    out &lt;&lt; chaine.getChaine();
    return out;
}</code></pre><p id="r-556097" data-claire-element-id="556097"><em>J'ai placé cette fonction dans ZString.cpp. Son prototype est dans ZString.h, mais attention, mettez-le en-dehors de la déclaration de la classe car ce n'est pas une méthode de la classe !</em></p><div id="r-556099" data-claire-element-id="556099" data-claire-semantic="question"><p id="r-556098" data-claire-element-id="556098">Pourquoi ne pas avoir écrit <em>chaine.m_chaine</em> cette fois ?</p></div><p id="r-556100" data-claire-element-id="556100">Jusqu'ici je pouvais le faire car j'étais à l'intérieur même de la classe, et donc j'avais accès à tous les attributs privés, même s'il s'agissait d'un autre objet de la même classe.</p><p id="r-556101" data-claire-element-id="556101">Là, on est dans une fonction qui n'a rien à voir avec la classe ZString. Elle n'a donc pas accès aux attributs. C'est pour cette raison que j'appelle la méthode getChaine() de ZString...<br/> Je sais. On n'avait pas écrit de méthode getChaine() jusqu'ici. Il s'agit juste d'un accesseur : vous devriez être capable de l'écrire en 10s chrono, il fait juste un return m_chaine; :)</p><p id="r-556102" data-claire-element-id="556102">On peut maintenant faire des cout d'objets de type ZString dans le main ! :D</p><pre id="r-556103" data-claire-element-id="556103"><code data-claire-semantic="cpp">int main()
{
    ZString chaine(&quot;Bonjour&quot;);
 
    cout &lt;&lt; chaine;
 
    return 0;
}</code></pre><pre id="r-556104" data-claire-element-id="556104"><code data-claire-semantic="console">Bonjour</code></pre><p id="r-556105" data-claire-element-id="556105">Joie, bonheur et volupté : ça marche ! :D</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring">TP : La POO en pratique avec ZString</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/notre-objectif-2">
Notre objectif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/quelques-preparatifs">
Quelques préparatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/constructeurs-et-destructeur-1">
Constructeurs et destructeur
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/la-surcharge-des-operateurs-1">
La surcharge des opérateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/recapitulatif-18">
Récapitulatif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/aller-encore-plus-loin-1">
Aller (encore) plus loin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/constructeurs-et-destructeur-1">
<span class="arrow"></span>
<span class="next">Constructeurs et destructeur</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/recapitulatif-18">
<span class="next">Récapitulatif</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Rcapitulatif"></a><h2>Récapitulatif</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/la-surcharge-des-operateurs-1">
<span class="arrow"></span>
<span class="next">La surcharge des opérateurs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/aller-encore-plus-loin-1">
<span class="next">Aller (encore) plus loin</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-556108" data-claire-element-id="556108">Je crois que vu tout ce qu'on a fait jusqu'ici, un petit récapitulatif s'impose.<br/> Je vais vous donner le code source de chacun des 3 fichiers (main.cpp, ZString.cpp et ZString.h) puis je vous proposerai de télécharger le projet en l'état actuel.</p><p id="r-556109" data-claire-element-id="556109">Nous finirons ensuite ce TP par une liste de suggestions d'améliorations de la classe ZString. Elle marche, certes, mais on pourrait encore lui rajouter de nombreuses fonctionnalités !</p><h2 id="r-main-cpp-14" data-claire-element-id="556115">main.cpp</h2><p id="r-556110" data-claire-element-id="556110">Ce fichier contient le main qui fait quelques tests sur la classe ZString :</p><pre id="r-556111" data-claire-element-id="556111"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &quot;ZString.h&quot;
 
using namespace std;
 
int main()
{
    ZString chaine(&quot;Bonjour&quot;);
    ZString nom = &quot;Mateo&quot;; // Cette façon d'initialisation revient au même
    ZString resultat;
 
    resultat = chaine + &quot; &quot; + nom;
 
    cout &lt;&lt; &quot;Le resultat vaut maintenant : &quot; &lt;&lt; resultat &lt;&lt; endl;
 
    return 0;
}</code></pre><p id="r-556112" data-claire-element-id="556112">Le résultat qui doit s'afficher si tout va bien est :</p><pre id="r-556113" data-claire-element-id="556113"><code data-claire-semantic="console">Le resultat vaut maintenant : Bonjour Mateo</code></pre><p id="r-556114" data-claire-element-id="556114">Avec ce code on teste le constructeur, le destructeur, l'opérateur =, les opérateurs +, le cout...</p><h2 id="r-zstring-h-1" data-claire-element-id="556118">ZString.h</h2><p id="r-556116" data-claire-element-id="556116">Le coeur de notre classe est là. On y trouve la définition de ZString, ses attributs, ses méthodes.<br/> On trouve aussi le prototype de l'opérateur &lt;&lt;, en-dehors de la classe comme je vous l'ai dit car c'est l'opérateur de la classe ostream que l'on modifie là, pas celui de la classe ZString.</p><pre id="r-556117" data-claire-element-id="556117"><code data-claire-semantic="cpp">#ifndef DEF_ZSTRING
#define DEF_ZSTRING
 
#include &lt;iostream&gt;
 
class ZString
{
    public:
        ZString();
        ZString(const char *chaine);
        ZString(const ZString &amp;chaine);
        ~ZString();
        int longueur(const char *chaine);
        char *copie(const char *chaine);
        void afficher();
        ZString operator=(const char *chaine);
        ZString operator=(const ZString &amp;chaine);
        ZString operator+(const char *chaine);
        ZString operator+(const ZString &amp;chaine);
        char *getChaine();
 
    private:
        char *m_chaine;
        int m_longueur;
};
 
std::ostream &amp;operator&lt;&lt;( std::ostream &amp;out, ZString &amp;chaine );
 
#endif</code></pre><h2 id="r-zstring-cpp-1" data-claire-element-id="556121">ZString.cpp</h2><p id="r-556119" data-claire-element-id="556119">C'est le plus gros fichier, celui qui nous aura donné le plus de fil à retordre aussi ^^ <br/> Il contient l'implémentation de toutes les méthodes de la classe ZString :</p><pre id="r-556120" data-claire-element-id="556120"><code data-claire-semantic="cpp">#include &quot;ZString.h&quot;

using namespace std;
 
ZString::ZString()
{
    m_chaine = NULL;
    m_longueur = 0;
}
 
ZString::ZString(const char *chaine)
{
    m_chaine = copie(chaine);
    m_longueur = longueur(chaine);
}
 
ZString::ZString(const ZString &amp;chaine)
{
    m_chaine = copie(chaine.m_chaine);
    m_longueur = chaine.m_longueur;
}
 
 
ZString ZString::operator=(const char *chaine)
{
    delete[] m_chaine;
    m_chaine = copie(chaine);
    m_longueur = longueur(chaine);
 
    return *this;
}
 
ZString ZString::operator=(const ZString &amp;chaine)
{
    delete[] m_chaine;
    m_chaine = copie(chaine.m_chaine);
    m_longueur = chaine.m_longueur;
 
    return *this;
}
 
ZString ZString::operator+(const char *chaine)
{
    int tailleTotale = m_longueur + longueur(chaine);
    char *sommeChaines = new char[tailleTotale + 1];
 
    for (int i = 0 ; i &lt; m_longueur ; i++)
    {
        sommeChaines[i] = m_chaine[i];
    }
 
    for (int i = m_longueur ; i &lt; tailleTotale ; i++)
    {
        sommeChaines[i] = chaine[i - m_longueur];
    }
    sommeChaines[tailleTotale] = '\0';
 
    ZString resultat(sommeChaines);
    delete[] sommeChaines;
    return resultat;
}
 
ZString ZString::operator+(const ZString &amp;chaine)
{
    int tailleTotale = m_longueur + chaine.m_longueur;
    char *sommeChaines = new char[tailleTotale + 1];
 
    for (int i = 0 ; i &lt; m_longueur ; i++)
    {
        sommeChaines[i] = m_chaine[i];
    }
 
    for (int i = m_longueur ; i &lt; tailleTotale ; i++)
    {
        sommeChaines[i] = chaine.m_chaine[i - m_longueur];
    }
    sommeChaines[tailleTotale] = '\0';
 
    ZString resultat(sommeChaines);
    delete[] sommeChaines;
    return resultat;
}
 
ostream &amp;operator&lt;&lt;( ostream &amp;out, ZString &amp;chaine )
{
    out &lt;&lt; chaine.getChaine();
    return out;
}
 
char *ZString::getChaine()
{
    return m_chaine;
}
 
void ZString::afficher()
{
    cout &lt;&lt; m_chaine &lt;&lt; endl;
}
 
int ZString::longueur(const char *chaine)
{
    int i = 0;
 
    while (chaine[i] != '\0')
    {
        i++;
    }
 
    return i;
}
 
char *ZString::copie(const char *chaine)
{
    int taille = longueur(chaine);
    char *chaineCopie = new char[taille + 1];
 
 
    for (int i = 0 ; i &lt; taille ; i++)
    {
        chaineCopie[i] = chaine[i];
    }
    chaineCopie[taille] = '\0';
 
    return chaineCopie;
}
 
 
ZString::~ZString()
{
    delete[] m_chaine;
}</code></pre><h2 id="r-telecharger-le-projet-3" data-claire-element-id="556124">Télécharger le projet</h2><p id="r-556122" data-claire-element-id="556122">Vous pouvez télécharger le projet (réalisé sous Code::Blocks) en cliquant sur le lien ci-dessous :</p><p id="r-556123" data-claire-element-id="556123"><a href="medias/www.siteduzero.com_uploads_fr_ftp_mateo21_cpp_zstring.zip">Télécharger le projet (1 Ko)</a></p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring">TP : La POO en pratique avec ZString</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/notre-objectif-2">
Notre objectif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/quelques-preparatifs">
Quelques préparatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/constructeurs-et-destructeur-1">
Constructeurs et destructeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/la-surcharge-des-operateurs-1">
La surcharge des opérateurs
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/recapitulatif-18">
Récapitulatif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/aller-encore-plus-loin-1">
Aller (encore) plus loin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/la-surcharge-des-operateurs-1">
<span class="arrow"></span>
<span class="next">La surcharge des opérateurs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/aller-encore-plus-loin-1">
<span class="next">Aller (encore) plus loin</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Allerencoreplusloin"></a><h2>Aller (encore) plus loin</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/recapitulatif-18">
<span class="arrow"></span>
<span class="next">Récapitulatif</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-556126" data-claire-element-id="556126">Dans un premier temps, je vous conseille de bien potasser mon code source, d'essayer de le lire, le relire, le comprendre. Il y a peu de chances pour que vous ayez tout saisi du premier coup, mais si vous prenez le temps de bien analyser mon code et de relire mes explications, je suis sûr que vous allez progressivement vous sentir plus à l'aise là-dedans :)</p><p id="r-556127" data-claire-element-id="556127">Maintenant, ce serait dommage de s'arrêter en si bon chemin vous ne trouvez pas ?<br/> Je vous propose une série de modifications et ajouts que vous pouvez faire sur la classe ZString pour améliorer ses fonctionnalités :</p><ul id="r-556156" data-claire-element-id="556156"><li id="r-556129" data-claire-element-id="556129"><p id="r-556128" data-claire-element-id="556128">On vient de faire l'accesseur <em>getChaine()</em>, mais ça pourrait être bien aussi de faire l'accesseur <em>getLongueur()</em> pour que l'utilisateur puisse savoir à tout moment la longueur de sa chaîne.</p></li><li id="r-556131" data-claire-element-id="556131"><p id="r-556130" data-claire-element-id="556130">Une méthode <em>vider(</em>) pourrait supprimer le contenu de la ZString. Il faudrait supprimer la chaîne mais aussi penser à remettre l'attribut m_longueur à 0.</p></li><li id="r-556140" data-claire-element-id="556140"><p id="r-556132" data-claire-element-id="556132">Une méthode <em>recherche()</em> pourrait faire une recherche dans la ZString. On pourrait même l'écrire en 3 versions :</p><ul id="r-556139" data-claire-element-id="556139"><li id="r-556134" data-claire-element-id="556134"><p id="r-556133" data-claire-element-id="556133">Une qui prend en paramètre un char (recherche d'un caractère)</p></li><li id="r-556136" data-claire-element-id="556136"><p id="r-556135" data-claire-element-id="556135">Une qui prend en paramètre un char * (recherche d'une chaîne)</p></li><li id="r-556138" data-claire-element-id="556138"><p id="r-556137" data-claire-element-id="556137">Une autre qui prend en paramètre une ZString (recherche d'une chaîne).</p></li></ul></li><li id="r-556142" data-claire-element-id="556142"><p id="r-556141" data-claire-element-id="556141">Dans le même style, on peut imaginer une méthode <em>remplacer()</em> qui prend au moins 2 paramètres : ce que vous recherchez, et par quoi vous voulez le remplacer.</p></li><li id="r-556144" data-claire-element-id="556144"><p id="r-556143" data-claire-element-id="556143">On n'a pas surchargé l'opérateur de comparaison == avec <em>operator==()</em> ! Si on veut pouvoir tester if (chaine1 == chaine2), il faut que l'on ait écrit cette méthode ! De même, vous devriez écrire <em>operator!=()</em> pour tester si 2 chaînes sont bien différentes, ça va de paire.</p></li><li id="r-556148" data-claire-element-id="556148"><p id="r-556145" data-claire-element-id="556145">Plus difficile : essayez de surcharger l'opérateur [] avec la méthode <em>operator[]()</em>. Le but est de pouvoir écrire :</p><pre id="r-556146" data-claire-element-id="556146"><code data-claire-semantic="cpp">ZString chaine = &quot;Mateo&quot;;
cout &lt;&lt; chaine[2]; // Doit afficher &quot;t&quot;</code></pre><p id="r-556147" data-claire-element-id="556147">Le paramètre passé à cette méthode est un nombre (int) correspondant au caractère de la chaîne que l'on veut extraire. En écrivant cette méthode, on peut alors récupérer n'importe quel caractère de la chaîne comme on le faisait avec les tableaux de char !</p></li><li id="r-556155" data-claire-element-id="556155"><p id="r-556149" data-claire-element-id="556149">Nous découvrirons dans un prochain chapitre ce que sont les méthodes statiques et constantes. Lorsque vous aurez lu ce chapitre, voyez si vous ne pouvez pas faire en sorte que certaines méthodes soient :</p><ul id="r-556154" data-claire-element-id="556154"><li id="r-556151" data-claire-element-id="556151"><p id="r-556150" data-claire-element-id="556150">Constantes : ce sont les méthodes qui ne modifient pas les attributs de votre objet.</p></li><li id="r-556153" data-claire-element-id="556153"><p id="r-556152" data-claire-element-id="556152">Statiques : ce sont les méthodes qui n'interagissent pas du tout avec les attributs de votre objet et qui pourraient être de simples fonctions. C'est le cas de copie() et longueur() par exemple.</p></li></ul></li></ul><p id="r-556157" data-claire-element-id="556157">Il vous faudra peut-être faire des recherches, voire demander de l'aide pour écrire certaines de ces méthodes.<br/> Il y a du challenge, mais le jeu en vaut la chandelle !</p><p id="r-556158" data-claire-element-id="556158">Vous savez quoi ? Je crois que c'est un des premiers chapitres que j'écris où je suis soulagé d'arriver à la fin :lol:</p><p id="r-556159" data-claire-element-id="556159">Il faut dire que ce TP n'était pas facile, vous comprenez pourquoi il était impensable de vous lâcher dans la nature tous seuls. J'ai tenu à vous expliquer pas à pas mon raisonnement et ma démarche pour écrire une classe en C++.</p><p id="r-556160" data-claire-element-id="556160">Je vous rassure : en temps normal on ne s'amuse pas à réécrire la classe string ! Toutefois, c'est vraiment un excellent exercice. Si vous prenez le temps de bien analyser ce qu'on a fait et de faire les améliorations proposées, vous allez <em>vraiment </em>progresser en C++.<br/> Vous voyez que ce n'est pas un langage simple, mais avec un peu de pratique on finit par acquérir certains automatismes qui limitent nos erreurs. Et encore. Si vous saviez le nombre d'erreurs que j'ai faites avant d'arriver à faire marcher la classe ZString ! :p</p><p id="r-556161" data-claire-element-id="556161">Tout ça pour vous dire qu'il ne faut pas paniquer devant cette apparente difficulté. Retroussez vos manches, relisez, réfléchissez. Vous progresserez !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring">TP : La POO en pratique avec ZString</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/notre-objectif-2">
Notre objectif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/quelques-preparatifs">
Quelques préparatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/constructeurs-et-destructeur-1">
Constructeurs et destructeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/la-surcharge-des-operateurs-1">
La surcharge des opérateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/recapitulatif-18">
Récapitulatif
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/aller-encore-plus-loin-1">
Aller (encore) plus loin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-la-poo-en-pratique-avec-zstring/recapitulatif-18">
<span class="arrow"></span>
<span class="next">Récapitulatif</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/-la-poo-en-pratique-avec-zstring.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 03:04:46 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/-la-poo-en-pratique-avec-zstring.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:41:00 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/qt-creation-de-plugins.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Oct 2013 20:06:07 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/qt-creation-de-plugins.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 03:47:18 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Qt - Création de plugins</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/qt-creation-de-plugins.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Qt - Création de plugins</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Qt-Crationdeplugins">Qt - Création de plugins</a><br/><a href="#Introduction">Introduction</a><br/><a href="#Thorie">Théorie</a><br/><a href="#PratiqueminiTP">Pratique : mini TP</a><br/></div>
<a name="Qt-Crationdeplugins"></a><h2>Qt - Création de plugins</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/introduction-91">
<span class="next">Introduction</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-571219" data-claire-element-id="571219">Ce tutoriel a pour but de vous faire découvrir les plugins avec Qt.</p><p id="r-571220" data-claire-element-id="571220">Il demande quelques connaissances en POO, dont l'abstraction de classe et montre un petit bout de code utilisant les templates.<br/> Si vous ne connaissez pas cela, ou si vous n'y êtes pas habitués, vous pouvez lire <a href="http://www.siteduzero.com/tutoriel-3-8965-c-notions-avancees.html">le tutoriel de Nanoc</a> qui explique bien quelques principes avancés de la POO (en C++).</p><p id="r-571221" data-claire-element-id="571221">Dans un premier temps, j'introduirai le principe des plugins, puis dans un second temps, vous aurez droit à une grande partie théorique. Pour finir et pour s'entraîner un petit peu, vous disposerez un mini TP sur la création d'un programme utilisant des plugins.</p>
</div><a name="Introduction"></a><h2>Introduction</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/theorie-22">
<span class="next">Théorie</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-definition-80" data-claire-element-id="571223">Définition</h2><p id="r-571222" data-claire-element-id="571222">En informatique, un plugin est un moyen de rajouter de nouvelles fonctionnalités à un logiciel de base. C'est pour cela qu'on appelle aussi les plugins « modules » ou « greffons ».<br/> Ces modules sont en général utilisés pour qu'un programme puisse évoluer facilement. De plus, d'autres personnes voulant aider le logiciel peuvent à leur tour en créer pour ajouter de nouvelles fonctionnalités. L'un des cas les plus connus reste le célèbre navigateur Internet Mozilla Firefox.</p><h2 id="r-ou-et-pourquoi" data-claire-element-id="571226">Où et pourquoi ?</h2><p id="r-571224" data-claire-element-id="571224">On peut rendre un programme totalement modulaire mais il ne faut pas perdre de vue que dans certains cas, cela peut se révéler complètement inutile. En effet, nous verrons par la suite qu'un plugin doit avoir une sorte de définition. Plus on veut rendre une partie de logiciel modulaire et plus la définition doit être floue, abstraite. Mais si elle l'était trop, cette partie n'aurait plus de but et ne servirait donc plus.</p><p id="r-571225" data-claire-element-id="571225">Il faut alors un but minimum pour qu'un système de plugins soit rentable. On peut pourtant en mettre dans beaucoup de programmes et votre seule limite est votre imagination. En effet, l'utilisation des plugins peut aller de la simple boîte de dialogue à un système complet utilisant lui aussi des plugins.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins">Qt - Création de plugins</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/introduction-91">
Introduction
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/theorie-22">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/pratique-mini-tp">
Pratique : mini TP
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/theorie-22">
<span class="next">Théorie</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Thorie"></a><h2>Théorie</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/introduction-91">
<span class="arrow"></span>
<span class="next">Introduction</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/pratique-mini-tp">
<span class="next">Pratique : mini TP</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-571228" data-claire-element-id="571228">Pour créer un plugin, il suffit de créer une définition puis de l'implémenter. Cependant, un plugin seul n'est pas très utile. :D <br/> Il faut donc aussi modifier la base du programme en lui donnant un moyen de charger les plugins.</p><h2 id="r-creer-une-definition" data-claire-element-id="571256">Créer une définition</h2><p id="r-571229" data-claire-element-id="571229">Comme dit plus haut, un plugin doit avoir un but minimal et une sorte de définition.<br/> La définition est la classe qui lie le projet mère à ses plugins. En effet, pour pouvoir concevoir un plugin, il y aura besoin de cette définition. Et pour que le projet utilise les plugins, il a besoin de savoir comment ils fonctionnent.<br/> La définition est donc dans les deux projets (projet mère et projet de chaque plugin).</p><p id="r-571230" data-claire-element-id="571230">Cette définition est une simple interface, c'est-à-dire une classe abstraite contenant une liste de fonctions que tous les plugins du même type auront.</p><p id="r-571231" data-claire-element-id="571231">Par exemple la classe Animal qui permettra de créer des plugins de type Animal aura comme méthodes :</p><ul id="r-571240" data-claire-element-id="571240"><li id="r-571233" data-claire-element-id="571233"><p id="r-571232" data-claire-element-id="571232"><code data-claire-semantic="cpp">void manger(const Nourriture &amp;repas) </code> ;</p></li><li id="r-571235" data-claire-element-id="571235"><p id="r-571234" data-claire-element-id="571234"><code data-claire-semantic="cpp">void bouger(const Position &amp;destination) </code> ;</p></li><li id="r-571237" data-claire-element-id="571237"><p id="r-571236" data-claire-element-id="571236"><code data-claire-semantic="cpp">void attaquer(const Cible &amp;cible) </code> ;</p></li><li id="r-571239" data-claire-element-id="571239"><p id="r-571238" data-claire-element-id="571238">...</p></li></ul><p id="r-571241" data-claire-element-id="571241">Plus le but est abstrait et moins la définition contient de méthodes, car plus de choses devraient « coller » avec elle.</p><p id="r-571242" data-claire-element-id="571242">Vous avez peut-être remarqué que cela ressemble à l'utilisation de la POO classique. En effet, pour concevoir plusieurs objets qui se ressemblent, on crée des classes de base abstraites, puis on les spécialise. Pour créer une interface, il faut que toutes les méthodes soient virtuelles pures.</p><p id="r-571243" data-claire-element-id="571243">Pour ceux qui ne savent pas comment les définir, voici un exemple :</p><pre id="r-571244" data-claire-element-id="571244"><code data-claire-semantic="cpp">class MaClass {
    public:
	virtual ~MaClass() {}

        virtual void maFonction() = 0; // On met = 0 pour dire qu'elle est virtuelle pure.
        virtual void maFonctConst() const = 0; // On met le =0 après le const
};</code></pre><p id="r-571245" data-claire-element-id="571245">On utilise le mot-clé <code data-claire-semantic="cpp">virtual </code> pour dire que la fonction est virtuelle. Ensuite, pour dire qu'on ne peut pas la définir, c'est-à-dire qu'elle est pure, on met <code data-claire-semantic="cpp">= 0 </code> à la fin de la déclaration. Cela rend notre classe abstraite car une méthode (ou plus) n'est pas définie.</p><p id="r-571246" data-claire-element-id="571246">Vous pouvez apercevoir que l'on ne rend pas le destructeur virtuel pur. En effet, il n'est pas possible pour la classe fille de choisir ce que fera le destructeur de la classe mère.</p><p id="r-571247" data-claire-element-id="571247">Cependant, comme vous l'avez remarqué, au tout début, j'ai utilisé le mot <em>interface</em> et non <em>classe</em> directement. En effet, Qt veut que nous déclarions explicitement une interface. Pour cela, on utilise la macro-définition <a href="http://doc.trolltech.com/4.1/qtplugin.html#Q_DECLARE_INTERFACE"><strong>Q_DECLARE_INTERFACE</strong></a>.</p><p id="r-571248" data-claire-element-id="571248">Elle prend en paramètre deux choses.<br/> La première est le nom de la classe interface et la seconde est l'identifiant de l'interface sous forme de chaîne de caractères. Attention, celle-ci doit finir par le nom de la classe et être unique.<br/> En général, cette macro-définition est située juste après la déclaration de la classe.</p><aside id="r-571250" data-claire-element-id="571250" data-claire-semantic="warning"><p id="r-571249" data-claire-element-id="571249">Si vous voulez créer une interface dans un namespace, il faut que la macro-définition soit appelée hors du namespace. Pour le nom de la classe, on utilise l'opérateur de portée « :: » (par exemple : « MonNamespace::MaClasse »).</p></aside><p id="r-571251" data-claire-element-id="571251">Voici un exemple de deux interfaces :</p><pre id="r-571252" data-claire-element-id="571252"><code data-claire-semantic="cpp">#ifndef __INTER_H__
#define __INTER_H__
	#include &lt;QtPlugin&gt;
	#include &quot;EtreVivant.h&quot;	// C'est une classe comme les autres (qui sont abstraites).
	
	class Animal : public EtreVivant {
		public:
			virtual ~Inter1() { }
			
			virtual void mange(const EtreVivant &amp;proie) = 0;
			virtual void attaquer(const EtreVivant &amp;victime) = 0;

		// On peut mettre des variables.
		protected:
			int m_Faim;
			int m_Vie;
	};
	Q_DECLARE_INTERFACE(Animal, &quot;Mon programme.Animal&quot;)
		
	// Voici un exemple avec un namespace.
	namespace Out { // Un namespace qui contient des classes de sorties pour le programme. Ce n'est qu'à titre d'exemple, bien sûr.
		class Console { // Ici on a l'interface dans le namespace.
			public:
				virtual Console() {}
					
				virtual print(const std::string &amp;str) = 0;
		};
	}
	Q_DECLARE_INTERFACE(Out::Console, &quot;Mon programme.Console&quot;) // On doit utiliser l'opérateur de portée :: pour accéder à notre interface.
		
#endif</code></pre><aside id="r-571254" data-claire-element-id="571254" data-claire-semantic="warning"><p id="r-571253" data-claire-element-id="571253">Il ne faut pas mettre de point-virgule après la macro-définition Q_DECLARE_INTERFACE. Il en est de même pour toutes les macro-définitions que vous rencontrerez dans ce cours.</p></aside><p id="r-571255" data-claire-element-id="571255">Vous connaissez maintenant presque tout sur la création d'interfaces avec Qt. Il ne reste plus que la création du plugin en lui-même, qui est très simple, et le chargeur.</p><h2 id="r-creation-du-plugin" data-claire-element-id="571281">Création du plugin</h2><p id="r-571257" data-claire-element-id="571257">Un plugin est avant tout un objet qui respecte une définition. Donc pour cela, il suffit de le faire hériter de l'interface.<br/> Puisqu'un plugin est aussi un objet Qt, alors il doit hériter de QObject (directement ou indirectement).</p><p id="r-571258" data-claire-element-id="571258">Voici donc pour l'instant votre définition du plugin :</p><pre id="r-571259" data-claire-element-id="571259"><code data-claire-semantic="cpp">class MyPlugin : public QObject, public MyInter { };</code></pre><aside id="r-571261" data-claire-element-id="571261" data-claire-semantic="information"><p id="r-571260" data-claire-element-id="571260">Le fait de ne pas dériver votre plugin de QObject avant toute autre classe entraînera forcément une erreur. Veillez donc à bien faire hériter votre interface dans un premier temps de QObject, puis de toute autre classe.</p></aside><p id="r-571262" data-claire-element-id="571262">Il faut ensuite dire à Qt que cette classe n'est pas comme les autres. Tout d'abord, c'est un QObjet, donc on peut mettre la macro-définition <a href="http://doc.trolltech.com/4.1/qobject.html#Q_OBJECT"><strong>Q_OBJECT</strong></a>. Puis il faut signaler à Qt que l'on utilise une ou des interfaces. Pour cela, on utilise la macro-définition <a href="http://doc.trolltech.com/4.1/qobject.html#Q_INTERFACES"><strong>Q_INTERFACES</strong></a>. Elle attend la liste des interfaces séparées par des espaces.</p><p id="r-571263" data-claire-element-id="571263">Notre prototype de la classe est donc pour l'instant :</p><pre id="r-571264" data-claire-element-id="571264"><code data-claire-semantic="cpp">class Chien : public QObject, public Animal { // Un chien est un animal, il dérive donc de l'interface Animal.
	Q_OBJECT
	Q_INTERFACES(Animal)

	// Si notre plugin dérivait de plusieurs interfaces, il aurait fallu donner la liste à la macro-définition avec des espaces entre chaque nom.
	// Comme cela :
	// Q_INTERFACES(MyInter1 MyInter2 ...)
};</code></pre><p id="r-571265" data-claire-element-id="571265">Pour pouvoir utiliser un plugin, il faut qu'il soit concret. En effet, un plugin est avant tout une classe. Or si une classe est abstraite, elle ne peut pas être instanciée.<br/> Puisque notre plugin hérite d'une interface abstraite, il faudra donc définir toutes les méthodes virtuelles pures.</p><p id="r-571266" data-claire-element-id="571266">Si notre plugin a besoin de plus de fonctions, on peut en rajouter. Cependant, le programme de base ne pourra toucher qu'aux méthodes définies dans l'interface. En effet, il ne connaît que l'interface, il ne sait donc pas si un plugin a la fonction machin().</p><p id="r-571267" data-claire-element-id="571267">Dans l'implémentation, tout se passe comme d'habitude, mais il faut rajouter la macro-définition <a href="http://doc.trolltech.com/4.1/qtplugin.html#Q_EXPORT_PLUGIN2"><strong>Q_EXPORT_PLUGIN2(nomPlugin, nomClass)</strong></a>.<br/> Le nom du plugin est celui que l'on définira dans le <em>.pro</em> du plugin. Le nom de la classe est celui de la classe d'entrée du plugin, donc celle qui hérite de l'interface. On peut donc mettre plusieurs classes dans un plugin.</p><p id="r-571268" data-claire-element-id="571268">Voici la macro-définition pour l'exemple :</p><pre id="r-571269" data-claire-element-id="571269"><code data-claire-semantic="cpp">Q_EXPORT_PLUGIN2(nom_plugin, MyPlugin) // Pas de point-virgule après la macro-définition.</code></pre><p id="r-571270" data-claire-element-id="571270">Il faut maintenant changer le <em>.pro</em> du projet. En effet, notre « projet » ne contient pas de main, donc le compilateur ne trouvera pas de point d'entrée s'il en cherche. Il faut donc le signaler en lui disant que l'on veut faire une bibliothèque. Pour cela, on utilise la variable TEMPLATE du <em>.pro</em> comme ceci :</p><pre id="r-571271" data-claire-element-id="571271"><code data-claire-semantic="cpp">TEMPLATE = lib</code></pre><p id="r-571272" data-claire-element-id="571272">Il existe différents types de bibliothèques : les dynamiques, les statiques et aussi les plugins. On utilise alors CONFIG pour montrer à Qt que c'est un plugin :</p><pre id="r-571273" data-claire-element-id="571273"><code data-claire-semantic="cpp">CONFIG += plugin</code></pre><aside id="r-571275" data-claire-element-id="571275" data-claire-semantic="information"><p id="r-571274" data-claire-element-id="571274">Si un programme est en débogage, alors les plugins doivent aussi être en mode débogage, de même pour le release. On peut donc dire le type de compilation en rajoutant « release » ou « debug » à CONFIG.</p></aside><p id="r-571276" data-claire-element-id="571276">Pour finir, on définit le nom de la cible (c'est-à-dire le plugin) avec TARGET. C'est aussi le nom du plugin qu'on avait mis dans la macro-définition Q_EXPORT_PLUGIN2 :</p><pre id="r-571277" data-claire-element-id="571277"><code data-claire-semantic="cpp">TARGET = nom_plugin</code></pre><p id="r-571278" data-claire-element-id="571278">On a donc maintenant un <em>.pro</em> qui permet de compiler notre plugin. Il ne reste plus que la partie sur la création d'un chargeur de plugins et la partie théorique est finie.</p><aside id="r-571280" data-claire-element-id="571280" data-claire-semantic="warning"><p id="r-571279" data-claire-element-id="571279">Pour qu'il n'y ait pas d'ambiguïtés, sachez qu'un plugin ne se compile pas avec le projet mère. Il utilise donc un fichier <em>.pro</em> différent. Mais il peut utiliser des fichiers du projet mère (l'interface, notamment). De même, un plugin a son propre fichier projet et ne le partage pas avec un autre plugin.</p></aside><h2 id="r-faire-un-chargeur-de-plugins" data-claire-element-id="571297">Faire un chargeur de plugins</h2><p id="r-571282" data-claire-element-id="571282">Il est relativement simple de charger un plugin car Qt a une classe prête pour cela : <a href="http://doc.trolltech.com/4.0/qpluginloader.html"><strong>QPluginLoader</strong></a>.<br/> Pour en créer un, il suffit juste de donner le chemin vers le plugin.<br/> Ensuite, on peut récupérer un pointeur vers le plugin avec la méthode <a href="http://doc.trolltech.com/4.0/qpluginloader.html#instance"><strong>QPluginLoader::instance()</strong></a>. Elle retourne un <strong>QObject*</strong>, donc il faudra la réinterpréter en MyPlugin*, par exemple.<br/> Pour la réinterpréter, soit on utilise le cast C++ <code data-claire-semantic="cpp">reinterprete_cast&lt;T&gt;(obj) </code>, soit on utilise un cast défini par Qt : <code data-claire-semantic="cpp">qobject_cast&lt;T&gt;(obj) </code>.<br/> Puisque l'on utilise Qt et que <strong>qobject_cast</strong> utilise <strong>reinterprete_cast</strong> avec un plus, le mieux est d'utiliser <strong>qobject_cast</strong>. Ce cast demande simplement le type de transformation comme argument template et prend aussi l'objet à réinterpréter.</p><p id="r-571283" data-claire-element-id="571283">Cela se résume par ce bout de code :</p><pre id="r-571284" data-claire-element-id="571284"><code data-claire-semantic="cpp">QPluginLoader loader(&quot;./cheminVersMonPlugin&quot;); // On charge le plugin en lui donnant juste le chemin.
if(QObject *plugin = loader.instance()) { // On prend l'instance de notre plugin sous forme de QObject. On vérifie en même temps s'il n'y a pas d'erreur.
    MyPlugin* myPlugin = qobject_cast&lt;MyPlugin *&gt;(plugin); // On réinterprète alors notre QObject en MyPlugin
}</code></pre><p id="r-571285" data-claire-element-id="571285">Ce code fonctionne et permet de charger un plugin, mais il est assez basique. Un système de plugin doit permettre à une application d'évoluer facilement, elle doit donc savoir si un plugin a été ajouté. Si on met tous les plugins du même type dans le même dossier, alors on peut utiliser <a href="http://doc.trolltech.com/4.5/qdir.html"><strong>QDir</strong></a> pour lire ce dossier et donc connaître tous les plugins.</p><p id="r-571286" data-claire-element-id="571286">Déjà, il faut créer un <a href="http://doc.trolltech.com/4.5/qdir.html"><strong>QDir</strong></a> en lui donnant le dossier du programme pour être sûr de connaître le bon chemin vers le plugin.<br/> Justement, la fonction <code data-claire-semantic="cpp">qApp-&gt;applicationDirPath() </code> retourne le chemin vers l'application. :)</p><p id="r-571287" data-claire-element-id="571287">Ensuite, il faut déplacer le <a href="http://doc.trolltech.com/4.5/qdir.html"><strong>QDir</strong></a> dans le dossier du plugin avec la méthode « cd ». Si vous utilisez la console, vous verrez que l'utilisation de cette méthode est identique à la commande « cd ».</p><p id="r-571288" data-claire-element-id="571288">Voici pour l'instant le code :</p><pre id="r-571289" data-claire-element-id="571289"><code data-claire-semantic="cpp">QDir plugDir = QDir(qApp-&gt;applicationDirPath()); // On place le QDir dans le dossier de notre exécutable.
plugDir.cd(&quot;./cheminSecretVersLeTresorDuTuto&quot;); // Puis on le déplace dans le dossier des plugins. Je ne pense pas que le chemin de votre plugin soit celui-ci.</code></pre><p id="r-571290" data-claire-element-id="571290">Il faut maintenant boucler avec la liste des fichiers se trouvant dans le répertoire. <a href="http://doc.trolltech.com/4.5/qdir.html#entryList-2"><strong>QDir::entryList()</strong></a> retourne la liste des fichiers avec comme arguments la define <strong>QDir::Files</strong> qui est un filtre : il ne prendra que les fichiers du dossier, les répertoires ne seront pas listés. Elle retourne un QStringList.<br/> Puisqu'un QStringList est une List, il est alors possible d'utiliser un foreach. Un foreach est une structure de Qt qui permet de faire des actions <strong>pour chaque</strong> élément d'une liste. D'où son nom.<br/> Cela revient au même qu'une boucle itérative, mais je trouve qu'elle prend moins de place.</p><p id="r-571291" data-claire-element-id="571291">Voici comment on utilise une classe foreach :</p><pre id="r-571292" data-claire-element-id="571292"><code data-claire-semantic="cpp">// T est un type défini.

T unElement;
QList&lt;T&gt; listElement;

foreach(unElement, listElement) { // On prend chaque élément de listElement que l'on met l'un après l'autre dans la variable unElement.
    // Les actions.
}</code></pre><p id="r-571293" data-claire-element-id="571293">On se servira aussi de <a href="http://doc.trolltech.com/4.5/qdir.html#absoluteFilePath"><strong>QDir::absoluteFilePath(QString)</strong></a> qui nous permet d'avoir le chemin absolu vers le fichier.</p><p id="r-571294" data-claire-element-id="571294">Voici donc notre chargeur de plugins :</p><pre id="r-571295" data-claire-element-id="571295"><code data-claire-semantic="cpp">QList&lt;MyPlugin *&gt; m_LsPlugin; // On crée une liste de MyPlugin* qui contiendra nos plugins.
QDir plugDir = QDir(qApp-&gt;applicationDirPath()); // Comme avant, on crée un QDir.
plugDir.cd(&quot;./Chemin&quot;); // On se déplace encore.

foreach(QString file, plugDir.entryList(QDir::Files)) { // Puis on utilise le foreach.
	QPluginLoader loader(plugDir.absoluteFilePath(file)); // On fait ensuite la même chose que pour un seul plugin.
	if(QObject *plugin = loader.instance())
		MyPlugin* myPlugin = qobject_cast&lt;MyPlugin *&gt;(plugin);
		m_LsPlugin.push_back(myPlugin); // Vous pouvez maintenant les stocker ou directement les utiliser.
	}
}</code></pre><p id="r-571296" data-claire-element-id="571296">Vous avez enfin un chargeur de plugins. Vous pouvez soit utiliser une fonction soit une classe singleton (pas la peine d'avoir 50 instances) pour le chargeur.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins">Qt - Création de plugins</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/introduction-91">
Introduction
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/theorie-22">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/pratique-mini-tp">
Pratique : mini TP
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/introduction-91">
<span class="arrow"></span>
<span class="next">Introduction</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/pratique-mini-tp">
<span class="next">Pratique : mini TP</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="PratiqueminiTP"></a><h2>Pratique : mini TP</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/theorie-22">
<span class="arrow"></span>
<span class="next">Théorie</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-571299" data-claire-element-id="571299">Maintenant que vous savez comment faire pour réaliser des plugins avec Qt, je pense qu'il ne reste plus qu'à s'entraîner.<br/> Cette dernière partie sera donc sous la forme d'un mini TP où le but sera de créer une application utilisant les plugins.</p><p id="r-571300" data-claire-element-id="571300">Pour ne pas rendre l'exemple trop compliqué, il sera inutile simple.<br/> En effet, le sujet de ce cours n'est pas la création d'une grosse application. C'est pourquoi, vous aurez au maximum à créer une fenêtre.</p><p id="r-571301" data-claire-element-id="571301">J'aurais même pu vous faire faire un TP en console car Qt n'est pas qu'une bibliothèque de fenêtrage. Et vous le voyez justement dans ce cours.</p><p id="r-571302" data-claire-element-id="571302">Le programme principal de ce TP sera donc une simple fenêtre avec un menu ne contenant rien par défaut.</p><p id="r-571303" data-claire-element-id="571303">Quand vous l'aurez fini, je pense que vous trouverez que la capacité de votre programme est très limitée. :D</p><p id="r-571304" data-claire-element-id="571304">Pour mettre un but à notre programme, il faudrait alors remplir ce menu. Mais cela reviendrait à changer complètement le programme. Si on utilise les plugins dans ce cas, il suffirait de changer ou de les ajouter dans un dossier sans recompiler le projet. Il faudra simplement un chargeur de plugin mais une fois installé, on n'a plus besoin de toucher à l'application de base. De plus, d'autres pourront vous aider à développer votre application. :)</p><p id="r-571305" data-claire-element-id="571305">Je vous l'accorde, ce n'est pas vraiment le choix le plus judicieux, mais c'est pour que cela reste un exemple simple puisque je ne veux pas rendre le TP trop difficile.</p><p id="r-571306" data-claire-element-id="571306">Dans un premier temps, il faut donc d'abord créer cette fenêtre.<br/> Ensuite, puisque c'est vide pour l'instant, je vous propose de créer des plugins pour une action au hasard. Dans le TP ça sera un plugin simple qui ouvre une boîte de dialogue contenant le cri d'un animal (pour reprendre l'exemple de la partie théorique).<br/> Ce n'est pas très utile mais au moins, c'est facile. Cependant, une fois que vous aurez bien compris comment utiliser les plugins, vous pourrez créer des plugins beaucoup plus complexes (comme la résolution d'équation dans les complexes :p ).</p><p id="r-571307" data-claire-element-id="571307">Pour que vous ne vous égariez pas dans la jungle de plugins à créer, voici une petite liste des cris des animaux à faire (vous pouvez en faire d'autre si vous voulez) :</p><ul id="r-571316" data-claire-element-id="571316"><li id="r-571309" data-claire-element-id="571309"><p id="r-571308" data-claire-element-id="571308">aboiement du chien ;</p></li><li id="r-571311" data-claire-element-id="571311"><p id="r-571310" data-claire-element-id="571310">miaulement du chat ;</p></li><li id="r-571313" data-claire-element-id="571313"><p id="r-571312" data-claire-element-id="571312">hennissement du cheval ;</p></li><li id="r-571315" data-claire-element-id="571315"><p id="r-571314" data-claire-element-id="571314">hurlement d'une hystérique.</p></li></ul><h2 id="r-analyse-du-probleme" data-claire-element-id="571329">Analyse du problème</h2><p id="r-571317" data-claire-element-id="571317">Cette partie vous permet, si vous n'y arrivez pas, à mieux voir comment on pourrait résoudre ce TP.</p><aside id="r-571319" data-claire-element-id="571319" data-claire-semantic="information"><p id="r-571318" data-claire-element-id="571318">Il y a plusieurs solutions et la mienne n'est ni la meilleure ni la moins bonne (j'espère :) ) ; donc si vous faites le programme d'une autre façon, ce n'est pas grave tant que ça fonctionne.</p></aside><p id="r-571320" data-claire-element-id="571320">La création de la fenêtre principale ne demande pas énormément d'analyse car c'est une simple fenêtre qui contient un menu. Pour remplir ce menu, je pense que l'on peut stocker les plugins dans un tableau puis le boucler et y mettre les actions.</p><p id="r-571321" data-claire-element-id="571321">Il faut maintenant choisir la définition de nos plugins. Un animal a déjà un nom que l'on pourra mettre dans le menu.<br/> Il doit aussi avoir un cri qui apparaîtra quand on cliquera sur son nom.</p><p id="r-571322" data-claire-element-id="571322">Cela nous donne donc deux informations pour notre définition :</p><ul id="r-571327" data-claire-element-id="571327"><li id="r-571324" data-claire-element-id="571324"><p id="r-571323" data-claire-element-id="571323"><code data-claire-semantic="cpp">QString getName() const</code></p></li><li id="r-571326" data-claire-element-id="571326"><p id="r-571325" data-claire-element-id="571325"><code data-claire-semantic="cpp">void brawl() const [slot]</code></p></li></ul><p id="r-571328" data-claire-element-id="571328">Maintenant vous devez avoir tous les éléments pour créer ce programme. Il est donc temps de travailler un peu. :)</p><h2 id="r-correction-198" data-claire-element-id="571403">Correction</h2><p id="r-571330" data-claire-element-id="571330">Comme la création de l'application n'est pas très difficile, je vous donne la correction directement.</p><h3 id="r-header-1" data-claire-element-id="571332">Header</h3><pre id="r-571331" data-claire-element-id="571331"><code data-claire-semantic="cpp">#ifndef MYWIDGET_H
#define MYWIDGET_H
	#include &lt;QtGui/QMainWindow&gt;

	class MyWidget : public QMainWindow { // On crée un QMainWindow.
		Q_OBJECT

		public:
			MyWidget(QWidget *parent = 0);
			~MyWidget();
	};
#endif // MYWIDGET_H</code></pre><h3 id="r-l-implementation-4" data-claire-element-id="571335">L'implémentation</h3><pre id="r-571333" data-claire-element-id="571333"><code data-claire-semantic="cpp">#include &quot;mywidget.h&quot;
#include &quot;PluginInter.h&quot; //Pour que notre système puisse savoir la forme de nos plugins

#include &lt;QApplication&gt; //Pour l'utilisation de qApp plus tard
#include &lt;QMenu&gt;
#include &lt;QMenuBar&gt;

MyWidget::MyWidget(QWidget *parent) : QMainWindow(parent) {
	QMenu* mCri = menuBar()-&gt;addMenu(&quot;Cri&quot;); // On ajoute le menu.
}

MyWidget::~MyWidget() { }</code></pre><p id="r-571334" data-claire-element-id="571334">Je ne mets pas le <em>main.cpp</em> car il est trop simple et trop banal. Comme vous le voyez, je n'ai fait que le minimum (et ça se voit à l'exécution).</p><h3 id="r-le-chargeur-de-plugin" data-claire-element-id="571351">Le chargeur de plugin</h3><p id="r-571336" data-claire-element-id="571336">Pour le chargeur de plugin, j'ai remarqué que l'on n'utilise que deux manières différentes pour charger les plugins : quand on veut un plugin précis ou quand on veut tous les plugins d'un dossier. J'ai donc décidé de créer ici des méthodes statiques.<br/> Ici une seule méthode nous servira mais au moins, vous pourrez réutiliser ce code. ;)</p><p id="r-571337" data-claire-element-id="571337">Puisque ces méthodes devront être utilisées avec n'importe quel plugin, il faudra utiliser les templates.</p><p id="r-571338" data-claire-element-id="571338">Tout d'abord, voici la correction de la première méthode (avec un plugin précis).<br/> Si l'utilisateur demande un plugin de type T, il faut lui renvoyer un pointeur vers le plugin, soit un T*.<br/> On utilise donc la méthode dans la partie théorie mais pas de QDir, cette fois. En effet, l'utilisateur devra donner le chemin vers le plugin. Donc c'est à lui d'utiliser qApp-&gt;applicationPath() (je le vois comme ça). Vous pouvez demander à l'utilisateur un chemin relatif par rapport à l'exécutable si vous voulez.</p><p id="r-571339" data-claire-element-id="571339">Ensuite on écrit le même code que dans la partie théorique. En effet, on crée un QPluginLoader. Puis on prend l'instance. Cette instance est alors retournée sous forme réinterprétée.</p><p id="r-571340" data-claire-element-id="571340">Donc cela fait :</p><pre id="r-571341" data-claire-element-id="571341"><code data-claire-semantic="cpp">// C'est une méthode qui demande un argument template pour éviter de créer un chargeur par type de plugin.
template&lt;typename T&gt; T* pluginByName(const QString&amp; fileName) {
	QPluginLoader loader(fileName); // On charge le plugin.
	QObject *plugin = loader.instance(); // On prend l'instance.
	return qobject_cast&lt;T*&gt;(plugin); // Et on retourne le plugin casté.
}</code></pre><p id="r-571342" data-claire-element-id="571342">Comme vous le voyez, il y a une petite différence avec le code de la partie théorique : il n'y a pas de vérification. Si on utilise cette méthode, il faudra donc vérifier si le plugin est valide.<br/> On aurait aussi pu faire la vérification dans la méthode et si le plugin n'est pas bon, cela aurait retourné une exception.</p><p id="r-571343" data-claire-element-id="571343">La seconde méthode, celle qui prend tous les plugins d'un dossier, doit prendre chaque plugin d'un dossier. Cela paraît bête de dire ça, mais la phrase montre qu'une partie est identique à notre première méthode. Pour éviter de taper le même code et d'avoir des répétitions, il est donc possible de réutiliser la première méthode.</p><p id="r-571344" data-claire-element-id="571344">Dans la seconde méthode, il faut boucler et prendre les fichiers d'un dossier avec QDir.<br/> Il est très similaire au code donné dans la partie théorie, voici donc directement le code :</p><pre id="r-571345" data-claire-element-id="571345"><code data-claire-semantic="cpp">// Toujours une méthode avec un argument template pour éviter qu'il y en ait 50.
template&lt;typename T&gt; QList&lt;T*&gt; pluginByDir(const QString&amp; dir) {
	QList&lt;T*&gt; ls; // On crée la liste où seront mis tous les plugins valides.
	QDir plugDir = QDir(dir);
	foreach(QString file, plugDir.entryList(QDir::Files)) { // On prend la liste des fichiers.
		if(T* plugin = PluginLoader::pluginByName&lt;T&gt;(plugDir.absoluteFilePath(file))) // On vérifie si le plugin existe.
			ls.push_back(plugin); // On l'ajoute à la liste si oui.
	}

	return ls;
}</code></pre><p id="r-571346" data-claire-element-id="571346">Ici on vérifie si le plugin existe avant de le mettre dans la QList. Il est, comme suggéré au-dessus, possible de mettre un else et d'y lancer une exception.</p><p id="r-571347" data-claire-element-id="571347">J'ai mis ces méthodes dans un namespace appelé PluginLoader, mais vous pouvez les laisser dans l'espace global (ou les mettre dans une classe).</p><p id="r-571348" data-claire-element-id="571348">Voici le code de ma classe PluginLoader :</p><pre id="r-571349" data-claire-element-id="571349"><code data-claire-semantic="cpp">#ifndef PLUGIN_LOADER_H
#define PLUGIN_LOADER_H
    // On n'oublie pas les inclusions.
    #include &lt;QList&gt;
    #include &lt;QPluginLoader&gt;
    #include &lt;QObject&gt;
    #include &lt;QString&gt;
    #include &lt;QDir&gt;
    #include &lt;QObject&gt;

    namespace PluginLoader {
        // C'est une méthode qui demande un argument template pour éviter de créer un chargeur par type de plugin.
        template&lt;typename T&gt; T* pluginByName(const QString&amp; fileName) {
            QPluginLoader loader(fileName); // On charge le plugin.
            QObject *plugin = loader.instance(); // On prend l'instance.
            return qobject_cast&lt;T*&gt;(plugin); // Et on retourne le plugin casté.
        }

        // Toujours une méthode avec un argument template pour éviter qu'il y en ait 50.
        template&lt;typename T&gt; QList&lt;T*&gt; pluginByDir(const QString&amp; dir) {
            QList&lt;T*&gt; ls; // On crée la liste où seront mis tous les plugins valides.
            QDir plugDir = QDir(dir);
            foreach(QString file, plugDir.entryList(QDir::Files)) { // On prend la liste des fichiers.
                if(T* plugin = PluginLoader::pluginByName&lt;T&gt;(plugDir.absoluteFilePath(file))) // On vérifie si le plugin existe.
                    ls.push_back(plugin); // On l'ajoute à la liste si oui.
            }

            return ls;
        }
    }
#endif</code></pre><p id="r-571350" data-claire-element-id="571350">Vous avez maintenant de beaux chargeurs de plugins qui pourront être utilisés dans n'importe quel programme.<br/> Il est temps maintenant de créer la définition du plugin.</p><h3 id="r-la-definition-du-plugin" data-claire-element-id="571360">La définition du plugin</h3><p id="r-571352" data-claire-element-id="571352">Comme dit plus haut, nos plugins auront simplement une méthode pour avoir son nom et un slot brawl().<br/> Il est donc très simple de créer la définition :</p><pre id="r-571353" data-claire-element-id="571353"><code data-claire-semantic="cpp">#ifndef PLUGIN_INTER_H
#define PLUGIN_INTER_H
	#include &lt;QtPlugin&gt;

	class QString;
	
	class PluginInter : public QObject {
		Q_OBJECT //Pour avoir les slots et les signaux

		public:
			virtual ~PluginInter() {} // Le destructeur ne fait rien ici.
			
			virtual QString getName() const = 0;
			
		public slots:
			virtual void brawl() = 0;
		
		protected:
			QString m_Name; // On peut très bien mettre une variable dans une interface. Ici c'est le nom.
	};
	Q_DECLARE_INTERFACE(PluginInter, &quot;MyProgramme.PluginInter&quot;) // On utilise la macro-définition pour déclarer une interface.
#endif // PLUGIN_INTER_H</code></pre><p id="r-571354" data-claire-element-id="571354">Comme dans la partie théorique, toutes les méthodes sont virtuelles pures et on utilise la macro-définition <a href="http://doc.trolltech.com/4.1/qtplugin.html#Q_DECLARE_INTERFACE"><strong>Q_DECLARE_INTERFACE</strong></a>.</p><p id="r-571355" data-claire-element-id="571355">Maintenant que l'on a notre définition, nous pouvons rajouter dynamiquement les actions au menu.<br/> Il faut prendre la liste des plugins avec PluginLoader::pluginByDir() puis rajouter l'action du plugin.</p><p id="r-571356" data-claire-element-id="571356">Voici le code qui permet de faire cela :</p><pre id="r-571357" data-claire-element-id="571357"><code data-claire-semantic="cpp">foreach(PluginInter* plugin, PluginLoader::pluginByDir&lt;PluginInter&gt;(qApp-&gt;applicationDirPath() + &quot;/plugins/&quot;)) { // On utilise notre super fonction pour récupérer la liste des plugins.
	QAction* action = mCri-&gt;addAction(plugin-&gt;getName()); //On crée ensuite l'action avec le nom du plugin.
	QObject::connect(action, SIGNAL(triggered()), plugin, SLOT(brawl())); // Et on connecte l'action au slot du plugin.
}</code></pre><p id="r-571358" data-claire-element-id="571358">Voici quelques explications sur le code.<br/> À chaque élément contenu dans le tableau de plugins obtenu par notre méthode, on crée un QAction avec le nom du plugin. Puis on connecte le signal triggered() de l'action au slot du plugin.</p><p id="r-571359" data-claire-element-id="571359">Avouez que, une fois traduit, c'est simple. :)</p><h3 id="r-les-plugins-5" data-claire-element-id="571369">Les plugins</h3><p id="r-571361" data-claire-element-id="571361">Il ne reste que les plugins. Les plugins héritent de notre interface et doivent être concrets. Il faudra donc définir toutes les méthodes virtuelles pures. Les méthodes deviendront alors seulement virtuelles.</p><p id="r-571362" data-claire-element-id="571362">Je ne donnerai l'exemple que pour le chien car seul le nom ou le hurlement change.<br/> Dans la déclaration de la classe, il faut bien utiliser les macro-définitions Q_OBJET et Q_INTERFACES.</p><p id="r-571363" data-claire-element-id="571363">Voici le code de la déclaration :</p><pre id="r-571364" data-claire-element-id="571364"><code data-claire-semantic="cpp">#ifndef CHIEN_H
#define CHIEN_H
	#include &quot;../PluginInter.h&quot; // On doit avoir accès à l'interface.
	
	class Chien : public PluginInter { // On le fait hériter de l'interface. Pas besoin de le faire hériter de QObject puisque PluginInter est déjà un QObject
		Q_OBJECT
		Q_INTERFACES(PluginInter) // On définit l'interface.
		
		// On définit toutes les méthodes de l'interface.
		public:
			Chien();
			virtual ~Chien();

			virtual QString getName() const; // Les méthodes ne sont plus abstraites.

		public slots:
			virtual void brawl();
	};
#endif // CHIEN_H</code></pre><p id="r-571365" data-claire-element-id="571365">L'implémentation dans cet exemple reste assez simple. Il faut quand même ne pas oublier d'utiliser la macro-définition Q_EXPORT_PLUGIN2.</p><pre id="r-571366" data-claire-element-id="571366"><code data-claire-semantic="cpp">#include &quot;Chien.h&quot;

#include &lt;QMessageBox&gt;

Chien::Chien() {
	m_Name = &quot;Chien&quot;; // On définit le nom de l'animal. On peut donc mettre chat ici.
}

Chien::~Chien() { }

QString Chien::getName() const {
	return m_Name;
}

void Chien::brawl() {
	QMessageBox::information(0, &quot;Cri du chien&quot;, &quot;OUAF&quot;); // Pareil que dans le construction, on peut mettre « MIAOU » dans le QMessageBox.
}

Q_EXPORT_PLUGIN2(plug_chien, Chien)</code></pre><p id="r-571367" data-claire-element-id="571367">Il suffit juste d'implémenter les fonctions comme d'habitude.</p><p id="r-571368" data-claire-element-id="571368">Il reste un dernier détail à régler qui n'est pas vraiment du code : le fichier projet du plugin.</p><h3 id="r-les-fichiers-pro" data-claire-element-id="571381">Les fichiers .pro</h3><p id="r-571370" data-claire-element-id="571370">Le fichier projet doit permettre à Qt de connaître les fichiers source utilisés. Ici nous en avons 3.<br/> Il y a <em>Chien.cpp</em>, <em>Chien.h</em> et il ne faut pas oublier <em>PluginInter.h</em>.</p><p id="r-571371" data-claire-element-id="571371">Les fichiers <em>.cpp</em> sont mis dans la variable SOURCES. Les fichiers header sont mis dans la variable HEADERS.</p><p id="r-571372" data-claire-element-id="571372">Notre fichier projet ressemble à ceci :</p><pre id="r-571373" data-claire-element-id="571373"><code>SOURCES += Chien.cpp
HEADERS += Chien.h \
HEADERS += ../PluginInter.h</code></pre><p id="r-571374" data-claire-element-id="571374">Comme dit dans la partie théorique, il y a ensuite quelques petites choses à mettre pour montrer que c'est un plugin.</p><p id="r-571375" data-claire-element-id="571375">Il y a donc les variables TEMPLATE, CONFIG et TARGET à mettre.<br/> TEMPLATE attend le type de projet. Un plugin est une lib.<br/> Il faut ensuite préciser dans la configuration que c'est un plugin.<br/> Enfin, il faut mettre le nom du plugin dans TARGET</p><p id="r-571376" data-claire-element-id="571376">On doit donc rajouter :</p><pre id="r-571377" data-claire-element-id="571377"><code>TEMPLATE = lib
CONFIG += plugin
TARGET = plug_chien</code></pre><p id="r-571378" data-claire-element-id="571378">Si vous faites plusieurs plugins, il faudra alors choisir un nom pour chacun.</p><p id="r-571379" data-claire-element-id="571379">Le fichier projet est donc à la fin :</p><pre id="r-571380" data-claire-element-id="571380"><code>SOURCES += Chien.cpp
HEADERS += Chien.h
HEADERS += ../PluginInter.h

TEMPLATE = lib
CONFIG += plugin
TARGET = plug_chien</code></pre><h3 id="r-recapitulatif-19" data-claire-element-id="571402">Récapitulatif</h3><p id="r-571382" data-claire-element-id="571382">Cet exemple ne sert à rien mais en général, un plugin est plus compliqué et je voulais surtout vous montrer comment faire un plugin avec Qt.</p><p id="r-571383" data-claire-element-id="571383">Pour ceux qui sont intéressés, Qt a fait un programme d'exemple utilisant des plugins. La source est disponible dans la documentation et le programme s'appelle Plug and Paint.<br/> Voici le lien vers l'exemple <a href="http://doc.trolltech.com/4.3/tools-plugandpaint.html">Plug And Paint</a>.</p><p id="r-571384" data-claire-element-id="571384">Il est temps de redonner tout le code.</p><p id="r-571385" data-claire-element-id="571385">Voici les sources du projet mère.</p><p id="r-571386" data-claire-element-id="571386">D'abord le tour de la classe principale de la fenêtre :</p><p id="r-571387" data-claire-element-id="571387"><em><strong>mywidget.h</strong></em></p><pre id="r-571388" data-claire-element-id="571388"><code data-claire-semantic="cpp">#ifndef MYWIDGET_H
#define MYWIDGET_H
	#include &lt;QtGui/QMainWindow&gt;

	class MyWidget : public QMainWindow { // On crée un QMainWindow.
		Q_OBJECT

		public:
			MyWidget(QWidget *parent = 0);
			~MyWidget();
	};
#endif // MYWIDGET_H</code></pre><p id="r-571389" data-claire-element-id="571389"><em><strong>mywidget.cpp</strong></em></p><pre id="r-571390" data-claire-element-id="571390"><code data-claire-semantic="cpp">#include &quot;mywidget.h&quot;
#include &quot;PluginLoader.h&quot;
#include &quot;PluginInter.h&quot;

#include &lt;QApplication&gt;
#include &lt;QMenu&gt;
#include &lt;QMenuBar&gt;

MyWidget::MyWidget(QWidget *parent) : QMainWindow(parent) {
	QMenu* mCri = menuBar()-&gt;addMenu(&quot;Cri&quot;); // On ajoute le menu.

	// On charge les plugins.
	foreach(PluginInter* plugin, PluginLoader::pluginByDir&lt;PluginInter&gt;(qApp-&gt;applicationDirPath() + &quot;/plugins/&quot;)) { // On utilise notre super fonction pour récupérer la liste des plugins.
		QAction* action = mCri-&gt;addAction(plugin-&gt;getName()); // On crée ensuite l'action avec le nom du plugin.
		QObject::connect(action, SIGNAL(triggered()), plugin, SLOT(brawl())); // Et on connecte l'action au slot du plugin.
	}
}

MyWidget::~MyWidget() { }</code></pre><p id="r-571391" data-claire-element-id="571391">Puis vient le tour du chargeur de template :</p><p id="r-571392" data-claire-element-id="571392"><em><strong>PluginLoader.h</strong></em></p><pre id="r-571393" data-claire-element-id="571393"><code data-claire-semantic="cpp">#ifndef PLUGIN_LOADER_H
#define PLUGIN_LOADER_H
    // On n'oublie pas les inclusions.
    #include &lt;QList&gt;
    #include &lt;QPluginLoader&gt;
    #include &lt;QObject&gt;
    #include &lt;QString&gt;
    #include &lt;QDir&gt;
    #include &lt;QObject&gt;

    namespace PluginLoader {
        // C'est une méthode qui demande un argument template pour éviter de créer un chargeur par type de plugin.
        template&lt;typename T&gt; T* pluginByName(const QString&amp; fileName) {
            QPluginLoader loader(fileName); // On charge le plugin.
            QObject *plugin = loader.instance(); // On prend l'instance.
            return qobject_cast&lt;T*&gt;(plugin); // Et on retourne le plugin casté.
        }

        // Toujours une méthode avec un argument template pour éviter qu'il y en ait 50.
        template&lt;typename T&gt; QList&lt;T*&gt; pluginByDir(const QString&amp; dir) {
            QList&lt;T*&gt; ls; // On crée la liste où seront mis tous les plugins valides.
            QDir plugDir = QDir(dir);
            foreach(QString file, plugDir.entryList(QDir::Files)) { // On prend la liste des fichiers.
                if(T* plugin = PluginLoader::pluginByName&lt;T&gt;(plugDir.absoluteFilePath(file))) // On vérifie si le plugin existe.
                    ls.push_back(plugin); // On l'ajoute à la liste si oui.
            }

            return ls;
        }
    }
#endif</code></pre><p id="r-571394" data-claire-element-id="571394">Il ne manque plus que la définition du plugin :</p><p id="r-571395" data-claire-element-id="571395"><strong><em>PluginInter.h</em></strong></p><pre id="r-571396" data-claire-element-id="571396"><code data-claire-semantic="cpp">#ifndef PLUGIN_INTER_H
#define PLUGIN_INTER_H
	#include &lt;QtPlugin&gt;

	class QString;
	
	class PluginInter : public QObject {
		Q_OBJECT

		public:
			virtual ~PluginInter() {} // Le destructeur ne fait rien ici.
			
			virtual QString getName() const = 0;
			
		public slots:
			virtual void brawl() = 0;
		
		protected:
			QString m_Name; // On peut très bien mettre une variable dans une interface. Ici c'est le nom.
	};
	Q_DECLARE_INTERFACE(PluginInter, &quot;MyProgramme.PluginInter&quot;) // On utilise la macro-définition pour déclarer une interface.
#endif // PLUGIN_INTER_H</code></pre><p id="r-571397" data-claire-element-id="571397">Viennent maintenant les sources du plugin. Je ne remettrai pas l'interface car elle est juste au-dessus. Mais il ne faut pas oublier qu'elle fait aussi partie du plugin.</p><p id="r-571398" data-claire-element-id="571398"><em><strong>Chien.h</strong></em></p><pre id="r-571399" data-claire-element-id="571399"><code data-claire-semantic="cpp">#ifndef CHIEN_H
#define CHIEN_H
	#include &quot;../PluginInter.h&quot; // On doit avoir accès à l'interface.
	
	class Chien : public PluginInter { // On le fait hériter de l'interface et de QObject.
		Q_OBJECT
		Q_INTERFACES(PluginInter) // On définit l'interface.
		
		// On définit toutes les méthodes de l'interface.
		public:
			Chien();
			virtual ~Chien();

			virtual QString getName() const; // Les méthodes ne sont plus abstraites.

		public slots:
			virtual void brawl();
	};
#endif // CHIEN_H</code></pre><p id="r-571400" data-claire-element-id="571400"><em><strong>Chien.cpp</strong></em></p><pre id="r-571401" data-claire-element-id="571401"><code data-claire-semantic="cpp">#include &quot;Chien.h&quot;

#include &lt;QMessageBox&gt;

Chien::Chien() {
	m_Name = &quot;Chien&quot;; // On définit le nom de l'animal. On peut donc mettre chat ici.
}

Chien::~Chien() { }

QString Chien::getName() const {
	return m_Name;
}

void Chien::brawl() {
	QMessageBox::information(0, &quot;Cri du chien&quot;, &quot;OUAF&quot;); // Pareil que dans le construction, on peut mettre MIAOU dans le QMessageBox.
}

Q_EXPORT_PLUGIN2(plug_chien, Chien)</code></pre><h2 id="r-quelques-idees-d-exercices" data-claire-element-id="571415">Quelques idées d'exercices</h2><p id="r-571404" data-claire-element-id="571404">Je ne peux pas donner des idées d'améliorations à faire puisque notre programme ne sert à rien.<br/> Je peux cependant vous donner des idées d'exercices si vous voulez allez plus loin.</p><ul id="r-571411" data-claire-element-id="571411"><li id="r-571406" data-claire-element-id="571406"><p id="r-571405" data-claire-element-id="571405">Un logiciel de dessin avec des brush modulable. Cette idée vient de la documentation de Qt.</p></li><li id="r-571408" data-claire-element-id="571408"><p id="r-571407" data-claire-element-id="571407">Un éditeur de texte proposant une panoplie de plugins comme l'indentation du code, l'exécution de commande en console.</p></li><li id="r-571410" data-claire-element-id="571410"><p id="r-571409" data-claire-element-id="571409">Un programme dont le style est complètement personnalisable.</p></li></ul><p id="r-571412" data-claire-element-id="571412">Il est assez dur de donner des types de logiciel POUR un plugin puisqu'en général, un plugin est un plus pour le logiciel qui peut aussi se greffer sur d'autres logiciels.</p><p id="r-571413" data-claire-element-id="571413">C'est pourquoi la plus grosse partie du travail dans la création de plugins est la conception.</p><p id="r-571414" data-claire-element-id="571414">On peut facilement penser que la création de plugins pour les logiciels est un vrai casse-tête à coder. C'est vrai que c'est un casse-tête, mais seulement pour la conception car la programmation devient très facile avec Qt, comme vous avez pu le constater dans ce tutoriel.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins">Qt - Création de plugins</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/introduction-91">
Introduction
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/theorie-22">
Théorie
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/pratique-mini-tp">
Pratique : mini TP
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-creation-de-plugins/theorie-22">
<span class="arrow"></span>
<span class="next">Théorie</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/qt-creation-de-plugins.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Oct 2013 20:06:07 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/qt-creation-de-plugins.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 03:47:18 GMT -->
</html>
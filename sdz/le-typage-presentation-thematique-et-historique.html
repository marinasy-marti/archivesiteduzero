<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/le-typage-presentation-thematique-et-historique.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 07:01:52 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/le-typage-presentation-thematique-et-historique.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:16:26 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Le typage : présentation thématique et historique</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/le-typage-presentation-thematique-et-historique.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Le typage : présentation thématique et historique</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Letypageprsentationthmatiqueethistorique">Le typage : présentation thématique et historique</a><br/><a href="#Toutestnombrepourl039ordinateur">Tout est nombre, pour l&#039;ordinateur</a><br/><a href="#Destypespourplusdesret">Des types pour plus de sûreté</a><br/><a href="#Letypagec039estsmantique">Le typage, c&#039;est sémantique</a><br/><a href="#Langagesdynamiqueslangagesstatiques">Langages dynamiques, langages statiques</a><br/><a href="#Formalisonstouta">Formalisons tout ça</a><br/><a href="#Infrencequandlesystmesedbrouilletoutseul">Inférence : quand le système se débrouille tout seul</a><br/><a href="#Polymorphismeparamtrique">Polymorphisme paramétrique</a><br/><a href="#Unnouveaupointdevueletypecommeinterface">Un nouveau point de vue : le type comme interface</a><br/><a href="#Lestypessontuniversels">Les types sont universels</a><br/></div>
<a name="Letypageprsentationthmatiqueethistorique"></a><h2>Le typage : présentation thématique et historique</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/tout-est-nombre-pour-l-ordinateur">
<span class="next">Tout est nombre, pour l&#039;ordinateur</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-568482" data-claire-element-id="568482">Ce tutoriel est un peu particulier, car il n'est pas destiné à vous enseigner une technique particulière, ou un langage de programmation particulier.</p><p id="r-568483" data-claire-element-id="568483">Il s'agit d'un tuto sur le typage, un concept utile et très répandu dans l'ensemble des langages de programmation. Je compte expliquer les raisons qui ont motivé son apparition, ses principes fondamentaux, ses différentes formes et pourquoi pas, vers la fin, quelques fonctionnalités avancées.</p><p id="r-568484" data-claire-element-id="568484">Ne vous attendez donc pas à ressortir de la lecture (ou pas) de ce tuto avec de nouvelles connaissances concrètes, à mettre en oeuvre pour l'écriture d'applications. Attendez-vous à réfléchir sur un sujet souvent présenté comme allant de soi, qui concerne la pratique de la programmation en général, et, dans le meilleur des cas, qui vous aura permis de comprendre un peu mieux votre propre pratique de la programmation.</p><p id="r-568485" data-claire-element-id="568485">Les exemples seront pris dans des langages très divers (que vous n'aurez probablement pour la plupart jamais vus, mais c'est rigolo de découvrir de nouvelles choses, non ? :p ), et j'ai un faible pour l'aspect historique des choses, même si la progression que suit le tuto est plus centrée sur la logique que sur la chronologie.</p>
</div><a name="Toutestnombrepourl039ordinateur"></a><h2>Tout est nombre, pour l&#039;ordinateur</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
<span class="next">Des types pour plus de sûreté</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568486" data-claire-element-id="568486">Les ordinateurs manipulent des nombres. Ils stockent des nombres en mémoire, font transiter des nombres par leurs circuits, et envoient des informations aux autres ordinateurs sous forme de nombres. C'est l'ère du numérique.</p><p id="r-568487" data-claire-element-id="568487">La programmation, c'est (entre autres) le fait de dialoguer avec l'ordinateur, afin de lui faire faire les opérations que l'on veut : on décide ce qu'on veut, on le traduit dans un langage compréhensible pour l'ordinateur, et il l'exécute (programmer, c'est donc essentiellement traduire de la pensée en code).</p><p id="r-568488" data-claire-element-id="568488">Comme c'est un ordinateur, il ne manipule que des nombres, et ces opérations se transforment donc forcément, à un moment ou un autre, en opérations sur des nombres. Quand on veut faire faire à l'ordinateur des additions, multiplications ou autres opérations mathématiques (il fait ça très bien :) ), ce n'est pas surprenant de savoir qu'il manipule des nombres. Mais quand on clique sur un bouton, qu'on choisit une couleur dans un logiciel de dessin ou qu'on écrit du texte dans un éditeur, est-ce que l'on conçoit clairement de quelle manière il va interpréter la chose en tant que nombre ? Non. Ce n'est d'ailleurs pas possible, parce que la manière dont est effectuée la traduction dépend de beaucoup de choses, que ce soit au niveau logiciel (encodage, format utilisé...) ou matériel (processeur, mémoire, etc.).</p><h3 id="r-quand-tout-est-nombre-pour-le-langage-de-programmation" data-claire-element-id="568492">Quand tout est nombre pour le langage de programmation...</h3><p id="r-568489" data-claire-element-id="568489">Les langages de bas niveau actuels, ainsi que les premiers langages de programmation sont très proches de la machine sur laquelle ils s'exécutent : les objets qu'ils manipulent sont, eux aussi, des nombres.</p><p id="r-568490" data-claire-element-id="568490">En <a href="http://fr.wikipedia.org/wiki/Assembleur">Assembleur</a> par exemple, la majorité des instructions consiste à modifier de manière arithmétique (en additionnant, multipliant, ou effectuant d'autres opérations de ce genre) le contenu des cases mémoire de l'ordinateur. Un exemple encore plus frappant est le <a href="http://fr.wikipedia.org/wiki/Brainfuck">Brainfuck</a>, un langage dont les seules opérations (à part l'entrée-sortie) permettent soit de changer de case mémoire, soit de changer la valeur de la case actuelle (et de boucler tant que la case ne contient pas 0). Pour les curieux, voici une multiplication en Brainfuck :</p><pre id="r-568491" data-claire-element-id="568491"><code>[-&gt;[-&gt;+&gt;+&lt;&lt;]&gt;[-&lt;+&gt;]&lt;&lt;]&gt;&gt;&gt;</code></pre>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique">Le typage : présentation thématique et historique</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/tout-est-nombre-pour-l-ordinateur">
Tout est nombre, pour l&#039;ordinateur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
Des types pour plus de sûreté
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
Le typage, c&#039;est sémantique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
Langages dynamiques, langages statiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
Formalisons tout ça
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
Inférence : quand le système se débrouille tout seul
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
Polymorphisme paramétrique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
Un nouveau point de vue : le type comme interface
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/les-types-sont-universels">
Les types sont universels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
<span class="next">Des types pour plus de sûreté</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Destypespourplusdesret"></a><h2>Des types pour plus de sûreté</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/tout-est-nombre-pour-l-ordinateur">
<span class="arrow"></span>
<span class="next">Tout est nombre, pour l&#039;ordinateur</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
<span class="next">Le typage, c&#039;est sémantique</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568494" data-claire-element-id="568494">Ces langages conviennent très bien quand il s'agit de manipuler des nombres (ils ont au départ été conçus pour des applications scientifiques), mais assez vite des problèmes se posent.<br/> Mettons que vous ayez écrit une opération qui transforme une chaîne de caractères (une suite de nombres en mémoire) dans la même suite, mais où tous les caractères majuscules sont remplacés par leurs équivalents minuscules. Cela suppose de bien connaître la convention de conversion nombre &lt;-&gt; caractère de votre langage, mais ce n'est sans doute pas un problème pour vous.</p><p id="r-568495" data-claire-element-id="568495">Imaginez maintenant que vous appliquiez par erreur cette opération non pas sur une phrase, mais sur la liste des âges des membres de votre site. L'ordinateur n'y verra que du feu : il traduira cette liste en une liste assez ressemblante, mais dans laquelle, par exemple, toutes les personnes âgées de 65 à 90 ans se seront vues vieillies de 32 ans ! Heureusement que les visiteurs de votre site sont plutôt jeunes...</p><p id="r-568496" data-claire-element-id="568496">Cette erreur est assez courante, et même si elle peut être évitée en faisant attention, elle peut être gênante. Imaginez qu'au lieu de la liste des âges des membres, vous ayez mis la liste de vos mots de passe, voire la liste des clés de contrôle du réacteur nucléaire ( :pirate: ) !</p><h3 id="r-peut-on-l-eviter" data-claire-element-id="568501">Peut-on l'éviter ?</h3><p id="r-568497" data-claire-element-id="568497">Cette erreur est aisément repérable : un humain, si on lui demande de transformer en lettres majuscules une liste d'âges, va comprendre immédiatement qu'il y a quelque chose qui cloche. Pourquoi l'ordinateur ne pourrait-il pas faire pareil ?<br/> C'est ce que se sont demandés très vite les ingénieurs concevant les ordinateurs et les langages de programmation, et ils ont vite décidé de mettre en place une gestion simple de ce genre d'erreur dans ces langages.</p><p id="r-568498" data-claire-element-id="568498">L'idée intuitive est qu'une lettre et un âge, ce &quot;n'est pas la même chose&quot;. Comme vous l'a peut-être dit un jour votre professeur de physique, &quot;on ne peut pas ajouter des patates et des carottes&quot;. On a donc introduit une sorte de <em>classification</em> des objets que manipule le langage : à chaque valeur du langage, on associe une étiquette qui dit &quot;c'est une lettre&quot;, &quot;c'est un âge&quot; (ou &quot;c'est un nombre&quot;), &quot;c'est une liste de lettres suivie par deux nombres entiers, puis un nombre à virgule&quot;, etc.<br/> Cette étiquette s'appelle le <strong>type</strong> : le type d'une valeur est tout simplement le groupe d'objets auxquels il appartient.</p><p id="r-568499" data-claire-element-id="568499">Ensuite, on précise quand on déclare une variable à quel type elle appartient, et, quand on définit une opération (par exemple, la mise en minuscules), on précise (dans le code source du programme) sur quel type de données elle <em>a le droit</em> d'agir.</p><p id="r-568500" data-claire-element-id="568500">Alors, il suffit de mettre en place, pendant que l'ordinateur lit le texte de votre programme en prévision de son exécution, une étape très simple qui vérifie que chaque opération est bien utilisée sur les variables du type qui convient, et sinon de rapporter l'erreur au programmeur.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique">Le typage : présentation thématique et historique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/tout-est-nombre-pour-l-ordinateur">
Tout est nombre, pour l&#039;ordinateur
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
Des types pour plus de sûreté
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
Le typage, c&#039;est sémantique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
Langages dynamiques, langages statiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
Formalisons tout ça
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
Inférence : quand le système se débrouille tout seul
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
Polymorphisme paramétrique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
Un nouveau point de vue : le type comme interface
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/les-types-sont-universels">
Les types sont universels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/tout-est-nombre-pour-l-ordinateur">
<span class="arrow"></span>
<span class="next">Tout est nombre, pour l&#039;ordinateur</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
<span class="next">Le typage, c&#039;est sémantique</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Letypagec039estsmantique"></a><h2>Le typage, c&#039;est sémantique</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
<span class="arrow"></span>
<span class="next">Des types pour plus de sûreté</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
<span class="next">Langages dynamiques, langages statiques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568503" data-claire-element-id="568503">La réaction des informaticiens face aux erreurs de ce genre (que l'on appelle depuis les <strong>erreurs de typage</strong>) est naturelle. Si vous aviez été ingénieur chez IBM dans les années 50, vous auriez sûrement réagi pareil. :p</p><p id="r-568504" data-claire-element-id="568504">Ce qui est intéressant, c'est que la démarche du typage s'inscrit dans une direction plus générale, que l'on peut observer en de nombreux endroits de l'histoire des langages de programmation : on a apporté du sens au langage.</p><p id="r-568505" data-claire-element-id="568505">Quand vous concevez votre programme de mise en minuscules, vous savez très bien quel type de variables vous allez manipuler. L'ordinateur, lui, ne le savait pas. En introduisant le typage, on a permis au programmeur de rajouter des informations (dans le code source), pour en quelque sorte augmenter les connaissances de l'ordinateur au sujet du programme. Plus l'ordinateur est au courant, mieux il peut vérifier que ces informations sont cohérentes, et vous avertir si cela n'est pas le cas.<br/> Le fait de modéliser le sens des objets manipulés par un programme est généralement appelé de la sémantique.<br/> La plupart des langages informatiques que vous connaissez se sont préoccupés de sémantique (de la manière dont les programmes qu'on pouvait écrire reflétaient bien la signification des actions voulues par le programmeur). Le <a href="http://fr.wikipedia.org/wiki/C_(langage)">C</a> (créé pour être portable, et donc avoir des instructions reflétant mieux (qu'en <strong>assembleur</strong>) le sens des fonctions désirées, en faisant abstraction de l'architecture matérielle de l'ordinateur) et le <a href="http://fr.wikipedia.org/wiki/XHTML">XHTML</a> (dont une des grandes avancées a été de mettre l'accent sur les balises décrivant la structure des pages web - et donc leur sens -, au lieu de leur présentation) en sont de bons exemples.</p><h3 id="r-cela-ajoute-effectivement-du-sens-au-programme" data-claire-element-id="568512">Cela ajoute effectivement du sens au programme</h3><p id="r-568506" data-claire-element-id="568506">Regardez le code de la fonction qui met en minuscule un caractère majuscule, en C :</p><pre id="r-568507" data-claire-element-id="568507"><code data-claire-semantic="c">char tolower(char c)
{
   if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
      return (c - 'A' + 'a');
   else return c;
}</code></pre><p id="r-568508" data-claire-element-id="568508">Si la lettre est comprise entre 'A' et 'Z', on la décale dans les minuscules (ce n'est pas grave si vous ne comprenez pas pourquoi ça marche, et d'ailleurs ça ne marchera pas forcément, car cela repose sur des fonctionnalités qui dépendent de l'environnement), sinon on la renvoie inchangée.</p><p id="r-568509" data-claire-element-id="568509">Si un informaticien lit ce code, il comprendra immédiatement ce que fait cette fonction. Mais un des intérêts du typage repose dans le fait qu'en pratique, on n'est pas obligé de lire tout le code !<br/> En effet, il est possible en C d'insérer avant le code d'une fonction un <em>prototype</em>, qui la déclare à l'avance, et qui est souvent placé dans les fichiers de header (.h) :</p><pre id="r-568510" data-claire-element-id="568510"><code data-claire-semantic="c">char tolower(char )</code></pre><p id="r-568511" data-claire-element-id="568511">Ce qui est surprenant, c'est que cette ligne suffit pour comprendre ce que fait la fonction tolower ! Évidemment, cela suppose de connaître l'anglais, mais une fois que vous voyez le type (la fonction prend un char et renvoie un char), la signification est claire (de toute façon, en 1950, les ingénieurs d'IBM parlaient tous anglais :D ).<br/> Ainsi, le typage a effectivement apporté du sens dans le code : on peut se contenter de lire le prototype d'une fonction pour la comprendre ; c'est un gros gain de temps par rapport à l'époque où il fallait chercher le code source de la fonction dans tout le programme (bon, la documentation ça existe, mais les vrais hommes (et femmes !) chez IBM lisaient plutôt le code source, évidemment).</p><h3 id="r-mais-ce-n-est-pas-si-nouveau" data-claire-element-id="568514">... mais ce n'est pas si nouveau !</h3><p id="r-568513" data-claire-element-id="568513">Si vous avez déjà fait de la physique, vous avez sûrement remarqué l'importance qu'attachent les physiciens aux unités des valeurs qu'ils manipulent : pas question d'ajouter des mètres et des kilogrammes ! Cette restriction, cette classification des valeurs a de nombreux avantages : entre autres, elle permet d'obtenir très vite des informations sur une grandeur (c'est une distance, c'est une température...), et elle réduit les risques de faire des erreurs de calcul : il est très simple de vérifier qu'une formule est bien typée (on dit qu'elle est &quot;homogène&quot;), et si ce n'est pas le cas on sait tout de suite que la formule est fausse !<br/> C'est un peu comme cela qu'on utilise en général les types en informatique.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique">Le typage : présentation thématique et historique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/tout-est-nombre-pour-l-ordinateur">
Tout est nombre, pour l&#039;ordinateur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
Des types pour plus de sûreté
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
Le typage, c&#039;est sémantique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
Langages dynamiques, langages statiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
Formalisons tout ça
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
Inférence : quand le système se débrouille tout seul
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
Polymorphisme paramétrique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
Un nouveau point de vue : le type comme interface
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/les-types-sont-universels">
Les types sont universels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
<span class="arrow"></span>
<span class="next">Des types pour plus de sûreté</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
<span class="next">Langages dynamiques, langages statiques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Langagesdynamiqueslangagesstatiques"></a><h2>Langages dynamiques, langages statiques</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
<span class="arrow"></span>
<span class="next">Le typage, c&#039;est sémantique</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
<span class="next">Formalisons tout ça</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568516" data-claire-element-id="568516">La description que j'ai faite du processus de vérification du typage est plus que simpliste. En fait, il existe grosso-modo deux manières répandues de procéder : le typage statique, et le typage dynamique.</p><p id="r-568517" data-claire-element-id="568517">La différence réside dans le moment où la vérification est effectuée : au moment où les opérations sont effectuées, ou plutôt une fois pour toutes, avant de lancer le programme ?</p><h3 id="r-un-langage-type-dynamiquement-python" data-claire-element-id="568526">Un langage typé dynamiquement : Python</h3><p id="r-568518" data-claire-element-id="568518">Le principe du typage dynamique, c'est de typer au besoin, pendant l'exécution du programme : on fait ce que demande le programme, et on vérifie à chaque opération que le type correspond bien (ce qui peut se faire assez rapidement si le système des types est simple).<br/> C'est le typage le plus utilisé par les langages de script.<br/> Voici un exemple en <a href="http://fr.wikipedia.org/wiki/Python_(langage)">Python</a> :</p><pre id="r-568519" data-claire-element-id="568519"><code data-claire-semantic="python">def essai(test):
    if test:
       return (1 + 2)
    else:
       return (1 + &quot;essai&quot;)</code></pre><p id="r-568520" data-claire-element-id="568520">On a défini une fonction qui prend un booléen en argument, et renvoie (1 + 2) s'il est vrai, et (1 + &quot;essai&quot;) s'il est faux. Il y a une erreur de typage (on ne peut pas ajouter un entier et un mot !) mais l'interpréteur n'a pas protesté. On essaie ensuite d'utiliser la fonction :</p><p id="r-568521" data-claire-element-id="568521"><cite>Citation</cite></p><blockquote id="r-568523" data-claire-element-id="568523"><p id="r-568522" data-claire-element-id="568522">&gt;&gt;&gt; essai(True)<br/> 3<br/> &gt;&gt;&gt; essai(False)<br/> TypeError: unsupported operand type(s) for +: 'int' and 'str'</p></blockquote><p id="r-568524" data-claire-element-id="568524">essai(True) renvoie un résultat correct, et seul essai(False) renvoie une erreur. Cela veut dire que tant qu'on n'est pas entré dans la branche &quot;else&quot; du if, aucune vérification de typage n'a été faite sur son contenu : on a véritablement un typage dynamique.</p><p id="r-568525" data-claire-element-id="568525">Ce typage est très simple à comprendre et à mettre en oeuvre. Cependant, un de ses désavantages apparents ici est le fait que pour être sûr que les types du programme sont corrects, il faut tester tous les &quot;embranchements&quot; du code. Ici, il faut faire deux tests, mais pour peu que vous ayez plusieurs if et des conditions un peu compliquées, tester l'ensemble du code devient vite long et difficile (même s'il existe des outils pour tenter d'automatiser le processus).<br/> Avec un typage statique, comme vous allez le voir, toutes les erreurs seront relevées avant l'exécution du code.</p><h3 id="r-un-langage-type-statiquement-c" data-claire-element-id="568537">Un langage typé statiquement : C</h3><p id="r-568527" data-claire-element-id="568527">Un langage est typé statiquement si, avant de s'exécuter, votre code source passe par une phase de vérification des types. Si le langage est compilé, cette phase est souvent comprise dans le compilateur, mais il existe aussi des langages interprétés (ou des implémentations interprétées de langages, plus exactement) qui ont un typage statique.</p><p id="r-568528" data-claire-element-id="568528">L'exemple que j'ai choisi est le C. Ce langage n'a pas un système de types très évolué (il n'empêche pas beaucoup de choses), mais cela reste un typage statique, et il a inspiré les typages des langages qui l'ont suivi (le C++, principalement). De plus, indépendamment des contraintes de typage imposées par le langage, les compilateurs ont développé des techniques de recherche d'erreurs probables (si le code est valide, mais assez bizarre pour être une erreur dans la plupart des cas), qui donnent lieu à des avertissements, et peuvent donc être considérées comme une sécurité supplémentaire au niveau du typage.</p><p id="r-568529" data-claire-element-id="568529">Un exemple de problème de typage en C est la comparaison d'un entier de type &quot;unsigned int&quot; (un type qui ne peut contenir que des entiers positifs) et &quot;int&quot; (ou &quot;signed int&quot;), qui peut représenter des nombres négatifs.</p><pre id="r-568530" data-claire-element-id="568530"><code data-claire-semantic="c">#include &lt;stdio.h&gt;
 
const unsigned int i = 23;
const int j = -5;
 
int main(void)
{
        if (i &lt; j) printf(&quot;i &lt; j\n&quot;);
        else printf(&quot;i &gt; j\n&quot;);
 
        return 0;
}</code></pre><p id="r-568531" data-claire-element-id="568531">Si vous compilez ce code, vous verrez peut-être (si vous avez les <em>warning</em> activés) un message équivalent à celui-ci :</p><p id="r-568532" data-claire-element-id="568532"><cite>Citation</cite></p><blockquote id="r-568534" data-claire-element-id="568534"><p id="r-568533" data-claire-element-id="568533">test.c: In function 'main':<br/> test.c:8: warning: comparison between signed and unsigned</p></blockquote><p id="r-568535" data-claire-element-id="568535">Le compilateur a repéré l'erreur de type, mais il compile le programme quand même. Si vous l'exécutez, vous verrez qu'il dit que i est plus petit que j !<br/> 23 &lt; -5, ça ne ferait pas plaisir à votre prof de maths, mais c'est normal si l'on connaît les règles de conversion utilisées pour passer d'un int à un unsigned int.</p><p id="r-568536" data-claire-element-id="568536">L'avantage du typage statique, c'est qu'il nous prévient de l'erreur avant l'exécution. De plus, il vérifie tout le code, même celui qui se trouve dans des branches de &quot;if&quot;.<br/> Le typage statique présente aussi un avantage non négligeable du point de vue des performances : une fois que le test de typage a été effectué, le programme est supposé valide, et le compilateur peut alors se débarrasser des informations de typage qu'il a accumulées. À l'inverse, les typages dynamiques imposent de conserver pendant toute l'exécution les informations sur le type de chaque variable, et de faire des tests tout au long du programme, ce qui a un impact sur les performances.</p><h3 id="r-tout-est-dans-la-nuance" data-claire-element-id="568542">Tout est dans la nuance</h3><p id="r-568538" data-claire-element-id="568538">Dans le monde du typage, rien n'est tout blanc ni tout noir. Tout est dans la nuance : il existe un grand nombre de manières différentes de typer, et tous les langages font ça un peu différemment, avec plus ou moins de contraintes. Ainsi, même les langages que l'on désigne couramment comme &quot;non typés&quot; (comme <a href="http://fr.wikipedia.org/wiki/Lisp">Lisp</a>) ont généralement une certaine forme (très réduite) de typage.</p><p id="r-568539" data-claire-element-id="568539">De même, aucun langage à ma connaissance n'est complètement rigoureux au niveau du typage. Par exemple, l'opération de division / peut s'effectuer sur des entiers, et provoque une erreur quand le deuxième argument est nul (division par zéro). Dans un langage complètement typé (au sens mathématique du terme), il faudrait définir un type &quot;entier non nul&quot; qui serait celui du deuxième argument de la division, et il faudra convertir, et n'autoriser que des variables de ce type (ou faire une conversion implicite).</p><p id="r-568540" data-claire-element-id="568540">Le typage se mesure donc en degrés, en niveaux, et assez approximativement. Les langages les plus typés actuellement sont désignés comme pratiquant un <strong>typage fort</strong>, alors qu'on parle pour les autres (par exemple pour le C ou le PHP) de <strong>typage faible</strong>. Ces notions sont indépendantes de l'aspect statique ou dynamique du typage : les <em>pythonneux</em> considèrent qu'ils ont un typage dynamique fort.</p><p id="r-568541" data-claire-element-id="568541">La différence entre le typage fort et le typage faible n'est pas très claire, car il n'y a pas de consensus à ce sujet : la définition dépend des gens, et si vous discutez de typage fort avec quelqu'un, demandez-lui celle qu'il utilise avant de provoquer des malentendus. Une définition possible du typage faible est la suivante : les langages faiblement typés sont les langages qui n'attachent pas une grande importance au typage. Par exemple, si vous faites une erreur de typage en PHP, dans la plupart des cas il utilisera un comportement par défaut (ignorer la variable qui pose problème, ou la convertir automatiquement vers un autre type, etc.), qui ne sera pas forcément celui que vous vouliez, mais il ne vous préviendra pas qu'il y a une incohérence, à moins que vous ne l'ayez configuré en mode ultra-paranoïaque.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique">Le typage : présentation thématique et historique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/tout-est-nombre-pour-l-ordinateur">
Tout est nombre, pour l&#039;ordinateur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
Des types pour plus de sûreté
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
Le typage, c&#039;est sémantique
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
Langages dynamiques, langages statiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
Formalisons tout ça
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
Inférence : quand le système se débrouille tout seul
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
Polymorphisme paramétrique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
Un nouveau point de vue : le type comme interface
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/les-types-sont-universels">
Les types sont universels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
<span class="arrow"></span>
<span class="next">Le typage, c&#039;est sémantique</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
<span class="next">Formalisons tout ça</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Formalisonstouta"></a><h2>Formalisons tout ça</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
<span class="arrow"></span>
<span class="next">Langages dynamiques, langages statiques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
<span class="next">Inférence : quand le système se débrouille tout seul</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568544" data-claire-element-id="568544">Quand les premiers langages de programmation se sont mis au typage (bien que certain langages, comme Lisp, soient restés non typés, ou très peu typés, pendant très longtemps), chaque créateur de langage a mis au point sa propre recette.</p><p id="r-568545" data-claire-element-id="568545">Pendant quelques temps, le typage est resté une idée très concrète (on choisit un certain nombre de &quot;groupes&quot; dans lesquels se répartissent les variables), sans bénéficier d'une formalisation : on ne s'est globalement pas intéressé à ses aspects théoriques.</p><p id="r-568546" data-claire-element-id="568546">C'est vers les années 70, donc pendant ce qu'on appelle habituellement la deuxième génération des langages de programmation (la période qui a aussi vu naître, entre autres, le C et les langages objets), qu'ont commencé à se répandre des modèles formalisés de système de types de certains langages de programmation.</p><h3 id="r-le-langage-ml" data-claire-element-id="568550">Le langage ML</h3><p id="r-568547" data-claire-element-id="568547">Ainsi apparaît en 1973 le langage <a href="http://fr.wikipedia.org/wiki/ML_(langage)">ML</a>, dont le système de type est un précurseur d'absolument tous les systèmes de typage statique formalisés existant actuellement. Il existait déjà quelques systèmes formels de typage auparavant, mais ils n'étaient pas assez avancés pour avoir l'influence de celui de ML.</p><p id="r-568548" data-claire-element-id="568548">Ce langage a été créé par <a href="http://fr.wikipedia.org/wiki/Robin_Milner">Robin Milner</a>, pour être utilisé dans le démonstrateur automatique de preuves LCF, qu'il développait à l'époque à l'université d'Edimbourg. Un démonstrateur automatique de preuves est un logiciel qui prend en entrée un théorème mathématique et sa preuve (écrite dans un langage spécialisé), et capable de vérifier mécaniquement (informatiquement, sans intervention humaine) que la preuve est correcte (et correspond bien au théorème).</p><p id="r-568549" data-claire-element-id="568549">Comme vous pouvez le constater, on s'est éloigné des ingénieurs d'IBM : la formalisation du typage est apparue du côté de l'informatique théorique, dans un environnement très mathématique. Et ce n'est pas par hasard.</p><h3 id="r-nos-cousins-les-mathematiciens" data-claire-element-id="568560">Nos cousins les mathématiciens</h3><p id="r-568551" data-claire-element-id="568551">Ce n'est pas pour rien que les systèmes de typages évolués sont apparus en informatique sous l'influence des mathématiciens : comme beaucoup de concepts de l'informatique, ils ont en fait été inventés par eux, et ce bien avant l'apparition des premiers ordinateurs !</p><p id="r-568552" data-claire-element-id="568552">Il faut savoir qu'au début du 20e siècle, les mathématiciens ont rencontré une série de problèmes liés à la théorie des ensembles, qui ont montré la faiblesse de ce qu'ils pensaient à l'époque être une formalisation satisfaisante des mathématiques. Un exemple très accessible et très connu de ces difficultés théoriques est le <a href="http://fr.wikipedia.org/wiki/Paradoxe_de_Russell">paradoxe</a> découvert par <a href="http://fr.wikipedia.org/wiki/Bertrand_Russell">Russel</a> en 1901, et que l'on peut formuler ainsi : &quot;le barbier rase tous ceux qui ne se rasent pas eux-mêmes (et personne d'autre). Le barbier se rase-t-il ?&quot;. La question amène à un paradoxe : essayez et vous verrez, quoi que fasse le barbier, on arrive à une contradiction :</p><ul id="r-568557" data-claire-element-id="568557"><li id="r-568554" data-claire-element-id="568554"><p id="r-568553" data-claire-element-id="568553">soit le barbier se rase, ce qui crée une contradiction car il ne doit raser que les personnes qui ne se rasent pas elles-mêmes ;</p></li><li id="r-568556" data-claire-element-id="568556"><p id="r-568555" data-claire-element-id="568555">soit le barbier ne se rase pas, et alors il devrait se raser, car il doit raser toutes les personnes qui ne se rasent pas.</p></li></ul><p id="r-568558" data-claire-element-id="568558">Les mathématiciens ont résolu le problème en inventant des systèmes où le barbier (enfin, l'analogue mathématique du barbier) n'existe pas, c'est-à-dire où on ne peut pas construire des objets qui vérifient des propriétés aussi tordues que ça.<br/> L'un de ces systèmes est une théorie des types, mise au point par Russel et <a href="http://fr.wikipedia.org/wiki/Alfred_North_Whitehead">Whitehead</a> dans les années <strong>1910</strong> ! Elle est extrêmement complexe, et ce n'est donc pas le modèle utilisé de nos jours en mathématiques, mais historiquement c'est une des premières apparitions d'un typage proche de ce que nous connaissons dans la littérature scientifique.</p><p id="r-568559" data-claire-element-id="568559">Le typage a été réutilisé à nouveau dans les années 1940 (donc, encore avant l'informatique) par <a href="http://fr.wikipedia.org/wiki/Alonzo_Church">Church</a>, un logicien qui est à la base du <a href="http://fr.wikipedia.org/wiki/Lambda_calcul">Lambda calcul</a>, le premier langage de programmation (théorique :p ), inventé en 1930 pour résoudre un problème algorithmique d'origine mathématique : &quot;quelles sont les fonctions que l'on peut calculer ?&quot;. Le Lambda calcul était initialement non typé, et il s'est très vite avéré que la plupart des termes (ou programmes) que l'on construisait ne terminaient pas, c'est-à-dire avaient un &quot;temps d'exécution&quot; infini. L'introduction du typage a permis l'ajout de contraintes garantissant qu'aucun programme ne boucle à l'infini ; malheureusement, ces contraintes font que certaines fonctions ne peuvent plus être construites par le langage. C'est un point théorique assez technique, et je n'en parlerai plus par la suite , rassurez-vous ^^</p><h3 id="r-une-preference-pour-le-typage-statique" data-claire-element-id="568564">Une préférence pour le typage statique</h3><p id="r-568561" data-claire-element-id="568561">Cette formalisation a permis la création d'algorithmes puissants permettant de traiter les types d'un programme. Certaines de ces fonctionnalités seront décrites dans les chapitres suivants.<br/> Cette puissance supplémentaire a cependant un coût : elle rend plus complexe la phase de traitement des types. Elle est donc relativement inadaptée au typage dynamique (qui se fait &quot;sur le pouce&quot;, à chaque exécution du programme, et a donc besoin d'être relativement léger) ; c'est pourquoi elle a été mise en place quasi-exclusivement pour les langages à typage statique.</p><p id="r-568562" data-claire-element-id="568562">Cela peut aussi être relié à l'influence des mathématiciens : ce qu'a apporté la formalisation du typage, c'est la possibilité de <strong>prouver</strong> qu'un programme est correctement typé. Quand on peut démontrer une partie de la sécurité (dans le sens &quot;absence de bugs&quot;) d'un programme, vous pensez qu'on choisit de le faire plutôt avant de le lancer, ou pendant qu'il tourne ?</p><p id="r-568563" data-claire-element-id="568563">Les langages que je présenterai par la suite seront donc majoritairement statiquement typés, car ce sont eux qui ont les systèmes de typage les plus élaborés.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique">Le typage : présentation thématique et historique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/tout-est-nombre-pour-l-ordinateur">
Tout est nombre, pour l&#039;ordinateur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
Des types pour plus de sûreté
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
Le typage, c&#039;est sémantique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
Langages dynamiques, langages statiques
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
Formalisons tout ça
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
Inférence : quand le système se débrouille tout seul
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
Polymorphisme paramétrique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
Un nouveau point de vue : le type comme interface
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/les-types-sont-universels">
Les types sont universels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
<span class="arrow"></span>
<span class="next">Langages dynamiques, langages statiques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
<span class="next">Inférence : quand le système se débrouille tout seul</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Infrencequandlesystmesedbrouilletoutseul"></a><h2>Inférence : quand le système se débrouille tout seul</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
<span class="arrow"></span>
<span class="next">Formalisons tout ça</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
<span class="next">Polymorphisme paramétrique</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568566" data-claire-element-id="568566">L'inférence des types est une des commodités qu'a apporté la formalisation du système de typage des langages de programmation. Sa version simplifiée a été découverte par Feys et <a href="http://fr.wikipedia.org/wiki/Haskell_Curry">Curry</a> en 1958, mais l'algorithme général, encore utilisé dans les langages modernes à inférence de types, a été découvert par Hindley en 1969, et redécouvert indépendamment par Milner en 1978, qui l'a alors intégré à son langage ML.</p><p id="r-568567" data-claire-element-id="568567">Le principe de l'inférence de type, c'est que l'ordinateur peut, dans la plupart des cas, <strong>deviner</strong> de quel type sont les valeurs manipulées.<br/> Voici par exemple le programme <em><strong>périmètre_rectangle</strong></em>, qui calcule le périmètre d'un rectangle dont on donne les deux dimensions, écrit en pseudo-code (un langage qui n'existe pas et qui sert juste à décrire les algorithmes) :</p><p id="r-568568" data-claire-element-id="568568"><cite>Citation</cite></p><blockquote id="r-568570" data-claire-element-id="568570"><p id="r-568569" data-claire-element-id="568569">Soit périmètre_rectangle (longueur, largueur) = 2 * (longueur + largeur)</p></blockquote><p id="r-568571" data-claire-element-id="568571">Comme vous pouvez le voir, le code ne comporte aucune annotation précisant le type des valeurs 'longueur' et 'largeur', et indiquant le type de retour de la fonction. Mais sont-elles bien nécessaires ?<br/> En fait, on peut s'en passer : on voit bien que les opérations (multiplier, ajouter) sont des opérations arithmétiques, et on en déduit tout naturellement que cette fonction s'applique à des nombres (le type numérique exact dépend du langage que vous utiliserez pour l'implémentation).</p><p id="r-568572" data-claire-element-id="568572">Comme c'était le cas pour les erreurs de typage, l'ordinateur passe pour l'instant à côté d'une information qui nous est accessible : nous pouvons deviner le type attendu de cette fonction. Eh bien l'algorithme de Hindley-Milner permet de faire exactement la même chose : s'il connaît le type des fonctions de base du langage, il peut en déduire le type des fonctions ou des valeurs que vous construisez.<br/> Si pendant la phase où il infère (devine) les types présents dans le programme, le système de types découvre une contradiction, alors le programme n'est pas correctement typé, et il renvoie une erreur.</p><p id="r-568573" data-claire-element-id="568573">Voici un exemple du code en <a href="http://fr.wikipedia.org/wiki/OCaml">OCaml</a> (le langage ML que j'utilise) :</p><pre id="r-568574" data-claire-element-id="568574"><code data-claire-semantic="ocaml">let périmètre longueur largeur = 2 * (longueur + largeur)</code></pre><p id="r-568575" data-claire-element-id="568575">Si l'on demande à OCaml le type de la fonction &quot;périmètre&quot;, il renvoie ceci :</p><p id="r-568576" data-claire-element-id="568576"><cite>Citation</cite></p><blockquote id="r-568578" data-claire-element-id="568578"><p id="r-568577" data-claire-element-id="568577">val périmètre : int -&gt; int -&gt; int</p></blockquote><p id="r-568579" data-claire-element-id="568579">La valeur périmètre est de type int -&gt; int -&gt; int, ce qui signifie qu'elle prend deux entiers (les deux premiers) et renvoie un entier (le dernier après la deuxième flèche).</p><p id="r-568580" data-claire-element-id="568580">On a donc combiné les avantages de sûreté (le compilateur découvre une partie des erreurs du programmeur, qui se manifestent par l'emploi de types contradictoires), de sémantique (on peut demander le type d'une fonction au compilateur, et cela aide pour comprendre sa signification) avec une légèreté fort agréable : plus besoin de rédiger à la main les types les plus évidents (on se doute bien que la fonction &quot;multiplie&quot; ne va pas renvoyer un couple de nombres !).<br/> Encore une fois, on a pu reporter une partie du travail sur l'ordinateur, et en décharger le pauvre programmeur.</p><p id="r-568581" data-claire-element-id="568581">Cette fonctionnalité est longtemps restée confinée dans les langages dérivés du ML (les plus utilisés actuellement étant le SML et le <a href="http://fr.wikipedia.org/wiki/OCaml">OCaml</a>). Récemment, des langages &quot;mainstream&quot; (c'est-à-dire moins utilisés - parce qu'ils sont moches - par les chercheurs en info, et plus par les ingénieurs informaticiens - idem) ont commencé à intégrer cette fonctionnalité : c'est le cas de <a href="http://fr.wikipedia.org/wiki/Java_(langage)">Java</a> et <a href="http://fr.wikipedia.org/wiki/C_sharp">C#</a>.</p><p id="r-568582" data-claire-element-id="568582">Cependant, la garantie d'une inférence totale de tous les types du programme par le compilateur (sans aide de la part du programmeur) impose des contraintes assez subtiles (et parfois assez restrictives) sur le langage, et n'est possible à ma connaissance que dans les langages ML.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique">Le typage : présentation thématique et historique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/tout-est-nombre-pour-l-ordinateur">
Tout est nombre, pour l&#039;ordinateur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
Des types pour plus de sûreté
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
Le typage, c&#039;est sémantique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
Langages dynamiques, langages statiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
Formalisons tout ça
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
Inférence : quand le système se débrouille tout seul
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
Polymorphisme paramétrique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
Un nouveau point de vue : le type comme interface
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/les-types-sont-universels">
Les types sont universels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
<span class="arrow"></span>
<span class="next">Formalisons tout ça</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
<span class="next">Polymorphisme paramétrique</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Polymorphismeparamtrique"></a><h2>Polymorphisme paramétrique</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
<span class="arrow"></span>
<span class="next">Inférence : quand le système se débrouille tout seul</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
<span class="next">Un nouveau point de vue : le type comme interface</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568584" data-claire-element-id="568584">Le polymorphisme paramétrique, c'est le fait qu'une valeur donnée d'une fonction puisse, sur plusieurs appels différents de la fonction, avoir des types différents.<br/> L'idée se voit très bien avec l'inférence de type ; mettons que je code la fonction identité (ou 'id'), qui ne fait par définition <em>rien</em> à son argument, puisqu'elle le renvoie <em>à l'identique</em> (on dirait pas mais cette fonction est centrale en maths : si, si) :</p><p id="r-568585" data-claire-element-id="568585"><cite>Citation</cite></p><blockquote id="r-568587" data-claire-element-id="568587"><p id="r-568586" data-claire-element-id="568586">Soit identité x = x</p></blockquote><p id="r-568588" data-claire-element-id="568588">En OCaml, cela s'écrit ainsi :</p><pre id="r-568589" data-claire-element-id="568589"><code data-claire-semantic="ocaml">let id x = x</code></pre><p id="r-568590" data-claire-element-id="568590">Comment le compilateur va-t-il deviner le type de la variable x ? Justement, il ne peut pas trop : les fonctions auxiliaires qui pourraient l'aider (comme <strong>+</strong> et <strong>*</strong> dans l'autre programme, qui permettent de comprendre qu'on manipule des nombres) ont disparu !</p><p id="r-568591" data-claire-element-id="568591">On est donc dans un cas où le compilateur ne &quot;peut pas deviner&quot; le type de la fonction. C'est dans ces cas-là qu'on rencontre le <strong><em>polymorphisme</em></strong> : le compilateur déclare &quot;x est de type quelconque inconnu, que j'appellerai 'a&quot;, et il fonctionne avec le type 'a comme s'il s'agissait d'un type qu'il connaît.</p><p id="r-568592" data-claire-element-id="568592">Voici ce que répond le compilateur quand on lui demande le type de notre fonction id :</p><p id="r-568593" data-claire-element-id="568593"><cite>Citation</cite></p><blockquote id="r-568595" data-claire-element-id="568595"><p id="r-568594" data-claire-element-id="568594">val id : 'a -&gt; 'a</p></blockquote><p id="r-568596" data-claire-element-id="568596">Il a donc donné un nom au type inconnu qu'on lui avait présenté.</p><p id="r-568597" data-claire-element-id="568597">L'avantage du polymorphisme va plus loin : en plus d'être inconnu, ce type est quelconque : n'importe quelle valeur du langage pourrait être donnée à la fonction id.<br/> Ainsi, si je donne un entier à id (par exemple 'id 3' renvoie 3), id va rester de type 'a -&gt; 'a (ce n'est pas parce qu'on lui a donné un entier une fois qu'elle devient de type int -&gt; int). On pourra toujours, dans la suite du programme, lui donner une chaîne de caractères, un tableau d'entiers, etc.</p><p id="r-568598" data-claire-element-id="568598">On a donc ajouté de la richesse à notre système de types : en plus d'avoir des types particuliers, on a aussi des types &quot;généralistes&quot; qui permettent d'être employés sur tous les types.</p><p id="r-568599" data-claire-element-id="568599">Vous allez me dire &quot;ça existe aussi en C, on a (void *)&quot;. Il y a une différence notoire entre les deux : si vous construisez par exemple une liste chaînée dont le champ de données est de type void* (pour pouvoir y mettre n'importe quoi), quand vous mettez une valeur dedans, elle devient de type void* et <strong>perd</strong> son information de typage. Il est alors possible de la manipuler comme toutes les autres données de type void*, et à ce niveau-là de faire des erreurs.<br/> Par exemple, si vous avez une liste chaînée qui contient des strings, et l'autre qui contient des tableaux d'entiers, les données seront forcées de devenir des void* en étant insérées dans la liste, et il sera possible quand vous les extrairez de ces listes (par exemple &quot;donne-moi le premier élément de la liste des tableaux de notes&quot;) de les faire passer de void* à un type différent de celui qu'elles avaient à l'origine (par exemple, de mélanger des fonctions s'appliquant à la liste des tableaux d'entiers et à la liste des strings).</p><p id="r-568600" data-claire-element-id="568600">Le <em><strong>polymorphisme paramétrique</strong></em> est plus puissant que cela : le type de données générique est &quot;'a list&quot; (liste d'objets de n'importe quel type), mais si vous construisez une liste d'entiers, elle sera de type &quot;int list&quot;. En effet, 'a est une lettre qui désigne le type (inconnu) de la liste ; si, pour une liste particulière, le type que représente 'a est connu, cette liste n'est plus polymorphe, et 'a est remplacé par le véritable nom du type. 'a joue un rôle de &quot;paramètre de types&quot;, d'où le nom &quot;polymorphisme paramétrique&quot;.</p><p id="r-568601" data-claire-element-id="568601">Ainsi, une liste de strings sera de type &quot;string list&quot;, une liste de tableaux d'entiers &quot;int array list&quot; (on doit lire &quot;(int array) list&quot;), et vous ne pourrez pas les mélanger entre elles : le typage vous en empêche. Par contre, les fonctions qui prennent en entrée le type &quot;'a list&quot; (par exemple : &quot;quelle est la taille de la liste donnée&quot;, car la taille de la liste ne dépend pas du type de ses éléments) pourront s'appliquer aux deux types de listes différents, puisque &quot;int array list&quot; et &quot;string list&quot; sont tous les deux des <em>cas particuliers</em> de &quot;'a list&quot; (où 'a représente respectivement le type int array et le type string).</p><p id="r-568602" data-claire-element-id="568602">Le polymorphisme paramétrique n'est pas forcément évident à comprendre, alors voici deux petits exemples pour la route :</p><pre id="r-568603" data-claire-element-id="568603"><code data-claire-semantic="ocaml">let gauche x y = x</code></pre><p id="r-568604" data-claire-element-id="568604">Le type de cette fonction est &quot;'a -&gt; 'b -&gt; 'a&quot;. Cela signifie que le premier argument est de type 'a, le deuxième de type 'b, et que la valeur de retour est de type 'a (vu qu'on renvoie le premier argument). Que vient faire le 'b ici ? Il indique que le deuxième argument est de type quelconque, et <em>non nécessairement</em> le même que le premier : pour différencier deux &quot;types inconnus&quot;, on leur met un nom de paramètre différent.</p><pre id="r-568605" data-claire-element-id="568605"><code data-claire-semantic="ocaml">let choisir test x y = if test then x else y</code></pre><p id="r-568606" data-claire-element-id="568606">Le type de cette fonction est &quot;bool -&gt; 'a -&gt; 'a -&gt; 'a&quot; : elle prend en argument un booléen (représentant une valeur de vérité, true ou false), un argument de type 'a, et un autre argument de type 'a, et renvoie soit le deuxième, soit le troisième argument, selon la valeur du booléen.<br/> Pourquoi les deux arguments sont-ils du même type 'a ? Parce que la valeur &quot;choisir&quot; ne peut avoir qu'un seul type de retour. Si le troisième argument était de type 'b, le type de retour de la fonction devrait être &quot;soit 'a, soit 'b&quot;, ce qui n'est pas possible. Par inférence, le compilateur a donc conclu que les deux arguments étaient nécessairement du même type.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique">Le typage : présentation thématique et historique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/tout-est-nombre-pour-l-ordinateur">
Tout est nombre, pour l&#039;ordinateur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
Des types pour plus de sûreté
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
Le typage, c&#039;est sémantique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
Langages dynamiques, langages statiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
Formalisons tout ça
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
Inférence : quand le système se débrouille tout seul
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
Polymorphisme paramétrique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
Un nouveau point de vue : le type comme interface
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/les-types-sont-universels">
Les types sont universels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
<span class="arrow"></span>
<span class="next">Inférence : quand le système se débrouille tout seul</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
<span class="next">Un nouveau point de vue : le type comme interface</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Unnouveaupointdevueletypecommeinterface"></a><h2>Un nouveau point de vue : le type comme interface</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
<span class="arrow"></span>
<span class="next">Polymorphisme paramétrique</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/les-types-sont-universels">
<span class="next">Les types sont universels</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568608" data-claire-element-id="568608">Le travail sur le polymorphisme paramétrique permet un nouveau point de vue sur les types. Souvenez-vous, la raison initiale à l'introduction des types polymorphiques était l'existence d'une valeur qu'on &quot;ne sait pas inférer&quot;.</p><p id="r-568609" data-claire-element-id="568609">Le point de vue est donc le suivant : le programmeur code son programme, manipule les valeurs comme il le souhaite, et après, le compilateur se débrouille pour trouver le type des variables comme il le peut. Quand il ne sait pas, il met un type polymorphe.</p><p id="r-568610" data-claire-element-id="568610">Ce point de vue n'est pas tout à fait exact, en tout cas il n'est pas suffisant, car il ne prend pas en compte les avantages du type polymorphique : en permettant la manipulation des données sans se soucier de leur type, mais en conservant la sûreté du typage, le polymorphisme permet d'introduire un degré d'abstraction et de <strong>généricité</strong> (de <em>générique</em>) supplémentaire. Le programmeur se trouve alors dans une autre position : il s'apprête à créer une fonction dont il souhaite qu'elle soit polymorphe, et choisit donc de restreindre les manipulations qu'il effectue dessus pour que (selon le premier point de vue) le compilateur &quot;ne sache pas&quot; donner un type particulier à la fonction.</p><p id="r-568611" data-claire-element-id="568611">On a ici changé de sens : ce ne sont plus les manipulations du programmeur qui imposent un type à la fonction, c'est le type que le programmeur désire qui le restreint dans les manipulations auxquelles il est autorisé : les types dirigent la manière dont on traite les valeurs.</p><p id="r-568612" data-claire-element-id="568612">Reprenons l'exemple &quot;let id x = x&quot;. Vous avez remarqué qu'on &quot;ne fait rien&quot; à cette valeur x : on ne la manipule <em>pas du tout</em>. Et c'est pour cela qu'on a un type polymorphe. Si on l'avait discrètement additionnée, affichée ou copiée dans un tableau, on aurait fait une manipulation permettant au compilateur de déterminer son type concret, et le polymorphisme aurait disparu.</p><p id="r-568613" data-claire-element-id="568613">Une valeur est donc polymorphe dans un contexte où on ne la &quot;manipule&quot; pas trop. Pas trop, cela veut dire qu'on ne la touche pas (comme ici), ou qu'on ne lui applique que des fonctions polymorphes.<br/> Par exemple, la fonction &quot;let id2 x = id x&quot; manipule la valeur x, puisqu'elle lui applique la fonction &quot;id&quot;. Mais comme cette dernière est polymorphe (ne manipule pas trop x), la fonction id2 conserve le polymorphisme elle aussi. Rassurez-vous, il existe des fonctions polymorphes un peu plus utiles que id :p (mais on les rencontre sur les objets plus évolués, comme les listes ou les tableaux).</p><p id="r-568614" data-claire-element-id="568614">Avec ce nouveau point de vue, on peut voir le type comme l'<em>interface</em> selon laquelle on manipule une valeur (on peut voir une interface comme la liste des fonctions qui sont autorisées) : si on applique la fonction ( <strong>+</strong> ) (l'addition), on utilise une interface d'entier, donc le type des deux arguments (a + b) est un entier. Si l'on applique la fonction &quot;taille_liste&quot;, on utilise l'interface d'une 'a list, donc la fonction est une 'a list (et si, dans le reste de la fonction, on demande un élément et qu'on le manipule comme un entier, alors la liste sera une int list). Si on ne la manipule pas, on n'utilise aucune interface (donc, toutes les interfaces conviennent), donc on obtient un type polymorphe.</p><p id="r-568615" data-claire-element-id="568615">Ce nouveau point de vue est un peu compliqué, et il ne recèle pas plus de vérité que l'idée simple des types : il n'y en a pas un qui est juste, et l'autre, faux : ce sont deux manières d'envisager la chose ; selon la situation, il peut être utile pour raisonner sur les types de choisir l'un ou l'autre des points de vue, comme je le montrerai à la fin de cette partie.</p><p id="r-568616" data-claire-element-id="568616">On peut remarquer que le choix d'interface est assez limité : soit on en choisit une, et on a un type déterminé, soit on n'en choisit aucune et la valeur est de type polymorphe ; si on en choisit deux, on essaie d'utiliser la valeur avec des fonctions de deux types différents, et on a une erreur.<br/> Ce concept d'interface a été repris et enrichi dans les langages objets, mais, pour la plupart, ils ne bénéficient pas d'un système de typage formalisé, ce qui réduit beaucoup leur intérêt d'un point de vue théorique (en ce qui concerne le typage). Des langages fonctionnels modernes, c'est-à-dire développés dans les années 90 (quelques variantes de Ocaml et SML, et <a href="http://fr.wikipedia.org/wiki/Haskell">Haskell</a>) ont poussé l'idée dans un contexte formel, et cela a donné des résultats assez riches, mais qui sortent du cadre de ce tutoriel.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique">Le typage : présentation thématique et historique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/tout-est-nombre-pour-l-ordinateur">
Tout est nombre, pour l&#039;ordinateur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
Des types pour plus de sûreté
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
Le typage, c&#039;est sémantique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
Langages dynamiques, langages statiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
Formalisons tout ça
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
Inférence : quand le système se débrouille tout seul
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
Polymorphisme paramétrique
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
Un nouveau point de vue : le type comme interface
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/les-types-sont-universels">
Les types sont universels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
<span class="arrow"></span>
<span class="next">Polymorphisme paramétrique</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/les-types-sont-universels">
<span class="next">Les types sont universels</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lestypessontuniversels"></a><h2>Les types sont universels</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
<span class="arrow"></span>
<span class="next">Un nouveau point de vue : le type comme interface</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568618" data-claire-element-id="568618">Un reproche que l'on entend souvent dans la bouche des programmeurs au sujet des langages non typés (ou plutôt peu typés, ou faiblement typés) est &quot;votre langage a la contrainte additionnelle du typage, donc il est moins puissant&quot;. Rassurez-vous, ils se trompent ; et le nouveau point de vue permet de le comprendre.</p><p id="r-568619" data-claire-element-id="568619">Il faut savoir que les langages au système de typage riche ont développé des fonctionnalités qui permettent de construire des types complexes à partir des types simples fournis initialement par le langage : un peu à la manière (mais en beaucoup mieux :p ) des struct et des enum du C (mais je n'en parlerai pas dans ce tutoriel).<br/> J'ai dit plus haut qu'il n'était pas possible de mélanger des manipulations issues de deux types différents. Il est cependant possible (avec la construction ressemblant à enum) de construire un troisième type, qui contient soit un objet du premier type, soit un objet du deuxième, et donc de choisir selon le cas la manipulation à effectuer.</p><h3 id="r-un-exemple-17" data-claire-element-id="568629">Un exemple</h3><p id="r-568620" data-claire-element-id="568620">Voici un exemple qui pourrait (à première vue seulement) mettre en difficulté un programmeur d'un langage typé : les listes d'un langage typé imposent que tous les éléments de la liste soient du même type. Si vous mettez par exemple un entier dans une liste, tous les autres éléments doivent obligatoirement être des entiers, faute de quoi vous aurez une erreur de typage.</p><p id="r-568621" data-claire-element-id="568621">Imaginez maintenant un programmeur dans un langage non typé qui a une liste de nombres, un nom (par exemple &quot;liste de notes&quot;), qui doit coder une fonction qui affiche le nom de la liste, puis son contenu, et qui a envie de produire du code laid. Il peut décider de mettre le nom de la liste en première position de la liste : ainsi, il ne donne que la liste à la fonction, qui récupère le premier élément (c'est le nom), le traite spécialement, et affiche normalement tous les éléments du reste de la liste.</p><p id="r-568622" data-claire-element-id="568622">Comme dans un langage typé, on ne peut mélanger des éléments de types différents dans une liste, cette solution n'est pas praticable. La première solution, la plus simple, consiste à fournir à la fonction d'affichage, au lieu d'une liste qui mélange tout, un couple (nom, liste), qui contient d'une part le nom, et d'autre part la liste des nombres. Cette solution convient tout à fait, mais le programmeur du langage non typé risque de vous dire que ce n'est pas le même algorithme, puisque lui n'envoie qu'une liste, et que vous avez triché parce qu'il n'existe pas de manière de créer des couples dans son langage à lui. On va donc produire une autre solution, moins élégante, mais qui reprend exactement le principe de son algorithme.</p><p id="r-568623" data-claire-element-id="568623">Quand il a mis le nom en premier élément de la liste, est-ce que cela veut dire qu'il a traité tous les éléments de la même manière ? Non, il ne peut pas, puisque le premier élément est une string, alors que les suivants sont des nombres : s'il avait essayé des fonctions d'affichage de nombres sur la string, ou d'affichage de string sur les nombres, il n'aurait pas eu le bon résultat. Le traitement qu'il effectue aux éléments de sa liste est un choix : si c'est le premier élément, l'afficher comme une string, si c'est un autre élément, l'afficher comme un nombre.</p><p id="r-568624" data-claire-element-id="568624">Pour reproduire son comportement, il nous suffit donc de créer un type qui représente ce choix :</p><pre id="r-568625" data-claire-element-id="568625"><code data-claire-semantic="ocaml">type élément = Premier of string | Autre of nombre</code></pre><p id="r-568626" data-claire-element-id="568626">C'est la syntaxe de déclaration des types ressemblant à enum, en ML. Le '|' représente le choix : une valeur de type élément est soit Premier s, où s est une string, soit Autre n, où n est un entier. Maintenant, quand on a un nom et une liste de nombres, on crée une liste de type élément (par exemple : de &quot;notes&quot; et la liste [1; 2; 3], on crée la liste [Premier &quot;notes&quot;; Autre 1; Autre 2; Autre 3], qui a bien tous les éléments du même type). Ensuite, on le donne à une fonction d'affichage. Pour l'exemple, voici le code d'une telle fonction :</p><pre id="r-568627" data-claire-element-id="568627"><code data-claire-semantic="ocaml">let présente liste =
let affiche_élément = function
   | Premier titre -&gt; printf &quot;titre : %s\n&quot; titre
   | Autre n -&gt; printf &quot;%d\t&quot; n
in List.iter affiche_élément liste</code></pre><p id="r-568628" data-claire-element-id="568628">(La fonction List.iter est une fonction prédéfinie du langage, qui applique une fonction à tous les éléments d'une liste.)<br/> On a donc résolu le problème du programmeur sceptique, et de la même façon laide que lui, en stockant tout dans la liste.</p><h3 id="r-le-cas-general" data-claire-element-id="568636">Le cas général</h3><p id="r-568630" data-claire-element-id="568630">Voyons maintenant le cas général : ils pensent qu'il existe des programmes qui ne peuvent pas être écrits dans un langage typé, mais qui seraient possibles dans le même langage, non typé. Il ne suffit pas de montrer que tous les codes qu'ils présentent sont traduisibles dans un langage typé (comme je viens de le faire pour l'exemple), mais il faut maintenant leur montrer qu'un tel code <strong>n'existe pas</strong>. C'est ce que je vais essayer (de manière très peu formelle) de faire.</p><p id="r-568631" data-claire-element-id="568631">Imaginez un programme de la sorte, écrit dans une variante non typée du langage : tout ce qu'il fait, c'est manipuler des valeurs. On peut donc pour chaque valeur regarder l'ensemble des manipulations (ou fonctions) qui lui sont appliquées : cela nous donne son interface. Et cette interface, aussi alambiquée soit-elle, peut être traduite (à l'aide des méthodes de constructions de nouveaux types) en un type de données.<br/> Ainsi, n'importe quel programme écrit dans le langage non typé peut se traduire en un programme dans le langage typé, et le point de vue &quot;type comme interface&quot; le montre très clairement.</p><p id="r-568632" data-claire-element-id="568632">J'espère que cette petite ( :-° ) dissertation sur le typage vous a intéressés.<br/> C'est un sujet très large, très riche, mais trop souvent négligé des programmeurs qui, par manque d'information, de temps ou d'intérêt, ne se sont pas aventurés du côté des langages portés sur les développements théoriques de l'informatique.</p><p id="r-568633" data-claire-element-id="568633">La culture, c'est important, autant en informatique qu'ailleurs. Des connaissances historiques de base, ainsi qu'une vague idée de ce qui se fait dans les langages moins connus ne pourront qu'améliorer la manière dont vous concevez la programmation.</p><p id="r-568634" data-claire-element-id="568635">Ce tutoriel est mis à disposition sous licence <a href="http://creativecommons.org/licenses/by-sa/2.0/fr/">creative commons <img id="r-568635" data-claire-element-id="568634" src="../../licensebuttons.net/l/by-sa/2.0/fr/88x31.png" alt="- Paternité - Partage des conditions à l'identique"/></a>. Ça signifie que vous pouvez librement copier et modifier ce tutoriel, à condition de citer l'auteur original et de conserver cette licence.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique">Le typage : présentation thématique et historique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/tout-est-nombre-pour-l-ordinateur">
Tout est nombre, pour l&#039;ordinateur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/des-types-pour-plus-de-surete">
Des types pour plus de sûreté
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/le-typage-c-est-semantique">
Le typage, c&#039;est sémantique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/langages-dynamiques-langages-statiques">
Langages dynamiques, langages statiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/formalisons-tout-ca">
Formalisons tout ça
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/inference-quand-le-systeme-se-debrouille-tout-seul">
Inférence : quand le système se débrouille tout seul
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/polymorphisme-parametrique">
Polymorphisme paramétrique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
Un nouveau point de vue : le type comme interface
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/les-types-sont-universels">
Les types sont universels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-typage-presentation-thematique-et-historique/un-nouveau-point-de-vue-le-type-comme-interface">
<span class="arrow"></span>
<span class="next">Un nouveau point de vue : le type comme interface</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/le-typage-presentation-thematique-et-historique.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 07:01:52 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/le-typage-presentation-thematique-et-historique.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:16:26 GMT -->
</html>
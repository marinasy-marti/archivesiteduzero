<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Oct 2013 22:46:57 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:01:26 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#MulticoeursHyperthreadingGPGPUlesarchitecturesmodernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a><br/><a href="#Lesdiffrentesarchitecturesparallles">Les différentes architectures parallèles</a><br/><a href="#Lesdiffrentstypesdeparalllisme">Les différents types de parallélisme</a><br/><a href="#Partagedelammoire">Partage de la mémoire</a><br/><a href="#Leslimitesthoriques">Les limites théoriques</a><br/><a href="#Loid039Amdhal">Loi d&#039;Amdhal</a><br/><a href="#LoideGustafson">Loi de Gustafson</a><br/><a href="#Hyperthreadingetcompagnie">Hyperthreading et compagnie</a><br/><a href="#Duparalllismeavecunseulprocesseur">Du parallèlisme avec un seul processeur</a><br/><a href="#Etdansleprocesseur">Et dans le processeur ?</a><br/><a href="#Processeursmulticoeurs">Processeurs multicoeurs</a><br/><a href="#Processeursmulticurs">Processeurs multicœurs</a><br/><a href="#Lepartagedescaches">Le partage des caches</a><br/><a href="#Cohrencemmoire">Cohérence mémoire</a><br/><a href="#Mcanismesdebase">Mécanismes de base</a><br/><a href="#Protocolesdecohrencedescaches">Protocoles de cohérence des caches</a><br/><a href="#Consistancemmoire">Consistance mémoire</a><br/><a href="#Modlesdeconsistance">Modèles de consistance</a><br/><a href="#FencesetMemoryBarrier">Fences et Memory Barrier</a><br/><a href="#SynchronisationentreThreads">Synchronisation entre Threads</a><br/><a href="#Exclusionmutuelle">Exclusion mutuelle</a><br/><a href="#MmoireTransactionelleMatrielle">Mémoire Transactionelle Matérielle</a><br/><a href="#InstructionsSIMD">Instructions SIMD</a><br/><a href="#InstructionsSIMD">Instructions SIMD</a><br/><a href="#ExemplesMMXSSEetAVX">Exemples : MMX, SSE et AVX</a><br/><a href="#Lesprocesseursvectoriels">Les processeurs vectoriels</a><br/><a href="#Pipelining">Pipelining</a><br/><a href="#Accsmmoires">Accès mémoires</a><br/><a href="#Quelquesregistresutiles">Quelques registres utiles</a><br/><a href="#GPGPUetStreamsProcessors">GPGPU et Streams Processors</a><br/><a href="#Architectured039unGPU">Architecture d&#039;un GPU</a><br/><a href="#Hirarchiemmoire">Hiérarchie mémoire</a><br/><a href="#Jeud039instruction">Jeu d&#039;instruction</a><br/></div>
<a name="MulticoeursHyperthreadingGPGPUlesarchitecturesmodernes"></a><h2>Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</h2><div class="content" role="article">
<p id="r-442720" data-claire-element-id="442720">De nos jours, avec l’avènement des architectures multicœurs, de nombreux programmeurs cherchent à utiliser au mieux la puissance fournie par les processeurs modernes. En effet, il n'est pas rare de posséder des processeurs contenant plusieurs cœurs. Cela fait quelques années que de tels processeurs ont étés mis sur le marché et sont accessibles à tout un chacun moyennant une certaine somme d'argent (très souvent trop assez conséquente). L'utilité de tels processeurs est très simple : la performance ! De tels processeurs permettent de faire exécuter des instructions indépendantes dans des processeurs séparés. Cette solution qui consiste à répartir des calculs sur plusieurs processeurs s'appelle le <strong>parallélisme</strong>.</p><p id="r-442721" data-claire-element-id="442721">Mais les processeurs multicœurs ne sont pas les seuls processeurs permettant de faire ceci : de nombreux autres processeurs et architectures permettent d’exécuter plusieurs calculs simultanément. Entre les ordinateurs embarquant plusieurs processeurs, les architectures <em>dataflow</em>, les processeurs vectoriels et autres, il y a de quoi être perdu assez rapidement. Mais rassurez-vous : ce tutoriel est là ! Grâce à ce tutoriel, vous aurez un aperçu des différentes architectures parallèles et vous verrez leurs forces et leurs faiblesses. Nous parlerons aussi bien du fonctionnement de ces processeurs et ordinateurs que des interactions entre matériel et logiciel : préparez-vous, le monde du parallélisme vous attend.</p>
</div>
<div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1358423835269-0" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1358423835269-0');
        });
    }
    </script>
</div><a name="Lesdiffrentesarchitecturesparallles"></a><h2>Les différentes architectures parallèles</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
<span class="next">Les différents types de parallélisme</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-442723" data-claire-element-id="442723">Il existe différents types d'ordinateurs parallèles, tous plus bizarres que les autres. L'imagination des chercheurs en architectures de ordinateurs a en effet été mise à rude épreuve devant le défi que nous imposait la création des architectures parallèles et de nombreuses architectures ont étés inventées pour répondre à ce besoin. Si on devait se lancer sans chercher à organiser le tout, on serait rapidement perdu. Pour se faciliter la tâche, diverses classifications ont été inventées pour mettre un peu d'ordre dans tout ce foutoir.</p>
</div><a name="Lesdiffrentstypesdeparalllisme"></a><h2>Les différents types de parallélisme</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">
<span class="arrow"></span>
<span class="next">Les différentes architectures parallèles</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
<span class="next">Partage de la mémoire</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-les-differents-types-de-parallelisme" data-claire-element-id="442790">Les différents types de parallélisme</h4><p id="r-442724" data-claire-element-id="442724">Il faut savoir qu'il existe différentes formes de parallélisme, qui ne cherchent pas à paralléliser la même chose et ne fonctionnent pas de la même façon. Pour s'y retrouver, diverses classifications ont vus le jour.</p><h5 id="r-quoi-1" data-claire-element-id="442738">Quoi ?</h5><p id="r-442725" data-claire-element-id="442725">La première d'entre elle se base sur ce qui est parallélisé.</p><h6 id="r-parallelisme-de-threads" data-claire-element-id="442731">Parallélisme de <em>Threads</em></h6><p id="r-442726" data-claire-element-id="442726">La première solution, la plus évidente, consiste simplement à exécuter des calculs indépendants en parallèle. Pour cela, il suffit de découper notre programme en plusieurs sous-programmes indépendants qu'on peut faire éxecuter en parallèle. Ces sous-programmes indépendants sont ce qu'on appelle des <strong><em>Threads</em></strong>.</p><aside id="r-442728" data-claire-element-id="442728" data-claire-semantic="warning"><p id="r-442727" data-claire-element-id="442727">Attention : j'utilise le terme <em>thread </em>non dans le sens <em>thread </em>logiciel, mais dans un sens plus général, largement utilisé dans la littérature sur l'architecture des ordinateurs parallèles. Quand je parlerai de <em>threads</em>, je parlerai de <em>threads </em><strong>threads matériels</strong>. Je préfère prévenir tout de suite, vu que dans la suite du tutoriel, j'utiliserai le terme <em>thread </em>de cette façon, et particulièrement dans les chapitres sur les processeurs multithreadés un peu spéciaux. Pour le moment, considérez qu'un <em>thread </em>est simplement un morceau de programme, constitué d'une suite d'instructions à exécuter en série, et qui devra utiliser le processeur.</p></aside><p id="r-442729" data-claire-element-id="442729">Il suffit de faire exécuter chaque <em>Thread</em> sur un processeur séparé pour pouvoir paralléliser le tout. Les architectures permettant d’exécuter des <em>threads </em>en parallèle sont donc des architectures multiprocesseurs ou multicœurs, ainsi que quelques autres processeurs un peu spéciaux. Avec ce genre de parallélisme, le découpage d'un programme en <em>threads </em>est avant tout un problème logiciel. Ce découpage est donc dans ce cas du ressort du compilateur ou du programmeur : c'est à eux de modifier le programme pour le paralléliser. Nos langages de programmation disposent souvent de mécanismes permettant de découper notre programmes en <em>threads </em>logiciels, exécutables en parallèle si le matériel le permet. Dans certains cas, le compilateur peut s'en charger tout seul, bien que cela soit plus rare.</p><p id="r-442730" data-claire-element-id="442730">Et enfin, plus étonnant, certains processeurs sont capables de découper un programme à l’exécution, éventuellement grâce à des indications fournies par le programme lui-même ! On peut ainsi, à partir d'un programme unique non-découpé en <em>threads</em>, utiliser plusieurs cœurs ou processeurs sans problèmes ! Le découpage en <em>thread </em>se fait alors à l’exécution, et ce de façon optimale en fonction du nombre de processeurs. Mais cela est tout de même assez rare, même si cela a déjà été tenté : on reviendra dessus quand je parlerai des architectures EDGE et du <em>spéculative multithreading</em> dans ce tutoriel.</p><h6 id="r-parallelisme-d-instruction" data-claire-element-id="442734">Parallélisme d'instruction</h6><p id="r-442732" data-claire-element-id="442732">Mais certains chercheurs se sont dit que penser hors du cadre ne faisait pas de mal : ceux-ci ont considéré que paralléliser un programme pouvait être un problème matériel, et que créer des architectures réellement conçue pour exécuter des instructions en parallèle serait une grande avancée. Créer des architectures spéciales serait donc un gros plus qui permettrait non pas de découper des programmes entiers en morceaux qu'on pourrait exécuter en parallèle, mais permettrait de paralléliser directement un programme au niveau de ses instructions ! Nos chercheurs ont cherché (quoi de plus normal...) un moyen de créer des ordinateurs de ce genre, sans trop d'aide venant du logiciel. Les architectures <em>dataflow </em>furent une de ces réponses. Mais nous ne parlerons pas de ces architectures spéciales dans ce tutoriel.</p><p id="r-442733" data-claire-element-id="442733">Les techniques apprises sur les ordinateurs <em>dataflow </em>ont malgré tout été reprises dans les processeurs modernes, qui incorporent des techniques comme l'<em>Out Of Order</em> et autres renommages de registres, qui sont des descendants directs de nos architectures <em>dataflow</em>. Ces techniques permettent à un processeur seul d’exécuter plusieurs instructions simultanément, à la condition que ces instructions appartiennent à un seul et unique programme. Les concepteurs de processeurs on en effet inventé des tas de techniques permettant à notre processeur de ne pas exécuter des instructions dans l'ordre prévu par le programmeur : le pipeline, l'Out Of Order, la création de processeurs superscalaires, etc. Sachez juste que cette forme de parallélisme n'est pas au programme de ce tutoriel : le tutoriel <a href="http://www.siteduzero.com/tutoriel-3-509203-fonctionnement-d-un-ordinateur-depuis-zero.html">Fonctionnement d'un ordinateur depuis zéro</a> se charge déjà d'expliquer certaines de ces techniques. Allez donc lire la partie 7 si vous vous en sentez le courage et que vous en avez les compétences !</p><h6 id="r-parallelisme-de-donnees" data-claire-element-id="442737">Parallélisme de données</h6><p id="r-442735" data-claire-element-id="442735">Autre solution, exécuter le même programme sur des données différentes et indépendantes. Cela permet donc de traiter N données sur N processeurs en même temps. Pour résumer : tous les processeurs exécutent un seul et unique programme ou une suite d'instructions, mais chacun de ces processeurs va travailler sur une donnée différente. Cette solution est celle qui est la moins limitée, comme on le verra plus tard : il n'y a pas vraiment de limitations théoriques à ce genre de parallélisme.</p><p id="r-442736" data-claire-element-id="442736">Les processeurs pouvant faire ce genre de chose ne sont pas rares, bien au contraire : la quasi-totalité des processeurs est aujourd'hui de ce type. Plus précisément, tous les processeurs Intel et AMD actuels, ainsi que leurs confrères de chez ARM, MIPS et VIA en sont capables. Le parallélisme de donnée est aussi massivement utilisé dans les cartes graphiques, qui sont des composants devant exécuter les mêmes instructions sur un grand nombre de données : chaque calcul sur un pixel est plus ou moins indépendant des transformations qu'on effectue sur ses voisins.</p><h5 id="r-taxonomie-de-flynn" data-claire-element-id="442789">Taxonomie de Flynn</h5><p id="r-442739" data-claire-element-id="442739">Maintenant qu'on connait un peu les différentes formes de parallélisme, on va maintenant voir les différents types d'architectures parallèles. Dans les années 1966, un scientifique américain assez connu dans le milieu du <em>hardware </em>qui se nomme Flynn a classé ces architectures en 4 grandes catégories : SISD, SIMD, MISD, et MIMD. Cette classification a remarquablement tenue le coup au fil du temps : on a beau eu inventer des tas d'architectures plus bizarres les unes que les autres, cette classification n'en est pas moins restée consistante et redoutablement fiable. Elle n'est pas parfaite, et certaines architectures ne rentrent pas vraiment dans les catégorie de la classification de Flynn, mais ce n'est qu'un détail que je me permets de passer sous silence. Aussi, je me permets de vous parler de cette classification qui, bien que simpliste, est d'une grande aide au quotidien (ou presque).</p><h6 id="r-sisd" data-claire-element-id="442744">SISD</h6><p id="r-442740" data-claire-element-id="442740">Le premier type d'ordinateur correspond aux processeurs purement séquentiels et incapables de toute forme de parallélisme. Ceux-ci vont exécuter une instruction sur un seul ensemble de données, et rien d'autre. Ce sont les ordinateurs SISD (<em>Single Instruction Single Data</em>).</p><figure id="r-442742" data-claire-element-id="442743"><img id="r-442741" data-claire-element-id="442741" src="medias/uploads.siteduzero.com_files_363001_364000_363689.png" alt="Image utilisateur"/></figure><h6 id="r-simd" data-claire-element-id="442750">SIMD</h6><p id="r-442745" data-claire-element-id="442745">Vient ensuite le tour des architectures <strong>SIMD</strong> (<em>Single Instruction Multiple Data</em>), qui sont des architectures permettant d'exploiter le parallélisme de données. Celles-ci peuvent exécuter une instruction sur plusieurs données à la fois.</p><figure id="r-442747" data-claire-element-id="442748"><img id="r-442746" data-claire-element-id="442746" src="medias/uploads.siteduzero.com_files_363001_364000_363687.png" alt="Image utilisateur"/></figure><p id="r-442749" data-claire-element-id="442749">On verra ces types d'architectures en détail dans notre tutoriel. Vous verrez par exemple que nos processeurs un tant soit peu récents possèdent des instructions machines capables d'effectuer des calculs sur plusieurs données différentes à la fois, ce qui les classe d'office dans la catégorie SIMD. C'est aussi le cas de pas mal de cartes graphique, comme on le verra plus tard. Nous verrons aussi des architectures composées de plusieurs processeurs, sur lesquelles chaque processeur exécute la même instruction que ses collègues, mais sur des données différentes.</p><h6 id="r-misd" data-claire-element-id="442756">MISD</h6><p id="r-442751" data-claire-element-id="442751">Vient ensuite le tour des ordinateurs MISD (<em>Multiple Instruction Single Data</em>). Ceux-ci peuvent exécuter des instructions différentes en parallèle sur une donnée identique.</p><figure id="r-442753" data-claire-element-id="442754"><img id="r-442752" data-claire-element-id="442752" src="medias/uploads.siteduzero.com_files_363001_364000_363690.png" alt="Image utilisateur"/></figure><p id="r-442755" data-claire-element-id="442755">Autant prévenir tout de suite : on ne verra aucun exemple de ce type dans le tutoriel. Cette catégorie d’architectures est vraiment très rare. On peut citer comme exemples d'architectures MISD les architectures systoliques et cellulaires.</p><h6 id="r-mimd" data-claire-element-id="442763">MIMD</h6><p id="r-442757" data-claire-element-id="442757">Et enfin, voici la classe la plus importante : les architectures MIMD (<em>Multiple Instruction Multiple Data</em>). Celles-ci peuvent éxecuter des instructions différentes sur des données différentes.</p><figure id="r-442759" data-claire-element-id="442760"><img id="r-442758" data-claire-element-id="442758" src="medias/uploads.siteduzero.com_files_363001_364000_363693.png" alt="Image utilisateur"/></figure><p id="r-442761" data-claire-element-id="442761">Nos processeurs multicœurs et multiprocesseurs font partie de la catégorie MIMD.</p><p id="r-442762" data-claire-element-id="442762">On peut préciser que cette catégorie MIMD peut être découpée en deux sous-catégories. La première est le <strong><em>Single Program Multiple Data </em></strong>, aussi appelé SPMD : cela consiste à exécuter un seul programme sur plusieurs données à la fois. Dit comme cela, on pourrait croire qu'il s'agit de SIMD. Mais il y a une différence : avec le SPMD, on peut parfaitement exécuter des morceaux de programmes différents sur des données différents. Le SIMD force à exécuter la même instruction sur plusieurs données. Vient ensuite le <strong><em>Multiple Program Multiple Data</em></strong>, qui consiste à exécuter des programmes en parallèle sur des données différentes.</p><h6 id="r-resume-20" data-claire-element-id="442788">Résumé</h6><p id="r-442764" data-claire-element-id="442764">Cette classification peut sembler simple, mais est tout de même redoutablement efficace. Elle marche pour la grosse majorité des architectures parallèles que nous allons voir dans ce tutoriel, les cas spéciaux méritant un article à eux tout seuls.</p><table id="r-442787" data-claire-element-id="442787"><tbody id="r-442786" data-claire-element-id="442786"><tr id="r-442771" data-claire-element-id="442771"><td id="r-442766" data-claire-element-id="442766"><p id="r-442765" data-claire-element-id="442765">Peut traiter :</p></td><td id="r-442768" data-claire-element-id="442768"><p id="r-442767" data-claire-element-id="442767">Un seul ensemble de données à la fois</p></td><td id="r-442770" data-claire-element-id="442770"><p id="r-442769" data-claire-element-id="442769">Plusieurs ensembles de données à la fois</p></td></tr><tr id="r-442778" data-claire-element-id="442778"><td id="r-442773" data-claire-element-id="442773"><p id="r-442772" data-claire-element-id="442772">Une instruction à la fois</p></td><td id="r-442775" data-claire-element-id="442775"><p id="r-442774" data-claire-element-id="442774"><strong>SISD</strong></p></td><td id="r-442777" data-claire-element-id="442777"><p id="r-442776" data-claire-element-id="442776"><strong>SIMD</strong></p></td></tr><tr id="r-442785" data-claire-element-id="442785"><td id="r-442780" data-claire-element-id="442780"><p id="r-442779" data-claire-element-id="442779">Plusieurs instructions différentes à la fois</p></td><td id="r-442782" data-claire-element-id="442782"><p id="r-442781" data-claire-element-id="442781"><strong>MISD</strong></p></td><td id="r-442784" data-claire-element-id="442784"><p id="r-442783" data-claire-element-id="442783"><strong>MIMD</strong></p></td></tr></tbody></table>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">
<span class="arrow"></span>
<span class="next">Les différentes architectures parallèles</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
<span class="next">Partage de la mémoire</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Partagedelammoire"></a><h2>Partage de la mémoire</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
<span class="arrow"></span>
<span class="next">Les différents types de parallélisme</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">
<span class="next">Les limites théoriques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-partage-de-la-memoire" data-claire-element-id="442827">Partage de la mémoire</h4><p id="r-442791" data-claire-element-id="442791">La capacité à traiter des données ou des instructions différentes simultanément n'est pas la seule différence entre les architectures parallèles : la façon dont les processeurs doivent se partager la mémoire est aussi très importante. Suivant la façon dont est partagée la mémoire, de nombreux problèmes peuvent apparaitre. Aussi, il est important de savoir à comment est partagée la mémoire. Voyons un peu les différentes possibilités de partage de la mémoire.</p><h5 id="r-sasm" data-claire-element-id="442805">SASM</h5><p id="r-442792" data-claire-element-id="442792">Dans le premier cas, on se retrouve avec une seule et unique mémoire partagée entre tous les processeurs. Le temps mit pour accéder à la mémoire est identique pour tous les processeurs : on parle alors d'<strong><em>Unifed Memory Access</em></strong> ou encore d'<strong>UMA</strong>.</p><figure id="r-442794" data-claire-element-id="442795"><img id="r-442793" data-claire-element-id="442793" src="medias/uploads.siteduzero.com_files_363001_364000_363699.png" alt="Image utilisateur"/></figure><p id="r-442796" data-claire-element-id="442796">Avec ce genre d'architecture, rien n’empêche à plusieurs processeurs de vouloir accéder à la mémoire en même temps. Seul problème : la mémoire ne peut lire ou écrire qu'une donnée à la fois (enfin sur des mémoires normales : on passe sous le tapis le cas des mémoires multiports). Il va donc falloir trouver des moyens pour arbitrer les accès à la mémoire entre les processeurs pour éviter les problèmes. Par exemple, imaginez qu'un processeur aille modifier une donnée qui est en cours de traitement par un autre processeur : on peut aller rapidement vers une belle catastrophe et il est facile de se retrouver avec des données écrasées, mises à jour trop tôt, ou pire. Pour éviter ce genre de situations fâcheuses, le matériel se charge alors de fournir quelques instructions pour faciliter la communication ou la synchronisation entre les différents morceaux de programmes (interruptions inter-processeurs, instructions machines atomiques permettant d'implémenter des <em>Mutex</em>, etc).</p><p id="r-442797" data-claire-element-id="442797">La conséquence, c'est que les couts de synchronisation et de communication entre les différents morceaux de programmes peut être assez conséquent et peut réduire les performances si on s'y prend assez mal : ce partage de la mémoire est assez embêtant. Sans compter certaines contraintes concernant la hiérarchie mémoire, qui jouent souvent de mauvais tours.</p><h6 id="r-et-avec-des-caches" data-claire-element-id="442804">Et avec des caches ?</h6><p id="r-442798" data-claire-element-id="442798">Il n'est pas rare que l'on améliore l'architecture SASM en rajoutant ce qu'on appelle des <strong>mémoires caches</strong>. Il s'agit simplement de mémoires intercalées entre la RAM de l'ordinateur et le processeur. Ces mémoires caches sont plus petites, mais aussi plus rapides et permettent ainsi d’accéder plus rapidement à la mémoire RAM de l'ordinateur. Il faut dire que la mémoire RAM est vraiment plus lente que le processeur, qui passe beaucoup de temps à attendre la mémoire. C'est pour limiter la casse que l'on a inventé ces fameux caches.</p><figure id="r-442800" data-claire-element-id="442801"><img id="r-442799" data-claire-element-id="442799" src="medias/uploads.siteduzero.com_files_363001_364000_363736.png" alt="Image utilisateur"/></figure><p id="r-442802" data-claire-element-id="442802">Cela permet d’accélérer l'accès à la mémoire partagée, et permet ainsi des gains assez conséquents. Malheureusement, ajouter un ou plusieurs caches sur des architectures SASM entraine l'apparition de quelques petits problèmes lorsque deux processeurs doivent écrire au même endroit en mémoire. Imaginons que deux processeurs manipulent une donnée : ceux-ci ont une copie de la donnée dans leur cache qu'ils manipulent et modifient à loisir. Si un processeur modifie cette copie de la donnée et que celle-ci est enregistrée dans son cache ou en mémoire, elle sera alors différente de celle présente dans le cache de l'autre processeur. Ce qui fait qu'un processeur peut continuer à manipuler une donnée périmée qui vient d'être mise à jour par l'autre processeur. Et ça peut poser quelques problèmes ! Un processeur doit toujours éviter de se retrouver avec une donnée périmée et doit toujours avoir la valeur correcte dans ses caches : cela s'appelle la <strong>cohérence des caches</strong>.</p><p id="r-442803" data-claire-element-id="442803">De manière générale, les mémoires caches posent de sacrés problèmes sur pas mal d'architectures parallèles. Autant prévenir tout de suite : je parlerai beaucoup des mémoires caches et des problèmes qu'elles peuvent poser dans ce tutoriel. Mais on abordera le sujet en détail plus tard.</p><h5 id="r-dadm" data-claire-element-id="442817">DADM</h5><p id="r-442806" data-claire-element-id="442806">Viennent ensuite les architectures DADM, aussi appelées les architectures distribuées. Avec elles, chaque processeur possède sa propre mémoire, sans aucune mémoire partagée entre les processeurs. Tous les processeurs sont reliés entre eux via un réseau local, qui leur sert à échanger des données ou des ordres un peu particuliers.</p><figure id="r-442808" data-claire-element-id="442809"><img id="r-442807" data-claire-element-id="442807" src="medias/uploads.siteduzero.com_files_363001_364000_363701.png" alt="Image utilisateur"/></figure><p id="r-442810" data-claire-element-id="442810">Les processeurs peuvent ainsi accéder à la mémoire d'un autre processeur via le réseau local : il leur suffit de faire une demande au processeur qui détient la donnée. Cette demande va traverser le réseau local et arriver à son destinataire : la donnée demandée est alors envoyée via le réseau local et est copiée dans la mémoire locale de l’ordinateur demandeur. Il va de soit que les communications entre les différents processeurs peuvent prendre un temps relativement long, et que ceux-ci sont loin d'être négligeables. Avec une organisation de ce genre, la qualité et les performances du réseau reliant les ordinateurs est très important pour les performances.</p><h6 id="r-encore-des-caches" data-claire-element-id="442816">Encore des caches</h6><p id="r-442811" data-claire-element-id="442811">Bien sûr, rien n’empêche de mettre des mémoires caches entre la mémoire d'un processeur et celui-ci.</p><figure id="r-442813" data-claire-element-id="442814"><img id="r-442812" data-claire-element-id="442812" src="medias/uploads.siteduzero.com_files_363001_364000_363977.png" alt="Image utilisateur"/></figure><p id="r-442815" data-claire-element-id="442815">Cette fois, placer des mémoires caches ne pose strictement aucun problème : on n'a pas besoin de garantir la cohérence des caches avec ce genre de système.</p><h5 id="r-sadm" data-claire-element-id="442826">SADM</h5><p id="r-442818" data-claire-element-id="442818">Enfin, il reste une dernière classe d'architectures : les architectures SADM. Avec elles, les processeurs possèdent une mémoire locale, qui leur est réservée et dans laquelle ils peuvent faire ce que bon leur semble. Mais ils peuvent aussi accéder aux autres mémoires : cela leur prend un peu plus de temps.</p><p id="r-442819" data-claire-element-id="442819">Voici un exemple d'architecture NUMA possible.</p><figure id="r-442821" data-claire-element-id="442822"><img id="r-442820" data-claire-element-id="442820" src="medias/uploads.siteduzero.com_files_357001_358000_357763.png" alt="Image utilisateur"/></figure><p id="r-442823" data-claire-element-id="442823">Avec cette méthode, chaque processeur voit toute les mémoires virtuellement rassemblées dans une seule grosse mémoire unique. Accéder à une portion de cette mémoire unique correspondant à sa mémoire locale est rapide, mais accéder à une portion de la grosse mémoire unique correspondant à la mémoire d'un autre processeur est redoutablement plus lent. Bien gérer les temps d'accès aux différentes mémoires est donc un plus bien agréable.</p><h6 id="r-des-caches-encore-et-toujours" data-claire-element-id="442825">Des caches, encore et toujours !</h6><p id="r-442824" data-claire-element-id="442824">On peut encore une fois utiliser des mémoires caches sur ce genre de machines, mais on retombe sur un problème : la cohérence des caches n'est pas assurée et on doit se débrouiller pour qu'elle le soit, comme pour les architectures SASM.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
<span class="arrow"></span>
<span class="next">Les différents types de parallélisme</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">
<span class="next">Les limites théoriques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Leslimitesthoriques"></a><h2>Les limites théoriques</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
<span class="arrow"></span>
<span class="next">Partage de la mémoire</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
<span class="next">Loi d&#039;Amdhal</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-442829" data-claire-element-id="442829">On a vu dans le chapitre précédent que l'on pouvait donc utiliser plusieurs processeurs pour traiter des taches ou des données.</p><div id="r-442831" data-claire-element-id="442831" data-claire-semantic="question"><p id="r-442830" data-claire-element-id="442830">Mais existe-t-il des limites à l'utilisation de plusieurs processeurs ?</p></div><p id="r-442832" data-claire-element-id="442832">Dans ce chapitre, on va voir que suivant la manière utilisée pour exploiter plusieurs processeurs, les résultats changent du tout au tout. On y verra que dans certains cas, ajouter des processeurs ne sert pas à grand chose, voire à rien. Dans d'autres, il n'y a pas vraiment de limites théoriques aux gains de performances que l'on peut obtenir en ajoutant des processeurs.</p>
</div><a name="Loid039Amdhal"></a><h2>Loi d&#039;Amdhal</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">
<span class="arrow"></span>
<span class="next">Les limites théoriques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
<span class="next">Loi de Gustafson</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-loi-d-amdhal" data-claire-element-id="443014">Loi d'Amdhal</h4><p id="r-442833" data-claire-element-id="442833">Imaginez que vous ayez codé un programme, spécialement conçu pour exploiter plusieurs processeurs. Votre programme est conçu de façon à répartir ses calculs sur autant de processeurs que possible.</p><p id="r-442834" data-claire-element-id="442834">Seul problème, vous ne savez pas trop quel sera le gain que vous obtiendrez en utilisant plusieurs processeurs avec un programme pareil, et vous voudriez savoir quel est le gain théorique maximal que vous pourriez obtenir. Et bien pour connaître ce gain maximal, vous pouvez utiliser la <strong>loi d'Amdhal</strong>. Cette loi est basée sur une approche simple : on prend un programme et on regarde ce qui se passe en fonction du nombre de processeurs.</p><h5 id="r-hypotheses-de-base" data-claire-element-id="442869">Hypothèses de base</h5><p id="r-442835" data-claire-element-id="442835">Pour démontrer cette loi, on va supposer :</p><ul id="r-442844" data-claire-element-id="442844"><li id="r-442837" data-claire-element-id="442837"><p id="r-442836" data-claire-element-id="442836">que notre ordinateur contient un nombre N de processeurs,</p></li><li id="r-442839" data-claire-element-id="442839"><p id="r-442838" data-claire-element-id="442838">qu'une portion plus ou moins importante de notre programme peut utiliser plusieurs processeurs ,</p></li><li id="r-442841" data-claire-element-id="442841"><p id="r-442840" data-claire-element-id="442840">cette utilisation est la plus efficace possible quel que soit le nombre de processeurs,</p></li><li id="r-442843" data-claire-element-id="442843"><p id="r-442842" data-claire-element-id="442842">on se moque des coûts induits par la gestion du code s’exécutant sur plusieurs processeurs, le système d’exploitation, la façon dont est conçu le matériel, et on passe tous ces détails sous le tapis.</p></li></ul><p id="r-442845" data-claire-element-id="442845">Expliquons un peu plus en détail la deuxième hypothèse. Une portion de notre programme peut exploiter plusieurs CPU : on l'appelle le <strong>code parallèle</strong>. Mettre plusieurs CPU n'accélérera que cette portion du programme et pas le reste. Intuitivement, on se doute que plus la quantité de ce code parallèle est importante, plus notre programme profitera de la présence de plusieurs processeurs. On va appeler le reste du programme, incapable d'exploiter plusieurs CPU, le <strong>code série</strong>. Là encore, on devine facilement que plus le programme contient de code série, moins notre programme gagnera en performances si l'on augmente le nombre de processeurs.</p><p id="r-442846" data-claire-element-id="442846">Pour calculer le gain maximal que l'on peut obtenir sur N processeurs, on suppose que ce code parallèle peut tout aussi bien exploiter la puissance d'un seul processeur, que de <strong>2</strong>, <strong>20</strong>, voir <strong>10 000 000</strong> processeurs. Bref, ce code est quasiment parfait et on s'interdit les situations du style : on observe un gain énorme avec <strong>2 </strong>ou <strong>4</strong> processeurs, mais pas au-delà.</p><p id="r-442847" data-claire-element-id="442847">De plus, ce programme est exécuté sur la même quantité de données : on ne rajoute pas de données en même temps qu'on ajoute des processeurs, et ces données ont toujours la même taille, histoire de comparer ce qui est comparable.</p><h6 id="r-un-seul-processeur" data-claire-element-id="442856">Un seul processeur</h6><p id="r-442848" data-claire-element-id="442848">Pour commencer, il va nous falloir une référence pour pouvoir comparer les gains dû à l'ajout de processeurs. La meilleure référence, c'est le cas où l'on utilise un seul processeur.</p><p id="r-442849" data-claire-element-id="442849">Le temps mis par notre programme pour s’exécuter sur un seul processeur, qu'on notera T, est donc la somme :</p><ul id="r-442854" data-claire-element-id="442854"><li id="r-442851" data-claire-element-id="442851"><p id="r-442850" data-claire-element-id="442850">du temps d’exécution du code série, noté Ts,</p></li><li id="r-442853" data-claire-element-id="442853"><p id="r-442852" data-claire-element-id="442852">et du temps d’exécution du code parallèle sur un seul processeur, noté Tp.</p></li></ul><p id="r-442855" data-claire-element-id="442855">T = Ts + Tp</p><h6 id="r-plusieurs-processeurs" data-claire-element-id="442868">Plusieurs processeurs</h6><p id="r-442857" data-claire-element-id="442857">Maintenant, on va prendre plusieurs processeurs et comparer.</p><div id="r-442859" data-claire-element-id="442859" data-claire-semantic="question"><p id="r-442858" data-claire-element-id="442858">Mais combien va-t-on prendre de processeurs ?</p></div><p id="r-442860" data-claire-element-id="442860">N processeurs, pas un de plus, pas un de moins ! :p</p><p id="r-442861" data-claire-element-id="442861">Voyons ce qui se passe : le code parallèle va faire exécuter des calculs simultanément sur ces N processeurs, au lieu de les exécuter les uns après les autres. Le temps passé à exécuter ce code parallèle va diminuer.</p><div id="r-442863" data-claire-element-id="442863" data-claire-semantic="question"><p id="r-442862" data-claire-element-id="442862">Mais que vaut le temps d’exécution du code parallèle sur N processeurs ?</p></div><p id="r-442864" data-claire-element-id="442864">Pour l'évaluer, on n'a pas vraiment le choix : on doit utiliser une des hypothèses de départ qui dit que notre code va répartir au mieux ses instructions sur les N processeurs. Le temps d’exécution du code parallèle sera alors divisé par le nombre de processeurs N. Bien sûr, le code série n'est pas affecté par le nombre de processeurs : celui-ci est exécuté sur un seul processeur et met donc toujours le même temps à s’exécuter : Ts ne change pas !</p><p id="r-442865" data-claire-element-id="442865">En notant T(N) le temps mis par notre code à s’exécuter sur N processeurs, on obtient donc :</p><p id="r-442866" data-claire-element-id="442866">T(N) = Ts + \frac {Tp} {N}</p><p id="r-442867" data-claire-element-id="442867">On rappelle que Tp est le temps mis pour exécuter le code parallèle sur un processeur, pas N.</p><h5 id="r-gain" data-claire-element-id="442880">Gain</h5><p id="r-442870" data-claire-element-id="442870">Mais que faire pour comparer le temps d’exécution du programme sur la machine avec un processeur et celui mesuré sur une machine avec plusieurs processeurs ? Pour cela, on va devoir calculer un truc que l'on appelle le <strong>gain</strong>.</p><p id="r-442871" data-claire-element-id="442871">Ce gain se calcule en inversant la fraction vue au-dessus, ce qui nous donne :</p><p id="r-442872" data-claire-element-id="442872">Gain = \frac {T} {T(N)}</p><p id="r-442873" data-claire-element-id="442873">En clair, il suffit de diviser le temps d’exécution obtenu avec un seul processeur par le temps d’exécution sur N processeurs.</p><p id="r-442874" data-claire-element-id="442874">Ce gain a une signification simple : si le gain vaut X, alors l'application est X fois plus rapide que si on l’exécutait sur un seul processeur. On verra ainsi si le programme s’exécute 2, 3, voir 50 fois rapidement. Bien évidemment, plus ce gain est élevé, plus notre programme aura gagné en performance comparé à la version avec un seul processeur.</p><h6 id="r-exemple-121" data-claire-element-id="442879">Exemple</h6><p id="r-442875" data-claire-element-id="442875">Si le temps de calcul avec, mettons 5 processeurs (donc N = 5) est la moitié du temps de calcul obtenu avec un seul processeur, cela veut dire que</p><p id="r-442876" data-claire-element-id="442876">\frac {T(5)} {T} = \frac {1} {2}</p><p id="r-442877" data-claire-element-id="442877">Dans ce cas, on peut aussi dire que le programme va deux fois plus vite. Vu que le temps de calcul avec 5 processeurs est égal à la moitié du temps de calcul avec un seul processeur, on peut aussi dire que le temps de calcul avec un processeur est en effet 2 fois plus long que le temps de calcul avec 5. Cela se vérifie en calculant simplement notre gain :</p><p id="r-442878" data-claire-element-id="442878">\frac {T} {T(5)} = 2</p><h5 id="r-derivation-de-la-loi-d-amdhal" data-claire-element-id="442902">Dérivation de la Loi d'Amdhal</h5><p id="r-442881" data-claire-element-id="442881">Partons de notre fraction</p><p id="r-442882" data-claire-element-id="442882">\frac {T(N)} {T}</p><p id="r-442883" data-claire-element-id="442883">Remplaçons T(N) par sa valeur explicitée plus haut à savoir</p><p id="r-442884" data-claire-element-id="442884">T(N) = Ts + \frac {Tp} {N}.</p><p id="r-442885" data-claire-element-id="442885">On trouve donc le rapport entre T et T(N) qui vaut</p><p id="r-442886" data-claire-element-id="442886">\frac {T(N)} {T} = \frac {Ts + \frac {Tp} {N}} {T}</p><p id="r-442887" data-claire-element-id="442887">Cette équation peut se &quot;simplifier&quot; et donne alors l'équation suivante</p><p id="r-442888" data-claire-element-id="442888">\frac {T(N)} {T} = \frac {Ts} {T} + \frac {\frac {Tp} {N}} {T}</p><p id="r-442889" data-claire-element-id="442889">Et là, il faut remarquer deux choses très simples :</p><ul id="r-442894" data-claire-element-id="442894"><li id="r-442891" data-claire-element-id="442891"><p id="r-442890" data-claire-element-id="442890">\frac {Ts} {T} n'est rien d'autre qu'un pourcentage : c'est le pourcentage de temps mis à exécuter le code série.</p></li><li id="r-442893" data-claire-element-id="442893"><p id="r-442892" data-claire-element-id="442892">De même, \frac {Tp} {T} est le pourcentage de temps mis à exécuter le code parallèle.</p></li></ul><p id="r-442895" data-claire-element-id="442895">En posant S = \frac {Ts} {T} et P = \frac {Tp} {T}, on peut alors simplifier notre equation en</p><p id="r-442896" data-claire-element-id="442896">\frac {T(N)} {T} = S + \frac {P} {N}</p><p id="r-442897" data-claire-element-id="442897">On peut alors calculer le gain en inversant notre fraction et on trouve</p><p id="r-442898" data-claire-element-id="442898">\frac {T} {T(N)} = \frac {1} {S + \frac {P} {N}}</p><p id="r-442899" data-claire-element-id="442899">On peut aussi remarquer que S = 1 - P et ainsi obtenir</p><p id="r-442900" data-claire-element-id="442900">Gain = \frac {1} {1 - P + \frac {P} {N}}</p><p id="r-442901" data-claire-element-id="442901">Cette équation s'appelle la <strong>loi d'Amdhal</strong> et nous donne la gain maximal théorique que l'on peut obtenir avec un code passant P pourcents de son temps d’exécution dans un code parallèle, avec N processeurs.</p><h5 id="r-ce-que-nous-dit-la-loi-d-amdhal" data-claire-element-id="443013">Ce que nous dit la loi d'Amdhal</h5><p id="r-442903" data-claire-element-id="442903">Cette loi nous donne donc une estimation du gain en temps d’exécution d'une application exécutée sur plusieurs processeurs. Mais que peut-on en déduire d'utile ? Peut-on trouver des moyens de gagner en performance efficacement grâce à cette loi ? Oui, et c'est ce qu'on va voir.</p><h6 id="r-parallelisons-mieux" data-claire-element-id="442908">Parallélisons mieux !</h6><p id="r-442904" data-claire-element-id="442904">Tout d'abord remarquons une chose : quand on fait tendre le nombre de processeurs vers l'infini, le gain atteint un maximum qui vaut<br/>Gain = \frac {1} {1 - P}</p><p id="r-442905" data-claire-element-id="442905">Qu'on peut simplifier en <br/>Gain = \frac {1} {S}</p><p id="r-442906" data-claire-element-id="442906">Cela signifie une chose très simple : quand N tend vers l'infini, le code parallélisé est exécuté en un temps qui tend vers 0. Seul reste le code série qui ne peut pas être accéléré par plusieurs processeurs. Le temps d’exécution de ce code restant le même, le temps d’exécution du programme ne peut pas descendre en-dessous du temps d’exécution du code série. C'est donc la première limite que nous impose la loi d'Amdhal.</p><p id="r-442907" data-claire-element-id="442907">La solution la plus simple est donc de paralléliser le plus possible le code de notre programme, histoire de faire diminuer S et augmenter P le plus possible. C'est cela qui est le plus recherché à l'heure actuelle. Seul problème : tous les programmes ne se laissent pas paralléliser aussi facilement. Certains programmes se parallélisent facilement parce que les calculs qu'ils ont à faire sont assez indépendants. Mais d'autres n'ont pas cette particularité et sont très très difficilement parallélisables, voire pas du tout.</p><h6 id="r-nombre-de-processeurs" data-claire-element-id="442979">Nombre de processeurs</h6><p id="r-442909" data-claire-element-id="442909">L'autre solution est d'augmenter le nombre de processeurs, afin de réduire le plus possible le terme \frac {P} {N} . Mais cette solution a une efficacité assez limitée : il faut que la part de code parallélisable soit suffisante pour que cela ait un impact suffisant.</p><p id="r-442910" data-claire-element-id="442910">Imaginons un exemple simple : 20% du temps d’exécution de notre programme (quand il est exécuté sur un seul processeur) est passé à exécuter du code parallèle.</p><p id="r-442911" data-claire-element-id="442911">Avec N processeurs, le gain calculable par la loi d'Amdhal nous donne un gain maximal de <br/>Gain = \frac {1} {1 - 0.2 + \frac {0.2} {N}}</p><p id="r-442912" data-claire-element-id="442912">Si on calcule le gain en fonction du nombre de processeurs, on obtient alors la tableau suivant.</p><table id="r-442975" data-claire-element-id="442975"><thead id="r-442918" data-claire-element-id="442918"><tr id="r-442917" data-claire-element-id="442917"><th id="r-442914" data-claire-element-id="442914"><p id="r-442913" data-claire-element-id="442913">Nombre de processeurs</p></th><th id="r-442916" data-claire-element-id="442916"><p id="r-442915" data-claire-element-id="442915">Gain maximal</p></th></tr></thead><tbody id="r-442974" data-claire-element-id="442974"><tr id="r-442923" data-claire-element-id="442923"><td id="r-442920" data-claire-element-id="442920"><p id="r-442919" data-claire-element-id="442919">2</p></td><td id="r-442922" data-claire-element-id="442922"><p id="r-442921" data-claire-element-id="442921">11.11%</p></td></tr><tr id="r-442928" data-claire-element-id="442928"><td id="r-442925" data-claire-element-id="442925"><p id="r-442924" data-claire-element-id="442924">3</p></td><td id="r-442927" data-claire-element-id="442927"><p id="r-442926" data-claire-element-id="442926">15.38%</p></td></tr><tr id="r-442933" data-claire-element-id="442933"><td id="r-442930" data-claire-element-id="442930"><p id="r-442929" data-claire-element-id="442929">4</p></td><td id="r-442932" data-claire-element-id="442932"><p id="r-442931" data-claire-element-id="442931">17.64%</p></td></tr><tr id="r-442938" data-claire-element-id="442938"><td id="r-442935" data-claire-element-id="442935"><p id="r-442934" data-claire-element-id="442934">5</p></td><td id="r-442937" data-claire-element-id="442937"><p id="r-442936" data-claire-element-id="442936">19.04%</p></td></tr><tr id="r-442943" data-claire-element-id="442943"><td id="r-442940" data-claire-element-id="442940"><p id="r-442939" data-claire-element-id="442939">6</p></td><td id="r-442942" data-claire-element-id="442942"><p id="r-442941" data-claire-element-id="442941">20%</p></td></tr><tr id="r-442948" data-claire-element-id="442948"><td id="r-442945" data-claire-element-id="442945"><p id="r-442944" data-claire-element-id="442944">7</p></td><td id="r-442947" data-claire-element-id="442947"><p id="r-442946" data-claire-element-id="442946">20.6%</p></td></tr><tr id="r-442953" data-claire-element-id="442953"><td id="r-442950" data-claire-element-id="442950"><p id="r-442949" data-claire-element-id="442949">8</p></td><td id="r-442952" data-claire-element-id="442952"><p id="r-442951" data-claire-element-id="442951">21.21%</p></td></tr><tr id="r-442958" data-claire-element-id="442958"><td id="r-442955" data-claire-element-id="442955"><p id="r-442954" data-claire-element-id="442954">...</p></td><td id="r-442957" data-claire-element-id="442957"><p id="r-442956" data-claire-element-id="442956">...</p></td></tr><tr id="r-442963" data-claire-element-id="442963"><td id="r-442960" data-claire-element-id="442960"><p id="r-442959" data-claire-element-id="442959">16</p></td><td id="r-442962" data-claire-element-id="442962"><p id="r-442961" data-claire-element-id="442961">23%</p></td></tr><tr id="r-442968" data-claire-element-id="442968"><td id="r-442965" data-claire-element-id="442965"><p id="r-442964" data-claire-element-id="442964">...</p></td><td id="r-442967" data-claire-element-id="442967"><p id="r-442966" data-claire-element-id="442966">...</p></td></tr><tr id="r-442973" data-claire-element-id="442973"><td id="r-442970" data-claire-element-id="442970"><p id="r-442969" data-claire-element-id="442969">\infty</p></td><td id="r-442972" data-claire-element-id="442972"><p id="r-442971" data-claire-element-id="442971">25%</p></td></tr></tbody></table><p id="r-442976" data-claire-element-id="442976">On voit bien qu'au delà de 5 ou 6 processeurs, augmenter le nombre de processeurs ne sert pas vraiment à grand chose : doubler leur nombre revient souvent à augmenter les performances d'un misérable pourcent.</p><p id="r-442977" data-claire-element-id="442977">Cette solution devient donc très limitée quand on augmente le nombre de processeurs. En clair : au-delà d'un certain nombre de processeurs, ça ne marche plus !</p><p id="r-442978" data-claire-element-id="442978">Au-delà de 10 processeurs avec un code passant 20% de son temps à exécuter du code parallèle, le gain est négligeable. Pour prendre un autre exemple, au-delà de 8 processeurs, un code passant 50% de son temps à exécuter du code parallèle ne sera pas vraiment exécuté plus vite. 8 processeurs, cela correspond à une quadri-core incorporant la technologie SMT comme on en trouve chez intel. Remarquons que les programmes qui passent la moitié de leur temps à exécuter du code parallèle sont rares chez les programmes grand-public.</p><h6 id="r-code-serie" data-claire-element-id="443010">Code série</h6><p id="r-442980" data-claire-element-id="442980">Une autre solution, plus simple est encore de diminuer le temps d’exécution du code série en optimisant le code, sans forcément chercher à le paralléliser. C'est la seule solution viable pour un programme contenant peu de code parallélisable. Pour donner un exemple, on va faire un petit tableau contenant le gain obtenu avec un programme avec un P de 10% en fonction du nombre de processeurs.</p><table id="r-443008" data-claire-element-id="443008"><thead id="r-442986" data-claire-element-id="442986"><tr id="r-442985" data-claire-element-id="442985"><th id="r-442982" data-claire-element-id="442982"><p id="r-442981" data-claire-element-id="442981">Nombre de processeurs</p></th><th id="r-442984" data-claire-element-id="442984"><p id="r-442983" data-claire-element-id="442983">Gain maximal</p></th></tr></thead><tbody id="r-443007" data-claire-element-id="443007"><tr id="r-442991" data-claire-element-id="442991"><td id="r-442988" data-claire-element-id="442988"><p id="r-442987" data-claire-element-id="442987">2</p></td><td id="r-442990" data-claire-element-id="442990"><p id="r-442989" data-claire-element-id="442989">5%</p></td></tr><tr id="r-442996" data-claire-element-id="442996"><td id="r-442993" data-claire-element-id="442993"><p id="r-442992" data-claire-element-id="442992">4</p></td><td id="r-442995" data-claire-element-id="442995"><p id="r-442994" data-claire-element-id="442994">8%</p></td></tr><tr id="r-443001" data-claire-element-id="443001"><td id="r-442998" data-claire-element-id="442998"><p id="r-442997" data-claire-element-id="442997">8</p></td><td id="r-443000" data-claire-element-id="443000"><p id="r-442999" data-claire-element-id="442999">10%</p></td></tr><tr id="r-443006" data-claire-element-id="443006"><td id="r-443003" data-claire-element-id="443003"><p id="r-443002" data-claire-element-id="443002">\infty</p></td><td id="r-443005" data-claire-element-id="443005"><p id="r-443004" data-claire-element-id="443004">11.11%</p></td></tr></tbody></table><p id="r-443009" data-claire-element-id="443009">Si notre programme ne peut pas voir P augmenter, au-delà de 4-8 processeurs, il vaudra mieux diminuer le temps d’exécution de celui-ci plutôt que de chercher à rajouter beaucoup de processeurs inutilement.</p><h6 id="r-dans-la-realite-1" data-claire-element-id="443012">Dans la réalité</h6><p id="r-443011" data-claire-element-id="443011">Enfin, une dernière remarque : la loi d'Amdhal est optimiste : elle a été démontrée en postulant que le code parallèle peut être réparti sur autant de processeurs qu'on veut et peut profiter d'un grand nombre de processeurs. Dans la réalité, rares sont les programmes de ce genre : certains programmes peuvent à la rigueur exploiter efficacement 2, 4 , voir 8 processeurs mais pas au-delà. Elle ne tient pas compte des nombreux problèmes techniques, aussi bien logiciels que matériels qui limitent les performances des programmes conçus pour exploiter plusieurs processeurs. La loi d'Amdhal donne une borne théorique maximale au gain apporté par la présence de plusieurs processeurs, mais le gain réel sera quasiment toujours inférieur au gain calculé par la loi d'Amdhal.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">
<span class="arrow"></span>
<span class="next">Les limites théoriques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
<span class="next">Loi de Gustafson</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="LoideGustafson"></a><h2>Loi de Gustafson</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
<span class="arrow"></span>
<span class="next">Loi d&#039;Amdhal</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">
<span class="next">Hyperthreading et compagnie</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-loi-de-gustafson" data-claire-element-id="443051">Loi de Gustafson</h4><h5 id="r-parallelisme-de-donnees-1" data-claire-element-id="443023">Parallélisme de données</h5><p id="r-443015" data-claire-element-id="443015">La loi d'Amdhal est basée sur une approche simple : on prend un programme qui fait ce qu'il y a à faire, et on regarde ce qui se passe en augmentant le nombre de processeurs.</p><div id="r-443017" data-claire-element-id="443017" data-claire-semantic="question"><p id="r-443016" data-claire-element-id="443016">Mais n'y aurait-il pas une autre façon de faire, qui permettrait d'utiliser plusieurs processeurs différemment ?</p></div><p id="r-443018" data-claire-element-id="443018">Et bien si !</p><p id="r-443019" data-claire-element-id="443019">Avec la loi d'Amdhal, on a pris un programme qui travaille toujours sur des données de même taille et on n'a pas augmenté le nombre de données à traiter avec le passage de 1 à N processeurs.</p><p id="r-443020" data-claire-element-id="443020">Au lieu de toujours utiliser la même quantité de données, pourquoi ne pas simplement utiliser les processeurs supplémentaires pour travailler sur un nombre de données plus grand ? Prenons l'exemple d'une application de traitement d'image : au lieu de travailler sur une image de 2048*2048, pourquoi ne pas utiliser nos processeurs pour travailler sur plusieurs images de même taille ou sur une image de taille quadruple, histoire de rentabiliser ?</p><p id="r-443021" data-claire-element-id="443021">Cela s'appelle le <strong>parallélisme de données</strong>, qui consiste à exécuter le même programme sur des données différentes et indépendantes. Cela permet donc de traiter N données sur N processeurs en même temps. Pour résumer : tous les processeurs exécutent un seul et unique programme ou une suite d'instructions, mais chacun de ces processeurs va travailler sur une donnée différente.</p><p id="r-443022" data-claire-element-id="443022">Et là encore, on peut trouver une loi similaire à la loi d'Amdhal, mais beaucoup moins restrictive : la <strong>loi de Gustafson</strong> !</p><h5 id="r-hypotheses-de-base-1" data-claire-element-id="443032">Hypothèses de base</h5><p id="r-443024" data-claire-element-id="443024">Prenons un programme s’exécutant sur un seul processeur. Celui-ci prend un temps Ts à exécuter son code série et un temps Tp pour exécuter son code parallèle. Ce code parallèle s’exécute sur une donnée (image, fichier son, ou autre). Ce code parallèle sera exécuté simultanément sur plusieurs données : ainsi, pour N données, On pourra prendre N processeurs et exécuter sur chacun d'eux le code paralléle sur une des N données.</p><p id="r-443025" data-claire-element-id="443025">En prenant 1 ou N processeurs, la partie série restera la même et sera executée sur un seul processeur durant un temps Ts.</p><h6 id="r-une-seule-donnee" data-claire-element-id="443027">Une seule donnée</h6><p id="r-443026" data-claire-element-id="443026">Avec une seule donnée, le temps d’exécution T est égal à Ts + Tp, avec Ts le temps d’exécution du code série et Tp celui du code paralléle.</p><h6 id="r-plusieurs-donnees" data-claire-element-id="443031">Plusieurs données</h6><p id="r-443028" data-claire-element-id="443028">Par contre, durant le temps Tp, on pourra demander à chacun des N processeurs de traiter une donnée en un temps Tp. Ce qui fait qu'en un temps T, on peut demander à notre processeur d’exécuter un programme sur N données.</p><p id="r-443029" data-claire-element-id="443029">Dans ce cas, le temps T(N) vaut donc Ts + Tp.</p><p id="r-443030" data-claire-element-id="443030">Si ce calcul fait sur ces N données avait été fait sur un seul processeur, on aurait dû calculer ces Ndonnées unes par une, ce qui aurait pris un temps égal à <br/>T = Ts + ( N imes Tp )</p><h5 id="r-gain-1" data-claire-element-id="443042">Gain</h5><p id="r-443033" data-claire-element-id="443033">En calcule donc le gain \frac {T} {T(N)}</p><p id="r-443034" data-claire-element-id="443034">\frac {T} {T(N)} = \frac {Ts + ( N imes Tp )} {Ts + Tp}</p><p id="r-443035" data-claire-element-id="443035">Cette équation se factorise en</p><p id="r-443036" data-claire-element-id="443036">\frac {T} {T(N)} = \frac {Ts} {Ts + Tp} + \frac { N imes ( Tp )} {Ts + Tp}</p><p id="r-443037" data-claire-element-id="443037">A ce stade, une petite remarque s'impose : \frac {Ts} {Ts + Tp} est égal au pourcentage de temps S passé à exécuter le code série et \frac {Tp} {Ts + Tp} celui du code paralléle (sur N processeurs), qu'on note P.</p><p id="r-443038" data-claire-element-id="443038">On trouve la loi de Gustafson qui nous donne le gain en fonction du nombre de processeurs :</p><p id="r-443039" data-claire-element-id="443039">Gain = S + ( N imes P )</p><p id="r-443040" data-claire-element-id="443040">En remarquant que S = 1 - P, on trouve alors la <strong>loi de Gustafson</strong></p><p id="r-443041" data-claire-element-id="443041">Gain = 1 - P + ( N imes P )</p><h5 id="r-que-nous-apprend-gustafson" data-claire-element-id="443050">Que nous apprend Gustafson ?</h5><p id="r-443043" data-claire-element-id="443043">La loi de Gusatfson répond à un besoin certain : comment faire pour exploiter au mieux le parallélisme lorsque l'on souhaite travailler sur une grande quantité de données. Cela correspond au parallélisme de données : exécuter simultanément un même programme sur des données indépendantes.</p><p id="r-443044" data-claire-element-id="443044">Plus le nombre de données traitées en parallèles est grand, plus ce genre de parallélisme est efficace. En effet, sur un seul processeur, si on augmente le nombre N de données, et que ces N données doivent être traitées par la partie parallélisée du programme, cela prendrait un temps égal à Ts + ( Tp imes N )</p><p id="r-443045" data-claire-element-id="443045">Mais surtout, il n'y a pas de limites théoriques à N : on peut mettre autant de données que l'on veut, avec N processeurs, celles-ci sont toutes traitées par un processeur simultanément et le temps mis pour traiter N données sur Nprocesseurs sera identique au temps mit pour traiter une donnée sur un seul processeur. Aucune limite n'existe concernant la quantité de données traitables simultanément, et donc au gain que l'on peut obtenir.</p><p id="r-443046" data-claire-element-id="443046">Bien sûr, il faut se rappeler que la loi de Gustafson s'applique sur une durée déterminée : elle ne rend pas les calculs plus rapides : si une donnée N met un temps T à être traitée, alors on ne gagne rien en terme de temps de calcul.</p><p id="r-443047" data-claire-element-id="443047">Voici donc quelques conclusions que l'on peut tirer avec ce que l'on vient de voir. Paralléliser un programme qui exécute de nombreux calculs en parallèle sur le même ensemble de données est voué à montrer &quot;rapidement ses limites&quot;. Ce parallélisme est en effet soumi à la loi d'Amdhal. Par contre, le parallélisme de données, consistant à effectuer un même programme/sous-programme sur un ensemble de données différentes donne de très bons résultats.</p><p id="r-443048" data-claire-element-id="443048">Il existe néanmoins d'autres formules ou lois permettant de déduire plus ou moins précisément l'efficacité théorique de la parallélisation d'un programme quelconque. On peut citer par exemple la métrique de Karp–Flatt.</p><p id="r-443049" data-claire-element-id="443049">Mais dans la réalité, aucune de ces formules n'est utilisable directement : de nombreux autres paramètres interviennent, qui dépendent de l'architecture des processeurs utilisés, du langage de programmation utilisé et de la manière dont a été programmé le programme en question. N'oublions pas que ces formules sont théoriques, et ne servent qu'a donner des indictions qualitatives.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
<span class="arrow"></span>
<span class="next">Loi d&#039;Amdhal</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">
<span class="next">Hyperthreading et compagnie</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Hyperthreadingetcompagnie"></a><h2>Hyperthreading et compagnie</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
<span class="arrow"></span>
<span class="next">Loi de Gustafson</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
<span class="next">Du parallèlisme avec un seul processeur</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-443055" data-claire-element-id="443055">Dans ce qui précède, on a vu des ordinateurs possédant plusieurs processeurs. Vous devez donc fatalement penser qu'il faut obligatoirement plusieurs processeurs pour éxecuter plusieurs programmes en parallèle, mais sachez que c'est faux ! Il est parfois possible pour un processeur seul d’exécuter plusieurs programmes en même temps. Pour cela, il faut utiliser des processeurs spéciaux, qui utilisent des ruses de sioux.</p>
</div><a name="Duparalllismeavecunseulprocesseur"></a><h2>Du parallèlisme avec un seul processeur</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">
<span class="arrow"></span>
<span class="next">Hyperthreading et compagnie</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
<span class="next">Et dans le processeur ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-du-parallelisme-avec-un-seul-processeur" data-claire-element-id="443106">Du parallèlisme avec un seul processeur</h4><p id="r-443056" data-claire-element-id="443056">A l'intérieur d'un processeur, on trouve un petit circuit qui est capable d'effectuer des calculs. Celui-ci s'appelle <strong>l'unité de calcul</strong>. Ce circuit n'est pas le seul présent dans notre processeur, loin de là, mais c'est celui qui va nous intéresser dans ce chapitre.</p><h5 id="r-le-pipeline-fait-des-bulles" data-claire-element-id="443066">Le pipeline fait des bulles !</h5><p id="r-443057" data-claire-element-id="443057">Il arrive souvent que l'unité de calcul d'un processeur ne fasse rien. Mine de rien, un paquet de phénomènes bizarres aux noms à coucher dehors (dépendances de données, accès à la mémoire, mauvaise prédiction de branchement, etc) peuvent aboutir à ce genre de choses. Par exemple, dans certains cas, le fait qu'une instruction doive attendre le résultat d'une autre peut rendre l'unité de calcul inutilisée durant un moment.</p><figure id="r-443059" data-claire-element-id="443060"><img id="r-443058" data-claire-element-id="443058" src="medias/uploads.siteduzero.com_files_364001_365000_364352.png" alt="Image utilisateur"/></figure><p id="r-443061" data-claire-element-id="443061">De nombreuses techniques ont étés inventées pour faire en sorte que notre unité de calcul soit utilisée au plus possible : utilisation de caches non-bloquants, <em>forwarding, Out Of Order</em>, exécution superscalaire, et autre techniques aux noms qui font peur aux enfants sont de la partie. Mais il arrive toujours que notre unité de calcul soit inutilisée durant quelques cycles. Par quelques cycles, on veut dire que quand on accède à la mémoire RAM, on peut faire patienter l'unité de calcul durant une bonne centaine de cycles d'horloge. Autant dire que niveau efficacité, on peut mieux faire !</p><p id="r-443062" data-claire-element-id="443062">Un jour, quelqu'un a eu une idée fabuleuse : puisqu'on arrive pas à trouver de quoi donner du travail à notre unité de calcul avec un seul programme, pourquoi ne pas essayer avec plusieurs programmes ? Au lieu de faire en sorte de ne réserver notre unité de calcul qu'aux instructions d'un seul programme, on pourrait prendre des instructions en provenance de plusieurs programmes et les répartir sur notre unité de calcul suivant les besoins : si un programme n'utilise pas notre ALU, elle sera disponible pour un autre.</p><figure id="r-443064" data-claire-element-id="443065"><img id="r-443063" data-claire-element-id="443063" src="medias/uploads.siteduzero.com_files_364001_365000_364355.png" alt="Image utilisateur"/></figure><h5 id="r-types-de-super-threading-materiel-explicite" data-claire-element-id="443100">Types de <em>super-threading </em>matériel explicite</h5><p id="r-443067" data-claire-element-id="443067">Il existe différentes manières pour remplir notre unité de calcul avec des instructions en provenance de plusieurs programmes. Suivant la méthode utilisée, on peut se retrouver avec des gains plus ou moins intéressants et une unité de calcul plus ou moins utilisée. Dans ce qui va suivre, on va détailler ces différentes façons.</p><h6 id="r-fine-grained-multithreading" data-claire-element-id="443084"><em>Fine Grained Multithreading</em></h6><p id="r-443068" data-claire-element-id="443068">La première méthode consiste à <em>switcher </em>entre les programmes : on exécute une instruction d'un programme, puis on passe au second programme, et ainsi de suite. C'est le processeur qui se charge de passer automatiquement d'un programme à un autre, sans temps d'attente.</p><figure id="r-443070" data-claire-element-id="443071"><img id="r-443069" data-claire-element-id="443069" src="medias/uploads.siteduzero.com_files_364001_365000_364356.png" alt="Image utilisateur"/></figure><p id="r-443072" data-claire-element-id="443072">Cette technique a de nombreux avantages : on est certain que lorsque une instruction s’exécute, elle n'a pas à attendre le résultat de l'instruction exécutée juste avant elle. Ces deux instructions n'appartenant pas au même programme, il est impossible qu'une instruction doive manipuler le résultat d'une autre. Cela permet de grandement simplifier le processeur vu que l'on a pas besoin de gérer le cas où une instruction doit attendre le résultat d'une autre : ça fait des circuits en moins, et l'unité de calcul est mieux utilisée.</p><p id="r-443073" data-claire-element-id="443073">Mais ces processeurs ont un défaut : pour obtenir de bonnes performances, on est obligé d'avoir beaucoup de programmes en cours d’exécution. Sans cela, diverses raisons techniques vont faire que l'unité de calcul sera inutilisée durant pas mal de temps.</p><figure id="r-443075" data-claire-element-id="443076"><img id="r-443074" data-claire-element-id="443074" src="medias/uploads.siteduzero.com_files_364001_365000_364867.png" alt="Image utilisateur"/></figure><aside id="r-443078" data-claire-element-id="443078" data-claire-semantic="information"><p id="r-443077" data-claire-element-id="443077">Pour ceux qui ont lu mon tutoriel fonctionnement d'un ordinateur depuis zéro, je peux aller plus loin dans les précisions : il faut autant des programmes en cours d’exécution que d'étages dans notre pipeline</p></aside><p id="r-443079" data-claire-element-id="443079">Pour limiter la casse, certains processeurs peuvent décider de lancer plusieurs instructions d'un même programme à la suite sur l'unité de calcul, au lieu de changer de programme constamment. Évidemment, cela nécessite des conditions particulières. Généralement, chaque instruction va contenir quelques bits qui permettront de dire au processeur : tu peux lancer 1, 2, 3; etc : instructions à la suite sans problème, il n'y aura pas de dépendances entre ces instructions. Ainsi, le processeur peut décider si besoin d'alimenter l'unité de calcul avec ces instruction du même programme. Cette technique s'appelle la <em><strong>dependance lookahead technique</strong></em>.</p><figure id="r-443081" data-claire-element-id="443082"><img id="r-443080" data-claire-element-id="443080" src="medias/uploads.siteduzero.com_files_364001_365000_364408.png" alt="Image utilisateur"/></figure><p id="r-443083" data-claire-element-id="443083">La technique du <em>Fine Grained Multithreading </em>pose tout de même quelques problèmes : on n'a rarement suffisamment de programmes pour alimenter l'unité de calcul convenablement, et les techniques de <em>dependance lookahead </em> n'arrivent pas forcément à limiter la casse. Aussi cette technique de parallélisme matériel a assez peu d'efficacité en dehors de quelques cas particuliers.</p><h6 id="r-coarse-grained-multitrheading" data-claire-element-id="443092"><em>Coarse Grained Multitrheading</em></h6><p id="r-443085" data-claire-element-id="443085">Autre forme de parallélisme matériel : le <em><strong>Coarse Grained Multitrheading</strong></em>. Avec celui-ci, le processeur décide toujours de changer de programme, mais il fait nettement moins souvent. Le changement de programme se fait lors de certains évènements particuliers qui prennent du temps.</p><figure id="r-443087" data-claire-element-id="443088"><img id="r-443086" data-claire-element-id="443086" src="medias/uploads.siteduzero.com_files_364001_365000_364357.png" alt="Image utilisateur"/></figure><p id="r-443089" data-claire-element-id="443089">L'idée est d’exécuter les instructions d'un programme normalement, jusqu'à ce qu'un évènement rendant l'unité de calcul inutle durant un certain temps arrive : accès à la mémoire (cache miss), branchement mal prédit, etc. Au lieu de passer tout ce temps à ne rien faire, autant changer de programme pour remplir les vides avec des instructions d'un autre programme.</p><p id="r-443090" data-claire-element-id="443090">Suivant le processeur, les évènements faisant changer de programme ne sont pas forcément les mêmes. Sur certains processeurs, on change de programme lorsque certaines instructions sont exécutées : accès à la mémoire, branchements, etc. Sur certains processeurs, on utilise une instruction de changement de programme, fournie par le jeu d'instruction du processeur : elle seule peut faire changer le programme exécuté. Et enfin, nettement plus intéressant : certains processeur décident tout seuls quand changer de programme ! Généralement, ces processeurs changent de programme à éxecuter lorsqu'on doit accéder à la mémoire (lors d'un <em>cache </em>miss). Il faut dire que l'accès à la mémoire est quelque chose de très lent, aussi changer de programme et éxecuter des instructions pour recouvrir l'accès à la mémoire est une bonne chose.</p><p id="r-443091" data-claire-element-id="443091">Il faut tout de même remarquer une chose : pour être efficace, ce genre de processeurs a besoin de pouvoir accéder à la mémoire cache pendant qu'il attend des données en provenance de la mémoire. En termes techniques, on dit que celui-ci a besoin de caches non-bloquants. Et oui, il n'est pas rare que les instructions du programme fraichement démarré doivent accéder à la mémoire cache pour faire leurs calculs : autant dire que si le cache n'est pas utilisable parce qu'un autre programme est interrompu pour accéder à la mémoire, ça la fout mal !</p><h6 id="r-simultaneous-multithreading" data-claire-element-id="443099"><em>Simultaneous Multithreading</em></h6><p id="r-443093" data-claire-element-id="443093">Les techniques vues au-dessus imposent pas mal de contraintes et surtout peuvent laisser l'unité de calcul inutilisée durant assez longtemps. Pour éviter ce genre de choses, il existe une dernière technique qui permet de mieux exploiter l'unité de calcul dans pas mal de situations. Il s'agit du <em><strong>Simultaneous Multi-Threading</strong></em> ou <strong>SMT</strong>.</p><p id="r-443094" data-claire-element-id="443094">Cette technique consiste à faire pareil que ses prédécesseurs, à une différence prêt : aucun programme n'a la priorité sur l'autre. Pas besoin de changer de programme tout les cycles ou lors d'un évènement particulier : les deux programmes s’exécutent en même temps, et chaque programme va utiliser l'unité de calcul dès que les autres la laissent libre.</p><figure id="r-443096" data-claire-element-id="443097"><img id="r-443095" data-claire-element-id="443095" src="medias/uploads.siteduzero.com_files_364001_365000_364598.png" alt="Image utilisateur"/></figure><p id="r-443098" data-claire-element-id="443098">Ce fameux <em>Simultaneous Multi-Threading</em> porte un autre nom : Intel lui a en effet donné le nom d'<strong><em>Hyperthreading</em></strong>, pour de sombres raisons <em>marketing</em>. Après tout, <em>Hyperthreading </em>est quand même un nom un peu plus vendeur que <em>Simultaneous Multi-Threading</em>. :-° Le premier processeur Intel qui a intégré cette technologie était le processeur Intel Pentium 4. Il faut dire que ce processeur possédait des caractéristiques techniques (un pipeline long, trop long) qui faisaient qu'il utilisait assez peu son unité de calcul et qu'il avait énormément de vides à remplir. L'<em>Hyperthreading </em>était limité à deux programmes/<em>threads </em>logiciels différents et ne pouvait faire plus.</p><h5 id="r-processeurs-superscalaires-2" data-claire-element-id="443105">Processeurs superscalaires</h5><p id="r-443101" data-claire-element-id="443101">Nos ordinateurs modernes implémentent souvent non pas une, mais plusieurs unités de calcul. C'est ainsi, au lieu d'utiliser une seule unité de calcul, ceux-ci peuvent répartir les instructions d'un programme sur ces différentes unités de calcul histoire d'aller plus vite. Ainsi, nos processeurs peuvent contenir entre 2, 4, 8, voire encore plus unités de calcul, sans problèmes (ou presque). Et il faut savoir que les techniques vues au-dessus se marient très bien avec la présence de plusieurs unités de calcul. On a beaucoup plus d'opportunités pour éxecuter des instructions de programmes différents !</p><figure id="r-443103" data-claire-element-id="443104"><img id="r-443102" data-claire-element-id="443102" src="medias/uploads.siteduzero.com_files_364001_365000_364603.png" alt="Image utilisateur"/></figure>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">
<span class="arrow"></span>
<span class="next">Hyperthreading et compagnie</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
<span class="next">Et dans le processeur ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Etdansleprocesseur"></a><h2>Et dans le processeur ?</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
<span class="arrow"></span>
<span class="next">Du parallèlisme avec un seul processeur</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">
<span class="next">Processeurs multicoeurs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-et-dans-le-processeur" data-claire-element-id="443183">Et dans le processeur ?</h4><p id="r-443107" data-claire-element-id="443107">Reste à savoir comment notre processeur est capable de réussir ce genre de prouesses. Et on va le voir, ce n'est pas si difficile que ça ! Mais pour commencer, quelques rappels sont de rigueur !</p><h5 id="r-cycle-fetch-execution" data-claire-element-id="443160">Cycle <em>Fetch </em>/ Exécution</h5><p id="r-443108" data-claire-element-id="443108">Nos processeurs sont censés éxecuter des instructions machines. Pour ce faire, ceux-ci comportent donc une unité de calcul, qui est capable d’exécuter notre instruction. Mais notre unité de calcul n'est pas le seul circuit nécessaire pour éxecuter notre instruction : notre instruction n'arrive pas de nulle part ! Chaque instruction est représentée dans notre ordinateur sous la forme d'une suite de bits, stockée dans la mémoire RAM de notre ordinateur à un endroit bien précis. Celles-ci sont placées les unes à la suite des autres dans l'ordre où elles doivent être exécutées.</p><p id="r-443109" data-claire-element-id="443109">Par exemple :</p><table id="r-443152" data-claire-element-id="443152"><thead id="r-443115" data-claire-element-id="443115"><tr id="r-443114" data-claire-element-id="443114"><th id="r-443111" data-claire-element-id="443111"><p id="r-443110" data-claire-element-id="443110">Adresse</p></th><th id="r-443113" data-claire-element-id="443113"><p id="r-443112" data-claire-element-id="443112">Instruction</p></th></tr></thead><tbody id="r-443151" data-claire-element-id="443151"><tr id="r-443120" data-claire-element-id="443120"><td id="r-443117" data-claire-element-id="443117"><p id="r-443116" data-claire-element-id="443116">0</p></td><td id="r-443119" data-claire-element-id="443119"><p id="r-443118" data-claire-element-id="443118">Charger le contenu de l'adresse 0F05</p></td></tr><tr id="r-443125" data-claire-element-id="443125"><td id="r-443122" data-claire-element-id="443122"><p id="r-443121" data-claire-element-id="443121">1</p></td><td id="r-443124" data-claire-element-id="443124"><p id="r-443123" data-claire-element-id="443123">Charger le contenu de l'adresse 0555</p></td></tr><tr id="r-443130" data-claire-element-id="443130"><td id="r-443127" data-claire-element-id="443127"><p id="r-443126" data-claire-element-id="443126">2</p></td><td id="r-443129" data-claire-element-id="443129"><p id="r-443128" data-claire-element-id="443128">Additionner ces deux nombres</p></td></tr><tr id="r-443135" data-claire-element-id="443135"><td id="r-443132" data-claire-element-id="443132"><p id="r-443131" data-claire-element-id="443131">3</p></td><td id="r-443134" data-claire-element-id="443134"><p id="r-443133" data-claire-element-id="443133">Charger le contenu de l'adresse 0555</p></td></tr><tr id="r-443140" data-claire-element-id="443140"><td id="r-443137" data-claire-element-id="443137"><p id="r-443136" data-claire-element-id="443136">4</p></td><td id="r-443139" data-claire-element-id="443139"><p id="r-443138" data-claire-element-id="443138">Faire en XOR avec le résultat antérieur</p></td></tr><tr id="r-443145" data-claire-element-id="443145"><td id="r-443142" data-claire-element-id="443142"><p id="r-443141" data-claire-element-id="443141">...</p></td><td id="r-443144" data-claire-element-id="443144"><p id="r-443143" data-claire-element-id="443143">...</p></td></tr><tr id="r-443150" data-claire-element-id="443150"><td id="r-443147" data-claire-element-id="443147"><p id="r-443146" data-claire-element-id="443146">5464</p></td><td id="r-443149" data-claire-element-id="443149"><p id="r-443148" data-claire-element-id="443148">Instruction d'arrêt</p></td></tr></tbody></table><p id="r-443153" data-claire-element-id="443153">Pour se souvenir d'où il en est, le processeur contient une petite mémoire qui contient la position (l'adresse mémoire) de notre instruction dans la RAM de l'ordinateur. Vu que nos instructions sont placées les unes après les autres en mémoire, ce registre permet de localiser la prochaine instruction à éxecuter : il suffit d'augmenter le contenu de ce registre de façon à le faire pointer sur l'instruction suivante à chaque exécution d'une instruction. Ce fameux registre s'appelle le <em><strong>Program Counter</strong></em>. Il existe quand même un moyen pour modifier l'ordre d’exécution des instructions : certaines instructions permettent de modifier le contenu du <em>Program Counter</em>. Ces instructions permettent de &quot;sauter&quot; directement à une instruction voulue dans le programme et poursuivre l'exécution à partir de celle-ci. Ce sont les instructions de <strong>branchements</strong>.</p><p id="r-443154" data-claire-element-id="443154">Cette instruction, il va falloir la charger depuis la mémoire, et l'amener de la mémoire à notre unité de calcul. C'est le rôle d'un ou de plusieurs circuits présents dans notre processeur, qui contient notamment notre fameux <em>Program Counter</em>. Ce chargement est toutefois un peu plus compliqué : un processeur ne fonctionne pas aussi simplement, et notre circuit chargé de récupérer une instruction depuis la mémoire est un peu plus complexe : il est découpé en plusieurs circuits qui effectuent des taches diverses comme &quot; décoder l'instruction &quot; ou &quot; renommer des registres &quot;. Cela consiste à interpreter la suite de bits qui représente l'instruction et en déduire comment configurer l’unité de calcul et les autres circuits du processeur. Mais cela ne nous intéresse pas ici.</p><p id="r-443155" data-claire-element-id="443155">On peut donc considérer que notre processeur est découpé en deux grands circuits : une unité de calcul (aussi appelée ALU) qui se charge de faire les calculs, et un circuit qui se charge de récupérer l'instruction depuis la mémoire.</p><figure id="r-443157" data-claire-element-id="443158"><img id="r-443156" data-claire-element-id="443156" src="medias/uploads.siteduzero.com_files_403001_404000_403721.png" alt="Image utilisateur"/></figure><p id="r-443159" data-claire-element-id="443159">Notre processeur contient aussi de petites mémoires ultra-rapides qui servent à stocker temporairement des données : on les appelle des <strong>registres</strong>. Pour information, le <em>Program Counter</em> est un de ces registres. Généralement, une instruction qui doit manipuler une donnée contenue dans un registre devra indiquer qu'elle veut manipuler ce registre dans sa suite de bits. Un programme pourra manipuler le contenu des registres, pour plus de simplicité et de performances. Pour identifier chacun des registres, on donne à ceux-ci des noms, qui ne sont rien d'autres que des numéros.</p><h5 id="r-niveau-circuits" data-claire-element-id="443182">Niveau circuits</h5><p id="r-443161" data-claire-element-id="443161">Autrefois, on fusionnait les circuits chargés du chargement de notre instruction (et de tas d'autres taches annexes), et l'unité de calcul. Mais aujourd’hui, ce n'est pas le cas : ces deux circuits sont séparés. Cela a un avantage certain : l'unité de chargement (aussi appelée l'unité de <em>Fetch</em>) peut ainsi éxecuter une instruction sur l'unité de calcul et commencer à charger l'instruction suivante.</p><h6 id="r-multiple-fetch" data-claire-element-id="443168"><em>Multiple Fetch</em></h6><p id="r-443162" data-claire-element-id="443162">Les processeurs permettant d’exécuter plusieurs programmes utilisent cette technique à fond. En effet, ceux-ci doivent remplir les vides de notre unité de calcul avec des instructions en provenance de plusieurs programmes. En clair, ceux-ci doivent charger à l'avance plusieurs instructions : au minimum une par programme ! Il restera ensuite à les répartir sur notre unité de calcul suivant les besoins.</p><p id="r-443163" data-claire-element-id="443163">Pour cela, on va devoir trouver un moyen pour charger plusieurs instructions, en provenance de programmes différents. Mine de rien, la solution est assez simple : il suffit d'utiliser plusieurs unités de chargement, chacune avec son <em>Program Counter</em>. Voilà qui est simple.</p><figure id="r-443165" data-claire-element-id="443166"><img id="r-443164" data-claire-element-id="443164" src="medias/uploads.siteduzero.com_files_403001_404000_403845.png" alt="Image utilisateur"/></figure><p id="r-443167" data-claire-element-id="443167">Toutefois, cela n'est pas la seule solution : on peut très bien rassembler ces plusieurs unités de chargement en une seule grosse unité, avec plusieurs <em>Program Counter</em> (toujours un par programme). Mais cela est un détail. ^^ Quoiqu'il en soit, beaucoup de circuits sont dupliqués dans un processeur utilisant le SMT.</p><h6 id="r-decoupled-architectures" data-claire-element-id="443174"><em>Decoupled architectures</em></h6><p id="r-443169" data-claire-element-id="443169">Il faut bien stocker ces instructions préchargées quelque part. Et pour cela, on va intercaler une petite mémoire entre l'unité de chargement/décodage et l'unité de calcul. Cette petite mémoire s'appelle l'<em><strong>instruction buffer</strong></em>. Nos instructions seront donc mises en attente dans cette mémoire tampon, avant d'être réparties sur notre ALU au besoin. Pour cela, un circuit spécialisé, le <em><strong>dispatcher</strong></em> se chargera de répartir les différentes instructions sur les unités de calcul.</p><p id="r-443170" data-claire-element-id="443170">Ainsi, on peut répartir nos instructions en provenance de divers programmes sur notre ALU. Il suffit de précharger les instructions en provenance de nos programmes dans cet <em> Instruction Buffer</em>, et laisser le <em>dispatcher </em>faire son travail. Sur les processeurs utilisant le SMT, on trouve non pas un, mais plusieurs <em> Instruction Buffers</em>. Il y en a un par programme.</p><figure id="r-443172" data-claire-element-id="443173"><img id="r-443171" data-claire-element-id="443171" src="medias/uploads.siteduzero.com_files_403001_404000_403847.png" alt="Image utilisateur"/></figure><h6 id="r-jeu-de-registres" data-claire-element-id="443181">Jeu de registres</h6><p id="r-443175" data-claire-element-id="443175">Il nous reste enfin un léger petit problème à régler : chaque programme manipule des registres et il semble difficile de partager un registre pour le laisser stocker plusieurs données en provenance de plusieurs programmes. Il faudra donc dupliquer les registres histoire que chaque programme puisse avoir son ensemble de registres rien qu'à lui. Cela évite que nos processeurs se marchent sur les pieds.</p><p id="r-443176" data-claire-element-id="443176">Il faudra aussi faire quelques modifications : les registres étant identifiés par des noms, dupliquer des registres ne suffira pas. Si deux programmes utilisent le même nom de registre, ils utiliseront le même registre. Pour éviter les ennuis, on va donc décider de placer chaque registre ayant un nom en plusieurs exemplaires : plusieurs registres auront le même nom, et chacun d'entre eux se verra attribuer à un programme différent. Dans les faits, cela est fait en dupliquant les registres, et aussi en ajoutant des circuits qui permettront de savoir à quel programme est attribué chaque registre.</p><p id="r-443177" data-claire-element-id="443177">Et voilà, on obtient enfin notre processeur, qui utilise du SMT.</p><figure id="r-443179" data-claire-element-id="443180"><img id="r-443178" data-claire-element-id="443178" src="medias/uploads.siteduzero.com_files_403001_404000_403718.png" alt="Image utilisateur"/></figure>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
<span class="arrow"></span>
<span class="next">Du parallèlisme avec un seul processeur</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">
<span class="next">Processeurs multicoeurs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Processeursmulticoeurs"></a><h2>Processeurs multicoeurs</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
<span class="arrow"></span>
<span class="next">Et dans le processeur ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
<span class="next">Processeurs multicœurs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-443185" data-claire-element-id="443185">Dans les chapitres précédents, on a vu que le parallélisme de tache pouvait s’accommoder d'un seul processeur. Néanmoins, ces techniques ne sont pas des plus efficaces, et rien ne vaut l'utilisation de plusieurs processeurs pour réellement tirer partie du parallélisme de taches.</p><p id="r-443186" data-claire-element-id="443186">Les premières tentatives pour implémenter le parallélisme au niveau matériel ont étés des plus simples : il suffisait simplement de mettre plusieurs ordinateurs ensemble et de les relier via un réseau local. Puis, on a ensuite utilisé une autre méthode : placer plusieurs processeurs dans la même machine. Ainsi, certains ordinateurs contenaient une carté mère sur laquelle on pouvait mettre plusieurs processeurs, généralement 2 ou 4. Mais utiliser plusieurs processeurs n'est pas la seule solution pour éxecuter plusieurs programmes en parallèles.</p>
</div><a name="Processeursmulticurs"></a><h2>Processeurs multicœurs</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">
<span class="arrow"></span>
<span class="next">Processeurs multicoeurs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
<span class="next">Le partage des caches</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-processeurs-multicoeurs" data-claire-element-id="443237">Processeurs multicœurs</h4><p id="r-443187" data-claire-element-id="443187">Vous avez tous surement entendus parler des processeurs multicœurs, et si ça se trouve, vous avez la chance d'en posséder un. Ces processeurs permettent aussi d'éxecuter plusieurs programmes à la fois.</p><h5 id="r-le-multicoeurs-c-est-quoi" data-claire-element-id="443206">Le multicœurs, c'est quoi ?</h5><p id="r-443188" data-claire-element-id="443188">Avant toute chose, il pourrait paraitre bizarre qu'un seul processeur puisse éxecuter plusieurs programmes simultanément. Logiquement, un processeur n'est censé éxecuter qu'un programme à la fois (sauf si celui-ci utilise le <em>Simultaneous Multithreading</em>). On vous a surement dit que ce processeur contenait plusieurs cœurs, capables d’exécuter des programmes en parallèle, mais cela ne vous a pas vraiment éclairé ? Et bien je vous le donne en mille : en fait, un processeur multicœurs n'est rien d'autre qu'une puce de silicium sur laquelle on a placé plusieurs processeurs ! Et oui, ce n'est rien de plus que cela. Chacun de ces processeurs intégré dans ce circuit s’appellera un <strong>coeur</strong>.</p><p id="r-443189" data-claire-element-id="443189">Suivant le nombre de cœurs présents dans notre processeur, celui-ci sera appelé un processeur dual-core (deux cœurs), quad-core (4 cœurs), octo-core (8 cœurs), etc.</p><p id="r-443190" data-claire-element-id="443190">On pourrait croire que placer deux processeurs sur la même puce est un peu du gâchis : pourquoi ne pas simplement utiliser deux processeurs séparés, chacun dans son coin. Mais sachez que ce genre d'intuitions est toujours trompeuse ! Intégrer deux cœurs sur une même puce a au contraire de nombreux avantages en terme de performances. Ces processeurs multicœurs sont apparus ces dernières années. Et ce n'est pas un hasard : pour créer ce genre de processeurs, il a fallu faire de nombreux progrès dans les technologies de fabrications de nos processeurs, et attendre que le besoin s'en fasse sentir.</p><h6 id="r-multicoeurs-asymetrique" data-claire-element-id="443201">Multicœurs asymétrique</h6><p id="r-443191" data-claire-element-id="443191">Dans la grosse majorité des cas, les cœurs d'un processeur multicœurs sont tous identiques. Mais ce n'est certainement pas une obligation : on peut très bien mettre plusieurs processeurs assez différents sur la même puce, sans que cela ne pose problème. On peut très bien utiliser un cœur principal avec des cœurs plus spécialisés autour, par exemple. Cela s'appelle du <strong>multicœurs asymétrique</strong>. Ce terme est à opposer au <strong>multicœurs symétrique</strong>, dans lequel on place des processeurs identiques sur la même puce de silicium.</p><p id="r-443192" data-claire-element-id="443192">Le processeur CELL est un des exemples les plus récent de processeur multicœurs asymétrique. Vous connaissez surement ce fameux processeur, et vous en possédez peut-être un chez vous. Évidemment, il ne faut pas chercher dans l'unité centrale de votre PC de bureau, non. Il faut chercher dans votre console de jeux : et oui, votre PS3 contient un processeur CELL.</p><p id="r-443193" data-claire-element-id="443193">Pour simplifier, notre processeur CELL peut être vu comme intégrant un cœur principal POWER PC version 5, qu'on retrouvait autrefois dans les Mac, et environ 8 processeurs auxiliaires.</p><figure id="r-443195" data-claire-element-id="443196"><img id="r-443194" data-claire-element-id="443194" src="medias/uploads.siteduzero.com_files_364001_365000_364379.png" alt="Image utilisateur"/></figure><p id="r-443197" data-claire-element-id="443197">Sur le schéma du dessus, le processeur principal est appelé le PPE, et les processeur auxiliaires sont les SPE. Comme on le voit sur ce schéma, l'organisation des caches et des différentes mémoires intégrées au processeur CELL est assez déroutante. Notre processeur principal intégré un cache L1, ainsi qu'un cache L2, tout deux spécialement dédié à celui-ci. On remarque que nos processeurs, PPE et SPE, sont reliés via la mémoire et aux différents bus de notre ordinateur pas un bus intercalé, qui relier tous les processeurs, la mémoire, et les autres bus entre eux.</p><p id="r-443198" data-claire-element-id="443198">Nos SPE sont reliés à une mémoire locale, le <em><strong>Local Store</strong></em>, qui communique avec le processeur principal via un bus spécial. Pour information, cette mémoire fait dans les 256 kibioctets : c'est très peu, mais suffisant pour ce que ces processeurs doivent faire. Chaque SPE peut ainsi aller charger ou enregistrer des données dans cette mémoire locale. Par contre, il leur est interdit d'aller manipuler la mémoire centrale de l'ordinateur directement. Pour cela, ces processeurs doivent passer par un intermédiaire : des <strong>contrôleurs DMA</strong>. Ceux-ci sont capables de faire transiter des blocs de mémoire entre la mémoire centrale et le <em>local store</em> du SPE. C'est un peu l'exact opposé de ce qui se passe pour le processeur principal : celui-ci peut aller trifouiller la mémoire RAM de l'ordinateur sans problème, et sans devoir passer par un intermédiaire.</p><p id="r-443199" data-claire-element-id="443199">Pour rentrer dans les détails scabreux, il faut savoir que les SPE possèdent des instructions permettant de commander leur contrôleur DMA et que c'est le seul moyen qu'ils ont pour récupérer des informations depuis la mémoire. Et c'est au programmeur de gérer tout ça !</p><p id="r-443200" data-claire-element-id="443200">C'est le processeur principal qui va envoyer aux SPE les programmes qu'ils doivent éxecuter. On peut considérer que notre processeur principal va déléguer des calculs à effectuer aux SPE. Pour cela, notre processeur principal va simplement écrire dans le local store du SPE, et va lui envoyer une demande lui ordonnant de commencer l’exécution du programme qu'il vient d'écrire.</p><h6 id="r-cluster-multithreding" data-claire-element-id="443205">Cluster Multithreding</h6><p id="r-443202" data-claire-element-id="443202">Plus haut, j'avais dit qu'un cœur n'était rien d'autre qu'un processeur. Ce n'est pas tout à fait faux, mais ce n'est pas tout à fait vrai non plus : certaines architectures outrepassent légèrement cette règle. Sur les processeurs précédents, on avait réellement plusieurs cœurs séparés, chacun avec se propres circuits rien qu'à lui. Mais sur certains processeurs multicœurs, ce n'est pas vraiment le cas : certains circuits sont communs et partagés entre plusieurs cœurs. Cette technique consistant à ne pas dupliquer certains circuits et à en partager certains s'appelle le <em><strong>cluster multithreading</strong></em>.</p><p id="r-443203" data-claire-element-id="443203">Cette technique est notamment utilisée sur les processeurs FX-8150 et FX-8120 d'AMD, et quelques autres processeurs de la même gamme. Ceux-ci sont basés sur l'architecture Bulldozer. Avec ces processeurs, tous les cœurs se partagent l'unité de calcul sur les nombres flottants (les nombres à virgule).</p><p id="r-443204" data-claire-element-id="443204">Ce partage des circuits a une utilité : cela permet d'éviter de dupliquer trop de circuits. Il est en effet évident qu'un seul circuit partagé entre tous les cœurs prendra moins de place et utilisera moins de composants élèctroniques que plusieurs circuits (un par cœur). Le seul problèmes, c'est que ce partage peut parfois se faire avec des pertes de performances, sur certains processeurs. Mais c'est un détail : en choisissant bien les circuits à partager, cela peut être assez indolore.</p><h5 id="r-communication-inter-processeurs" data-claire-element-id="443236">Communication inter-processeurs</h5><div id="r-443208" data-claire-element-id="443208" data-claire-semantic="question"><p id="r-443207" data-claire-element-id="443207">Bon, c'est bien beau d'avoir plusieurs processeurs ou plusieurs coeurs, mais comment on fait pour les utiliser ?</p></div><p id="r-443209" data-claire-element-id="443209">Et oui, mine de rien, il faut bien trouver comment assigner un programme à un processeur ou un cœur en particulier ! Je vous dit tout de suite, cela est géré en partie par le système d'exploitation de votre ordinateur, même si le matériel a son mot à dire. Pour expliquer comment notre système d'exploitation se débrouille pour lancer un programme sur un autre processeur ou un autre coeur, il va falloir expliquer une notion : celle d'interruption.</p><h6 id="r-interruption-1" data-claire-element-id="443227">Interruption</h6><div id="r-443211" data-claire-element-id="443211" data-claire-semantic="question"><p id="r-443210" data-claire-element-id="443210">Holà, c'est quoi une interruption ?</p></div><p id="r-443212" data-claire-element-id="443212">C'est une fonctionnalité de notre processeur qui va permettre d’arrêter temporairement l’exécution d'un programme pour en exécuter un autre. Ces interruptions ont pour but d'interrompre l’exécution d'un programme afin de réagir à un événement extérieur (matériel, erreur fatale d’exécution d'un programme, demande faite par l'OS ou un programme...) et de la traiter en temps voulu, avant de rendre la main au programme interrompu. Notre interruption va donc devoir effectuer un petit traitement (ici, lancer un programme sur un processeur). Ce petit traitement est fait par un petit programme au auquel on a donné un nom technique : <strong>routine d'interruption</strong>.</p><p id="r-443213" data-claire-element-id="443213">Lorsqu'un processeur doit exécuter une interruption, celui-ci :</p><ul id="r-443220" data-claire-element-id="443220"><li id="r-443215" data-claire-element-id="443215"><p id="r-443214" data-claire-element-id="443214">arrête l'exécution du programme en cours d'exécution,</p></li><li id="r-443217" data-claire-element-id="443217"><p id="r-443216" data-claire-element-id="443216">exécute la routine d'interruption,</p></li><li id="r-443219" data-claire-element-id="443219"><p id="r-443218" data-claire-element-id="443218">reprend l'exécution du programme suspendu là ou il en était.</p></li></ul><figure id="r-443222" data-claire-element-id="443223"><img id="r-443221" data-claire-element-id="443221" src="../../user.oc-static.com/files/324001_325000/324697.png" alt="Image utilisateur"/></figure><p id="r-443224" data-claire-element-id="443224">Notre OS et nos pilotes fournissent toutes les routines d'interruptions de bases pour que notre matériel fonctionne : la majorité des programmes systèmes sont des interruptions. Voici comment nos programmes applicatifs peuvent exploiter le matériel sans se fatiguer : en exécutant l'interruption qui va bien. Vous voulez écrire une donnée sur le disque dur, un programme système exécutant des interruptions est fourni par votre OS.</p><p id="r-443225" data-claire-element-id="443225">Dans notre cas, la gestion des programmes à exécuter en parallèle se fera à grand coup d'<strong>interruptions inter-processeurs</strong>. Ces interruptions inter-processeurs ne sont rien d'autre que des interruptions déclenchées par un processeur ou un cœur et envoyées vers un autre. Pour démarrer un programme sur un autre processeur, il suffira d'envoyer une interruption vers cet autre processeur afin de le réveiller et faire en sorte que notre interruption initialise celui-ci correctement pour lancer le programme voulu. Et pour cela, il suffit juste d'écrire une routine qui soit programmée pour. C'est donc le système d'exploitation qui fournira cette routine.</p><p id="r-443226" data-claire-element-id="443226">Dans notre cas, ces interruptions seront déclenchées par le programme parallélisé : celui-ci déclenchera une interruption pour démarrer un <em>thread</em>, au besoin.</p><h6 id="r-l-exemple-du-x86" data-claire-element-id="443235">L'exemple du x86</h6><p id="r-443228" data-claire-element-id="443228">Généralement, notre processeur ou notre carte mère incorpore un circuit qui s'occupe de gérer les interruptions déclenchées par le matériel et qu'on appelle le <strong>contrôleur d'interruptions</strong>. Pour générer des interruptions inter-processeur, ce circuit doit être adapté pour pouvoir rediriger des interruptions déclenchées par un processeur vers un autre. Par exemple, nos anciens PC incorporaient sur leur carté mère un contrôleur d'interruption crée par Intel qui se nomme le 8259A. Mais celui-ci ne gèrait pas les interruptions inter-processeurs. Pour gérer cette situation, les carte mères multiprocesseurs devaient incorporer un contrôleur spécial en complément. Celui-ci a été remplacé par plusieurs autres contrôleurs, des contrôleurs APIC, plus évolués et capables de gérer les architectures multiprocesseur et multicœurs.</p><p id="r-443229" data-claire-element-id="443229">Pour simplifier, chaque processeur possède un <em><strong>local APIC</strong></em>, qui s'occupe de gérer les interruptions en provenance ou arrivant vers ce processeur. On trouve aussi un <em><strong>IO-APIC</strong></em>, qui s'occupe de gérer les interruptions en provenance des périphériques et de les redistribuer vers les <em>local APIC</em>. Ce IO-<em>APIC </em>s'occupe aussi de gérer les interruptions inter-processeurs en faisant passer les interruptions d'un <em>local APIC</em> vers un autre.</p><figure id="r-443231" data-claire-element-id="443232"><img id="r-443230" data-claire-element-id="443230" src="medias/uploads.siteduzero.com_files_364001_365000_364407.png" alt="Image utilisateur"/></figure><p id="r-443233" data-claire-element-id="443233">Tous les <em>local APIC</em> et l'IO-<em>APIC </em>sont reliés ensembles par un bus <em>APIC </em>spécialisé, par lequel ils vont pouvoir communiquer et s'échanger des demandes d'interruptions.</p><p id="r-443234" data-claire-element-id="443234">On peut préciser quel est le processeur de destination en configurant certains registres du IO-APIC, afin que celui-ci redirige la demande d'interruption d'un <em>local APIC</em> vers celui sélectionné. En gros, cela se fait avec l'aide d'un registre de 64 bits nommé l'<em><strong>Interrupt Command Register</strong></em>. Pour simplifier le mécanisme complet, chaque processeur se voit attribuer un Id au démarrage qui permet de l'identifier (en fait, cet Id est attribué au <em>local APIC</em> de chaque processeur). Certains bits de ce registre permettent de préciser quel est le type de transfert : doit-on envoyer l'interruption au processeur émetteur, à tous les autres processeurs, à un processeur particulier. Dans le dernier cas, certains bits du registre permettent de préciser l'Id du processeur qui va devoir recevoir l'interruption. A charge de l'APIC de faire ce qu'il faut en fonction du contenu de ce registre.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">
<span class="arrow"></span>
<span class="next">Processeurs multicoeurs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
<span class="next">Le partage des caches</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lepartagedescaches"></a><h2>Le partage des caches</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
<span class="arrow"></span>
<span class="next">Processeurs multicœurs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">
<span class="next">Cohérence mémoire</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-le-partage-des-caches" data-claire-element-id="443269">Le partage des caches</h4><p id="r-443238" data-claire-element-id="443238">C'est bien beau de mettre plusieurs processeurs sur une même puce, mais il ne faut pas oublier ce qui arrive à LA pièce maitresse de tout processeur actuel : sa mémoire cache ! Et oui, encore une fois, nous allons parler de ce bon vieux cache. Parce que mine de rien, l'organisation des différents caches d'un processeur multicœurs est légèrement plus complexe que prévu.</p><h5 id="r-caches-dedies-versus-caches-partages" data-claire-element-id="443255">Caches dédiés versus caches partagés</h5><p id="r-443239" data-claire-element-id="443239">Tout d'abord, dans le cas le plus simple, chaque cœur possède sa propre mémoire cache rien que pour lui.</p><figure id="r-443241" data-claire-element-id="443242"><img id="r-443240" data-claire-element-id="443240" src="medias/uploads.siteduzero.com_files_364001_365000_364138.png" alt="Image utilisateur"/></figure><p id="r-443243" data-claire-element-id="443243">Sur d'autres microprocesseurs multicœurs, la mémoire cache est partagée entre les cœurs, qui peuvent tous les deux accéder à une seule et unique mémoire cache.</p><figure id="r-443245" data-claire-element-id="443246"><img id="r-443244" data-claire-element-id="443244" src="medias/uploads.siteduzero.com_files_364001_365000_364132.png" alt="Image utilisateur"/></figure><p id="r-443247" data-claire-element-id="443247">Ces deux méthodes ont des inconvénients et des avantages. Mais avant toute chose, il faut savoir que la quantité de mémoire cache que l'on peut placer sur une surface donnée est limitée : on ne peut pas mettre autant de cache que l'on veut dans un processeur. Et le cache prend une très grande place dans notre processeur : environ la moitié, voire 60% des circuits de notre processeur servent à intégrer la mémoire cache ! <br/> Si vous ne me croyez pas, voici un exemple avec un processeur dual-core Inrel core 2 duo. J'ai entouré le cache en rouge.</p><figure id="r-443249" data-claire-element-id="443250"><img id="r-443248" data-claire-element-id="443248" src="medias/uploads.siteduzero.com_files_364001_365000_364143.png" alt="Image utilisateur"/></figure><p id="r-443251" data-claire-element-id="443251">Autant vous dire que le cache est une ressource précieuse. Et cela pose un problème pour les architectures qui utilisent des caches séparés pour chaque cœur : ceux-ci seront individuellement assez petits. Alors qu'est-ce qui est le mieux : pleins de caches plus petits, ou un unique cache aussi gros que la somme de tous les caches séparés ? Le principal défaut des architectures à cache dédiés vient de là. Si on exécute un programme prévu pour n'utiliser qu'un seul cœur, celui-ci n'aura accès qu'à un seul cache : celui dédié au cœur sur lequel il va s’exécuter. Avec un cache partagé, il aura accès à une mémoire cache unique beaucoup plus grosse : on a moins de <em>cache miss</em>, et donc des performances qui s'envolent (vraiment !).</p><p id="r-443252" data-claire-element-id="443252">Et cela peut aussi se généraliser avec plusieurs programmes : si un programme a besoin de beaucoup de cache et l'autre très peu, on peut alors partager le cache de façon à ce que chacun aie sa juste part, le programme gourmand pouvant utiliser autant de mémoire cache qu'il le peut. Avec des caches dédiés, le cache utilisable par ce programme aurait été plus petit, et le programme aurait pu manquer de mémoire cache.</p><p id="r-443253" data-claire-element-id="443253">Qui plus est, si une donnée est utilisée par deux cœurs et est présente dans le cache, les processeurs à caches partagé ont un gros avantage. Sur un processeur à cache séparé, si une donnée présente dans plusieurs caches est modifiée, la mise à jour des autre version de la donnée dans le cache des autres processeurs se fera en passant par la mémoire RAM comme intermédiaire. Vu la lenteur de la mémoire RAM, on se doute que les performances seront catastrophiques ! Avec les processeurs à cache partagé, il y a juste à mettre à jour la donnée dans le cache unique, et puis c'est tout : pas de mise à jour des données dans les caches des autres cœurs, ni rien d'autre.</p><p id="r-443254" data-claire-element-id="443254">Par contre, les architectures à cache partagé ont aussi leurs problèmes : plusieurs programmes utilisent le même cache et peuvent se marcher sur les pieds. Rien n’empêche à un programme d'utiliser une portion du cache déjà utilisée par un autre : l'autre programme devant alors recharger la donnée stockée dedans en mémoire. Mais ce défaut est assez rare en pratique, et on obtient souvent de meilleurs performances avec un cache partagé qu'avec des caches dédiés.</p><h5 id="r-la-realite" data-claire-element-id="443268">La réalité</h5><p id="r-443256" data-claire-element-id="443256">Dans la réalité, il faut nuancer un tout petit peu les choses : un processeur multicœurs ne contient pas qu'un seul cache, et on se retrouve avec une organisation assez hybride, dans laquelle certains caches sont partagés et pas d'autres.</p><figure id="r-443258" data-claire-element-id="443259"><img id="r-443257" data-claire-element-id="443257" src="medias/uploads.siteduzero.com_files_364001_365000_364157.png" alt="Image utilisateur"/></figure><p id="r-443260" data-claire-element-id="443260">Généralement, on trouve deux à trois caches dans un processeur (multicœurs ou non) : le L1, le L2, et le L3. Le L2 et le L3 sont souvent partagés, tandis que le L1 n'est jamais partagé !</p><div id="r-443262" data-claire-element-id="443262" data-claire-semantic="question"><p id="r-443261" data-claire-element-id="443261">Heu...pourquoi le cache L1 a droit à ce genre de traitement de faveur ?</p></div><p id="r-443263" data-claire-element-id="443263">Très simple : il est trop moche pour mériter d'être partagé. Oui, j'avoue, c'était nul comme blague. La vraie raison tient dans le fait que ce cache doit avoir une latence très faible, et que partager un cache n'est jamais vraiment innocent en terme de temps d'accès. Partager le cache L1 serait parfaitement possible, mais rendrait celui-ci tellement lent qu'on aurait l'impression que nos programmes tourneraient au ralenti. Par contre, rien n’empêche de partager les autres caches, comme le L2 ou le L3 sans trop pourrir leur temps d'accès.</p><p id="r-443264" data-claire-element-id="443264">On peut décider de partager un cache entre tous les cœurs, voire limiter ce partage à quelques cœurs particuliers pour des raisons de performances. Ainsi, rien n’empêche pour un processeur quad-core d'avoir deux caches L2, chacun partagés avec deux cœurs, et le cache L3 partagé entre tous les cœurs.</p><figure id="r-443266" data-claire-element-id="443267"><img id="r-443265" data-claire-element-id="443265" src="medias/uploads.siteduzero.com_files_364001_365000_364590.png" alt="Image utilisateur"/></figure>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
<span class="arrow"></span>
<span class="next">Processeurs multicœurs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">
<span class="next">Cohérence mémoire</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Cohrencemmoire"></a><h2>Cohérence mémoire</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
<span class="arrow"></span>
<span class="next">Le partage des caches</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
<span class="next">Mécanismes de base</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-443273" data-claire-element-id="443273">Comme je l'ai dit dans ce tutoriel, partager la mémoire RAM entre plusieurs processeurs n'est pas une chose facile et pose de nombreux problèmes. Et c'est maintenant que l'on va rentrer dans les vif du sujet et parler de ces fameux problèmes en détail. Lorsque ces <em>threads </em>doivent manipuler une même donnée, les ennuis commencent. Il faut savoir que dans de telles situations, la gestion des caches pose de sacrés problèmes, capables de faire planter un programme en un rien de temps. Pour illustrer ces problèmes, je vais commencer par introduire la situation par un petit exemple assez simple.</p><p id="r-443274" data-claire-element-id="443274">Imaginons que deux processeurs manipulent une donnée : ceux-ci ont une copie de la donnée dans leur cache qu'ils manipulent et modifient à loisir. Si un processeur modifie cette copie de la donnée et que celle-ci est enregistrée dans son cache ou en mémoire, elle sera alors différente de celle présente dans le cache de l'autre processeur.</p><figure id="r-443276" data-claire-element-id="443277"><img id="r-443275" data-claire-element-id="443275" src="medias/uploads.siteduzero.com_files_372001_373000_372432.png" alt="Image utilisateur"/></figure><p id="r-443278" data-claire-element-id="443278">Ce qui fait qu'un processeur peut continuer à manipuler une donnée périmée qui vient d'être mise à jour par l'autre processeur. C'est pas bon ! Il faut corriger ça.</p><p id="r-443279" data-claire-element-id="443279">D'autres situations peuvent faire en sorte que le contenu du cache devienne périmé, et les écritures dans une mémoire cache ne sont pas les seules à poser problème.</p><p id="r-443280" data-claire-element-id="443280">Derrière ce problème, se cache deux problématiques assez complexes :</p><ul id="r-443285" data-claire-element-id="443285"><li id="r-443282" data-claire-element-id="443282"><p id="r-443281" data-claire-element-id="443281">pour commencer, il faut faire en sorte que notre processeur ne puisse pas lire une donnée périmée et faire en sorte d'avoir les bonnes valeurs dans la mémoire cache et/ou sa mémoire : on parle de <strong>cohérence mémoire</strong> ;</p></li><li id="r-443284" data-claire-element-id="443284"><p id="r-443283" data-claire-element-id="443283">et ensuite, il faut faire en sorte que nos écritures ou lectures en mémoire (ou dans les caches) soient prises en compte dans le bon ordre, et s'occuper de faire les mises à jour au bon moment : on parle de <strong>consistance mémoire</strong>.</p></li></ul><p id="r-443286" data-claire-element-id="443286">Pour simplifier, la cohérence porte sur la valeur de la donnée, et se préoccupe du contenu de la donnée. Elle s'occupe du &quot;quoi&quot; mettre à jour, et avec quelle valeur. La consistance s'occupe du &quot;quand&quot; mettre à jour. Chacun de ces deux problèmes impose des contraintes techniques distinctes. Nous allons commencer par la cohérence mémoire, qui est plus simple à aborder.</p><p id="r-443287" data-claire-element-id="443287">Un processeur doit toujours éviter de se retrouver avec une donnée périmée et doit toujours avoir la valeur correcte dans ses caches : il doit maintenir la <strong>cohérence des caches</strong>. Pour cela, la seule solution est d'utiliser des mécanismes permettant de faire en sorte que ce genre de cas n'arrivent pas.</p>
</div><a name="Mcanismesdebase"></a><h2>Mécanismes de base</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">
<span class="arrow"></span>
<span class="next">Cohérence mémoire</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
<span class="next">Protocoles de cohérence des caches</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-mecanismes-de-base" data-claire-element-id="443334">Mécanismes de base</h4><p id="r-443288" data-claire-element-id="443288">Lire des données est rarement un problème en terme de cohérence mémoire : ce sont surtout les écritures qui vont être la cause des divers problèmes de cohérence mémoire. Ce sont les écritures en mémoire RAM, ainsi que les écritures dans la mémoire cache qui vont poser problème.</p><p id="r-443289" data-claire-element-id="443289">On va commencer par regarder ce qui se passe lors d'une écriture dans la mémoire cache.</p><h5 id="r-politique-d-ecriture-du-cache" data-claire-element-id="443317">Politique d'écriture du cache</h5><p id="r-443290" data-claire-element-id="443290">Si on écrit dans la mémoire cache, il se peut que le contenu de la mémoire RAM ne soit pas à jour. Cela peut poser quelques problèmes : un processeur qui veut lire une donnée depuis la mémoire n'aura pas la dernière version de la donnée, vu que la mémoire n'a pas encore été mise à jour.</p><figure id="r-443292" data-claire-element-id="443293"><img id="r-443291" data-claire-element-id="443291" src="medias/uploads.siteduzero.com_files_378001_379000_378981.png" alt="Image utilisateur"/></figure><p id="r-443294" data-claire-element-id="443294">C'est ce qui se passe avec les caches <em>Write Back</em>. Avec eux, le contenu de la mémoire n'est pas cohérent avec le contenu du cache.</p><p id="r-443295" data-claire-element-id="443295">Avec les caches <em>Write Back</em>, le processeur écrit dans le cache contenant la donnée sans écrire dans la mémoire RAM et dans les niveaux de caches inférieurs (par exemple, le L2 et le L3 sont des niveaux de caches inférieurs au L1, plus &quot;proche&quot; du processeur) s'ils existent. On doit attendre que la donnée soit effacée du cache pour l'enregistrer en mémoire ou dans les niveaux de caches inférieurs (s'ils existent). Cela évite de nombreuses écritures mémoires inutiles.</p><p id="r-443296" data-claire-element-id="443296">les caches <em>Write Back</em> rendent plus difficile l'implantation de mécanismes de gestion de la cohérence des caches, et ne maintiennent pas la cohérence de la mémoire. C'est pourquoi il existe un autre type de cache : le cache <em>Write Trought</em> ; mieux adapté à ce genre de situations.</p><h6 id="r-write-through-1" data-claire-element-id="443316"><em>Write Through</em></h6><p id="r-443297" data-claire-element-id="443297">Avec les caches <em>Write Through</em>, toute donnée écrite dans le cache est écrite en même temps dans la mémoire RAM et dans les niveaux de caches inférieurs s'ils existent. Avec ces caches, l'implémentation des mécanismes permettant d'assurer la cohérence mémoire est plus facile : on est certain que la cohérence mémoire est assurée dans le cas où une donnée n'est présente que dans le ou les caches attribués à un seul processeur.</p><p id="r-443298" data-claire-element-id="443298">Avant</p><figure id="r-443300" data-claire-element-id="443301"><img id="r-443299" data-claire-element-id="443299" src="medias/uploads.siteduzero.com_files_372001_373000_372677.png" alt="Image utilisateur"/></figure><p id="r-443302" data-claire-element-id="443302">Après</p><figure id="r-443304" data-claire-element-id="443305"><img id="r-443303" data-claire-element-id="443303" src="medias/uploads.siteduzero.com_files_372001_373000_372676.png" alt="Image utilisateur"/></figure><p id="r-443306" data-claire-element-id="443306">Le contenu de la mémoire est donc toujours le bon. Mais ce n'est pas forcément le cas pour les données stockées dans les mémoires caches des autres processeurs. La cohérence des caches n'est pas maintenue.</p><p id="r-443307" data-claire-element-id="443307">Avant</p><figure id="r-443309" data-claire-element-id="443310"><img id="r-443308" data-claire-element-id="443308" src="medias/uploads.siteduzero.com_files_372001_373000_372685.png" alt="Image utilisateur"/></figure><p id="r-443311" data-claire-element-id="443311">Après</p><figure id="r-443313" data-claire-element-id="443314"><img id="r-443312" data-claire-element-id="443312" src="medias/uploads.siteduzero.com_files_372001_373000_372689.png" alt="Image utilisateur"/></figure><p id="r-443315" data-claire-element-id="443315">Ces caches ont aussi de nombreux défauts en terme de performances. Ils ont notamment tendance commettre beaucoup d'écritures dans la mémoire RAM, ce qui peut saturer le bus reliant le processeur à la mémoire. Les performances peuvent s'en ressentir.</p><h5 id="r-caches-partages" data-claire-element-id="443323">Caches partagés</h5><p id="r-443318" data-claire-element-id="443318">Les caches partagés ne posent aucun problème de cohérence. Avec eux, une donnée n'est pas dupliquée en plusieurs exemplaires, mais n'est présente qu'une seule fois dans tout le cache. Ainsi, si on écrit celle-ci, on peut être sur que les autres processeurs liront la donnée mise à jour et non une ancienne version.</p><figure id="r-443320" data-claire-element-id="443321"><img id="r-443319" data-claire-element-id="443319" src="medias/uploads.siteduzero.com_files_372001_373000_372672.png" alt="Image utilisateur"/></figure><p id="r-443322" data-claire-element-id="443322">Vous remarquerez que sur le schéma, la mémoire RAM contient encore une autre version de la donnée (du moins, si on utilise un cache <em>Write Back</em>). Mais cela ne pose pas de problème : les processeurs ne pourront pas accéder à la donnée en RAM, et iront toujours chercher la donnée dans le cache. Le cache est conçu pour. Au final, notre processeur aura donc toujours accès à la dernière valeur écrite par les autres processeurs.</p><h5 id="r-direct-memory-acces-1" data-claire-element-id="443331"><em>Direct Memory Acces</em></h5><p id="r-443324" data-claire-element-id="443324">Malheureusement, les mémoires caches ne sont pas vraiment les seules fautives dans ce genre de situation. D'autres phénomènes peuvent mettre le bazar.</p><p id="r-443325" data-claire-element-id="443325">Le processeur n'est pas toujours le seul composant dans notre ordinateur capable d'aller écrire dans la mémoire : certains périphériques peuvent ainsi aller directement lire ou écrire dans la mémoire RAM. Pour ce faire, ces périphériques utilisent un circuit intermédiaire : le contrôleur DMA. Pour les curieux, celui-ci est détaillé dans mon tutoriel sur le fonctionnement d'un ordinateur depuis zéro, dans ce chapitre : <a href="http://www.siteduzero.com/tutoriel-3-563632-communication-avec-les-entrees-sorties.html">Communication avec les entrées-sorties</a>. Pour simplifier, on va simplement dire qu'il s'agit d'un intermédiaire, qui permet aux périphériques d'aller lire ou écrire en RAM.</p><p id="r-443326" data-claire-element-id="443326">Quoiqu'il en soit, si un contrôleur mémoire va écrire en mémoire RAM, les modifications faites en mémoire ne seront pas répercutées dans les mémoires caches. Et utiliser des caches <em>Write Through</em> n'y changera rien !</p><figure id="r-443328" data-claire-element-id="443329"><img id="r-443327" data-claire-element-id="443327" src="medias/uploads.siteduzero.com_files_368001_369000_368614.png" alt="Image utilisateur"/></figure><p id="r-443330" data-claire-element-id="443330">Pour résoudre ce problème, on interdit de charger dans le cache des données stockées dans les zones de la mémoire qui peuvent être modifiées par des périphériques ou des contrôleurs DMA. Toute lecture ou écriture dans ces zones de mémoire ira donc directement dans la mémoire RAM, sans passer par la ou les mémoires caches.</p><h5 id="r-conclusion-44" data-claire-element-id="443333">Conclusion</h5><p id="r-443332" data-claire-element-id="443332">Comme on l'a vu, on dispose de certaines solutions de base, comme partager les caches, utiliser des caches <em>Write Trough</em>, ne pas copier certaines données dans le cache, etc; qui peuvent fortement limiter la casse. Mais ces techniques de base ne résolvent pas tout ! Les caches <em>Write Trough</em> permettent de maintenir la cohérence entre des niveaux de cache différents (L1-L2 ou cache-mémoire, par exemple), mais ne peuvent rien pour les autres situations. On peut les utiliser pour maintenir la cohérence entre le cache et la mémoire, ou entre un cache L1 et un cache L2 associés à un processeur. Mais ils ne servent à rien si une donnée est copiée dans les caches L1 de deux processeurs différents. De même, on ne peut pas partager tous les caches : partager le L1 n'est pas possible sans grosses contreparties que n'importe quel concepteur de processeur voudrait éviter à tout prix. Ces solutions sont donc limitées.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">
<span class="arrow"></span>
<span class="next">Cohérence mémoire</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
<span class="next">Protocoles de cohérence des caches</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Protocolesdecohrencedescaches"></a><h2>Protocoles de cohérence des caches</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
<span class="arrow"></span>
<span class="next">Mécanismes de base</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">
<span class="next">Consistance mémoire</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-protocoles-de-coherence-des-caches" data-claire-element-id="443446">Protocoles de cohérence des caches</h4><p id="r-443335" data-claire-element-id="443335">Pour limiter la casse, on a inventé d'autres mécanismes qui se chargent de déterminer quelles sont les données périmées et de les remplacer par des données valides. Ces mécanismes mettent à jour les données dans les différents caches en copiant les données mises à jour d'un cache vers un autre, ce qui se fait parfois en se servant de la mémoire comme intermédiaire. Ces mécanismes sont implémentés dans différents circuits présents dans nos processeurs ou sur nos cartes mères. Ces circuits vont fonctionner suivant un certain protocole, qui décrira quand considérer qu'une donnée est périmée, comment échanger les données entre caches, etc. Ce protocole est ce qu'on appelle un <strong>protocole de cohérence des caches</strong>.</p><p id="r-443336" data-claire-element-id="443336">Il existe beaucoup de protocoles de cohérence des caches, comme vous pouvez en juger par cette liste non-exhaustive :</p><ul id="r-443359" data-claire-element-id="443359"><li id="r-443338" data-claire-element-id="443338"><p id="r-443337" data-claire-element-id="443337">MSI protocol ;</p></li><li id="r-443340" data-claire-element-id="443340"><p id="r-443339" data-claire-element-id="443339">MESI, aussi appelé <em>Illinois protocol</em> ;</p></li><li id="r-443342" data-claire-element-id="443342"><p id="r-443341" data-claire-element-id="443341">MOSI ;</p></li><li id="r-443344" data-claire-element-id="443344"><p id="r-443343" data-claire-element-id="443343">MOESI ;</p></li><li id="r-443346" data-claire-element-id="443346"><p id="r-443345" data-claire-element-id="443345">MERSI ;</p></li><li id="r-443348" data-claire-element-id="443348"><p id="r-443347" data-claire-element-id="443347">MESIF ;</p></li><li id="r-443350" data-claire-element-id="443350"><p id="r-443349" data-claire-element-id="443349">write-once ;</p></li><li id="r-443352" data-claire-element-id="443352"><p id="r-443351" data-claire-element-id="443351">Synapse ;</p></li><li id="r-443354" data-claire-element-id="443354"><p id="r-443353" data-claire-element-id="443353">Berkeley ;</p></li><li id="r-443356" data-claire-element-id="443356"><p id="r-443355" data-claire-element-id="443355">Firefly and Dragon protocol ;</p></li><li id="r-443358" data-claire-element-id="443358"><p id="r-443357" data-claire-element-id="443357">etc.</p></li></ul><h5 id="r-generalites-20" data-claire-element-id="443393">Généralités</h5><p id="r-443360" data-claire-element-id="443360">Malgré ce grand nombre de protocoles, on peut dégager quelques régularités et généralités. Il existe deux grands types de protocoles utilisées pour maintenir la cohérence des caches :</p><ul id="r-443365" data-claire-element-id="443365"><li id="r-443362" data-claire-element-id="443362"><p id="r-443361" data-claire-element-id="443361">les <em><strong>snooping protocols</strong></em>, dans lesquels chaque donnée contient des informations pour savoir si elle est partagée entre plusieurs processeurs ;</p></li><li id="r-443364" data-claire-element-id="443364"><p id="r-443363" data-claire-element-id="443363">et les <em><strong>directory protocols</strong></em>, qui stockent des informations sur chaque donnée, pour savoir si elle est partagée ou non : ces informations étant stockées dans un circuit spécialisé qu'on appelle le <em>directory</em>.</p></li></ul><h6 id="r-directory-protocol" data-claire-element-id="443369">Directory Protocol</h6><p id="r-443366" data-claire-element-id="443366">Notre mémoire cache est, comme toutes les autres mémoires, divisées en cases mémoires, qu'on peut modifier individuellement. Dans un cache, ces cases mémoires sont regroupées en blocs de taille fixe qu'on appelle des lignes de cache. Généralement, ces blocs ont une taille assez grosse comparé aux cases mémoires : cela peut varier de 64 à 256 octets.</p><p id="r-443367" data-claire-element-id="443367">Avec un <em>directory protocol</em>, on utilise un circuit spécial qui contient des informations sur toutes les lignes de caches présentes dans notre processeur. Ce gros circuit, le <em>directory</em>, sait donc quelle est la ligne de cache qui a la dernière version valide d'une donnée présente dans plusieurs caches, si telle ligne de cache contient une donnée périmée, si telle ligne de cache est présente dans plusieurs caches, etc. Ces informations sur l'état des lignes de caches sont souvent stockées en mémoire RAM : notre <em>directory </em>est ainsi fortement relié à la mémoire RAM, voire totalement implanté dedans. Ce <em>directory</em> est mis à jour à chaque fois qu'un processeur écrit dans sa mémoire cache : dans ce cas, le processeur va mettre à jour le <em>directory</em> automatiquement.</p><p id="r-443368" data-claire-element-id="443368">Ces protocoles sont surtout utilisés sur les architectures distribuées : ils sont en effet difficiles à implémenter, tandis que leurs concurrents sont plus simples à implanter sur les machines à mémoire partagée.</p><h6 id="r-snooping-protocols" data-claire-element-id="443378"><em>Snooping protocols</em></h6><p id="r-443370" data-claire-element-id="443370">Ces concurrents sont ce qu'on appelle les <em>Snooping protocols</em>. En soit, nos <em>Snooping protocols</em> n'ont rien de bien compliqué : chaque ligne de cache contient des bits qui permettent de savoir si cette ligne de cache contient une donnée périmée ou si la ligne de cache est valide. Quand on veut lire une donnée, les circuits chargés de lire dans le cache vont vérifier ces bits. si ces bits disent que la ligne de cache est valide, les circuits gérant le cache vont autoriser la lecture de la ligne de cache, sans rien faire de spécial. Par contre, si la ligne de cache est périmée, on va alors lire les données depuis la RAM, et remplacer les données pourries par la valeur correcte.</p><p id="r-443371" data-claire-element-id="443371">La mise à jour de ces bits se fait lorsqu'un processeur doit aller écrire dans le cache. Plus précisément, nos caches sont interconnectés entre eux, afin de maintenir la cohérence. Si un cache contient une donnée partagée, ce cache devra prévenir tous les autres caches quand on écrira dedans. A chaque écriture dans une donnée partagée, il devra donc prévenir ses collègues qui se chargeront alors de mettre à jour la donnée partagée s'ils en possèdent une copie.</p><p id="r-443372" data-claire-element-id="443372">Généralement, cette communication est facilement implémentable sur les processeurs actuels. La raison est très simple : tous les caches sont reliés à la mémoire via un bus, une série de fils qui permet de transférer des données entre le cache et la mémoire. Sur nos ordinateurs actuels, ce bus est partagé entre tous les caches.</p><figure id="r-443374" data-claire-element-id="443375"><img id="r-443373" data-claire-element-id="443373" src="medias/uploads.siteduzero.com_files_378001_379000_378759.png" alt="Image utilisateur"/></figure><p id="r-443376" data-claire-element-id="443376">On peut donc faire passer les échanges d’informations entre caches via ce bus sans aucun problème. On réutilise l'existant pour mettre en œuvre notre protocole de cohérence des caches, sans devoir créer des circuits supplémentaires. Vous remarquerez que c'est un avantage certain qu'on les <em>snooping protocols</em> sur les <em>directory protocols</em>.</p><p id="r-443377" data-claire-element-id="443377">A chaque fois qu'une information est transférée sur ce bus, les différents caches vont regarder ce qui est transmis sur ce bus, et vont mettre à jour les informations sur les lignes de cache, voire les données de celle-ci, à jour.</p><h6 id="r-coherence-entre-differents-niveaux-de-caches" data-claire-element-id="443382">Cohérence entre différents niveaux de caches</h6><p id="r-443379" data-claire-element-id="443379">Sur les processeurs actuels, on trouve toute une hiérarchie de mémoires caches, certains étant partagés, et d'autres non ; certains utilisent le <em>Write Trough</em>, et d'autres les <em>Write Back</em>, etc. Mais le plus important est que ces caches ne sont pas tous reliés au bus mémoire.</p><p id="r-443380" data-claire-element-id="443380">Par exemple, sur un processeur contenant un cache L1 et un cache L2, le cache L1 n'est pas relié à la mémoire : c'est le cache L2, le plus proche de la mémoire, qui l'est. On peut donc utiliser un <em>Snooping Protocol</em> pour le L2, mais pas pour le L1. Une solution est de faire en sorte que les caches L1 soient de type &quot; <em>Write Trough</em> &quot; (ou presque) : toute écriture dans le L1 doit être répercutée dans le L2. Il existe bien sûr d'autres moyens, mais passons ceux-ci sous silence.</p><p id="r-443381" data-claire-element-id="443381">Et ne parlons pas des processeurs utilisant des caches L1, L2 et L3, voire L4... Bref, maintenir la cohérence entre tous ces caches est un sacré challenge.</p><h6 id="r-write-invalidation-et-write-broadcasting" data-claire-element-id="443392">Write Invalidation et Write Broadcasting</h6><p id="r-443383" data-claire-element-id="443383">Pour compliquer un peu les choses, cette mise à jour se fait différemment suivant les processeurs :</p><ul id="r-443388" data-claire-element-id="443388"><li id="r-443385" data-claire-element-id="443385"><p id="r-443384" data-claire-element-id="443384">soit on utilise des techniques de <em><strong>Write Invalidation</strong></em> ;</p></li><li id="r-443387" data-claire-element-id="443387"><p id="r-443386" data-claire-element-id="443386">soit on utilise le <em><strong>Write Update</strong></em>.</p></li></ul><p id="r-443389" data-claire-element-id="443389">Ah, je crois que quelques explications s'imposent, non ? ^^</p><p id="r-443390" data-claire-element-id="443390">Bon, alors pour résumer, la première méthode, la <em>Write Invalidation</em> est celle qui est utilisée dans les protocoles qu'on a vu précédemment : quand on écrit une donnée dans un cache, toutes les autres versions de cette donnée, présentes dans les autres caches sont invalidées, considérées comme périmées. Lorsque l'on cherche à lire une donnée périmée, on ne peut pas accéder au cache, et la bonne version de la donnée doit être transférée depuis la mémoire ou depuis d'autres caches.</p><p id="r-443391" data-claire-element-id="443391">Avec le<em> Write Update</em>, toute écriture dans un cache est propagée, et les autres caches sont mis à jour automatiquement. La différence, c'est que les données dans les autres caches sont modifiées automatiquement, même si le processeur ne cherche pas à les lire. Avec la<em> Write Invalidation</em>, la mise à jour ne commence que lorsque l'on veut lire une donnée primée. Avec le<em> Write Update</em>, on met à jour le plus tôt possible, avant même toute tentative de lecture.</p><h5 id="r-protocole-msi" data-claire-element-id="443423">Protocole MSI</h5><p id="r-443394" data-claire-element-id="443394">Le plus simple de ces protocoles s'appelle le <strong>protocole MSI</strong>. Ce protocole se contente simplement de donner à chaque donnée stockée dans le cache un état, qui permet de savoir si cette donnée est présente dans les autres caches, si elle a été modifiée, etc. <br/> Le protocole MSI définit trois états :</p><ul id="r-443401" data-claire-element-id="443401"><li id="r-443396" data-claire-element-id="443396"><p id="r-443395" data-claire-element-id="443395"><strong><em>Modified </em></strong>;</p></li><li id="r-443398" data-claire-element-id="443398"><p id="r-443397" data-claire-element-id="443397"><strong><em>Shared </em></strong>;</p></li><li id="r-443400" data-claire-element-id="443400"><p id="r-443399" data-claire-element-id="443399"><strong><em>Invalid</em></strong>.</p></li></ul><p id="r-443402" data-claire-element-id="443402">Vous remarquerez que les initiales de ces états ne sont rien d'autre que le nom du protocole.</p><p id="r-443403" data-claire-element-id="443403">L'état <em>Shared </em>correspond à une donnée à jour : cet exemplaire de la donnée est présent dans tous les caches du processeur, et aussi en mémoire.</p><p id="r-443404" data-claire-element-id="443404">L'état <em>Modified</em> correspond à une donnée qu'on a modifiée dans le cache. Cette donnée est donc à jour, mais les autres copies présentes dans les autres caches du processeur ou en mémoire sont périmées.</p><p id="r-443405" data-claire-element-id="443405">Enfin, l'état <em>Invalid</em> correspond au cas où la donnée présente dans le cache est périmée : un autre processeur a mit à jour l'exemplaire présent dans son cache, et seul cet autre processeur a une donnée valide (qui est dans l'état <em>Modified</em>).</p><p id="r-443406" data-claire-element-id="443406">Quand on veut lire une donnée devenue invalide, le processeur va lire la bonne donnée en mémoire RAM ou dans un autre cache qui possède la bonne version de la donnée. Une fois les données mises à jour, la donnée dans l'état <em>Modified </em>(dans le cache du processeur qui a modifié la donnée) et <em>Invalid </em>(dans les autres caches) repassent dans l'état <em>Shared</em>. C'est seulement quand on veut lire une donnée périmée que la mise à jour a lieu, pas avant. Retenez bien ce détail pour la suite du tutoriel.</p><h6 id="r-fonctionnement-29" data-claire-element-id="443422">Fonctionnement</h6><figure id="r-443408" data-claire-element-id="443409"><img id="r-443407" data-claire-element-id="443407" src="medias/uploads.siteduzero.com_files_378001_379000_378960.png" alt="Image utilisateur"/></figure><p id="r-443410" data-claire-element-id="443410">Quand un processeur veut aller lire dans le cache, il se retrouve face à deux solutions :</p><ul id="r-443415" data-claire-element-id="443415"><li id="r-443412" data-claire-element-id="443412"><p id="r-443411" data-claire-element-id="443411">soit la donnée dans le cache est dans l'état <em>Modified </em>ou <em>Shared</em>, et le processeur peut l'utiliser sans problème ;</p></li><li id="r-443414" data-claire-element-id="443414"><p id="r-443413" data-claire-element-id="443413">soit elle est dans l'état <em>Invalid</em>, et il devra aller récupérer la bonne version en mémoire RAM ou dans un autre cache.</p></li></ul><p id="r-443416" data-claire-element-id="443416">Pour l'écriture, c'est autre chose. Quand le processeur écrit dans une donnée, on se retrouve face à plusieurs cas :</p><ul id="r-443421" data-claire-element-id="443421"><li id="r-443418" data-claire-element-id="443418"><p id="r-443417" data-claire-element-id="443417">si la donnée est dans l'état <em>Modified</em>, rien ne change, elle reste dans cet état ;</p></li><li id="r-443420" data-claire-element-id="443420"><p id="r-443419" data-claire-element-id="443419">si la donnée est dans l'état <em>Shared</em>, et elle passe donc dans l'état <em>Modified</em>.</p></li></ul><h5 id="r-protocole-mesi" data-claire-element-id="443437">Protocole MESI</h5><p id="r-443424" data-claire-element-id="443424">Ce protocole MSI n'est pas parfait. Par exemple, un tel protocole ne permet pas de savoir si une donnée présente dans un cache est présente dans les autres caches. Ainsi, si on veut modifier cette donnée, on doit prévenir tous les autres caches (ou un circuit qui est chargé de gérer la cohérence mémoire) qu'on vient de modifier cette donnée. Évidemment, si aucun autre cache ne possède cette donnée, on aura prévenu pour rien, et gaspillé des communications entre caches ou entre cache et mémoire pour rien. Ces communications entre caches ne sont pas gratuites et en faire trop peut ralentir fortement notre ordinateur. Pour régler ce problème, on a inventé le <strong>protocole MESI</strong>. Ce protocole est assez connu, et pour cause : le premier processeur à l'avoir utilisé n'est autre que le processeur Pentium premier du nom ! Ce protocole a été utilisé sur de nombreux processeurs, jusqu’aux processeurs Core d'Intel, et leurs concurrents d'AMD.</p><p id="r-443425" data-claire-element-id="443425">Ce protocole MESI rajoute un état supplémentaire : <strong><em>Exclusive</em></strong>. <em>Exclusive </em> est une sorte d'amélioration de <em>Shared</em>. Avec le <em>Shared </em>du protocole MSI, on ne sait pas si les autres caches possèdent eux aussi une copie de la donnée, ou si seul un seul cache utilise cette donnée. Mais dans le protocole MESI, l'état <em>Shared </em>du protocole MSI est scindé en deux états pour faire cette distinction :</p><ul id="r-443430" data-claire-element-id="443430"><li id="r-443427" data-claire-element-id="443427"><p id="r-443426" data-claire-element-id="443426">une donnée sera dans l'état <em>Exclusive </em>si les autres processeurs ne possèdent pas de copie de la donnée ;</p></li><li id="r-443429" data-claire-element-id="443429"><p id="r-443428" data-claire-element-id="443428">et sera dans l'état <em>Shared </em>sinon.</p></li></ul><p id="r-443431" data-claire-element-id="443431">Avec cette distinction, on peut éviter l'envoi de messages aux autres caches (ou aux circuits chargés de gérer la cohérence des caches) si on écrit dans une donnée marquée <em>Exclusive </em>: on sait que les autres caches ne possèdent pas de copie de la donnée, alors il ne sert à rien de prévenir inutilement.</p><h6 id="r-fonctionnement-30" data-claire-element-id="443436">Fonctionnement</h6><p id="r-443432" data-claire-element-id="443432">Cette fois-ci, je ne vais pas vous donner un schéma pour illustrer le fonctionnement du protocole MESI : un tel schéma serait illisible. Tout ce qu'il faut retenir, c'est que le fonctionnement du protocole MESI est identique au protocole MSI, avec quelques ajouts.</p><p id="r-443433" data-claire-element-id="443433">Par exemple, si une donnée est chargée depuis la mémoire pour la première fois dans un cache, elle passe soit en <em>Exclusive </em>(les autres caches ne contenaient pas la donnée), soit en <em>Shared </em>(les autres caches en possèdent une copie).</p><p id="r-443434" data-claire-element-id="443434">Si on écrit dans une donnée marquée <em>Exclusive</em>, elle passe en état <em>Modified</em>.</p><p id="r-443435" data-claire-element-id="443435">Une donnée marquée Exclusive peut devenir <em>Shared </em>si la donnée est chargée dans le cache d'un autre processeur. Et inversement, une donnée <em>Shared </em>peut devenir <em>Exclusive</em> si tous les autres caches se débarrassent de cette donnée.</p><h5 id="r-protocole-moesi" data-claire-element-id="443445">Protocole MOESI</h5><p id="r-443438" data-claire-element-id="443438">Le protocole MESI est un protocole de cohérence des caches qui était assez utilisé dans pas mal de processeurs. Si je parle au passé, c'est simplement que d'autres protocoles sont utilisés sur les processeurs modernes. Sur les processeurs modernes, on utilise soit le protocole MOESI, soit un de ses collègues, comme le protocole MESIF. Vous devez surement vous poser une question : pourquoi ce protocole a-t-il remplacé le protocole MESI ? Voyons cela par un exemple !</p><p id="r-443439" data-claire-element-id="443439">Imaginons qu'un processeur veuille obtenir la bonne version d'une donnée. Il y a deux solutions : soit aller chercher la bonne version en mémoire, soit aller la chercher dans un autre cache. Si notre processeur ne dispose que de deux caches, la situation est très simple : notre processeur va ainsi faire sa demande, et c'est soit la mémoire soit l'autre cache qui va répondre. On peut ainsi optimiser nos protocoles MESI et MSI pour transférer nos données entre les caches sans passer par la mémoire.</p><p id="r-443440" data-claire-element-id="443440">Mais si on a plusieurs mémoires caches, des problèmes peuvent survenir. Par exemple, si la donnée est présente dans plusieurs caches, tous les caches ayant la bonne version de la donnée (la version <em>Shared</em> ou <em>Modified</em>) vont répondre en même temps à cette demande. Autant dire que gérer une situation dans laquelle tous les caches se marchent sur les pieds est loin d'être facile ! Seule solution : ne pas aller chercher la donnée dans les autres caches et passer uniquement par la mémoire. Cela nécessite de maintenir la mémoire à jour, et donc d'aller y écrire souvent : à chaque fois qu'une donnée passe dans l'état <em>Modified</em>, on doit l'écrire dans la mémoire. Les mises à jour de données <em>Invalid </em>se font donc via la mémoire RAM. Vu que la mémoire RAM est au minimum 20 fois plus lente que la mémoire cache, les performances s'effondrent et votre processeur devient aussi rapide qu'une antiquité du style 486DX.</p><h6 id="r-solution-du-moesi" data-claire-element-id="443444">Solution du MOESI</h6><p id="r-443441" data-claire-element-id="443441">Pour éviter ce gros problème, le protocole MOESI va simplement rajouter un état supplémentaire pour nos données : l'état <strong><em>Owned</em></strong>. Si un processeur écrit dans son cache, il mettra sa donnée en <em>Owned</em>. Les autres caches se mettront alors à jour, et passerons leur donnée en version <em>Modified</em>, voire <em>Shared </em>une fois la mémoire mise à jour. Ainsi, seul un seul processeur pourra avoir une donnée dans l'état <em>Owned </em>à la fois. Avec MOESI, seul le processeur qui possède la donnée en <em>Owned </em>va répondre à cette demande (ceux possédant la donnée <em>Shared </em>ne répondant pas à la demande formulée par le processeur demandeur), évitant ainsi d'aller chercher la donnée à jour en mémoire.</p><p id="r-443442" data-claire-element-id="443442">Cela a un autre avantage : on n'est pas obligé de maintenir la mémoire à jour. Ainsi, lorsqu'une donnée passe en état <em>Modified</em>, il n'y a pas besoin d'aller écrire en mémoire RAM la bonne version de la donnée. On diminue fortement le nombre d'écritures en mémoire. Les performances s'envolent !</p><p id="r-443443" data-claire-element-id="443443">Comme vous pouvez le voir, écrire dans des données partagées et utilisées par plusieurs <em>Threads </em>peut poser de lourds problèmes, qui peuvent ruiner les performances assez rapidement. La cohérence des caches est quelques chose de compliqué, qui peut parfois être une cause majeure de ralentissements dans des applications parallélisées sur plusieurs cœurs /processeurs. N'oubliez pas ce genre de choses quand vous programmez, messieurs !</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
<span class="arrow"></span>
<span class="next">Mécanismes de base</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">
<span class="next">Consistance mémoire</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Consistancemmoire"></a><h2>Consistance mémoire</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
<span class="arrow"></span>
<span class="next">Protocoles de cohérence des caches</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
<span class="next">Modèles de consistance</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-443448" data-claire-element-id="443448">Exécuter plusieurs <em>threads </em>sur plusieurs processeurs peut avoir des conséquences assez fâcheuses, comme je me plait à vous le répéter depuis le début de ce tutoriel, et on a déjà eu un petit aperçu de ce que cela pouvait donner dans le chapitre précédent. On y avait vu que dans certains cas, les opérations de lecture en mémoire effectuées par notre processeur pouvaient renvoyer une valeur périmée. Ces lectures foireuses étaient dues à la présence de mémoires caches, et disparaissaient dès qu'on pouvait maintenir la cohérence de la mémoire. Mais ces lectures foireuses n'ont pas encore disparues : les caches ne sont pas les seuls fautifs.</p><p id="r-443449" data-claire-element-id="443449">Première raison : une lecture ou qu'une écriture en mémoire RAM peut prendre un temps assez long et parfois variable suivant l'opération. Et il est parfaitement possible qu'une nouvelle opération de lecture ou d'écriture démarre avant que la lecture ou écriture précédente soit terminée. Vous pouvez ainsi avoir un processeur qui lit une donnée en même temps qu'un autre tente de l'écrire, ou deux processeurs qui tentent d'effectuer des écritures simultanées. En clair : ça fait des Chocapic ! Dans ce cas, le résultat des lectures et écritures peut fortement varier suivant l'état et le fonctionnement du bus mémoire, de la mémoire, de son contrôleur, et de l'age du capitaine. Par exemple, imaginez qu'on lance une écriture, suivie d'une lecture, la lecture commençant avant que l'écriture précédente soit terminée. Dans ce cas, rien n’empêche à la lecture de finir avant l'écriture : notre lecture peut alors renvoyer l'ancienne valeur, celle qu'on trouvait en mémoire avant l'écriture.</p><figure id="r-443451" data-claire-element-id="443452"><img id="r-443450" data-claire-element-id="443450" src="medias/uploads.siteduzero.com_files_394001_395000_394959.png" alt="Image utilisateur"/></figure><p id="r-443453" data-claire-element-id="443453">Pour régler ce genre de problèmes, des spécialistes et des chercheurs ont inventé les <strong>instructions atomiques</strong>. Ces instructions sont des instructions qu'on ne peut pas interrompre : elles vont réquisitionner la mémoire et empêcher toute lecture ou écriture tant qu'elle ne sont sera pas terminées. Toute autre instruction voulant accéder à la mémoire en même temps sera mise en attente. De telles instructions suffisent à garantir que nos écritures et lectures s’exécutent l'une après l'autre. Mais elles ne garantissent pas que l'ordre correct des opérations d'accès mémoire sera respecté...</p><p id="r-443454" data-claire-element-id="443454">Autre raison : les processeurs modernes n'hésitent pas à modifier l'ordre d’exécution des instructions histoire de gagner en efficacité. Il est ainsi parfaitement possible pour notre processeur de changer l'ordre d’exécution des instructions d'accès mémoire : il peut placer une lecture avant une écriture, une lecture avant une lecture, une écriture après une autre, etc. Mais notre processeur doit se débrouiller pour que cela ne change pas le comportement du programme. Il dispose pour cela de techniques de <em>Memory Disambiguation</em> assez compliquées. Mais avec plusieurs processeurs, chaque processeur fait cela chacun dans son coin, sans se préoccuper de ce que peuvent faire les autres processeurs. Les opérations d'écriture venant d'un processeur peuvent être mises dans un désordre complet, et les autres processeurs qui liront ces données écrites en mémoire auront droit à des données mises à jour dans le désordre. Les lectures effectuées par les autres processeurs peuvent alors renvoyer de vielles données.</p>
</div><a name="Modlesdeconsistance"></a><h2>Modèles de consistance</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">
<span class="arrow"></span>
<span class="next">Consistance mémoire</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
<span class="next">Fences et Memory Barrier</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-modeles-de-consistance" data-claire-element-id="443496">Modèles de consistance</h4><p id="r-443455" data-claire-element-id="443455">On a vu plus haut que le réordonnancent des instructions effectué par notre processeur peut poser de graves problèmes, et que mettre les instructions dans le bon ordre est une nécessité. On doit donc résoudre un problème : comment faire en sorte que nos accès mémoires effectués ou non dans le &quot;désordre&quot; ne posent pas de problèmes ?<br/> Toute la problématique est là : une lecture doit retourner la dernière valeur écrite dans l'ordre du programme. Il y a plusieurs solutions à ce problème. Ces solutions sont ce qu'on appelle des <strong>modèles de consistance mémoire</strong>.</p><h5 id="r-sequential-consistency" data-claire-element-id="443458">Séquential Consistency</h5><p id="r-443456" data-claire-element-id="443456">Le plus simple de ces modèles de consistance s'appelle la <strong>sequential consistency</strong>. Il est très simple à comprendre : aucune réorganisation de l'ordre des instructions n'est possible. Un processeur doit impérativement exécuter ses instructions dans l'ordre imposé par le programme. Pas de possibilité de réorganisation, rien. Tout se passe comme si les instructions de chaque programme s'effectuaient dans l'ordre imposé par celui-ci, et que les lectures ou écritures des différents processeurs étaient exécutées les unes après les autres. Les conséquences sont directes : pas d'utilisation de techniques de <em>Memory Disambiguation</em>. Est-ce un problème ?</p><p id="r-443457" data-claire-element-id="443457">Oui : ce modèle de consistance est vraiment strict. Trop même : il interdit de nombreux cas de réorganisation qui seraient pourtant parfaitement légaux. Après tout, toutes les réorganisations d'accès mémoire ne sont pas problématiques, même avec plusieurs processeurs. Cela empêche de nombreuses optimisations matérielles et limite grandement les possibilités d'optimisation des compilateurs. Votre processeur et votre compilateur ne peuvent plus changer l'ordre des instructions d'accès mémoire. Par exemple, il devient alors beaucoup plus difficile d’exécuter des lectures en avance, pour recouvrir le temps d'accès au cache ou à la mémoire par des instructions de calcul. En clair : votre programme fonctionne parfaitement bien, mais il est plus lent qu'il ne le devrait. Pour être franc, aucun processeur actuel n'utilise ce modèle de consistance. L'impossibilité d'effectuer des réorganisations et optimisations légales sur l'ordre des accès mémoire est proprement rédhibitoire en terme de performances. Et de nos jours, il en faut de la performance pour faire tourner des programmes de plus en plus programmés avec les pieds respectueux de la <a href="http://fr.wikipedia.org/wiki/Loi_de_Wirth">Loi de Wirth</a>.</p><h5 id="r-relaxed-consistency" data-claire-element-id="443469">Relaxed Consistency</h5><p id="r-443459" data-claire-element-id="443459">Pour permettre à ces optimisations légales, d'autres modèles de consistances ont été inventés. Ceux-ci permettent certaines réorganisations non-dangereuses. Par exemple, rien n’empêche d'effectuer une lecture avant une écriture si jamais ces deux instructions manipulent des endroits très différents de la mémoire : les deux données étant indépendantes, cette réorganisation ne pose aucun problème. Pareil pour deux lectures effectuées sur des données indépendantes : l'ordre des lectures ne changera rien.</p><p id="r-443460" data-claire-element-id="443460">Divers modèles de consistance existent donc, qui permettent d'autoriser ou d'interdire certaines réorganisation, et qui autorisent certaines instructions à ne pas être atomiques. En fait, c'est limite s'il n'existe pas un modèle de consistance pour chaque jeu d'instruction existant au monde. Autant dire que tous les présenter serait un peu long. Mais on peut grosso-modo classer ces modèles de consistance en trois grandes catégories.</p><h6 id="r-total-store-ordering" data-claire-element-id="443463">Total Store Ordering</h6><p id="r-443461" data-claire-element-id="443461">Dans le cas le plus strict, une donnée ne peut pas être réutilisée tant que la donnée n'a pas finie d'être écrite en mémoire et/ou mise à jour dans le cache des autres processeurs. C'est exactement ce qu'on attend de la <em>sequential consistency</em>.</p><p id="r-443462" data-claire-element-id="443462">Mais cette ordre peut être un peu relâché. Un processeur peut ainsi réutiliser une donnée qu'il vient d'écrire dans son cache avant que cette donnée soit enregistrée en mémoire ou dans les autres caches. Tout se passe donc comme si l'écriture en question n'était pas in-interruptible. Et oui, on peut parfaitement lire la donnée écrite avant même que l'écriture soit terminée et que toutes les versions de la donnée soient mises à jour. Mine de rien, c'est ce qui était fait dans les protocoles de cohérence des caches qu'on a vus précédemment : le statut <em>modified</em> n’empêchait pas les lectures de la donnée. Je ne vous cache pas que c'est exactement ce qui se passe avec la majorité des modèles de consistances plus laxistes, dont ceux implantés dans nos processeurs actuels.</p><h6 id="r-partial-store-ordering" data-claire-element-id="443465">Partial Store Ordering</h6><p id="r-443464" data-claire-element-id="443464">L'autre possibilité est de permettre des écritures simultanées, ainsi que des réorganisations de l'ordre des écritures quand ces écritures manipulent des données différentes. Ainsi, on peut démarrer une nouvelle écriture avant que les écritures précédentes ne soient terminées. Au lieu d'attendre que toutes les écritures précédentes se terminent, et faire comme si les écritures étaient in-interruptibles, on peut démarrer une écriture pendant qu'une autre est en attente ou manipule la mémoire. La seule condition pour éviter les catastrophe est que ces écritures manipulent des données différentes, placées à des endroits différents de la mémoire.</p><h6 id="r-no-limit" data-claire-element-id="443468">No Limit</h6><p id="r-443466" data-claire-element-id="443466">Enfin, certains processeurs vont encore plus loin : ils autorisent toutes les réorganisations possibles entre lectures et écritures, tant qu'elle se font sur des données différentes. Simple, rapide, et efficace. De même, ce qui a été fait plus haut pour l'écriture est alors possible pour les lectures : on peut parfaitement démarrer une autre lecture pendant que d'autres lectures sont en attente ou en cours. Difficile de faire plus laxiste comme modèle de consistance.</p><p id="r-443467" data-claire-element-id="443467">Et bien sachez qu'on peut faire encore plus pire : rien n’empêche de pouvoir modifier l'ordre des lectures effectuées sur une donnée. Ainsi, si deux lectures se suivent et qu'il n'y a pas d'écritures entre les deux, on peut effectuer ces deux lectures dans l'ordre qu'on veut. Mais que c'est assez rare. Il n'existe qu'un seul exemple de processeur connu qui puisse le faire : il s'agit du <a href="http://fr.wikipedia.org/wiki/DEC_Alpha">processeurs DEC Alpha</a>, un processeur particulièrement innovant pour son époque, qui n’eut pas le succès qui lui était du.</p><h5 id="r-exemples-24" data-claire-element-id="443495">Exemples</h5><p id="r-443470" data-claire-element-id="443470">Après ces histoires de théorie pure et simple, passons maintenant à la pratique. Dans cette partie, on va voir les modèles de consistances utilisés sur quelques processeurs plus ou moins grand public. Nous allons donc voir l'exemple des processeurs x86, ceux qu'on retrouve dans nos PC actuels. Le modèle de consistance des processeurs x86 a varié au cours de l'existence de l'architecture : un vulgaire 486DX n'a pas le même modèle de consistance qu'un Core 2 duo, par exemple. Quoiqu'il en soit, les modèles de consistance des processeurs x86 ont toujours étés assez forts, avec pas mal de restrictions. Si on compare aux autres processeurs, le x86 est assez strict.</p><p id="r-443471" data-claire-element-id="443471">Bref, le premier modèle de consistance utilisé sur les processeurs x86 est apparu sur les premiers processeurs x86 et est resté en place sur tous les processeurs de marque Pentium. Ce modèle est assez simple : hormis une exception, tout doit se passer comme si le processeur accédait à la mémoire dans l'ordre des opérations de notre programme. Cette exception concerne les lectures : dans certains cas, on peut les exécuter avant certaines écritures.<br/> Néanmoins, cela nécessite quelques conditions :</p><ul id="r-443480" data-claire-element-id="443480"><li id="r-443473" data-claire-element-id="443473"><p id="r-443472" data-claire-element-id="443472">ces écritures doivent se faire dans la mémoire cache ;</p></li><li id="r-443475" data-claire-element-id="443475"><p id="r-443474" data-claire-element-id="443474">la lecture doit se faire dans la mémoire ;</p></li><li id="r-443477" data-claire-element-id="443477"><p id="r-443476" data-claire-element-id="443476">nos écritures doivent aller écrire à des adresses différentes de l'adresse accédée en lecture ;</p></li><li id="r-443479" data-claire-element-id="443479"><p id="r-443478" data-claire-element-id="443478">aucune transaction avec un périphérique ne doit être en cours.</p></li></ul><p id="r-443481" data-claire-element-id="443481">En clair, ce modèle est vraiment strict !</p><p id="r-443482" data-claire-element-id="443482">Sur les processeurs à partir du Pentium 4, les choses changent. Le Pentium 4 est en effet le premier processeur à implémenter des techniques permettant d’exécuter plusieurs processus en parallèle. Ce processeur est en effet le premier à utiliser l'Hyperthreading. En conséquence, le modèle de consistance a du être assoupli pour éviter de perdre bêtement en performance.<br/> Voici un résumé de ce modèle de consistance :</p><ul id="r-443493" data-claire-element-id="443493"><li id="r-443484" data-claire-element-id="443484"><p id="r-443483" data-claire-element-id="443483">une lecture ne peut pas être déplacée avant ou après une autre lecture ;</p></li><li id="r-443486" data-claire-element-id="443486"><p id="r-443485" data-claire-element-id="443485">une écriture ne peut pas être déplacée avant une lecture ;</p></li><li id="r-443488" data-claire-element-id="443488"><p id="r-443487" data-claire-element-id="443487">à part pour quelques exceptions, l'ordre des écritures dans la mémoire ne change pas : une écriture dans la mémoire ne peut pas être déplacée avant ou après une autre écriture ;</p></li><li id="r-443490" data-claire-element-id="443490"><p id="r-443489" data-claire-element-id="443489">on ne peut pas déplacer une écriture ou une lecture avant ou après une instruction atomique, ainsi que quelques instructions supplémentaires (celles qui accèdent aux périphériques ou aux entrées-sorties, notamment) ;</p></li><li id="r-443492" data-claire-element-id="443492"><p id="r-443491" data-claire-element-id="443491">des lectures peuvent être déplacées avant des écritures, si ces écritures et la lecture ne se font pas au même endroit, à la même adresse.</p></li></ul><p id="r-443494" data-claire-element-id="443494">Dans cette liste, j'ai mentionné le fait que les écritures en mémoire peuvent changer dans certains cas exceptionnels. Ces cas exceptionnels sont les écritures effectuées par les instructions de gestion de tableaux et de chaines de caractères, ainsi que certaines instructions SSE. Ces instructions SSE sont les instructions qui permettent d'écrire des données sans passer par le cache, mentionnées il y a quelques chapitres. Ce sont donc les instructions <code data-claire-semantic="nasm">MOVNTI</code>, <code data-claire-semantic="nasm">MOVNTQ</code>, <code data-claire-semantic="nasm">MOVNTDQ</code>, <code data-claire-semantic="nasm">MOVNTPS</code>, <code data-claire-semantic="nasm">MOVNTPD</code>. Mais ce ne sont pas les seules : le x86 possède quelques instructions permettant de travailler directement sur des chaines de caractères ou des tableaux : ce sont les instruction <code data-claire-semantic="nasm">REPMOVSD</code>, <code data-claire-semantic="nasm">REPSCACB</code>, et bien d'autres encore. Et bien sachez que les écritures effectuées dans ces instructions peuvent se faire dans un désordre complet (ou presque).</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">
<span class="arrow"></span>
<span class="next">Consistance mémoire</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
<span class="next">Fences et Memory Barrier</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="FencesetMemoryBarrier"></a><h2>Fences et Memory Barrier</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
<span class="arrow"></span>
<span class="next">Modèles de consistance</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">
<span class="next">Synchronisation entre Threads</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-fences-et-memory-barrier" data-claire-element-id="443519">Fences et Memory Barrier</h4><p id="r-443497" data-claire-element-id="443497">Plus haut, j'ai parlé des modèles de consistance qui autorisent toute réorganisation sur des données non-partagées entre processeurs. J'ai dit plus haut que les réorganisations des lectures et écritures sont autorisées, même celles qui sont censées poser des problèmes de cohérence mémoire. Après tout, le modèle de consistance relaxé vu précédemment n'est rien d'autre que le modèle qui posait problème au départ : on a toujours des Store Queue, des caches non-bloquants, et des tas d'autres optimisations matérielles qui posent des problèmes de cohérence/consistance.</p><div id="r-443499" data-claire-element-id="443499" data-claire-semantic="question"><p id="r-443498" data-claire-element-id="443498">Comment nos processeurs font pour garantir que les accès à des données partagées vont se dérouler correctement ?</p></div><p id="r-443500" data-claire-element-id="443500">Très simple : le processeur fourni quelques instructions de base pour éviter tout problème. Ces instructions spéciales sont ce qu'on appelle des <em><strong>Memory Barriers</strong></em>, aussi appelées des <em><strong>Fences</strong></em>. Il en existe diverses catégories, aussi quelques précisions sont les bienvenues.</p><h5 id="r-full-fence" data-claire-element-id="443506">Full Fence</h5><p id="r-443501" data-claire-element-id="443501">La première catégorie de <em>Fence </em>s'appelle les <em>Full Fences</em>. Ces <em>Full Fences </em>sont des instructions qui vont ordonner au processeur de terminer toutes les écritures et/ou lectures qui la précède avant de passer à l'instruction suivante. Avec ça, il est impossible d’exécuter en avance les instructions placée après une <em>Full Fence</em>. De même, les instructions placées après la <em>Full Fence </em>ne peuvent pas être exécutées après elles. Cela supprime donc toute possibilité de réorganisation entre les instructions placées avant la <em>Full Fence </em>et celles placées après.</p><figure id="r-443503" data-claire-element-id="443504"><img id="r-443502" data-claire-element-id="443502" src="medias/uploads.siteduzero.com_files_384001_385000_384437.png" alt="Image utilisateur"/></figure><p id="r-443505" data-claire-element-id="443505">Tous les processeurs n'implémentent pas de telles <em>Full Fence </em>. Il s'agit en effet d'un luxe que tous ne peuvent pas s'offrir. Pour donner quelques exemples, les processeurs x86 qu'on trouve dans nos PC possèdent de telles <em>Full Fence </em> : il s'agit de l'instruction <code data-claire-semantic="nasm">MFENCE</code>. Par contre, ces <em>Full Fence </em> n'existent pas sur les processeurs Itanium.</p><h5 id="r-load-store-fences" data-claire-element-id="443510">Load/Store Fences</h5><p id="r-443507" data-claire-element-id="443507">Pour plus d'efficacité, certains processeurs procèdent autrement : ils possèdent deux <em>Fences</em> bien distincts. Il existe ainsi un <em>Fences</em> en charge des lectures, et un autre en charge des écritures. On peut ainsi décider de terminer toutes les écritures placées avant la <em>Fence</em> avec une instruction, tandis que la terminaison des lectures sera effectuée par une autre <em>Fence</em>. Cela a ses avantages dans certaines situations.</p><p id="r-443508" data-claire-element-id="443508">Par exemple, imaginons la situation suivante : on charge l'adresse mémoire d'une donnée depuis la mémoire dans un registre, puis on cherche à copier la donnée de cette adresse dans un autre registre. C'est parfaitement possible : notre processeur va d'abord charger l'adresse, puis il utilisera une instruction qui ira lire à l'adresse indiquée dans le registre. Dans un cas pareil, on doit charger l'adresse avant la donnée. Mais si le processeur est autorisé à déplacer une lecture avant une autre, le chargement de la donnée peut alors démarrer avant qu'on connaisse l'adresse... Pour faire en sorte que ces deux lectures (adresse et données) se fassent dans le bon ordre, on doit utiliser une <em>Fence</em> spécialisée dans les lectures.</p><p id="r-443509" data-claire-element-id="443509">Certains processeurs utilisent un nombre de <em>Fences</em> plus élevé, et peuvent ainsi avoir pleins de <em>Fences</em>, chacune dédiée à des cas particuliers. Les processeurs x86 ne sont pas dans ce cas : ils utilisent trois <em>Fences</em>, dont la fameuse<em> Full Fence</em><code data-claire-semantic="nasm">MFENCE</code>, et deux <em>Fences </em>spécialisées. On trouve donc une <em>Fence </em>pour les lectures : <code data-claire-semantic="nasm">LFENCE</code>, et une autre pour les écriture : <code data-claire-semantic="nasm">SFENCE</code>.</p><h5 id="r-et-pour-le-programmeur" data-claire-element-id="443518">Et pour le programmeur ?</h5><div id="r-443512" data-claire-element-id="443512" data-claire-semantic="question"><p id="r-443511" data-claire-element-id="443511">Mais qui se charge de placer ces <em>Fences </em>au bon endroit ?</p></div><p id="r-443513" data-claire-element-id="443513">Et bien il s'agit d'un subtil mélange entre programmeur et compilateur. Généralement, un compilateur peut placer ces <em>Fences</em> au bon endroit, avec un peu d'aide du programmeur. Mais les compilateurs ne le font pas forcément. En effet, un programmeur n'a généralement aucun moyen de dire à son compilateur qu'il faut placer une <em>Fence </em>à tel ou tel endroit. Toutefois, dans certains langages de programmation, on peut dire au compilateur qu'une donnée doit toujours être lue depuis la mémoire RAM. C'est très utile pour préciser que cette donnée est potentiellement partagée par plusieurs processeurs ou manipulable par des périphériques. Cela peut se faire en déclarant des variables en <code data-claire-semantic="c">volatile</code>. Dans certains cas, les compilateurs peuvent placer des <em>Fences </em>lors des lectures ou écritures sur ces variables. Mais ce n'est pas une obligation. En changeant de compilateur, on peut se retrouver avec des <em>Fences </em>manquantes, voire pas de <em>Fences </em>du tout.</p><p id="r-443514" data-claire-element-id="443514">Dans ces cas là, le programmeur doive manipuler explicitement des <em>Fences</em>. Première solution qui vient à l'esprit : utiliser l'assembleur, un langage de programmation dans lequel on utilise directement les instructions du processeur. Cela arrive assez rarement, mais ça existe. Seul problème : le programme obtenu sera spécialisé pour un seul jeu d'instruction, et sera difficilement portable sur d'autres processeurs. Pour limiter la casse, certains systèmes d'exploitations ou compilateurs peuvent aussi fournir des <em>Fences</em> explicites, encapsulées dans des bibliothèques ou cachées dans certaines fonctions.</p><p id="r-443515" data-claire-element-id="443515">Bref, si vous êtes programmeurs, renseignez-vous un peu plus sur ces histoires.</p><p id="r-443516" data-claire-element-id="443516">Et voilà, vous avez donc un aperçu des grandes classes de modèles de consistance existants. Mais ce n'est qu'un aperçu qui cache énormément de choses : on n'a pas parlé des spécificités de chaque processeur. Par exemple, vous ne savez pas quelles sont les différences entre le modèle des processeurs x86 et celui des processeurs PowerPc. Et pourtant, il y en a des différences entre ces deux modèles. Bref, je ne peux que vous conseiller de regarder les documentations techniques de ces processeurs, histoire de vous renseigner sur le sujet. Allez sur les sites des différents constructeurs de processeurs, et cherchez un peu si ça vous intéresse.</p><p id="r-443517" data-claire-element-id="443517">Les curieux qui veulent se documenter sur le sujet d'une façon un peu plus générale auront vraiment intérêt à lire ce tutoriel suivant, qui parle en détail de ces mécanismes de consistance mémoire : <a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf">Shared Memory Consistency Models</a>. De plus, la lecture de ce fichier .pdf sur les <em>Fences </em>pourra vous être utile : <a href="http://irl.cs.ucla.edu/~yingdi/paperreading/whymb.2010.06.07c.pdf">Memory Barriers : a hardware view For Software Hacker's</a>.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
<span class="arrow"></span>
<span class="next">Modèles de consistance</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">
<span class="next">Synchronisation entre Threads</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="SynchronisationentreThreads"></a><h2>Synchronisation entre Threads</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
<span class="arrow"></span>
<span class="next">Fences et Memory Barrier</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
<span class="next">Exclusion mutuelle</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-443521" data-claire-element-id="443521">Comme je l'ai dit dans les chapitres précédents, il n'est pas rare que plusieurs instructions appartenant à des <em>threads</em> différents veuillent accéder à une donnée simultanément. On a vu dans le chapitre précédent comment éviter que deux <em>threads</em> accèdent simultanément à une donnée : il suffit d’exécuter nos instructions les unes après les autres et interdire les accès simultanés. Pour cela, on utilise des instructions atomiques. cela suffit à maintenir la cohérence et la consistance de notre mémoire. Mais cela ne résout pas tout. Au niveau logiciel, d'autres contraintes peuvent apparaitre. Et les <em>Fences</em> et autres instructions atomiques peuvent être d'une grande aide dans ce genre de cas.</p>
</div><a name="Exclusionmutuelle"></a><h2>Exclusion mutuelle</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">
<span class="arrow"></span>
<span class="next">Synchronisation entre Threads</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
<span class="next">Mémoire Transactionelle Matérielle</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-exclusion-mutuelle-1" data-claire-element-id="443573">Exclusion mutuelle</h4><p id="r-443522" data-claire-element-id="443522">Dans les chapitres précédents, on a appris à faire en sorte que des instructions individuelles puissent ne pas être interrompues. Chose assez importante s'il en est. Le seul problème, c'est que notre <em>thread</em> ne peut pas faire tout ce qu'il veut sur une donnée partagée en une seule instruction. Il va devoir utiliser plusieurs instructions successives sur la donnée pour pouvoir en faire ce qu'il veut. Et comme toujours, cela pose encore une fois des problèmes (vous devez en avoir marre de voir cette phrase...).</p><h5 id="r-principe-46" data-claire-element-id="443531">Principe</h5><p id="r-443523" data-claire-element-id="443523">Prenons un exemple : on utilise une donnée partagée entre plusieurs <em>threads</em>, chaque <em>thread</em> s’exécutant sur un processeur x86. Notre donnée est un vulgaire nombre entier. Chaque <em>thread </em>veut l'augmenter de 1 régulièrement. Seul problème, augmenter de 1 la donnée n'est pas effectuée en une seule instruction sur les processeurs x86. Il faut en effet lire la donnée, l'augmenter de 1, puis l'écrire. Et si deux processeurs veulent augmenter simultanément cette donnée, on court à la catastrophe. Chaque <em>thread</em> peut être interrompu à n'importe quel moment par un autre processeur qui voudra modifier sa donnée. Les instructions de nos <em>threads </em>s’exécuteront en série, comme le modèle de consistance nous l'impose, mais le processeur peut parfaitement être dérangé par un autre processeur entre deux instructions.</p><p id="r-443524" data-claire-element-id="443524">Dans notre exemple, voici ce que cela donnerait.</p><figure id="r-443526" data-claire-element-id="443527"><img id="r-443525" data-claire-element-id="443525" src="medias/uploads.siteduzero.com_files_381001_382000_381758.png" alt="Image utilisateur"/></figure><p id="r-443528" data-claire-element-id="443528">On a donc une valeur de départ de 5, qui est augmentée de 1 deux fois, ce qui donne au final 6... Nos processeurs sont pas foutus de faire des calculs tellement basiques qu'on pourrait les laisser à des enfants de 5 ans !</p><p id="r-443529" data-claire-element-id="443529">Bon, blague à part, pour avoir le bon résultat il y a une seule et unique solution : le premier processeur doit avoir un accès exclusif à la donnée partagée. Sans cela, l'autre processeur ira lire une version de la donnée qui n'aura pas encore été modifiée par l'autre processeur. Dans notre exemple, un seul <em>thread </em>doit pouvoir manipuler notre compteur à la fois.</p><p id="r-443530" data-claire-element-id="443530">Et bien sûr, cette réponse peut, et doit se généraliser à presque toutes les autres situations impliquant une donnée partagée. Chaque <em>thread </em>doit donc avoir un accès exclusif à notre donnée partagée, sans qu'aucun autre <em>thread </em>ne puisse manipuler notre donnée. On doit donc définir ce qu'on appelle une <strong>section critique</strong> : un morceau de temps durant lequel un <em>thread </em>aura un accès exclusif à une donnée partagée : notre <em>thread </em>est certain qu'aucun autre <em>thread </em>n'ira modifier la donnée qu'il manipule durant ce temps.</p><h5 id="r-exclusion-mutuelle" data-claire-element-id="443572">Exclusion mutuelle</h5><p id="r-443532" data-claire-element-id="443532">Autant prévenir tout de suite : créer de telles sections critiques se base sur des mécanismes mêlant le matériel et le logiciel. Il existe deux grandes solutions, qui peuvent être soit codées sous la forme de programmes, soit implantées directement dans le silicium de nos processeurs. Voyons la première de ces solutions : l'<strong>exclusion mutuelle</strong>.</p><p id="r-443533" data-claire-element-id="443533">Avec celle-ci, on fait en sorte qu'un seul <em>thread </em>puisse accéder à notre donnée partagée. Un <em>thread </em>qui veut manipuler cette donnée va donc attendre qu'elle soit libre pour la réserver afin de l'utiliser, et la libérera une fois qu'il en a fini avec elle. Si la donnée est occupée par un <em>thread</em>, tous les autres <em>threads </em>devront attendre leur tour.</p><p id="r-443534" data-claire-element-id="443534">Pour mettre en œuvre cette réservation/dé-réservation, on va devoir ajouter quelque chose à chaque donnée à partager. Dans le cas le plus simple, ce quelque chose sera un simple compteur, écrit en mémoire à coté de la donnée, qui indiquera si la donnée partagée est libre ou si un programme se l'est déjà réservée. Dans le cas le plus simple, ce compteur vaudra 0 si la donnée est réservée, et 1 si elle est libre. Ainsi, un <em>thread </em>qui voudra réserver la donnée va d'abord devoir vérifier si ce nombre est à 1 avant de pouvoir réserver sa donnée. Si c'est le cas, il réservera la donnée en passant ce nombre à 0. Si la donnée est réservée par un autre <em>thread</em>, il devra tout simplement attendre son tour. On a alors crée ce qu'on appelle un <strong>verrou d'exclusion mutuelle</strong>.</p><h6 id="r-instructions-atomiques" data-claire-element-id="443564">Instructions atomiques</h6><p id="r-443535" data-claire-element-id="443535">Seul problème : cette vérification et modification du compteur pose problème. Celle-ci ne peut pas être interrompue, sous peine de problèmes. On peut reprendre l'exemple du dessus pour l'illustrer. Si notre compteur est à 0, et que deux <em>threads </em>veulent lire et modifier ce compteur simultanément, il est possible que les deux <em>threads </em>lisent le compteur en même temps : ils liront alors un zéro, et essayeront alors de se réserver la donnée simultanément. Bref, retour à la case départ...</p><p id="r-443536" data-claire-element-id="443536">Quoique non, il y a peut-être possibilité de faire en sorte que la vérification et modification de ce compteur puisse se faire correctement. En tout cas, cette vérification et modification du compteur se fait en plusieurs étapes : une lecture du compteur, puis une écriture si le compteur est à la bonne valeur. Il faudrait que cette lecture et l'écriture se fassent en une seule fois. Pour régler ce problème, certains processeurs fournissent des instructions spécialisées, in-interruptibles, capables d'effectuer cette modification du compteur en une seule fois. Ces instructions peuvent ainsi lire ce compteur, décider si on peut le modifier, et écrire la bonne valeur sans être dérangé par un autre processeur qui viendrait s'inviter dans la mémoire sans autorisation ! Par exemple, sur les processeurs x86, la vérification/modification du compteur vue plus haut peut se faire avec l'instruction <code data-claire-semantic="nasm">test and set</code>.</p><p id="r-443537" data-claire-element-id="443537">D'autres instructions atomiques similaires existent pour résoudre ce genre de problèmes. Leur rôle est toujours d'implémenter des verrous d'exclusion mutuelle plus ou moins sophistiqués, en permettant d'effectuer une lecture, suivie d'une écriture en une seule fois. Ces instructions permettent ainsi de créer des sémaphores, des <em>Locks</em>, etc. Généralement, un programmeur n'a pas à devoir manipuler des instructions atomiques lui-même, mais ne fait que manipuler des abstractions basées sur ces instructions atomiques, fournies par des bibliothèques ou son langage de programmation.</p><p id="r-443538" data-claire-element-id="443538">Voici la plupart de ces instructions atomiques les plus connues :</p><table id="r-443561" data-claire-element-id="443561"><thead id="r-443544" data-claire-element-id="443544"><tr id="r-443543" data-claire-element-id="443543"><th id="r-443540" data-claire-element-id="443540"><p id="r-443539" data-claire-element-id="443539">Instruction</p></th><th id="r-443542" data-claire-element-id="443542"><p id="r-443541" data-claire-element-id="443541">Description</p></th></tr></thead><tbody id="r-443560" data-claire-element-id="443560"><tr id="r-443549" data-claire-element-id="443549"><td id="r-443546" data-claire-element-id="443546"><p id="r-443545" data-claire-element-id="443545">Compare And Swap</p></td><td id="r-443548" data-claire-element-id="443548"><p id="r-443547" data-claire-element-id="443547">Cette instruction va lire une donnée en mémoire, va comparer celle-ci à l'opérande de notre instruction (une donnée fournie par l'instruction), et va écrire un résultat en mémoire si ces deux valeurs sont différentes. Ce fameux résultat est fourni par l'instruction, ou est stocké dans un registre du processeur.</p></td></tr><tr id="r-443554" data-claire-element-id="443554"><td id="r-443551" data-claire-element-id="443551"><p id="r-443550" data-claire-element-id="443550">Fetch And Add</p></td><td id="r-443553" data-claire-element-id="443553"><p id="r-443552" data-claire-element-id="443552">Cette instruction charge la valeur de notre compteur depuis la mémoire, l'incrémente, et écrit sa valeur en une seule fois. Elle permet de réaliser ce qu'on appelle des sémaphores. Elle permet aussi d'implémenter des compteurs concurrents.</p></td></tr><tr id="r-443559" data-claire-element-id="443559"><td id="r-443556" data-claire-element-id="443556"><p id="r-443555" data-claire-element-id="443555">XCHG</p></td><td id="r-443558" data-claire-element-id="443558"><p id="r-443557" data-claire-element-id="443557">Cette instruction peut échanger le contenu d'un registre et d'un morceau de mémoire de façon atomique. Elle est notoirement utilisée sur les processeurs x86 de nos PC, qui implémentent cette instruction.</p></td></tr></tbody></table><p id="r-443562" data-claire-element-id="443562">Comme je l'ai dit plus haut, ces instructions empêchent tout autre processeur d'aller lire ou modifier la donnée qu'elles sont en train de modifier. Ainsi, lors de l’exécution de l'instruction atomique, aucun processeur ne peut aller manipuler la mémoire : notre instruction atomique va alors bloquer la mémoire et en réserver l'accès au bus mémoire rien que pour elle. Cela peut se faire en envoyant un signal sur le bus mémoire, ou pas d'autres mécanismes de synchronisation entre processeurs. Quoiqu'il en soit, le cout de ce blocage de la mémoire est assez lourd : cela peut prendre un sacré bout de temps, ce qui fait que nos instructions atomiques sont lentes.</p><p id="r-443563" data-claire-element-id="443563">Du moins, c'est le cas si la donnée est en mémoire et que le processeur est un peu stupide. En effet, sur certains processeurs, on peut optimiser le tout dans le cas où la donnée est dans le cache. Dans ce cas, pas besoin de bloquer la mémoire : le processeur a juste à écrire dans la mémoire cache, et les mécanismes de cohérence des caches se contenteront de mettre à jour la donnée de façon atomique automatiquement. Le cout des instructions atomiques est alors fortement amorti.</p><h6 id="r-problemes-avec-les-verrous-d-exclusion-mutuelle" data-claire-element-id="443571">Problèmes avec les verrous d'exclusion mutuelle</h6><p id="r-443565" data-claire-element-id="443565">Néanmoins, cette technique des verrous d'exclusion mutuelle pose quelques problèmes.</p><p id="r-443566" data-claire-element-id="443566">Premièrement, ils imposent qu'un seul <em>thread </em>puisse accéder à notre donnée, en forçant tous les autres à se mettre en pause. Les autres <em>thread </em>doivent alors attendre que la donnée partagée soit libérée pour continuer leur exécution. Et c'est obligatoire, même s'ils veulent lire la donnée sans la modifier.</p><p id="r-443567" data-claire-element-id="443567">Deuxièmement, si on ne fait pas trop gaffe, il est possible qu'un <em>thread </em>réserve la donnée en oubliant la libérer. Dans ce cas, tous les autres <em>threads </em>seront définitivement bloqués. Ce genre de chose est souvent synonyme de mauvaise programmation, mais c'est malgré tout un défaut des verrous d'exclusion mutuelle.</p><p id="r-443568" data-claire-element-id="443568">Enfin, il est possible qu'un <em>thread </em>n'aie jamais accès à la donnée partagée parce que tous les autres <em>threads </em>passent devant : à chaque fois que le <em>thread </em>regarde si la donnée est libre, elle est occupé par un de ses collègues indélicat qui sera passé avant.</p><p id="r-443569" data-claire-element-id="443569">Deuxièmement : sur certains processeurs, ces instructions atomiques bloquent totalement tout accès à la mémoire durant un certain moment. Si la donnée partagée est placée en mémoire, tout accès à la mémoire, même inoffensif ou ne touchant pas à la donnée partagée devra attendre al fin de l'instruction atomique. Si on rajoute le cout des <em>Fences</em>, souvent placées avant ces instructions atomiques, cela commence à faire beaucoup. Alors certes, on peut limiter la casse : par exemple, si la donnée partagée est dans la mémoire cache, pas besoin de bloquer la mémoire. On peut alors écrire directement dans la mémoire cache, sans avoir à bloquer quoique ce soit : les mécanismes de cohérence des caches s'occuperont alors de gérer la lecture et l'écriture de façon atomique. Mais quoiqu'il en soit, ces blocages peuvent être assez couteux.</p><p id="r-443570" data-claire-element-id="443570">Bref, nos verrous d’exclusion mutuelle ne sont pas la panacée.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">
<span class="arrow"></span>
<span class="next">Synchronisation entre Threads</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
<span class="next">Mémoire Transactionelle Matérielle</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="MmoireTransactionelleMatrielle"></a><h2>Mémoire Transactionelle Matérielle</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
<span class="arrow"></span>
<span class="next">Exclusion mutuelle</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">
<span class="next">Instructions SIMD</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-memoire-transactionelle-materielle" data-claire-element-id="443607">Mémoire Transactionelle Matérielle</h4><p id="r-443574" data-claire-element-id="443574">Pour résoudre les différents problèmes posés par les verrous d'exclusion mutuelle, les chercheurs en informatique ont inventés diverses techniques matérielles ou logicielles pour se passer de ces verrous. Une de ses technique s'appelle la mémoire transactionnelle. Avec la mémoire transactionnelle, on n'utilise pas de verrous d'exclusion mutuelle, et plusieurs <em>threads </em>peuvent accéder à une donnée sans se la réserver. La création de nos sections critiques est alors assez différente de ce que l'on doit faire avec les verrous.</p><p id="r-443575" data-claire-element-id="443575">La mémoire transactionnelle est basée sur un principe simple. Avant, on disposait d'instructions atomiques. Maintenant, on peut carrément rendre atomiques des morceaux de programmes complets. Ces morceaux de programmes atomiques, ce sont ce qu'on appelle des <strong>transactions</strong>. Ces transactions ne sont rien d'autre qu'un morceau de programme, une suite d'instruction qui va s’exécuter et faire ce qu'elle veut de la donnée partagée. Cette transaction peut ainsi lire notre donnée, faire ses calculs, etc, puis l'écrire. Tout ce que fait notre transaction reste plus ou moins &quot;invisible&quot; des autres processeurs. Pendant que notre transaction s’exécute, tout se passe comme si notre transaction ne modifiait pas notre donnée. Dans le cas où la donnée partagée n'a pas été modifiée par un autre processeur durant l’exécution d'une transaction, celle-ci peut alors écrire son résultat en mémoire, et le rendre visible à tous les autres processeurs. Dans ce cas, tout s'est bien passé. Mais dans le cas contraire, la transaction échoue et doit rependre depuis le début et tous les changements effectués par la transaction seront effacés, non pris en compte.</p><p id="r-443576" data-claire-element-id="443576">Cette mémoire transactionnelle a quelques avantages sur les verrous d'exclusion mutuelle. Déjà, elle est plus souple que ces verrous : il n'y pas de possibilités de blocages ou de bugs bizarres comme on en voit avec les verrous. De plus, on n'a pas besoin d'utiliser d'instructions atomiques au cas où un autre processeur voudrait aller modifier notre donnée partagée en même temps. On n'a plus à utiliser ces instructions couteuses en terme de performance juste au cas où.</p><p id="r-443577" data-claire-element-id="443577">Cette mémoire transactionnelle est souvent implantée dans certains langages de programmation de façon purement logicielle, en utilisant des exclusions mutuelles bien cachées sous le tapis par le compilateur ou la bibliothèque utilisée. Ces versions logicielles de la mémoire transactionnelle sont souvent beaucoup plus lentes que ce qu'on peut obtenir avec des verrous d'exclusion mutuelle. Mais cette mémoire transactionnelle peut aussi être implantée de façon matérielle. Il existe plusieurs façons de l'implanter, et on va voir ce que cela donne pour les implémentations les plus connues.</p><h5 id="r-instructions-ll-sc" data-claire-element-id="443581">Instructions LL/SC</h5><p id="r-443578" data-claire-element-id="443578">La première technique de mémoire transactionnelle matérielle est basée sur deux instructions : Load-Link et Store-Conditional. Elle est assez fréquente sur certains processeurs possédant peu d'instructions qu'on appelle des processeurs RISC. Elle est notamment utilisée sur les processeurs POWER PC, ainsi que sur certains processeurs MIPS ou ARM, ainsi que sur le fameux processeur Alpha, le plus beau de tous.</p><p id="r-443579" data-claire-element-id="443579">L'instruction Load-Link va lire une donnée depuis la mémoire de façon atomique. Vient ensuite l'instruction Store-Conditional, qui est toujours précédée d'une instruction Load-Link. Cette instruction Store-Conditional écrit une donnée en mémoire à condition que notre donnée partagée en mémoire n'aie pas été modifiée depuis l’exécution de l'instruction Load-Link.<br/> Il arrive parfois que l'instruction Store-Conditionnal échoue alors que notre donnée partagée n'a pas été modifiée. Du moins, c'est le cas sur certains processeurs : sur ceux-ci, l’exécution d'interruptions ou d'exceptions matérielles dans une transaction la fait échouer. Mais c'est un défaut que certains processeurs n'ont pas.</p><p id="r-443580" data-claire-element-id="443580">Son seul problème, c'est qu'elle ne peut manipuler qu'une seule donnée partagée simple. Impossible de manipuler des données plus grandes qu'une certaine taille. Généralement, on ne peut pas dépasser la taille d'un registre. Notre instruction Load-Link va en effet charger la donnée partagée dans un registre : si on veut utiliser des données plus grosses que notre registre, il n'est pas possible d'utiliser Load-Link, et on doit revenir aux verrous d'exclusion mutuelle, ou faire un mélange entre mémoire transactionnelle et verrous.</p><h5 id="r-versions-evoluees" data-claire-element-id="443586">Versions évoluées</h5><p id="r-443582" data-claire-element-id="443582">Mais ces instructions Load-Link et Store Conditionnal ne sont pas les seul mécanismes de mémoire transactionnelle matérielle. D'autres mécanismes un peu plus évolués existent. Ceux-ci se basent sur les mécanismes de cohérence des caches au chapitre précédent. Avec ces techniques, les changements effectués dans le cache d'un processeur par une transaction ne vont pas être propagés par les mécanismes de cohérence des caches tant que celle-ci ne termine pas correctement. Tout ce passe comme si les mécanismes de cohérence des caches étaient mis en pause lors du démarrage d'une transaction. Une fois la transaction terminé, le matériel vérifie que les données manipulées par la transaction n’ont pas été accédées, et les modifications faites par celle-ci sont alors propagées dans les caches des autres processeurs si la transaction réussit. Par contre, si la transaction foire, les données modifiée par la transaction sont marquées <em>Invalid </em>par les mécanismes de cohérence des caches. Tout se passe comme si les mécanismes de cohérence des caches du processeur se remettent en route.</p><p id="r-443583" data-claire-element-id="443583">De même, les changements effectués par notre transaction sur les registres du processeur doivent être annulé si celle-ci échoue. Pour cela, on peut décider de sauvegarder une copie des registres du processeur au démarrage de la transaction, ou décider d'annuler les changements effectués lors de la transaction. Annuler les changements effectués lors d'une transaction n'est pas une chose simple. Nos processeurs permettent de le faire en réutilisant un circuit déjà utilisé dans d'autres circonstances : le <em>Reorder Buffer</em>. Mais celui a une taille limité à a peut-prêt une centaine d'instructions sur les processeurs modernes, ce qui limite la quantité d’instructions qu'on peut placer dans une transaction. La méthode concurrente, qui consiste à sauvegarder les registres du processeur, n'a pas ce problème.</p><p id="r-443584" data-claire-element-id="443584">Il arrive parfois que des transactions échouent sans qu'un autre <em>thread </em>n'aie fait quoique ce soit. Sur certains processeurs, l’exécution de certaines instructions critiques peut ainsi faire échouer automatiquement une transaction par mesure de sureté. Et parfois, cela peut arriver pour d'autres raisons. Bien sûr, certains processeurs n'ont pas ce genre de problèmes, mais ils sont plutôt rares.</p><p id="r-443585" data-claire-element-id="443585">C'est des techniques de ce genre qui sont utilisées sur les processeurs récents. Comme exemple, on peut citer le cas du processeur<em> Blue gene</em> d'IBM. Si vous ne connaissez pas ce processeur, sachez qu'il est utilisé sur deux des plus grands supercaculateur au monde : le supercalculateur <em>sequoia</em> du Lawrence Livermore National Laboratory, et le supercalculateur Mira du Argonne National Laboratory. <br/> Sur ce processeur, chaque donnée dans le cache peut être présente en plusieurs exemplaires. Lors du démarrage d'une transaction, le processeur va ainsi modifier notre donnée partagée dans un de ses caches créant une nouvelle version de la donnée. Les autres processeurs peuvent éventuellement faire de même. Lorsque la transaction termine, les changements sont propagés dans les autres caches. Si un seul processeur a manipulé la donnée partagée, celle-ci ne sera présente qu'en une seule version dans les caches des autres processeurs. Mais si plusieurs processeurs ont modifiée cette donnée dans leurs caches, ils auront chacun crée une nouvelle version de la donnée, et plusieurs versions d'une même donnée différente sera présente dans les caches des processeurs après intervention des mécanismes de cohérence des caches. Pour vérifier qu'une transaction a échoué, il suffit juste de vérifier combien de versions de la donnée se trouvent dans les caches : si on a plusieurs versions, la transaction a échouée et doit reprendre. Pour connaitre la version de la donnée, notre processeur va incorporer quelques bits supplémentaires avec notre donnée, qui indiqueront son numéro de version.</p><h5 id="r-speculative-lock-elision" data-claire-element-id="443593">Speculative Lock Elision</h5><p id="r-443587" data-claire-element-id="443587">Je suis sûr que vous ne voyez strictement aucun rapport entre les instructions atomiques et la mémoire transactionnelle. Mais méfiez-vous : la mémoire transactionnelle peut aussi se trouver là où on ne l'attend pas. Il peut y avoir un rapport !</p><p id="r-443588" data-claire-element-id="443588">Comme je l'ai déjà dit, les instructions atomiques sont lentes. Très lentes. Sans compter que ces instructions cherchent à installer des verrous qui empêchent à deux <em>threads </em>de s’exécuter simultanément. Le problème, c'est que les instructions atomiques sont utilisées de façon assez pessimistes : il arrive qu'on les utilise au cas où un <em>thread </em>irait aller modifier notre donnée partagée en même temps qu'un autre manipule notre donnée. Mais il arrive que dans certains cas, on réserve une donnée partagée alors qu'aucun autre <em>thread </em>ne cherche à y accéder : la réservation est inutile, mais on doit la faire au cas où. Aussi, pour accélérer l'exécution des instructions atomiques, des chercheurs se sont penchés sur ce problème de réservations inutiles. Et ils ont trouvés une solution assez sympathique, basée sur la mémoire transactionnelle. Au lieu de devoir mettre un verrous et de réserver notre donnée juste au cas où, on peut agir d'une façon un peu plus optimiste.</p><p id="r-443589" data-claire-element-id="443589">Rien n’empêche de transformer nos instructions atomiques servant pour les réservations en instructions permettant de démarrer des transactions. Bien évidemment, les instructions atomiques servant à libérer la donnée partagée vont marquer la fin de notre transaction. Ce mécanisme tente donc de se passer des instructions atomiques en les transformant en transaction une première fois, puis revient à la normale en cas d'échec. Il s'appelle le <em><strong> Lock Elision</strong></em>.</p><p id="r-443590" data-claire-element-id="443590">Ainsi, on n’exécute pas l'instruction atomique permettant d'effectuer une réservation, et on la transforme en une simple instruction de lecture de la donnée partagée. Une fois cela fait, on commence à exécuter la suite du programme en faisant en sorte que les autres processeurs ne voient pas les modifications effectuées sur nos données partagées. Puis, vient le moment de libérer la donnée partagée via une autre instruction atomique. A ce moment, si aucun autre <em>thread</em> n'a écrit dans notre donnée partagée, tout ira pour le mieux : on pourra rendre permanents les changements effectués. Par contre, si jamais un autre <em>thread </em>se permet d'aller écrire dans notre donnée partagée, on doit annuler les changements faits et les faire oublier. A la suite de l'échec de cette exécution optimiste, cette transaction cachée, le processeur reprendre son exécution au début de notre fausse transaction, et va exécuter son programme normalement : le processeur effectuera alors de vraies instructions atomiques, au lieu de les interpréter comme des débuts e transactions.</p><p id="r-443591" data-claire-element-id="443591">Il arrive parfois que le premier essai échoue lamentablement : si un autre <em>thread </em>a beaucoup de chance de manipuler une donnée partagée en même temps qu'un autre, le premier essai a de fortes chances de planter. Pour plus efficacité, certains processeurs cherchent parfois à éviter ce genre de situation en estimant la probabilité que le premier essai (la transaction) échoue. Pour cela, ils incorporent un circuit permettant d'évaluer les chances que notre premier marche en tant que transaction : le <em>Transaction Predictor</em>. Une fois cette situation connue, le processeur décide ou non d’exécuter ce premier essai en tant que transaction.</p><p id="r-443592" data-claire-element-id="443592">Ceux qui veulent se renseigner sur cette technique plus en détail et qui veulent aller plus loin que ce misérable petit tutoriel de vulgarisation peuvent aller lire l'article original des créateurs de cette technique ici : <a href="http://pages.cs.wisc.edu/~rajwar/papers/micro01.pdf">Speculative Lock Elision</a>. On remarquera que dans la version originale, présentée dans ce papier, on n'a pas besoin de rajouter d'instructions. Ce n'est toutefois pas une obligation, comme on va bientôt le voir.</p><h5 id="r-l-exemple-avec-le-x86" data-claire-element-id="443606">L'exemple avec le x86</h5><p id="r-443594" data-claire-element-id="443594">Autre exemple, on peut citer les processeurs Intel récents. Je pense notamment aux processeurs basés sur l’architecture Haswell. Au alentours de mars 2013, de nouveaux processeurs Intel sortiront sur le marché : ce seront les premiers processeurs grand public qui supporteront la mémoire transactionnelle matérielle. Attardons-nous un peu sur ces processeurs, et sur l'implémentation de la mémoire transactionnelle matérielle de ces processeurs.</p><p id="r-443595" data-claire-element-id="443595">Sur ces processeurs, deux modes sont disponibles pour la mémoire transactionnelle matérielle : le mode TSX, et le mode HLE.</p><h6 id="r-tsx" data-claire-element-id="443600">TSX</h6><p id="r-443596" data-claire-element-id="443596">Le mode TSX correspond simplement à quelques instructions supplémentaires permettant de gérer la mémoire transactionnelle matérielle. On trouve ainsi trois nouvelles instructions : <code data-claire-semantic="nasm">XBEGIN</code>, <code data-claire-semantic="nasm">XEND</code> et <code data-claire-semantic="nasm">XABORT</code>.</p><p id="r-443597" data-claire-element-id="443597"><code data-claire-semantic="nasm">XBEGIN</code> sert en quelque sorte de top départ : elle sert à démarrer une transaction. Toutes les instructions placées après elles dans l'ordre du programme seront ainsi dans une transaction. Au cas où la transaction échoue, il est intéressant de laisser le programmeur quoi faire. Pour cela, l'instruction <code data-claire-semantic="nasm">XBEGIN</code> permet au programmeur de spécifier une adresse. Cette adresse permet de pointer sur un morceau de code permettant de gérer l'échec de la transaction. En cas d'échec de la transaction, notre processeur va reprendre automatiquement son exécution à cette adresse.</p><p id="r-443598" data-claire-element-id="443598">Évidemment, si on a de quoi marquer le début d'une transaction, il faut aussi indiquer sa fin. Pour cela, on utilise l'instruction <code data-claire-semantic="nasm">XEND</code>. <code data-claire-semantic="nasm">XABORT</code> quand à elle, va servir à stopper l’exécution d'une transaction : elle sert à faire planter notre transaction si jamais on s’aperçoit d'un problème lors de l’exécution de notre transaction.</p><p id="r-443599" data-claire-element-id="443599">Lors de la fin d'une transaction, le processeur va automatiquement reprendre à l'adresse indiquée par <code data-claire-semantic="nasm">XBEGIN</code>, et va remmettre le processeur dans l'état dans lequel il était avant le début de la transaction : les registres modifiés par la transaction sont remis dans leur état initial, à une exception prêt : EAX. Celui-ci sert à stocker un code d'erreur qui indique les raisons de l'échec d'une transaction. Cela permet de donner des informations au code de gestion d'échec de transaction, qui peut alors gérer la situation plus finement.</p><h6 id="r-hle" data-claire-element-id="443605">HLE</h6><p id="r-443601" data-claire-element-id="443601">Les processeurs Haswall supportent aussi le <em>Lock Elision</em>. Les instructions atomiques peuvent ainsi supporter l’exécution en tant que transaction à une condition : qu'on leur rajoute un préfixe.</p><p id="r-443602" data-claire-element-id="443602">Le préfixe, pour les instructions x86, correspond simplement à un octet optionnel, placé au début de notre instruction dans la mémoire. Cet octet servira à donner des indications au processeur, qui permettront de modifier le comportement de notre instruction. Par exemple, les processeurs x86 supportent pas mal d'octets de préfixe : LOCK, qui permet de rendre certaines instructions atomiques, ou REPNZE, qui permet de répéter certaines instruction tant qu'une condition est requise.</p><p id="r-443603" data-claire-element-id="443603">Le fait est que certains préfixes n'ont pas de signification pour certaines instructions : les placer devant ces instructions n'a alors pas de sens. Autrefois, ils étaient totalement ignorés, et le processeur ne tenait pas compte de ces préfixes sans signification. Pour supporter le <em>Lock Elision</em>, ces préfixes sans significations sont réutilisés histoire de dire au processeur : cet instruction atomique doit subir la <em>Lock Elision</em> et doit être tentée en tant que transaction. Deux &quot;nouveaux&quot; préfixes font leur apparition : <code data-claire-semantic="nasm">XAQUIRE</code> qui sert à indiquer que notre instruction atomique doit être tentée en tant que transaction ; et <code data-claire-semantic="nasm">XRELEASE</code> qui dit que la transaction spéculative est terminée.</p><p id="r-443604" data-claire-element-id="443604">Ainsi, un programme peut être conçu pour utiliser la <em>Lock Elision</em>, tout en fonctionnant sur des processeurs plus anciens, qui ne la supportent pas ! Belle tentative de garder la rétrocompatibilité.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
<span class="arrow"></span>
<span class="next">Exclusion mutuelle</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">
<span class="next">Instructions SIMD</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="InstructionsSIMD"></a><h2>Instructions SIMD</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
<span class="arrow"></span>
<span class="next">Mémoire Transactionelle Matérielle</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
<span class="next">Instructions SIMD</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-443612" data-claire-element-id="443612">Nous allons maintenant continuer, et aborder une autre forme de parallélisme : le <strong>parallélisme de données</strong>. Traiter des données différentes en parallèle a été la première forme de parallélisme réellement exploitée. Il faut dire que de nombreuses situations s'y prêtes relativement bien : traitement d'image, manipulation de sons, vidéo, rendu 3d, etc. Et c'est pour cela que ce genre de parallélisme a été le premier à être adopté sur les architectures récentes. Mais pour ce faire, il a quand même fallu concevoir des processeurs et des architectures adaptées.</p><p id="r-443613" data-claire-element-id="443613">Une solution simple est d'utiliser plusieurs processeurs qui exécuteront tous la même instruction, mais chacun sur des données différentes. Cette solution a autrefois étés utilisée sur certains supercalculateurs, comme les Thinking machines CM-1 et CM-2. Ces ordinateurs possédaient environ 64000 processeurs minimalistes, qui exécutaient tous la même instruction au même moment. Mais ce genre de solution est vraiment quelque chose d'assez lourd, qui ne peut être efficace et rentable que sur des grosses données, et sur des ordinateurs chers et destinés à des calculs relativement importants. N'espérez pas commander ce genre d’ordinateurs pour noël !</p><p id="r-443614" data-claire-element-id="443614">Comme on va le voir, il existe d'autres manières d'exploiter le parallélisme de données au niveau matériel. Ainsi, de nombreux jeux d'instructions spécialisés sont apparus et des processeurs spéciaux ont étés inventés. Mais assez de bavardages, commençons !</p>
</div><a name="InstructionsSIMD"></a><h2>Instructions SIMD</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">
<span class="arrow"></span>
<span class="next">Instructions SIMD</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
<span class="next">Exemples : MMX, SSE et AVX</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-instructions-simd" data-claire-element-id="443647">Instructions SIMD</h4><p id="r-443615" data-claire-element-id="443615">Certains processeurs possèdent des instructions pouvant manipuler plusieurs données simultanément. Ainsi, le SIMD est intégré directement dans le jeu d'instruction du processeur, qui est spécialement conçu pour en tirer partie.</p><p id="r-443616" data-claire-element-id="443616">Il existe différents types d'instructions SIMD, comme on le voir dans ce qui suit. Mais dans tous les cas, celles-ci travaillent sur un ensemble de données de même taille et de même type. Ces données sont rassemblées dans des espèces de blocs de données, d'une taille fixe, qu'on appelle un <strong>paquet</strong>. Ces paquets contiennent plusieurs nombres entiers ou nombres flottants placés les uns à coté des autres et regroupés dans ce vecteur.</p><p id="r-443617" data-claire-element-id="443617">Quand on exécutera une instruction sur un vecteur, celle-ci traitera ces entiers ou flottants indépendamment : au lieu de les traiter unes par unes, les données présentes dans ce paquet seront traitées simultanément.</p><p id="r-443618" data-claire-element-id="443618"><em>Exemple avec une addition</em>.</p><figure id="r-443620" data-claire-element-id="443621"><img id="r-443619" data-claire-element-id="443619" src="medias/uploads.siteduzero.com_files_387001_388000_387271.png" alt="Image utilisateur"/></figure><p id="r-443622" data-claire-element-id="443622">Pour se faire, notre processeur contient souvent une unité de calcul capable de travailler en parallèle sur chaque donnée d'un paquet.</p><p id="r-443623" data-claire-element-id="443623">Comme instructions SIMD, on trouve souvent :</p><ul id="r-443632" data-claire-element-id="443632"><li id="r-443625" data-claire-element-id="443625"><p id="r-443624" data-claire-element-id="443624">des instructions arithmétiques du style additions, soustractions, multiplications, etc ;</p></li><li id="r-443627" data-claire-element-id="443627"><p id="r-443626" data-claire-element-id="443626">des opérations logiques, comme des ET, des OU, des décalages ou des rotations ;</p></li><li id="r-443629" data-claire-element-id="443629"><p id="r-443628" data-claire-element-id="443628">des comparaisons ;</p></li><li id="r-443631" data-claire-element-id="443631"><p id="r-443630" data-claire-element-id="443630">ou des opérations de conversion.</p></li></ul><p id="r-443633" data-claire-element-id="443633">Mais nos instructions précédentes en suffisent pas, et il faut parfois effectuer des manipulations spéciales sur nos paquets : des permutations, regrouper plusieurs données indépendantes dans un paquet, etc. Pour cela, on utilise donc des instructions supplémentaires.</p><p id="r-443634" data-claire-element-id="443634">Nos processeurs contiennent des registres spécialisés pouvant chacun contenir un paquet. Pour traiter un paquet, il suffira alors de le charger dans un de ces registres, et éxecuter une ou plusieurs instructions dessus. Cela a une conséquence : les registres ayant tous une taille fixe, la taille d'un paquet est fixée une fois pour toute par le jeu d'instruction. Cela implique que suivant la taille des données à manipuler, on pourra en placer plus ou moins dans un paquet.</p><figure id="r-443636" data-claire-element-id="443637"><img id="r-443635" data-claire-element-id="443635" src="medias/uploads.siteduzero.com_files_385001_386000_385935.png" alt="Image utilisateur"/></figure><p id="r-443638" data-claire-element-id="443638">On devra utiliser des instructions différentes suivant ce qu'on met dans le paquet : suivant la taille des données, et le type de celle-si, on devra effecteur des manipulations différentes. Par exemple, on devra utiliser deux instructions différente suivant le type des données présentes dans le vecteur (flottant, entier, booléens, etc). Il faudra aussi gérer la taille des données : il faudra bien savoir comment découper le paquet en données à traiter en parallèle. Et pour cela, on utilise différentes instructions suivant ce que contient le paquet : l'instruction pour manipuler des paquets contenant des entiers de 16 bits sera différente de celle manipulant des entiers de 32 bits.</p><h5 id="r-arithmetique-saturee" data-claire-element-id="443646">Arithmétique saturée</h5><p id="r-443639" data-claire-element-id="443639">Les instructions SIMD sont très souvent utilisées pour manipuler des données censées représenter de la vidéo, ou des images, voir du son. Et cela a une certaine incidence sur la façon dont se comportent les instructions dans certaines situations.</p><div id="r-443641" data-claire-element-id="443641" data-claire-semantic="question"><p id="r-443640" data-claire-element-id="443640">Par exemple, que se passe-il lors d'un <em>Overflow </em>?</p></div><p id="r-443642" data-claire-element-id="443642">Un <em>Overflow </em>? Cela mérite peut-être quelques explications.</p><p id="r-443643" data-claire-element-id="443643">Les instructions arithmétiques et quelques autres manipulent des nombres ou des données de taille fixe, qui ne peuvent prendre leurs valeurs que dans un intervalle déterminé par une valeur minimale et une valeur maximale. Si le résultat d'un calcul sort de cet intervalle, il ne pas être représenté dans notre ordinateur : il se produit ce qu'on appelle un <em>overflow</em>. Lorsqu'on travaille avec des paquets, il est évident que si un résultat prend plus de bits que ce qu'il est censé prendre, il vaut mieux éviter qu'il déborde sur la donnée d'à coté. Il faut donc trouver une solution pour éviter les catastrophe.</p><p id="r-443644" data-claire-element-id="443644">Première solution : on ne conserve que les bits de poids faibles du résultat et les bits en trop sont simplement oubliés. Par exemple, si on additionne deux nombres de 32 bits, le résultats est censé prendre 33 bits, mais on ne gardera que les 32 bits de base, et on oubliera le bit en trop. Seul problème : en faisant cela, une opération sur deux nombres très grands peut donner un nombre très petit, et cela peut poser des problèmes lorsqu'on manipule de la vidéo, des images ou du son. Imaginez que l'on représente une couleur par un entier de 8 bits (ce qui est souvent le cas) : par exemple, le blanc correspondra à la valeur maximal de cet entier, et le noir à 0. En ajoutant deux couleurs très proches du blanc (et donc deux entiers assez grands), le résultat obtenu sera un entier assez petit, qui sera donc proche du noir... Ce qui est fort peu crédible ! Et les mêmes problèmes peuvent arriver dans pleins d'autres situations : il vaut mieux qu'un son trop fort sature au lieu de le transformer en un son trop faible, par exemple.</p><p id="r-443645" data-claire-element-id="443645">Mais il existe une solution : utiliser ce qu'on appelle <strong>l'arithmétique saturée</strong>. Si un résultat est trop grand au point de générer un <em>overflow</em>, on arrondi le résultat au plus grand entier supporté par le processeur. Il va de soit que pas mal d'instructions SIMD utilisent cette arithmétique, vu qu'elles sont destinée au traitement d'image ou de son.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">
<span class="arrow"></span>
<span class="next">Instructions SIMD</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
<span class="next">Exemples : MMX, SSE et AVX</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="ExemplesMMXSSEetAVX"></a><h2>Exemples : MMX, SSE et AVX</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
<span class="arrow"></span>
<span class="next">Instructions SIMD</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">
<span class="next">Les processeurs vectoriels</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-exemples-mmx-sse-et-avx" data-claire-element-id="443831">Exemples : MMX, SSE et AVX</h4><p id="r-443648" data-claire-element-id="443648">On a donc vu un peu de théorie sur ces instructions SIMD, mais un peu de pratique ne ferait surement pas de mal. On va donc voir à quoi peuvent bien ressembler ces instructions avec des exemples concrets : on va étudier les instructions des processeurs x86, présents dans nos PC.</p><p id="r-443649" data-claire-element-id="443649">Le jeu d'instruction de nos PC qui fonctionnent sous Windows est appelé le x86. C'est un jeu d'instructions particulièrement ancien, apparu certainement avant votre naissance : 1978. Depuis, de plus en plus d'instructions ont été ajoutées et rajoutées : ces instructions sont ce qu'on appelle des <strong>extensions x86</strong>. On peut citer par exemple les extensions MMX, SSE, SSE2, voir 3dnow!. Une grande quantité de ces extensions x86 sont des ajouts d'instructions SIMD.</p><p id="r-443650" data-claire-element-id="443650">Avant toute chose, je tiens à signaler que les processeurs x86 ne sont pas les seuls à posséder des extensions de leur jeu d'instruction SIMD. Les processeurs PowerPC, ARM, SPARC, MIPS et bien d'autres, ont eux aussi des instructions SIMD dignes de ce nom et qui mériteraient toutes un détour. Mais il faut bien faire un choix, et j'ai personnellement décidé de voir les différentes instructions SIMD des processeurs x86.</p><h5 id="r-mmx" data-claire-element-id="443714">MMX</h5><p id="r-443651" data-claire-element-id="443651">Les premières instructions SIMD furent fournies par une extension x86 du nom de <strong>MMX</strong>. Ce MMX a été introduit par Intel dans les années 1996 sur le processeur Pentium MMX et a perduré durant quelques années avant d'être remplacé par les extensions SSE.</p><h6 id="r-registres-mmx" data-claire-element-id="443663">registres MMX</h6><p id="r-443652" data-claire-element-id="443652">Ce MMX introduisait 8 &quot;nouveaux registres&quot; (vous verrez, je ne mets pas des guillemets par hasard), du nom de MM0, MM1, MM2, MM3, MM4, MM5, MM6 et MM7. Ceux-ci avaient une taille de 64 bits, ce qui leur permettait de contenir soit :</p><ul id="r-443661" data-claire-element-id="443661"><li id="r-443654" data-claire-element-id="443654"><p id="r-443653" data-claire-element-id="443653">un entier de 64 bits ;</p></li><li id="r-443656" data-claire-element-id="443656"><p id="r-443655" data-claire-element-id="443655">deux entiers de 32 bits ;</p></li><li id="r-443658" data-claire-element-id="443658"><p id="r-443657" data-claire-element-id="443657">quatre entiers de 16 bits ;</p></li><li id="r-443660" data-claire-element-id="443660"><p id="r-443659" data-claire-element-id="443659">huit entiers de 8 bits.</p></li></ul><p id="r-443662" data-claire-element-id="443662">Le MMX ne manipulait que des nombres entiers : pas de nombres flottants à l'horizon.</p><h6 id="r-instructions-mmx" data-claire-element-id="443706">Instructions MMX</h6><p id="r-443664" data-claire-element-id="443664">Le MMX ajoutait aussi pas mal d'instructions SIMD assez basiques. Ces instructions correspondaient aux instructions qu'on rencontre habituellement dans un jeu d'instruction normal. Ainsi, on trouve des instructions arithmétiques, qui travaillent sur des entiers regroupés dans un paquet occupant un registre MMx. <br/> On trouve ainsi des instructions d'addition et de soustraction :</p><ul id="r-443675" data-claire-element-id="443675"><li id="r-443666" data-claire-element-id="443666"><p id="r-443665" data-claire-element-id="443665"><code data-claire-semantic="nasm">PADDB</code>, qui additionne deux paquets d'entiers de 8 bits ;</p></li><li id="r-443668" data-claire-element-id="443668"><p id="r-443667" data-claire-element-id="443667"><code data-claire-semantic="nasm">PADDW</code>, qui additionne deux paquets d'entiers de 16 bits ;</p></li><li id="r-443670" data-claire-element-id="443670"><p id="r-443669" data-claire-element-id="443669"><code data-claire-semantic="nasm">PADDD</code>, qui additionne deux paquets d'entiers de 32 bits ;</p></li><li id="r-443672" data-claire-element-id="443672"><p id="r-443671" data-claire-element-id="443671"><code data-claire-semantic="nasm">PADDSB</code>, qui prend un seul paquet et additionne tous les entiers de 8 bits contenus dans ce paquet ;</p></li><li id="r-443674" data-claire-element-id="443674"><p id="r-443673" data-claire-element-id="443673"><code data-claire-semantic="nasm">PADDSW</code> qui fait la même chose avec des paquets d'entiers de 16 bits.</p></li></ul><p id="r-443676" data-claire-element-id="443676">On trouve aussi des soustractions :</p><ul id="r-443683" data-claire-element-id="443683"><li id="r-443678" data-claire-element-id="443678"><p id="r-443677" data-claire-element-id="443677"><code data-claire-semantic="nasm">PSUBB</code>, qui soustrait deux paquets d'entiers de 8 bits ;</p></li><li id="r-443680" data-claire-element-id="443680"><p id="r-443679" data-claire-element-id="443679"><code data-claire-semantic="nasm">PSUBW</code>, qui soustrait deux paquets d'entiers de 16 bits ;</p></li><li id="r-443682" data-claire-element-id="443682"><p id="r-443681" data-claire-element-id="443681"><code data-claire-semantic="nasm">PSUBD</code>, qui soustrait deux paquets d'entiers de 32 bits ;</p></li></ul><p id="r-443684" data-claire-element-id="443684">La multiplication est aussi supportée, mais avec quelques petites subtilités, via l'instruction <code data-claire-semantic="nasm">PMULLW</code>.</p><p id="r-443685" data-claire-element-id="443685">Ces opérations arithmétiques utilisent l’arithmétique saturée.</p><p id="r-443686" data-claire-element-id="443686">Petit détail, dans la majorité des processeurs, on trouve un ou plusieurs registre spéciaux, les registres d'état, qui stockent des bits permettant d'avoir quelques informations sur l'état du processeur ou le résultat d'une instruction. Sur les processeurs x86, les calculs sur les nombres entiers ont leur registre d'état bien à eux, et pareil pour les calculs sur les flottants. Par exemple, si le résultat d'un calcul déborde et qu'un <em>overflow </em>a lieu, un des bits du registre d'état sera mit à 1. Il existe aussi d'autres bits qui servent à stocker des informations du style : le résultat de l'instruction est un zéro, etc. Mais si on regarde bien, on n'a pas de registre d'état pour les instructions MMX. Pire : les instructions MMX ne mettent aucun registre d'état à jour : ni celui des entiers, ni celui des flottants. Ces instructions ne manipulent pas le registre d'état, et elles ne préviennent pas en cas d'<em>overflow </em>ou d'<em>underflow</em> si ceux-ci arrivent (pour les instructions qui ne travaillent pas en arithmétique saturée).</p><p id="r-443687" data-claire-element-id="443687">En plus de ces opérations, on retrouve aussi des opérations logiques : <code data-claire-semantic="nasm">PAND</code>, <code data-claire-semantic="nasm">POR</code> et <code data-claire-semantic="nasm">PXOR</code>, aux noms assez explicites ; et l'instruction <code data-claire-semantic="nasm">PANDN</code>, qui met à zéro un registre MMx.</p><p id="r-443688" data-claire-element-id="443688">On trouve aussi des instructions de comparaisons :</p><ul id="r-443695" data-claire-element-id="443695"><li id="r-443690" data-claire-element-id="443690"><p id="r-443689" data-claire-element-id="443689"><code data-claire-semantic="nasm">PCMPEQB</code> et <code data-claire-semantic="nasm">PCMPGTB</code>, qui comparent deux paquets d'entiers de 8 bits ;</p></li><li id="r-443692" data-claire-element-id="443692"><p id="r-443691" data-claire-element-id="443691"><code data-claire-semantic="nasm">PCMPEQW</code> et <code data-claire-semantic="nasm">PCMPGTW</code>, qui comparent deux paquets d'entiers de 16 bits ;</p></li><li id="r-443694" data-claire-element-id="443694"><p id="r-443693" data-claire-element-id="443693"><code data-claire-semantic="nasm">PCMPEQD</code> et <code data-claire-semantic="nasm">PCMPGTD</code>, qui comparent deux paquets d'entiers de 32 bits.</p></li></ul><p id="r-443696" data-claire-element-id="443696">Les instructions commençant par PCMPEQ testent d'égalité des entiers du paquet, tandis que les instructions commençant par PCMPGT testent si la seconde opérande est supérieure à la première. leur résultat est fourni dans un paquet de 64 bits qui contient pour chaque entier : soit la valeur maximale si la condition testée est vraie, soit 0 dans le cas contraire. Cela contraste fortement au fonctionnement des instructions normales : avec des instructions x86 habituelle, le résultat d'une comparaison est stocké dans certains du registre d'état, et n'est pas enregistré dans un registre. Là encore, on voit bien que l'absence de registre d'état pose quelques problèmes.</p><p id="r-443697" data-claire-element-id="443697">A ces instructions, on peut ajouter les instructions de décalages et de rotations :</p><ul id="r-443704" data-claire-element-id="443704"><li id="r-443699" data-claire-element-id="443699"><p id="r-443698" data-claire-element-id="443698"><code data-claire-semantic="nasm">PSLLW</code>, <code data-claire-semantic="nasm">PSLLD</code>, <code data-claire-semantic="nasm">PSLLQ</code> : décalage logique à gauche d'entiers de 16, 32 et 64 bits ;</p></li><li id="r-443701" data-claire-element-id="443701"><p id="r-443700" data-claire-element-id="443700"><code data-claire-semantic="nasm">PSLRW</code>, <code data-claire-semantic="nasm">PSLRD</code>, <code data-claire-semantic="nasm">PSLRQ</code> : décalage logique à droite d'entiers de 16, 32 et 64 bits ;</p></li><li id="r-443703" data-claire-element-id="443703"><p id="r-443702" data-claire-element-id="443702"><code data-claire-semantic="nasm">PSRAW</code>, <code data-claire-semantic="nasm">PSRAD</code> : décalage arithmétique à droite d'entiers de 16, 32 bits.</p></li></ul><p id="r-443705" data-claire-element-id="443705">Et enfin, on peut rajouter des instructions de conversion et de copie entre registres MMx et la mémoire.</p><h6 id="r-c-est-intel-qui-a-invente-la-notion-d-epic-fail" data-claire-element-id="443713">C'est Intel qui a inventé la notion d'EPIC FAIL !</h6><p id="r-443707" data-claire-element-id="443707">Vu le titre, je suppose que vous avez deviné que le MMX avait quelques problèmes. Et bien c'est le cas : il y avait un léger problème au niveau des registres MMx.</p><p id="r-443708" data-claire-element-id="443708">Tous les processeurs x86 capables de manipuler des flottants comportent une unité de calcul flottante (une <strong>FPU</strong>) de base, capable d’effectuer des opérations sur les flottants. L'ensemble des instructions machines supportées par cette unité s'appelle le <strong>jeu d'instruction x87</strong>. En conséquence, cette FPU est couramment appelée la <strong>FPU x87</strong>. Cette FPU x87 est associée à 8 registres flottants de 80 bits, ainsi qu'à un registre d'état de 32 bits. Et c'est là qu'est le problème : <strong>chaque registres MMX correspondait aux 64 bits de poids faible d'un des 8 registres flottants de la x87 !</strong></p><figure id="r-443710" data-claire-element-id="443711"><img id="r-443709" data-claire-element-id="443709" src="medias/uploads.siteduzero.com_files_385001_386000_385936.png" alt="Image utilisateur"/></figure><p id="r-443712" data-claire-element-id="443712">En clair : il était impossible d'utiliser en même temps l'unité de calcul flottante et l'unité MMX. Le pire, c'est que ce n'était pas un bug, mais quelque chose de réellement voulu par Intel. En faisant ainsi, il n'y avait pas à sauvegarder 8 registres supplémentaires lorsqu'on appelait une fonction ou qu'on devait interrompre un programme pour en lancer un autre (changement de contexte, interruption, etc) : la sauvegarde des registres de la FPU x87 suffisait. Cela a sacrément gêné les programmeurs ou les compilateurs qui voulaient utiliser le jeu d'instruction MMX.</p><h5 id="r-sse-1" data-claire-element-id="443827">SSE</h5><p id="r-443715" data-claire-element-id="443715">Dans les années 1999, une nouvelle extension SIMD fit son apparition sur les processeurs Intel Pentium 3 : le <em>Streaming SIMD Extensions</em>, abrévié <strong>SSE</strong>. Ce SSE fut ensuite complété, et différentes versions virent le jour : le SSE2, SSE3, SSE4, etc.</p><p id="r-443716" data-claire-element-id="443716">Cette extension fit apparaitre 8 nouveaux registres, les registres XMM. Sur les processeurs 64 bits, ces registres sont doublés et on en trouve donc 16.</p><p id="r-443717" data-claire-element-id="443717"><em>Exemple avec les registres XMM des processeurs x86</em>.</p><figure id="r-443719" data-claire-element-id="443720"><img id="r-443718" data-claire-element-id="443718" src="medias/uploads.siteduzero.com_files_385001_386000_385937.png" alt="Image utilisateur"/></figure><p id="r-443721" data-claire-element-id="443721">En plus de ces registres, on trouve aussi un nouveau registre supplémentaire qui permet de contrôler le comportement des instructions SSE : celui contient des bits qui permettront de dire au processeur que les instructions doivent arrondir leurs calculs d'une certaine façon, etc. Ce registre n'est autre que le registre MXCSR. Chose étrange, seuls les 16 premiers bits de ce registres ont une utilité : les concepteurs du SSE ont surement préférés laisser un peu de marge au cas où.</p><table id="r-443804" data-claire-element-id="443804"><thead id="r-443727" data-claire-element-id="443727"><tr id="r-443726" data-claire-element-id="443726"><th id="r-443723" data-claire-element-id="443723"><p id="r-443722" data-claire-element-id="443722">Bit</p></th><th id="r-443725" data-claire-element-id="443725"><p id="r-443724" data-claire-element-id="443724">Utilité</p></th></tr></thead><tbody id="r-443803" data-claire-element-id="443803"><tr id="r-443732" data-claire-element-id="443732"><td id="r-443729" data-claire-element-id="443729"><p id="r-443728" data-claire-element-id="443728">IE</p></td><td id="r-443731" data-claire-element-id="443731"><p id="r-443730" data-claire-element-id="443730">Mit à 1 si une opération renvoie un résultat invalide.</p></td></tr><tr id="r-443737" data-claire-element-id="443737"><td id="r-443734" data-claire-element-id="443734"><p id="r-443733" data-claire-element-id="443733">DE</p></td><td id="r-443736" data-claire-element-id="443736"><p id="r-443735" data-claire-element-id="443735">Mit à 1 si le résultat de l'instruction est un flottant dénormal. Ces dénormaux sont des nombres flottants spéciaux qu'on utilise pour représenter des très petits nombres.</p></td></tr><tr id="r-443742" data-claire-element-id="443742"><td id="r-443739" data-claire-element-id="443739"><p id="r-443738" data-claire-element-id="443738">ZE</p></td><td id="r-443741" data-claire-element-id="443741"><p id="r-443740" data-claire-element-id="443740">Mit à 1 si une division par zéro a eu lieu.</p></td></tr><tr id="r-443747" data-claire-element-id="443747"><td id="r-443744" data-claire-element-id="443744"><p id="r-443743" data-claire-element-id="443743">OE</p></td><td id="r-443746" data-claire-element-id="443746"><p id="r-443745" data-claire-element-id="443745">Mit à 1 si <em>overflow</em>.</p></td></tr><tr id="r-443752" data-claire-element-id="443752"><td id="r-443749" data-claire-element-id="443749"><p id="r-443748" data-claire-element-id="443748">UE</p></td><td id="r-443751" data-claire-element-id="443751"><p id="r-443750" data-claire-element-id="443750">Mit à 1 si <em>underflow</em>. L'<em>underflow </em>est l'inverse de l'<em>overflow</em>, et est possible pour les nombres flottants. Si un calcul sur un nombre flottant renvoie un résultat trop petit pour tenir dans un nombre flottants, il est arrondi à 0 et on se retrouve avec un <em>underflow</em>.</p></td></tr><tr id="r-443757" data-claire-element-id="443757"><td id="r-443754" data-claire-element-id="443754"><p id="r-443753" data-claire-element-id="443753">PE</p></td><td id="r-443756" data-claire-element-id="443756"><p id="r-443755" data-claire-element-id="443755">Mit à 1 si une instruction flottante est obligé d'arrondir son résultat pour le faire renter dans un nombre flottant.</p></td></tr><tr id="r-443762" data-claire-element-id="443762"><td id="r-443759" data-claire-element-id="443759"><p id="r-443758" data-claire-element-id="443758">DAZ</p></td><td id="r-443761" data-claire-element-id="443761"><p id="r-443760" data-claire-element-id="443760">Si il est configuré à 1, tous les nombres flottants dénormaux sont considérés comme des zéros dans les calculs. Cela permet d’accélérer les calculs : il faut dire que la gestion des dénormaux est assez compliquée et que ces flottants dénormalisés ne sont pas forcément supportés par certains processeurs. Si le résultat d'un calcul est un nombre dénormalisé, notre processeur va générer ce qu'on appelle une exception matérielle : le processeur va interrompre temporairement l’exécution du programme en cours et va exécuter un petit programme capable de traiter l'exception. Dans notre cas, ce programme va émuler logiciellement le traitement de ces dénormaux. Mais même lorsque la gestion des dénormaux est implémentée en hardware (comme c'est le cas sur certains processeurs AMD), celle-ci reste malgré tout très lente.</p></td></tr><tr id="r-443767" data-claire-element-id="443767"><td id="r-443764" data-claire-element-id="443764"><p id="r-443763" data-claire-element-id="443763">IM</p></td><td id="r-443766" data-claire-element-id="443766"><p id="r-443765" data-claire-element-id="443765">Si configuré à 1, le processeur le lève pas d'exception matérielle en cas d’exécution d'une opération invalide.</p></td></tr><tr id="r-443772" data-claire-element-id="443772"><td id="r-443769" data-claire-element-id="443769"><p id="r-443768" data-claire-element-id="443768">DM</p></td><td id="r-443771" data-claire-element-id="443771"><p id="r-443770" data-claire-element-id="443770">Si à 1, le processeur ne lève pas d'exception si une instruction fourni un résultat dénormalisé.</p></td></tr><tr id="r-443777" data-claire-element-id="443777"><td id="r-443774" data-claire-element-id="443774"><p id="r-443773" data-claire-element-id="443773">ZM</p></td><td id="r-443776" data-claire-element-id="443776"><p id="r-443775" data-claire-element-id="443775">Si 1, on ne lève pas d'exception en cas de division par zéro, et on arrondit le résultat.</p></td></tr><tr id="r-443782" data-claire-element-id="443782"><td id="r-443779" data-claire-element-id="443779"><p id="r-443778" data-claire-element-id="443778">OM</p></td><td id="r-443781" data-claire-element-id="443781"><p id="r-443780" data-claire-element-id="443780">Si à 1, on ne lève pas d'exception en cas d'<em>overflow</em>.</p></td></tr><tr id="r-443787" data-claire-element-id="443787"><td id="r-443784" data-claire-element-id="443784"><p id="r-443783" data-claire-element-id="443783">UM</p></td><td id="r-443786" data-claire-element-id="443786"><p id="r-443785" data-claire-element-id="443785">Si à 1, on ne lève pas d'exception en cas d'<em>underflow</em>.</p></td></tr><tr id="r-443792" data-claire-element-id="443792"><td id="r-443789" data-claire-element-id="443789"><p id="r-443788" data-claire-element-id="443788">PM</p></td><td id="r-443791" data-claire-element-id="443791"><p id="r-443790" data-claire-element-id="443790">Si à 1, on ne lève pas d'exception quand une instruction flottante arrondit son résultat.</p></td></tr><tr id="r-443797" data-claire-element-id="443797"><td id="r-443794" data-claire-element-id="443794"><p id="r-443793" data-claire-element-id="443793">Bits 13 à 14</p></td><td id="r-443796" data-claire-element-id="443796"><p id="r-443795" data-claire-element-id="443795">Servent à indiquer comment il faut arrondir un résultat qui ne rentre pas dans un nombre flottant: vers zéro, vers + \infty, - \infty, ou vers le flottant le plus proche.</p></td></tr><tr id="r-443802" data-claire-element-id="443802"><td id="r-443799" data-claire-element-id="443799"><p id="r-443798" data-claire-element-id="443798">FZ</p></td><td id="r-443801" data-claire-element-id="443801"><p id="r-443800" data-claire-element-id="443800">Si configuré à 1, on traite les <em>underflow </em>en arrondissant le résultat à zéro.</p></td></tr></tbody></table><h6 id="r-sse" data-claire-element-id="443808">SSE</h6><p id="r-443805" data-claire-element-id="443805">La première version du SSE contenait assez peu d'instructions : seulement 70. :p Croyez-moi, je ne vais pas toutes les lister, mais je peux quand-même dire qu'on trouve des instructions similaires au MMX (comparaisons, opérations arithmétiques, opérations logiques, décalages, rotations, etc), avec pas mal d'opérations en plus. On y trouvait notamment des permutations, des opérations arithmétiques supplémentaires, et pas mal d'instructions pour charger des données depuis la mémoire dans un registre. Petit détail : la multiplication est gérée plus simplement, et l'on a pas besoin de s’embêter à faire mumuse avec plusieurs instructions différentes pour faire une simple multiplication comme avec le MMX.</p><p id="r-443806" data-claire-element-id="443806">Le SSE première version ne fournissait que des instructions pouvant manipuler des paquets contenant 4 nombres flottants de 32 bits (simple précision).</p><p id="r-443807" data-claire-element-id="443807">On peut quand même signaler une chose : des instructions permettant de contrôler le cache firent leur apparition. On retrouve ainsi des instructions qui permet d'écrire ou de lire le contenu d'un registre XMM en mémoire sans le copier dans le cache. Ces instructions permettent ainsi de garder le cache propre en évitant de copier inutilement des données dedans. On peut citer par exemple, les instructions <code data-claire-semantic="nasm">MOVNTQ</code> et <code data-claire-semantic="nasm">MOVNTPS</code> du SSE premiére version. On trouve aussi des instructions permettant de charger le contenu d'une portion de mémoire dans le cache, ce qui permet de contrôler son contenu. De telles instructions de <em>prefetch</em> permettent ainsi de charger à l'avance une donnée dont on aura besoin, permettant de supprimer pas mal de <em>cache miss</em>. Le SSE fournissait notamment les instruction <code data-claire-semantic="nasm">PREFETCH0</code>, <code data-claire-semantic="nasm">PREFETCH1</code>, <code data-claire-semantic="nasm">PREFETCH2</code> et <code data-claire-semantic="nasm">PREFETCHNTA</code>. Autant vous dire qu'utiliser ces instructions peut donner lieu à de sacrés gains si on s'y prend correctement ! Il faut tout de même noter que le SSE n'est pas seul &quot;jeu d'instruction&quot; incorporant des instructions de contrôle du cache : certains jeux d'instruction POWER PC (je pense à l'Altivec) ont aussi cette particularité.</p><h6 id="r-sse2" data-claire-element-id="443822">SSE2</h6><p id="r-443809" data-claire-element-id="443809">Avec le SSE2, de nouvelles instructions furent ajoutés, et l'on peut maintenant utiliser en plus des paquets contenant :</p><ul id="r-443820" data-claire-element-id="443820"><li id="r-443811" data-claire-element-id="443811"><p id="r-443810" data-claire-element-id="443810">2 nombres flottants 64 bits (double précision) ;</p></li><li id="r-443813" data-claire-element-id="443813"><p id="r-443812" data-claire-element-id="443812">2 entiers de 64 bits ;</p></li><li id="r-443815" data-claire-element-id="443815"><p id="r-443814" data-claire-element-id="443814">4 entiers de 64 bits ;</p></li><li id="r-443817" data-claire-element-id="443817"><p id="r-443816" data-claire-element-id="443816">8 entiers de 16 bits ;</p></li><li id="r-443819" data-claire-element-id="443819"><p id="r-443818" data-claire-element-id="443818">16 entiers de 8 bits.</p></li></ul><p id="r-443821" data-claire-element-id="443821">Le SSE2 incorporait ainsi pas moins de 144 instructions différentes, instructions du SSE première version incluses. Ce qui commençait à faire beaucoup.</p><h6 id="r-sse3" data-claire-element-id="443824">SSE3</h6><p id="r-443823" data-claire-element-id="443823">Puis, vient le SSE3, avec ses 13 instructions supplémentaires. Pas grand chose à signaler, si ce n'est que des instructions permettant d'additionner ou de soustraire tout les éléments d'un paquet SSE ensemble, des instructions pour les nombres complexes, et plus intéressant : les deux instructions <code data-claire-semantic="nasm">MWAIT</code> et <code data-claire-semantic="nasm">MONITOR</code> qui permettent de paralléliser plus facilement nos programmes.</p><h6 id="r-sse4" data-claire-element-id="443826">SSE4</h6><p id="r-443825" data-claire-element-id="443825">Le SSE4 fut un peu plus complexe et fut décliné lui-même en 2 sous-versions. Le SSE4.1 introduit ainsi des opérations de calcul de moyenne, de copie conditionnelle de registre (un registre est copié dans un autre si le résultat d'une opération de comparaison précédente est vrai), de calcul de produits scalaire, de calcul du minimum ou du maximum de deux entiers, des calculs d'arrondis, et quelques autres. Avec le SSE4.2, le vice à été poussé jusqu'à incorporer des instructions de traitement de chaines de caractères.</p><h5 id="r-avx" data-claire-element-id="443830">AVX</h5><p id="r-443828" data-claire-element-id="443828">Enfin, la dernière extension en date est l'AVX. Avec celle-ci, on retrouve 16 registres nommés de YMM0 à YMM15, dédiés aux instructions AVX et d'une taille de 256 bits. Ces registres YMM sont partagés avec les registres XMM : les 128 bits de poids faible des registres YMM ne sont autre que les registres XMM. L'AVX complète le SSE et ses extensions, en rajoutant quelques instructions, et surtout en permettant de traiter des données de 256 bits.</p><p id="r-443829" data-claire-element-id="443829">Son principal atout face au SSE, et que les instructions AVX permettent de préciser le registre de destination en plus des registres stockant les opérandes. Avec le SSE et le MMX, le résultat d'une instruction SIMD était écrit dans un des deux registres d'opérande manipulé par l'instruction : il fallait donc sauvegarder son contenu si on en avait besoin plus tard. Avec l'AVX, ce n'est plus le cas : on peut se passer des opérations de sauvegarde sans problème, ce qui supprime pas mal d'instructions.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
<span class="arrow"></span>
<span class="next">Instructions SIMD</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">
<span class="next">Les processeurs vectoriels</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesprocesseursvectoriels"></a><h2>Les processeurs vectoriels</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
<span class="arrow"></span>
<span class="next">Exemples : MMX, SSE et AVX</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
<span class="next">Pipelining</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-443833" data-claire-element-id="443833">Avec nos instructions SIMD, on pouvait travailler sur des paquets de taille fixe, qui avaient la taille d'un registre. Ces données devaient impérativement être placées les unes après les autres dans la mémoire, et avaient quelques limitations : on était obligé de traiter tous les éléments stockés dans un paquet, quelque soit la situation. Bizarrement, ces techniques sont assez rudimentaires, et certains processeurs assez anciens allaient un peu plus loin. Ces processeurs sont ce qu'on appelle des <strong>processeurs vectoriels</strong>.</p><p id="r-443834" data-claire-element-id="443834">Il existe deux grands types de processeurs vectoriels : les processeurs vectoriels Memory-Memory, et les processeurs vectoriels Load-Store. Les processeurs vectoriels <strong><em>Memory-Memory</em></strong> vont lire et écrire directement dans la mémoire. Il faut savoir que le fait qu'ils accèdent directement à la mémoire a quelques conséquences sur leurs architectures, et que ces processeurs possèdent quelques spécificités. L'architecture d'un processeur vectoriel <em>Memory-Memory</em> ressemble donc à ceci :</p><figure id="r-443836" data-claire-element-id="443837"><img id="r-443835" data-claire-element-id="443835" src="medias/uploads.siteduzero.com_files_385001_386000_385910.png" alt="Image utilisateur"/></figure><p id="r-443838" data-claire-element-id="443838">Comme on le voit sur ce schéma, un processeur vectoriel contient souvent un circuit à part, chargé de gérer les instructions vectorielles. Il contient aussi une unité de calcul normale, qui gère les instructions qui ne sont pas vectorielles. Alors certes, suivant le processeur, l'unité scalaire peut aussi avoir des registres dédiés, mais c'est un détail.</p><p id="r-443839" data-claire-element-id="443839">Par contre, les processeurs vectoriels de type <em>Load-Store</em> travaillent avec des registres vectoriels. Ces registres vectoriels ne sont rien d'autres que ces registres pouvant contenir des vecteurs, ou des morceaux de vecteur d'une taille fixe (128, 256, 512 bits). C'est la même chose que les registres qui stockaient des paquets sur les processeurs utilisant des instructions SIMD.</p><figure id="r-443841" data-claire-element-id="443842"><img id="r-443840" data-claire-element-id="443840" src="medias/uploads.siteduzero.com_files_385001_386000_385914.png" alt="Image utilisateur"/></figure><p id="r-443843" data-claire-element-id="443843">Avoir de tels registres est assez avantageux : on peut réutiliser des données placées dans ce registres au lieu de devoir aller lire nos paquets, nos vecteurs, en mémoire RAM à chaque fois qu'on veut les réutiliser. C'est pour cela que les architectures vectorielles sont presque toutes des architectures vectorielles de type <em>Load-Store</em>. Jusque ici, on ne voit pas vraiment la différence entre les processeurs vectoriels de type <em>Load-Store</em> et les processeurs dotés d'instructions SIMD, si ce n'est les unités de calcul vectorielles séparées. Mais comme vous allez le voir, il y a une différence.</p>
</div><a name="Pipelining"></a><h2>Pipelining</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">
<span class="arrow"></span>
<span class="next">Les processeurs vectoriels</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
<span class="next">Accès mémoires</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-pipelining" data-claire-element-id="443887">Pipelining</h4><p id="r-443844" data-claire-element-id="443844">La différence tient dans la façon dont sont traités nos paquets, nos vecteurs. Avec les instructions SIMD, on traitait chaque élément séparément, dans une seule grosse unité de calcul. On dispose d'une grosse unité de calcul qui peut effectuer certaines instructions, et qui traite tous les éléments d'un paquet simultanément. Ce n'est pas le cas des processeurs vectoriels, qui font autrement : ils travaillent à la chaine, ou avec des unités de calcul séparés !</p><p id="r-443845" data-claire-element-id="443845">Ces processeurs <strong>pipelinent leurs unités de calcul vectorielles</strong> ! Par pipeliner, on veut dire que l’exécution de chaque instruction sera découpée en plusieurs étapes, indépendantes les unes des autres. Au lieu d'attendre que l’exécution d'un opération sur une donnée soit terminée avant de passer à la suivante, on peut ainsi commencer le traitement d'une nouvelle donnée sans avoir à attendre que l'ancienne soit terminée. Par exemple, on peut charger la prochaine instruction pendant qu'on exécute la précédente : c'est un peu ce qu'on a vu dans le chapitre sur la parallélisme à un seul processeur. Après tout, ces deux étapes sont complètement indépendantes et utilisent des circuits séparés. Et rien n’empêche de découper les étapes de chargement d'une instruction et leur exécution par l'unité de calcul en plusieurs étapes bien distinctes, et de refaire pareil.</p><figure id="r-443847" data-claire-element-id="443848"><img id="r-443846" data-claire-element-id="443846" src="medias/uploads.siteduzero.com_files_385001_386000_385909.png" alt="Image utilisateur"/></figure><p id="r-443849" data-claire-element-id="443849">Cela ressemble à un peu au fonctionnement d'une chaine de montage, dans laquelle on découpe la fabrication d'un objet en pleins de sous-étapes qu'on effectue les unes après les autres dans des boxes différents. C'est très différent des instructions SIMD qui manipulaient des élèvements indépendants dans des unités de calculs séparées.</p><p id="r-443850" data-claire-element-id="443850">Pour donner un exemple, on peut donner l'exemple d'une multiplication flottante effectuée entre deux registres. Son exécution peut être décomposée en plusieurs étapes. <br/> Par exemple, on peut avoir 3 étapes :</p><ul id="r-443857" data-claire-element-id="443857"><li id="r-443852" data-claire-element-id="443852"><p id="r-443851" data-claire-element-id="443851">une première étape E qui va additionner les exposants et gérer les diverses exceptions ;</p></li><li id="r-443854" data-claire-element-id="443854"><p id="r-443853" data-claire-element-id="443853">une étape M qui va multiplier les mantisses ;</p></li><li id="r-443856" data-claire-element-id="443856"><p id="r-443855" data-claire-element-id="443855">et enfin une étape A qui va arrondir le résultat.</p></li></ul><p id="r-443858" data-claire-element-id="443858">L’exécution de notre opération flottante sur un vecteur donnerait donc quelque chose dans le genre :</p><figure id="r-443860" data-claire-element-id="443861"><img id="r-443859" data-claire-element-id="443859" src="medias/uploads.siteduzero.com_files_386001_387000_386575.png" alt="Image utilisateur"/></figure><p id="r-443862" data-claire-element-id="443862">Chaque ligne correspond au traitement d'un nouvel élément dans un vecteur, dans un paquet SIMD.</p><h5 id="r-startup-et-dead-time" data-claire-element-id="443874">Startup et Dead Time</h5><p id="r-443863" data-claire-element-id="443863">Quand une instruction vectorielle s’exécute, le fait qu'elle soit pipelinée va avoir de drôles de conséquences : une instruction vectorielle met un certain temps avant d'être vraiment efficace.</p><p id="r-443864" data-claire-element-id="443864">Pour expliquer pourquoi, on va reprendre l'exemple de notre multiplication flottante vu au-dessus. Supposons que je travaille sur un vecteur de 8 nombres flottants.<br/> Au départ, je commencerais à éxecuter la première étape sur le premier élément : je ne traiterais alors que mon premier élément, et seulement celui-ci. Puis, au cycle d'horloge suivant, j'aurais fini l'étape 1 du premier élément, qui passera à l’étape 2. En même temps, je commencerais l'étape 1 du second élément du vecteur. Je traiterais alors deux éléments en même temps, mais dans des étapes différentes, et donc dans des circuits séparés. Au fur et à mesure, j’exécuterais un nombre de plus en plus important d’éléments en même temps, et je finirais alors par avoir chaque circuit dédié à une étape occupés à traiter un élément : je serais alors en régime de crête.</p><figure id="r-443866" data-claire-element-id="443867"><img id="r-443865" data-claire-element-id="443865" src="medias/uploads.siteduzero.com_files_393001_394000_393686.png" alt="Image utilisateur"/></figure><p id="r-443868" data-claire-element-id="443868">Tout se passe comme si je mettais un certain temps avant d'arriver à mon régime de croisière. Durant un certain temps, je n'ai pas commencé à traiter suffisamment d’éléments pour que toutes mes étapes soient occupées. Il me faut donc attendre un certain temps, un certain nombre de cycles d'horloges pour que toutes mes étapes soient totalement utilisées. Ce temps de démarrage est strictement égal du nombre d'étapes nécessaires pour effectuer une instruction.</p><p id="r-443869" data-claire-element-id="443869">La même chose arrive vers la fin du vecteur, quand il ne reste plus suffisamment d’éléments à traiter pour remplir toutes les étapes.</p><figure id="r-443871" data-claire-element-id="443872"><img id="r-443870" data-claire-element-id="443870" src="medias/uploads.siteduzero.com_files_393001_394000_393687.png" alt="Image utilisateur"/></figure><p id="r-443873" data-claire-element-id="443873">Comme on le voit, la durée du régime de croisière n'est pas énorme. Elle dépend fortement du nombre d'étapes de notre instruction, et du nombre d’éléments à traiter. Plus on doit traiter d’éléments dans notre vecteur (plus celui-ci est long), et moins on effectue d'étape, plus on atteint et quitte le régime optimal rapidement.</p><h5 id="r-solutions-5" data-claire-element-id="443880">Solutions</h5><p id="r-443875" data-claire-element-id="443875">Pour amortir ces temps de démarrage et de fin, durant lesquels une bonne partie des étapes, des circuits de notre ALU, sont inutilisés, certains processeurs vectoriels utilisent la ruse. Ils peuvent démarrer une nouvelle instruction vectorielle sans attendre la fin d'une instruction précédente. On peut ainsi pipeliner les traitements à l'intérieur d'une instruction vectorielle, mais aussi entre deux opérations vectorielles. Elles peuvent ainsi se chevaucher pour remplir les vides.</p><figure id="r-443877" data-claire-element-id="443878"><img id="r-443876" data-claire-element-id="443876" src="medias/uploads.siteduzero.com_files_386001_387000_386599.png" alt="Image utilisateur"/></figure><p id="r-443879" data-claire-element-id="443879">Par contre, il faut absolument que le nombre d'étapes d'une instruction soit suffisamment petit, pour éviter les problèmes lorsque deux instructions vectorielles qui se suivent manipulent le même vecteur. Il faut que la première instruction aie fini de manipuler un élément avant que la suivante ne veuille commencer à le modifier. Pour cela, il faut avoir des vecteurs suffisamment qui contiennent plus d’éléments qu'il n'y a d'étapes pour effectuer notre instruction.</p><h5 id="r-chaining" data-claire-element-id="443884">Chaining</h5><p id="r-443881" data-claire-element-id="443881">Cette technique du pipeline peut encore être améliorée dans certains cas particuliers. Imaginons que l'on aie trois paquets : A, B et C. Pour chaque iéme élément de ces paquets, je souhaite effectuer le calcul Ai + Bi imes Ci. Mon processeur ne disposant pas d'instruction permettant de faire en une fois ce calcul, je dois utiliser deux instruction vectorielles : une d'addition, et une autre de multiplication. On pourrait penser que l'on doit effecteur d'abord la multiplication des paquets B et C, stocker le résultat dans un paquet temporaire, et effectuer l'addition de ce tableau avec le paquet A.</p><p id="r-443882" data-claire-element-id="443882">Mais en rusant un peu, on s’aperçoit qu'on peut simplifier le tout et utiliser notre pipeline plus correctement. Notre processeur peut en effet fusionner ces deux instructions indépendantes et les traiter en interne comme s'il s’agissait d'une instruction unique. Au lieu d'effectuer la multiplication, puis l'addition séparément pour chaque élément du paquet, il peut effectuer la multiplication et l'addition pour le premier élément, puis continuer avec le second, etc...En gros, il fusionne plusieurs instructions vectorielles en une seule instruction vectorielle qui regroupe les deux. Il s'agit de ce qu'on appelle le <em><strong>Vector Chaining</strong></em>.</p><p id="r-443883" data-claire-element-id="443883">Mais dans notre processeur vectoriel, les deux calculs sont exécutés l'un après l’autre, avant de passer à l’élément suivant. Pour ce faire, on doit modifier notre pipeline de façon à ce que le résultat de chaque étape d'un calcul soit réutilisable au cycle d’horloge suivant. Ainsi, dans l'exemple du dessus, le résultat de notre multiplication doit être réutilisable sans attendre par notre unité de calcul une fois qu'il est calculée : on ne doit pas avoir besoin de l'enregistrer en mémoire pour pouvoir calculer avec.</p><h5 id="r-multiple-lanes" data-claire-element-id="443886">Multiple Lanes</h5><p id="r-443885" data-claire-element-id="443885">Cependant, on doit préciser que certains de nos processeurs vectoriels peuvent utiliser plusieurs ALU pour accélérer leur temps de calcul. En clair, ils sont capables de traiter plusieurs éléments d'un vecteur en une fois, chacun de ces éléments allant dans une ALU. Vu que nos ALU sont pipelinées, rien n’empêche d’exécuter plusieurs instructions vectorielles différentes dans une seule ALU, chaque instruction étant à une étape différente. Et quand le tout est couplé aux techniques de <em>Chaining</em>, ça envoie du bois !</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">
<span class="arrow"></span>
<span class="next">Les processeurs vectoriels</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
<span class="next">Accès mémoires</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Accsmmoires"></a><h2>Accès mémoires</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
<span class="arrow"></span>
<span class="next">Pipelining</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
<span class="next">Quelques registres utiles</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-acces-memoires-2" data-claire-element-id="443926">Accès mémoires</h4><p id="r-443888" data-claire-element-id="443888">La façon dont ces instructions vectorielles accèdent à la mémoire est assez intéressante. Mais quoiqu'il en soit, il faut savoir que les données manipulées par nos instructions vectorielles ne passent pas par la mémoire cache. Il arrive aussi que nos processeurs vectoriels ne possèdent souvent aucune mémoire cache, ou très peu. Il faut dire que la mémoire cache est utile lorsque les données qu'on va placer dedans sont réutilisées plusieurs fois. Dans ce cas, la donnée est chargée dans le cache depuis la RAM, et est ensuite accédée dans le cache : le premier accès est aussi lent qu'un accès mémoire normal, mais les accès suivants vont aller lire ou écrire dans la mémoire cache, bien plus rapide que la RAM. Mais dans le cas qui nous intéresse, à savoir l'utilisation majeure qui est faite des instructions vectorielle, la donnée n'est accédée qu'une seule fois : elles servent souvent à itérer dans un tableau, et encore : chaque élément doit être traité indépendamment des autres. En clair, on n'accède qu'une seule fois à un élément de notre tableau, et on l'oublie pour un moment. Notre mémoire cache est alors inutile : le seul accès fait sur notre donnée sera aussi lent avec ou sans cache. Avec aussi peu de réutilisation des données, nos instructions vectorielles peuvent se passer de mémoires caches.</p><h5 id="r-pipelining-des-acces-memoires" data-claire-element-id="443894">Pipelining des accès mémoires</h5><p id="r-443889" data-claire-element-id="443889">Reste que nos accès mémoires sont un problème : ils sont lents. Pour limiter la casse, nos processeurs vectoriels disposent de diverses astuces. Déjà, les accès mémoires sont pipelinés : cela signifie qu'on pet commencer un accès mémoire sans attendre que le précédent soit fini. Ainsi, nos accès mémoires se &quot;recouvrent&quot;, et on peut en éxecuter plusieurs en même temps : c'est plus rapide que de les effectuer un par uns. Mais comme on va le voir, ce n'est pas la seule astuce.</p><figure id="r-443891" data-claire-element-id="443892"><img id="r-443890" data-claire-element-id="443890" src="medias/uploads.siteduzero.com_files_386001_387000_386290.png" alt="Image utilisateur"/></figure><p id="r-443893" data-claire-element-id="443893">L'exemple du dessus n'est pas à l'échelle : en réalité, les accès mémoires durent plus longtemps, et le nombre d'accès mémoire simultanés doit être beaucoup plus grand si on veut garder des performances correctes. Ce qui fait qu'en général, les processeurs vectoriels supportent souvent un grand nombre d'accès mémoires simultané, qui peut monter à plusieurs centaines d'accès mémoires.</p><h5 id="r-patterns-d-acces-memoire" data-claire-element-id="443925">Patterns d'accès mémoire</h5><p id="r-443895" data-claire-element-id="443895">Nos instructions vectorielles ont des fonctionnalités assez intéressantes : elles peuvent fournir au processeur des informations sur la façon dont le processeur doit accéder à la mémoire. Cela lui permet de savoir la position en mémoire (l'adresse) de la prochaine donnée à charger : sans ça, notre processeur serait bien ennuyé.</p><h6 id="r-acces-contigus" data-claire-element-id="443907">Accès contigus</h6><p id="r-443896" data-claire-element-id="443896">Généralement, ces instructions vont accéder à des données placées les unes à coté des autres en mémoire. L'instruction a juste à dire au processeur de toujours charger la donnée immédiatement suivante.</p><figure id="r-443898" data-claire-element-id="443899"><img id="r-443897" data-claire-element-id="443897" src="medias/uploads.siteduzero.com_files_365001_366000_365020.png" alt="Image utilisateur"/></figure><p id="r-443900" data-claire-element-id="443900">Pour améliorer les performances lors de tels accès à la mémoire, nos processeurs vectoriels sont souvent associés à des mémoires <em>interleaved</em>. Le nom fait peur, je l'avoue, mais il sera moins impressionnant une fois que vous aurez lus les explications qui suivent. Une mémoire <em>interleaved </em>est une mémoire spécialement conçue pour que les accès à des données consécutives soit le plus rapide possible. Elle est en réalité constituée de plusieurs mémoires assemblées dans une seule et unique barrette d'une certaine façon.</p><p id="r-443901" data-claire-element-id="443901">Si vous ne le savez pas encore, sachez que notre mémoire est découpée en petits blocs de mémoire, qui contiennent généralement 8 bits (un octet). Pour pouvoir identifier ces blocs de mémoires, ces <strong><em>bytes</em></strong>, on leur attribue à chacun un numéro qui permet de les identifier : leur <strong>adresse mémoire</strong>. Sur les mémoires <em>interleaved</em>, les bytes dont les adresses mémoires sont consécutives sont placés dans des sous-mémoires consécutives. Cela permet de limiter le temps mit pour accéder à notre byte.</p><p id="r-443902" data-claire-element-id="443902">L'accès à un boitier prend toujours un peu de temps : c'est le fameux temps d'accès. Si on place deux bytes ayant des adresses consécutives dans le même boitier, et qu'on souhaite lire/écrire ces deux bytes, on devra attendre que l'accès au premier byte soit fini avant de pouvoir accéder au suivant (sauf si la mémoire est multiports, mais bref). En clair : on ne peut effectuer qu'un seul accès à la fois sur des bytes consécutifs.</p><figure id="r-443904" data-claire-element-id="443905"><img id="r-443903" data-claire-element-id="443903" src="medias/uploads.siteduzero.com_files_365001_366000_365039.png" alt="Image utilisateur"/></figure><p id="r-443906" data-claire-element-id="443906">Mais ce n'est valable qu'avec les mémoires qui ne sont pas des mémoires <em>interleaved </em>! Avec les mémoires <em>interleaved</em>, la donne est différentes : des bytes consécutifs sont localisés dans des boitiers différentes qui peuvent être accédés en parallèle. On peut ainsi charger plusieurs mots contigus en mémoires séparément : au lieu de charger notre donnée bit par bit, on peut en charger 64 d'un coup sans aucun problèmes. Mais attention : cela ne marche qu'avec des accès mémoires consécutifs. Dans le cas d'accès mémoires pas vraiment consécutifs en mémoire et plutôt éloignés, on doit éxecuter nos accès mémoires uns par uns.</p><h6 id="r-acces-en-strides" data-claire-element-id="443915">Accès en strides</h6><p id="r-443908" data-claire-element-id="443908">Il arrive aussi assez souvent que l'on accède qu'à certains éléments tous séparés par une même distance. Par exemple, si on fait des calculs de géométrie dans l'espace, on peut très bien ne vouloir traiter que les coordonnées sur l'axe des x, sans instructionner sur l'axe des y ou des z. De tels accès sont ce qu'on appelle des accès en <em>stride</em>.</p><figure id="r-443910" data-claire-element-id="443911"><img id="r-443909" data-claire-element-id="443909" src="medias/uploads.siteduzero.com_files_365001_366000_365021.png" alt="Image utilisateur"/></figure><p id="r-443912" data-claire-element-id="443912">L'instruction a juste à dire au processeur de toujours charger la donnée située x cases plus loin, le x étant souvent fourni via l'instruction (il est incorporé dans la suite de de bits de l'instruction).</p><p id="r-443913" data-claire-element-id="443913">C'est une des grosses différences entre les processeurs vectoriels et les instructions SIMD qu'on a vu auparavant : ces dernières ne gèrent pas les accès mémoires complexes (comme ceux en <em>strides</em>), et se contentent d’accéder à des données contiguës. Cela pouvait poser quelques problèmes : si jamais on ne veux traiter que certains éléments, on ne pouvait pas utiliser d'instructions SIMD. Les processeurs vectoriels n'ont pas ce genre de problèmes.</p><p id="r-443914" data-claire-element-id="443914">Pour gérer efficacement ces accès en <em>Stride</em>, la mémoire de l'ordinateur doit être conçue pour. Généralement, cela signifie placer plusieurs mémoires séparées et les rassembler dans une seule grosse mémoire. Généralement, ces petites sous-mémoires séparées sont appelées des <strong>bancs mémoires</strong>. Vu que nos accès en <em>stride </em>sont souvent assez éloignés, cela signifie qu'ils seront assez distants dans la mémoire. En utilisant des bancs mémoires de bonne taille, on peut faire en sorte qu'avec des <em>strides </em>assez longs, les éléments à accéder soient placés dans des bancs séparés, accessibles séparément. On se retrouve alors dans la même situation qu'avec les mémoires <em>interleaved </em>: on peut commencer à aller chercher l’élément suivant alors que le précédent n'est pas encore disponible.</p><h6 id="r-acces-en-scatter-gather" data-claire-element-id="443924">Accès en Scatter/gather</h6><p id="r-443916" data-claire-element-id="443916">Les processeurs vectoriels incorporent aussi un autre type d'accès à la mémoire, le <em><strong>scatter-gather</strong></em> ! Oui, le nom est barbare et il faudra vous y faire.</p><p id="r-443917" data-claire-element-id="443917">Pour comprendre ce que peut être cet accès mémoire, il faut savoir certaines choses. Dans un programme, on doit parfois accéder à des données qui sont assez dispersées dans la mémoire. Et dans ce cas, difficile d'utiliser des instructions vectorielles. Les accès en <em>scatter </em>et en <em>gather </em> cherchent à résoudre ce genre de problèmes en rassemblant des données dispersées en mémoire dans un registre censée contenir des paquets.</p><p id="r-443918" data-claire-element-id="443918">Pour cela, on va fournir à notre processeur un paquet d'index qui stockera les adresses mémoires des données dispersées à rassembler dans un paquet. Quand une instruction exécutera un accès en <em>scatter</em>, les bytes de ces adresses seront rapatriées depuis la mémoire et rassemblées dans un paquet.</p><figure id="r-443920" data-claire-element-id="443921"><img id="r-443919" data-claire-element-id="443919" src="medias/uploads.siteduzero.com_files_365001_366000_365049.png" alt="Image utilisateur"/></figure><p id="r-443922" data-claire-element-id="443922">Bien sûr, il existe aussi l’inverse : on peut écrire les données d'un paquet dans des emplacements mémoires dispersés.</p><p id="r-443923" data-claire-element-id="443923">Ce genre d'accès permet ainsi d'utiliser des instructions SIMD ou des instructions vectorielles plus souvent, et donc de gagner en performances. Alors certes, on ne gagne pas beaucoup, mais c'est toujours ça de pris !</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
<span class="arrow"></span>
<span class="next">Pipelining</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
<span class="next">Quelques registres utiles</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Quelquesregistresutiles"></a><h2>Quelques registres utiles</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
<span class="arrow"></span>
<span class="next">Accès mémoires</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">
<span class="next">GPGPU et Streams Processors</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-quelques-registres-utiles" data-claire-element-id="443942">Quelques registres utiles</h4><p id="r-443927" data-claire-element-id="443927">Nos processeurs vectoriels utilisent donc des paquets, des vecteurs de taille fixe, déterminée par l'architecture de la machine. C'est exactement la même chose que pour les instructions SIMD. Mais nos processeurs vectoriels incorporent diverses techniques que de simples instructions SIMD n'ont pas forcément, même si elles gagneraient à être reprises sur celles-ci.</p><h5 id="r-vector-length-register" data-claire-element-id="443935">Vector Length Register</h5><p id="r-443928" data-claire-element-id="443928">Pour comprendre ces techniques, il faut savoir que nos paquets SIMD et autres vecteurs de machines vectorielles sont utilisés pour manipuler des tableaux de façon efficiente. Ces tableaux ne sont rien d'autre qu'un rassemblement de données de même type (et donc de même taille) placées les unes à la suite des autres en mémoire.</p><p id="r-443929" data-claire-element-id="443929">Mais ces tableaux n'ont pas forcément la même taille qu'un paquet SIMD. Si j'ai un tableau de 1000 éléments, j'aurais du mal à le traiter intégralement en utilisant des instructions vectorielles ou des instructions SIMD qui ne peuvent gérer que 64 éléments. Dans ce cas, on est obligé de répéter notre instruction à appliquer au tableau plusieurs fois, sur des morceaux de tableaux différents (on utilise une simple boucle).</p><p id="r-443930" data-claire-element-id="443930">Cela peut poser quelques problèmes. Reprenons notre exemple avec un tableau de 1000 éléments, et des paquets de 64 éléments. Vous remarquerez que 1000 / 64, ça ne tombe pas juste : si on découpe notre tableau, on se retrouvera avec 15 paquets complets de 64 éléments, et il restera 40 éléments à traiter. C'est ainsi : la taille d'un tableau n'est pas forcément multiple de la taille d'un paquet SIMD ou d'un vecteur, et il reste quelques éléments qu'on doit traiter. Comment faire pour traiter ces éléments restants ? Dans ce cas, deux solutions : soit on les traite en utilisant l'unité de calcul normale, et c'est au compilateur de gérer le tout (via des techniques de <em>Strip Mining</em>), soit on demande de l'aide au processeur.</p><p id="r-443931" data-claire-element-id="443931">Notre processeur peut fournir un <em>Vector Length Register</em> qui indique combien d’éléments on doit traiter dans notre vecteur. On peut ainsi dire au processeur : je veux que tu ne traite que les 40 premiers éléments présents d'un paquet, et que tu oublie les autres. Généralement notre instruction va traiter tout les éléments d'un vecteur, sauf quand on arrive à la fin d'un tableau : on configure alors notre <em>Vector Length Register</em> pour traiter seulement ce qui reste.</p><figure id="r-443933" data-claire-element-id="443934"><img id="r-443932" data-claire-element-id="443932" src="medias/uploads.siteduzero.com_files_386001_387000_386128.png" alt="Image utilisateur"/></figure><h5 id="r-vector-mask-register" data-claire-element-id="443941">Vector Mask Register</h5><p id="r-443936" data-claire-element-id="443936">Ces instructions SIMD sont très utiles quand on doit effectuer un traitement identique sur un ensemble de données identiques. Mais dès que le traitement à effectuer sur nos données varie suivant le résultat d'un test ou d'un branchement, les choses se gâtent. Mine de rien, avec une instruction vectorielle, on est obligé de calculer et de modifier tous les éléments d'un paquet : il est impossible de zapper certains éléments d'un paquet dans certaines conditions. Par exemple, imaginons que je veuille seulement additionner les éléments d'un paquet ensemble s'ils sont positifs : je ne peux pas le faire avec une instruction vectorielle &quot;normale&quot;. Du moins, pas sans aide.</p><p id="r-443937" data-claire-element-id="443937">Pour résoudre ce problèmes, certaines processeurs vectoriels dignes de ce nom utilisent un <em><strong>Vector Mask Register</strong></em>. Celui-ci permet de stocker des informations qui permettront de sélectionner certaines données et pas d'autres pour faire notre calcul. Ce <em>Vector Mask Register</em> va stocker des bits pour chaque flottant présent dans le vecteur à traiter. Si ce bit est à 1, notre instruction doit s’exécuter sur la donnée associée à ce bit. Sinon, notre instruction ne doit pas la modifier. On peut ainsi traiter seulement une partie des registres stockant des vecteurs SIMD.</p><figure id="r-443939" data-claire-element-id="443940"><img id="r-443938" data-claire-element-id="443938" src="medias/uploads.siteduzero.com_files_387001_388000_387273.png" alt="Image utilisateur"/></figure>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
<span class="arrow"></span>
<span class="next">Accès mémoires</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">
<span class="next">GPGPU et Streams Processors</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="GPGPUetStreamsProcessors"></a><h2>GPGPU et Streams Processors</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
<span class="arrow"></span>
<span class="next">Quelques registres utiles</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
<span class="next">Architecture d&#039;un GPU</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-443944" data-claire-element-id="443944">Dans les chapitres précédents, on a parlé des instructions SIMD, et des processeurs vectoriels. Ces deux types de processeurs sont particulièrement adaptés pour traiter des données en parallèle. Mais comparé à ce qu'on va voir, ces architectures vont passer pour des créations d'amateurs ! Nous allons parler des cartes graphiques modernes.</p>
</div><a name="Architectured039unGPU"></a><h2>Architecture d&#039;un GPU</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">
<span class="arrow"></span>
<span class="next">GPGPU et Streams Processors</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
<span class="next">Hiérarchie mémoire</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-architecture-d-un-gpu" data-claire-element-id="443963">Architecture d'un GPU</h4><div id="r-443946" data-claire-element-id="443946" data-claire-semantic="question"><p id="r-443945" data-claire-element-id="443945">Mais c'est quoi le rapport entre les cartes graphiques et le parallélisme ?</p></div><p id="r-443947" data-claire-element-id="443947">Et bien les cartes graphiques intègrent des processeurs spécialisés dont l'architecture est fortement parallèle. Ces derniers sont appelés des <strong>Graphic Processing Unit</strong>, abréviées GPU. Ces dernières années, ces GPU sont devenus de plus en plus programmables, et l'idée d'utiliser ceux-ci pour effectuer des calculs génériques s'est peu à peu répandue. De nos jours, nos GPU peuvent effectuer des taches qui auraient étè dévolues au processeur il y a quelques années. Des couches logicielles comme CUDA ou OpenMP permettent ainsi de paralléliser des programmes et en exécuter certaines portions sur ces GPU. Aussi, comprendre le fonctionnement de ces GPU devient un impératif pour faire du calcul à haute performances. Voyons un peu ce que nos GPU ont dans le ventre.</p><h5 id="r-vieux-gpus" data-claire-element-id="443953">Vieux GPUs</h5><p id="r-443948" data-claire-element-id="443948">Cela fait un moment que les cartes graphiques de nos ordinateurs sont devenues programmables. Sur les premières cartes graphiques programmables, on pouvait créer des <em>Shaders</em>, des petits programmes permettant de manipuler des pixels ou des données géométriques (des <em>Vertex</em>). Pour traiter ces <em>Shaders</em>, notre carte graphique incorporait des unités de traitement, capables d’exécuter des instructions sur des pixels ou des données géométriques. Ces unités de traitement n'étaient ni plus ni moins que de processeurs assez rudimentaires, capables d'effectuer des instructions entières et flottantes.</p><figure id="r-443950" data-claire-element-id="443951"><img id="r-443949" data-claire-element-id="443949" src="medias/uploads.siteduzero.com_files_403001_404000_403177.png" alt="Image utilisateur"/></figure><p id="r-443952" data-claire-element-id="443952">Et ces derniers n'étaient pas identiques : les instructions qu'ils étaient capables d'effectuer n'étaient pas les mêmes suivant que ces processeurs traitaient de la géométrie ou des pixels. Avec le temps, l'idée d'utiliser ces processeurs pour autre chose que des traitement graphique fit son chemin. Ces processeurs furent alors un peu modifiés.</p><h5 id="r-stream-processors" data-claire-element-id="443962">Stream Processors</h5><p id="r-443954" data-claire-element-id="443954">De nos jours, ces processeurs sont tous identiques et peuvent servir à faire aussi bien des calculs graphiques que des calculs sur des données quelconques. Ces processeurs sont ce qu'on appelle des <strong><em>Streams Processors</em></strong>, des processeurs spécialement conçus pour exécuter des suites d'instructions sur un grand nombre de données.</p><p id="r-443955" data-claire-element-id="443955">Sur ces processeurs, des programmes, nommés <em>Kernels</em>, sont appliqués entièrement à un tableau de donnée que l'on appelle un <em>Stream</em>. Dans nos cartes graphiques actuelles, ce <em>Stream</em> est découpé en morceaux qui seront chacun traités sur un <em>Stream Processor</em>. Chacun de ces morceaux est appelé un <em>Thread</em>. Vous remarquerez que le terme <em>Thread </em>est ici utilisé dans un sens différent de celui utilisé précédemment. Faites attention ! Quoiqu'il en soit, ces processeurs ressemblent fortement aux processeur vectoriels ou aux processeurs utilisant des instructions SIMD.</p><p id="r-443956" data-claire-element-id="443956">Un GPU actuel est souvent composé de plusieurs de ces <em>Streams Processors</em>, placés ensembles sur une même puce, avec quelques autres circuits annexes, utilisés dans les taches de rendu 3D. Ces <em>Streams Processors</em> sont alors pilotés par un gros micro-contrôleur qui se charge de découper le <em>Stream </em>à traiter en <em>Threads</em>, avant de les répartir sur les différents <em>Streams Processors</em> de la puce.</p><figure id="r-443958" data-claire-element-id="443959"><img id="r-443957" data-claire-element-id="443957" src="medias/uploads.siteduzero.com_files_403001_404000_403009.png" alt="Image utilisateur"/></figure><p id="r-443960" data-claire-element-id="443960">On remarque que le découpage du <em>Stream </em>en <em>Threads </em>se fait à l’exécution. C'est assez différent de ce qu'on trouve sur les processeurs SIMD ou vectoriels. Sur ces derniers, les instructions du processeur travaillent sur des données de taille fixe : pour traiter un tableau complet, on doit utiliser une boucle pour traiter celui-ci morceau par morceau. Rien de tout cela sur nos cartes 3D : on envoie à notre carte 3D des informations sur le tableau à manipuler et celle-ci se débrouille toute seule pour le découper en morceau et les répartir sur les processeurs disponibles.</p><p id="r-443961" data-claire-element-id="443961">L'ensemble est souvent complété par quelques petites mémoires, qui servent à stocker des constantes ou des textures de façon temporaire, et qui sont utilisables par tous les <em>Streams Processors</em> de la puce. On retrouve parfois plusieurs mémoires caches partagées entre les différents <em>Streams Processors</em>. C'est de plus en plus le cas sur les cartes graphiques actuelles.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">
<span class="arrow"></span>
<span class="next">GPGPU et Streams Processors</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
<span class="next">Hiérarchie mémoire</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Hirarchiemmoire"></a><h2>Hiérarchie mémoire</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
<span class="arrow"></span>
<span class="next">Architecture d&#039;un GPU</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
<span class="next">Jeu d&#039;instruction</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-hierarchie-memoire-2" data-claire-element-id="443993">Hiérarchie mémoire</h4><p id="r-443964" data-claire-element-id="443964">Pour commencer, nous allons voir grosso modo ce que l'on trouve dans un <em>Stream Processor</em>. Et pour cela, on va commencer par la façon dont il gère la mémoire, qui est assez spéciale.<br/> Voici à quoi ressemble l'architecture d'un <em>Stream Processor</em> :</p><figure id="r-443966" data-claire-element-id="443967"><img id="r-443965" data-claire-element-id="443965" src="medias/uploads.siteduzero.com_files_402001_403000_402994.png" alt="Image utilisateur"/></figure><p id="r-443968" data-claire-element-id="443968">A première vue, les schémas du dessus ne ressemblent à rien de connu. Et pourtant on peut déjà faire quelques remarques assez intéressantes. Déjà, il n'y a pas de mémoires caches. Ensuite, l'ensemble ressemble fortement à ce qu'on trouve sur les processeurs vectoriels, à part que les registres vectoriels sont scindés en plusieurs exemplaires.</p><h5 id="r-pas-de-cache-de-donnees" data-claire-element-id="443972">Pas de cache de données</h5><p id="r-443969" data-claire-element-id="443969">En théorie, les <em>Streams Processors</em> contiennent peu de mémoires caches, comme pour les processeurs vectoriels. Et encore, c'est quand ils en ont. Il faut dire que les <em>Streams Processors</em> sont, comme les processeurs vectoriels, conçus pour manipuler des tableaux de données plus ou moins complexes. Après tout, nos <em>Streams </em>ne sont rien d'autres que des tableaux. Généralement, ces tableaux ont une faible localité temporelle : quand on accède à une donnée dans un tableau, il est rare qu'on doive la réutiliser plus tard. Dans ces conditions, utiliser des mémoires caches est contre-productif. Il faut dire que celles-ci ont étés conçues pour stocker des données afin de pouvoir les réutiliser. Avec un cache, on accède une première fois à notre donnée depuis la mémoire (ce qui est lent) et on la copie dans le cache, pour la réutiliser plus rapidement (un cache est plus rapide que la RAM). On voit bien que si on utilise notre donnée une seule fois, notre cache ne sert à rien. Autant copier directement nos données dans les registres. C'est pour cela que les premiers processeurs vectoriels et les <em>Streams processors</em> ont peu ou pas de cache. Les premiers <em>Streams Processors</em>, comme l'Imagine, n'avaient strictement aucun cache.</p><p id="r-443970" data-claire-element-id="443970">Je tiens toutefois à nuancer ce que j'ai dit plus haut : si notre <em>Stream Processor</em> ne contient pas de mémoire cache pour les données, ce n'est pas le cas pour les instructions. Après tout, si l'on doit exécuter ces instructions plusieurs fois de suite sur des données différentes, autant éviter de les charger de la mémoire à chaque fois. Pour éviter cela, les suites d'instructions à exécuter sont stockées dans une petite mémoire une bonne fois pour toute. Il s'agit bel et bien d'une petite mémoire cache.</p><p id="r-443971" data-claire-element-id="443971">De plus, les cartes graphiques récentes utilisent de plus en plus de mémoires caches disséminées un peu partout sur leur puce. On trouve ainsi des caches L1, L2, L3, etc, certains étant partagés, d'autres non. Ces caches sont utiles lorsque l'on utilise la carte graphique via des couches logicielles de GPGPU comme CUDA ou OpenMP : on exécute alors du code assez généraliste, qui possède une localité pas trop mauvaise. Dans ces conditions, les mémoires caches peuvent se rendre utiles.</p><h5 id="r-register-files" data-claire-element-id="443980">Register Files</h5><p id="r-443973" data-claire-element-id="443973">Sur un processeur, les registres sont tous regroupés dans de grosses mémoires RAM qu'on appelle des <em>Register Files</em>. On en trouve dans des tas de processeurs, et pas seulement dans des <em>Streams Processors</em>. Dans nos <em>Streams Processors</em>, on remarque que l'on en a plusieurs. On trouve d'abord quelques <strong><em>Local Register File</em></strong>. Ceux-ci sont directement connectés aux unités de calcul. C'est dans ces <em>Local Register File</em> que nos unités de calcul vont aller chercher les données qu'elles doivent manipuler. Plus bas, ces <em>Local Register Files</em> sont reliés à un <em>Register File</em> plus gros, le <strong><em>Global Register File</em></strong>, lui-même relié à la mémoire. C'est très différent de ce qu'on trouve sur les processeurs plus habituels. D'habitude, on ne dispose pas de plusieurs couches de <em>Register Files</em>. A la place, on trouve une couche de registres, une couche de cache, une couche de mémoire. Sur les processeurs vectoriels, on trouve a la place une couche de registres vectoriels, avec une mémoire RAM. Alors pourquoi trouve-on plusieurs couches de registres ?</p><p id="r-443974" data-claire-element-id="443974">Le fait est que nos <em>Streams Processors</em> et nos GPU disposent d'une grande quantité d'unités de calcul. Et cela peut facilement aller à plus d'une centaine ou d'un millier d'ALU ! Si on devait relier toutes cas unités de calcul à un gros <em>Register File</em>, cela poserait pas mal de problème. Si on faisait ça, on se retrouverait avec un <em>Register File</em> énorme, lent, et qui chaufferait beaucoup trop. Pour garder un <em>Register Files</em> rapide et pratique, on est obligé de limiter le nombre d'unités de calcul connectées dessus, ainsi que le nombre de registres contenus dans le <em>Register File</em>. La solution est donc de casser notre gros <em>Register File</em> en plusieurs plus petits, reliés à un <em>Register File</em> plus gros, capable de communiquer avec la mémoire. Ainsi, nos unités de calcul vont aller lire ou écrire dans un <em>Local Register File</em> très rapide.</p><figure id="r-443976" data-claire-element-id="443977"><img id="r-443975" data-claire-element-id="443975" src="medias/uploads.siteduzero.com_files_403001_404000_403180.png" alt="Image utilisateur"/></figure><p id="r-443978" data-claire-element-id="443978">Notre <em>Global Register File</em> va en quelque sorte d'intermédiaire entre la mémoire RAM et le <em>Local Register File</em>. Un peu comme une mémoire cache. La différence entre ce <em>Global Register File</em> et un cache vient du fait que les caches sont souvent gérés par le matériel, tandis que ces <em>Register Files</em> sont gérés via des instructions machines. Le processeur dispose ainsi d'instructions pour transférer des données entre les <em>Register Files</em> ou entre ceux-ci et la mémoire. Leur gestion peut donc être déléguée au logiciel, qui saura les utiliser au mieux.</p><p id="r-443979" data-claire-element-id="443979">Notre <em>Global Register File</em> va servir à stocker un ou plusieurs <em>Threads</em> destinés à être traités par notre <em>Stream Processor</em>. Il peut aussi servir à transférer des données entre les <em>Local Register Files</em>, où à stocker des données globales, utilisées par des <em>Clusters </em>d'ALU différents. Quand à nos <em>Local Register File</em>, ils vont servir à stocker des morceaux de <em>Threads </em>en cours de traitement : tous les résultats temporaires vont aller dans ce <em>Local Register File</em>, afin d'être lus ou écrits le plus rapidement possible.</p><h5 id="r-du-cote-de-la-ram" data-claire-element-id="443983">Du coté de la RAM</h5><p id="r-443981" data-claire-element-id="443981">Les transferts de données entre la mémoire et le <em>Global Register File</em> ressemble fortement à ceux qu'on trouve sur les processeurs vectoriels. Généralement, un Stream Processor posséde quelques instructions capables de transférer des données entre ce <em>Global Register File</em> et la mémoire RAM. Et on trouve des instructions capables de travailler sur un grand nombre de données simultanées, des accès mémoires en <em>Stride</em>, en <em>Scatter-Gather</em>, etc. La mémoire RAM d'un <em>Stream Processor</em> est souvent une mémoire spéciale, divisée en plusieurs sous-mémoires auxquelles on peut accéder indépendamment. Ces mémoires indépendantes sont ce qu'on appelle des bancs mémoires, et on les a déjà évoqués dans le chapitre sur les processeurs vectoriels.</p><p id="r-443982" data-claire-element-id="443982">Cette mémoire RAM est une mémoire qui possède souvent un gros débit binaire. Je rappelle que le débit binaire d'une mémoire est le nombre de bits qu'elle peut transférer en une seule seconde. Par contre, cela ne signifie pas que cette mémoire est rapide : le temps mit pour lire ou écrire une donnée est assez important. Il ne faut pas faire la confusion entre le débit binaire et le temps d'accès. Pour faire une analogie avec les réseaux, le débit binaire peut être vu comme le débit de la mémoire, alors que le temps d'accès serait similaire au <em>ping</em>. Il est parfaitement possible d'avoir un ping élevé avec une connexion qui télécharge très vite, et inversement. Pour la mémoire, c'est similaire.</p><h5 id="r-une-histoire-de-latence" data-claire-element-id="443992">Une histoire de latence</h5><p id="r-443984" data-claire-element-id="443984">Comme je l'ai dit plus haut, la mémoire RAM est très lente. Et quand on n'a pas de mémoires caches pour diminuer la latence des accès mémoire, on doit trouver une autre solution. Au lieu de chercher à diminuer la latence, les <em>Streams Processors</em> vont plutôt chercher à cacher cette dernière.</p><h6 id="r-long-pipeline" data-claire-element-id="443986">Long Pipeline</h6><p id="r-443985" data-claire-element-id="443985">La première solution pour cela consiste à permettre à notre <em>Stream Processor</em> de continuer à exécuter des instructions pendant que l'on accède à la mémoire. Avec ce principe, on peut remplir les vides dus à l'accès mémoire par des instructions indépendantes de la donnée à lire ou à écrire. Cela fonctionne à condition que l'on aie suffisamment d'instructions à exécuter et que les lectures soient rares. Autant dire que c'est un cas assez rare. Et surtout, cela dépend fortement de la qualité du programme qui s’exécute, et de la qualité du compilateur qui a servi à compiler ce dernier.</p><h6 id="r-simt" data-claire-element-id="443991">SIMT</h6><p id="r-443987" data-claire-element-id="443987">Depuis les Radeon X1800, on préfère utiliser une autre technique : le <em><strong>Single Instruction Multiple Threads</strong></em>, aussi appelé <em>SIMT</em>. L'idée est simplement de permettre à notre processeur de gérer un grand nombre de <em>Threads</em> et de changer de <em>Thread </em>si l'un d'entre eux doit accéder à la mémoire. Mais attention, comme je l'ai dit plus haut, sur un GPU, un <em>Thread </em>n'est rien d'autre qu'un morceau de donnée similaire aux paquets SIMD vus dans les chapitres précédents. Avec le <em>SIMT</em>, si jamais on doit accéder à la mémoire, on change de <em>Thread</em>. Au lieu de perdre son temps à attendre, on va ainsi remplir les vides en commençant à traiter d'autres données.</p><figure id="r-443989" data-claire-element-id="443990"><img id="r-443988" data-claire-element-id="443988" src="medias/uploads.siteduzero.com_files_403001_404000_403707.png" alt="Image utilisateur"/></figure>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
<span class="arrow"></span>
<span class="next">Architecture d&#039;un GPU</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
<span class="next">Jeu d&#039;instruction</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Jeud039instruction"></a><h2>Jeu d&#039;instruction</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
<span class="arrow"></span>
<span class="next">Hiérarchie mémoire</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-jeu-d-instruction-1" data-claire-element-id="444042">Jeu d'instruction</h4><p id="r-443994" data-claire-element-id="443994">On peut se demander de quoi sont capables ces fameux <em>Streams Processors</em>, quels calculs ils sont capables d'effectuer. De ce point de vue, si on regarde les instructions qu'ils sont capables de faire, cela a beaucoup évolué au fil du temps. Les premiers processeurs traitant des <em>Shaders </em>avaient un jeu d'instruction assez restreint. On ne pouvait qu'effectuer des calculs arithmétiques les uns à la suite des autres, sans possibilités d'effectuer des choix (conditions if, else, etc), et sans pouvoir répéter des instructions (boucles). On trouvait de quoi faire des additions, des soustractions, des multiplications, mais rien de vraiment folichon. Au fil du temps, les GPU sont devenus de plus en plus programmables, et des instructions de tests et de branchements ont fait leur apparition. Les GPU sont devenus capables d'effectuer des boucles, des tests voire même des appels de fonctions. En même temps, les calculs qu'ils peuvent effectuer se sont enrichis.</p><p id="r-443995" data-claire-element-id="443995">Généralement, un <em>Stream Processor</em> peut effectuer des calculs sur des nombres entiers ou sur des nombres à virgule qu'on appelle des nombres à virgule flottante. On trouve les classiques additions, multiplications et opérations logiques (OU, ET, XOR, NON, etc).On trouve aussi des instructions qui permettent de calculer le maximum de deux nombres, leur moyenne, ou leur minimum). On a aussi des instructions d'arrondis pour les nombres à virgule flottante. Parfois, le <em>Stream Processor</em> est capable d'effectuer des opérations plus complexes comme des exponentielles, des racines carrées, le calcul de \frac {1} {\sqrt n}, \frac {1} {n}, des sinus, des cosinus, etc.</p><p id="r-443996" data-claire-element-id="443996">On peut aussi citer le fait que les GPU récents supportent des instructions atomiques, utilisée pour partager la mémoire. Cela peut servir dans certains algorithmes.</p><h5 id="r-plusieurs-alu" data-claire-element-id="444034">Plusieurs ALU</h5><p id="r-443997" data-claire-element-id="443997">Pour effectuer ces calculs, chaque <em>Stream Processor</em> contient des unités de calcul. Ces unités de calcul d'un <em>Stream Processor</em> ne sont pas forcément identiques. On peut parfaitement avoir quelques ALU capables d'effectuer des additions et multiplications (plus quelques opérations très simples du genre), à coté d'une grosse ALU capable d'effectuer des opérations couteuses et lentes (exponentielle, etc). On trouve aussi souvent une unité chargée de la gestion des accès mémoires, et notamment des transferts de données entre le <em>Local Register File</em> et le <em>Global Register File</em>. Ces unités de calcul ne sont pas commandées n'importe comment : il faut bien répartir nos calculs sur nos unités de calcul pour les faire fonctionner en parallèle. Il existe deux grandes façons de les piloter sur un <em>Stream processor</em> ou un GPU.</p><h6 id="r-vliw" data-claire-element-id="444031">VLIW</h6><p id="r-443998" data-claire-element-id="443998">Première solution : faire de nos <em>Streams Processors</em> des processeurs VLIW. Sur ces processeurs VLIW, nos instructions sont regroupées dans ce qu'on appelle des <em>Bundles</em>, des sortes de super-instructions. Ces <em>bundles </em>sont découpés en <em>slots</em>, en morceaux de taille bien précise, dans lesquels il va venir placer les instructions élémentaires à faire éxecuter.</p><table id="r-444029" data-claire-element-id="444029"><thead id="r-444006" data-claire-element-id="444006"><tr id="r-444005" data-claire-element-id="444005"><th id="r-444000" data-claire-element-id="444000"><p id="r-443999" data-claire-element-id="443999">Instruction</p></th><th id="r-444002" data-claire-element-id="444002"><p id="r-444001" data-claire-element-id="444001">VLIW</p></th><th id="r-444004" data-claire-element-id="444004"><p id="r-444003" data-claire-element-id="444003">à 3 slots</p></th></tr></thead><tbody id="r-444028" data-claire-element-id="444028"><tr id="r-444013" data-claire-element-id="444013"><td id="r-444008" data-claire-element-id="444008"><p id="r-444007" data-claire-element-id="444007">Slot 1</p></td><td id="r-444010" data-claire-element-id="444010"><p id="r-444009" data-claire-element-id="444009">Slot 2</p></td><td id="r-444012" data-claire-element-id="444012"><p id="r-444011" data-claire-element-id="444011">Slot 3</p></td></tr><tr id="r-444020" data-claire-element-id="444020"><td id="r-444015" data-claire-element-id="444015"><p id="r-444014" data-claire-element-id="444014">Addition</p></td><td id="r-444017" data-claire-element-id="444017"><p id="r-444016" data-claire-element-id="444016">Multiplication</p></td><td id="r-444019" data-claire-element-id="444019"><p id="r-444018" data-claire-element-id="444018">Décalage à gauche</p></td></tr><tr id="r-444027" data-claire-element-id="444027"><td id="r-444022" data-claire-element-id="444022"><p id="r-444021" data-claire-element-id="444021">0111 1111 0000</p></td><td id="r-444024" data-claire-element-id="444024"><p id="r-444023" data-claire-element-id="444023">0110 1111 0101</p></td><td id="r-444026" data-claire-element-id="444026"><p id="r-444025" data-claire-element-id="444025">0110 1001 0101</p></td></tr></tbody></table><p id="r-444030" data-claire-element-id="444030">Chaque <em>slot </em>sera attribué à une unité de calcul bien précise. Par exemple, le premier <em>slot</em> sera attribué à la première ALU, la second à une autre ALU, le troisième à la FPU, etc. Ainsi, l'unité de calcul exécutant l'instruction sera précisée via la place de l'instruction élémentaire, le <em>slot </em>dans lequel elle se trouve. Qui plus est, vu que chaque <em>slot </em>sera attribué à une unité de calcul différente, le compilateur peut se débrouiller pour que chaque instruction dans un <em>bundle</em> soit indépendante de toutes les autres instructions dans ce <em>bundle</em>. Lorsqu'on exécute un <em>bundle</em>, il sera décomposée par le séquenceur en petites instructions élémentaires qui seront chacune attribuée à l'unité de calcul précisée par le <em>slot</em> qu'elles occupent. Pour simplifier la tache du décodage, on fait en sorte que chaque <em>slot </em>aie une taille fixe.</p><h6 id="r-simd-1" data-claire-element-id="444033">SIMD</h6><p id="r-444032" data-claire-element-id="444032">Autre solution : faire en sorte que nos unités de calcul soient utilisées par des instructions SIMD. Ainsi, toutes nos unités de calculs sont identiques et exécutent simultanément la même instruction à chaque cycle d'horloge. On se retrouve ainsi avec la même situation que pour les processeurs vectoriels avec plusieurs lanes ou comme avec les processeurs utilisant des instructions SIMD utilisant une ALU par donnée d'un paquet SIMD. Cette solution est assez récente et date des GPU Geforce 8800. Les cartes graphiques récentes utilisent toutes des instructions SIMD et non des instructions VLIW. Il faut dire que le VLIW est certes très adapté pour les calculs de rendu 3D, mais est nettement moins adapté aux calculs généralistes. Et avec l'apparition de CUDA et des autres openMP et librairies de traitement GPGPU, le VLIW commence à perdre de l’intérêt.</p><h5 id="r-predication-1" data-claire-element-id="444041">Prédication</h5><p id="r-444035" data-claire-element-id="444035">Ces instructions SIMD sont très utiles quand on doit effectuer un traitement identique sur un ensemble de données identiques. Mais dès que le traitement à effectuer sur nos données varie suivant le résultat d'un test ou d'un branchement, les choses se gâtent. Mine de rien, avec une instruction vectorielle, on est obligé de calculer et de modifier tous les éléments d'un paquet : il est impossible de zapper certains éléments d'un paquet dans certaines conditions. Par exemple, imaginons que je veuille seulement additionner les éléments d'un paquet ensemble s'ils sont positifs : je ne peux pas le faire avec une instruction vectorielle &quot;normale&quot;. Du moins, pas sans aide.</p><p id="r-444036" data-claire-element-id="444036">Pour résoudre ce problèmes, nos <em>Streams Processors</em> et nos GPU utilisent une technique vue sur les processeurs vectoriels : le <em>Vector Mask Register</em>. Celui-ci permet de stocker des informations qui permettront de sélectionner certaines données et pas d'autres pour faire notre calcul. Ce <em>Vector Mask Register</em> va stocker des bits pour chaque flottant présent dans le vecteur à traiter. Si ce bit est à 1, notre instruction doit s’exécuter sur la donnée associée à ce bit. Sinon, notre instruction ne doit pas la modifier. On peut ainsi traiter seulement une partie des données via une instruction VLIW ou SIMD.</p><figure id="r-444038" data-claire-element-id="444039"><img id="r-444037" data-claire-element-id="444037" src="medias/uploads.siteduzero.com_files_403001_404000_403032.png" alt="Image utilisateur"/></figure><p id="r-444040" data-claire-element-id="444040">Nos <em>Streams Processors</em> ont souvent une grande quantité d'instructions pour mettre à jour ce <em>Vector Mask Register</em>, suivant les circonstances. Certaines instructions peuvent ainsi comparer le contenu de deux registres, données par données, et décider quoi mettre dans ce registre de masquage en fonction de chaque résultat.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes">Multicoeurs, Hyperthreading, GPGPU : les architectures modernes</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Le parallélisme : un peu de théorie
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differentes-architectures-paralleles">Les différentes architectures parallèles</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-differents-types-de-parallelisme">
Les différents types de parallélisme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/partage-de-la-memoire">
Partage de la mémoire
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-limites-theoriques">Les limites théoriques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-d-amdhal">
Loi d&#039;Amdhal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/loi-de-gustafson">
Loi de Gustafson
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Multi-processeurs, Multicoeurs et Hyperthreading
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hyperthreading-et-compagnie">Hyperthreading et compagnie</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/du-parallelisme-avec-un-seul-processeur">
Du parallèlisme avec un seul processeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/et-dans-le-processeur">
Et dans le processeur ?
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs-1">Processeurs multicoeurs</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/processeurs-multicoeurs">
Processeurs multicœurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/le-partage-des-caches">
Le partage des caches
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 3</span>
Le partage de la mémoire
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/coherence-memoire">Cohérence mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/mecanismes-de-base">
Mécanismes de base
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/protocoles-de-coherence-des-caches">
Protocoles de cohérence des caches
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/consistance-memoire">Consistance mémoire</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/modeles-de-consistance">
Modèles de consistance
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/fences-et-memory-barrier">
Fences et Memory Barrier
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/synchronisation-entre-threads">Synchronisation entre Threads</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exclusion-mutuelle-1">
Exclusion mutuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/memoire-transactionelle-materielle">
Mémoire Transactionelle Matérielle
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 4</span>
Le parallèlisme de données
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd-1">Instructions SIMD</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/instructions-simd">
Instructions SIMD
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/exemples-mmx-sse-et-avx">
Exemples : MMX, SSE et AVX
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/les-processeurs-vectoriels">Les processeurs vectoriels</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/pipelining">
Pipelining
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/acces-memoires-2">
Accès mémoires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/quelques-registres-utiles">
Quelques registres utiles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/gpgpu-et-streams-processors">GPGPU et Streams Processors</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/architecture-d-un-gpu">
Architecture d&#039;un GPU
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
Hiérarchie mémoire
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/jeu-d-instruction-1">
Jeu d&#039;instruction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes/hierarchie-memoire-2">
<span class="arrow"></span>
<span class="next">Hiérarchie mémoire</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Oct 2013 22:47:24 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/multicoeurs-hyperthreading-gpgpu-les-architectures-modernes.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:01:41 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/le-tri-par-insertion.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 11:16:53 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/le-tri-par-insertion.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:49:04 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Le tri par insertion</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/le-tri-par-insertion.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Le tri par insertion</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Letriparinsertion">Le tri par insertion</a><br/><a href="#Principe">Principe</a><br/><a href="#Implmentation">Implémentation</a><br/><a href="#Complexit">Complexité</a><br/></div>
<a name="Letriparinsertion"></a><h2>Le tri par insertion</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/principe-50">
<span class="next">Principe</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-483688" data-claire-element-id="483688">Le tri par insertion est le tri le plus connu.<br/> C'est celui que les gens utilisent intuitivement quand ils doivent trier une liste d'objets, par exemple quand on joue aux cartes.</p>
</div><a name="Principe"></a><h2>Principe</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/implementation-24">
<span class="next">Implémentation</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-483689" data-claire-element-id="483689">L'algorithme principal du tri par insertion est un algorithme qui insère un élément dans une liste d'éléments déjà triés (par exemple, par ordre croissant).</p><p id="r-483690" data-claire-element-id="483690">Imaginez un joueur de cartes qui dispose de cartes numérotées. Il a des cartes triées de la plus petite à la plus grande dans sa main gauche, et une carte dans la main droite. Où placer cette carte dans la main gauche de façon à ce qu'elle reste triée ? Il faut la placer après les cartes plus petites, et avant les cartes plus grandes.</p><p id="r-483691" data-claire-element-id="483691">Par exemple, si la main gauche est (1 3 6 8), et que j'ai la carte 5 dans la main droite, il faut la placer après (1 3) et avant (6 8). Si l'on fait ça, on se retrouve avec la main gauche (1 3 5 6 8), qui est encore triée.</p><p id="r-483692" data-claire-element-id="483692">Pour trier entièrement un ensemble de cartes dans le désordre, il suffit alors de placer toutes ses cartes dans la main droite (la main gauche est donc vide), et d'insérer les cartes une à une dans la main gauche, en suivant la procédure ci-dessus.</p><p id="r-483693" data-claire-element-id="483693">Au départ, la main gauche est vide, donc elle bien triée.<br/> À chaque fois que l'on insère une carte depuis la main droite vers la main gauche, la main gauche reste triée, et la main droite (l'ensemble des cartes non triées) perd une carte. Ainsi, si la main droite comprenait au départ N cartes, en N insertions, on se retrouve avec O carte dans la main droite, et N cartes, triées, dans la main gauche : on a bien trié notre ensemble de cartes.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion">Le tri par insertion</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/principe-50">
Principe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/implementation-24">
Implémentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/complexite-9">
Complexité
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/implementation-24">
<span class="next">Implémentation</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Implmentation"></a><h2>Implémentation</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/principe-50">
<span class="arrow"></span>
<span class="next">Principe</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/complexite-9">
<span class="next">Complexité</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-inserer-un-seul-element-dans-la-main-gauche" data-claire-element-id="483711">Insérer un seul élément dans la main gauche</h2><p id="r-483695" data-claire-element-id="483695">Commençons tout d’abord par l’opération d’insertion d’une carte de la main droite vers la main gauche. On veut placer la carte après toutes les cartes plus petites, et avant toutes les cartes plus grandes.</p><p id="r-483696" data-claire-element-id="483696">En reprenant notre exemple de tout à l'heure, pour insérer l'élément 5 dans la main (1 3 6 8), voici ce qu'on veut faire :</p><figure id="r-483698" data-claire-element-id="483699"><img id="r-483697" data-claire-element-id="483697" src="medias/uploads.siteduzero.com_files_229001_230000_229425.png" alt="Image utilisateur"/></figure><p id="r-483700" data-claire-element-id="483700">Pour faire cela avec un tableau, on a du décaler certaines cartes : 6 était en position 2 avant l'insertion, elle est en position 3 après. De même, la carte 8 a été décalée. Plus généralement, il faut décaler d’une case vers la droite toutes les cartes plus grandes que la carte à insérer.</p><p id="r-483701" data-claire-element-id="483701">Pour faire cela, une bonne méthode est de commencer par la droite : on décale la carte la plus à droite (8), puis celle juste à gauche (6), jusqu'au moment où on tombe sur une carte plus petite que celle qu'on veut insérer, qu'il ne faut pas décaler. Une fois qu'on a fait ces décalages, on peut insérer la carte, à la position à laquelle on s'est arrêté de décaler.</p><p id="r-483702" data-claire-element-id="483702">Voici le code :</p><pre id="r-483703" data-claire-element-id="483703"><code data-claire-semantic="c">void inserer(int element_a_inserer, int tab[], int taille_gauche)
{
    int j;
    for (j = taille_gauche; j &gt; 0 &amp;&amp; tab[j-1] &gt; element_a_inserer; j--)
      tab[j] = tab[j-1];
    tab[j] = element_a_inserer;
}</code></pre><p id="r-483704" data-claire-element-id="483704">On part de la fin de la main gauche, donc de <code>taille_gauche</code>, et on descend (<code>j--</code>) tant que les cartes sont plus grandes que la carte à insérer. Le test <code>j &gt; 0</code> vérifie qu’on ne sort pas du tableau, ce qui pourrait arriver si toutes les cartes sont plus grandes que l’élément à insérer.</p><p id="r-483705" data-claire-element-id="483705">La boucle s’arrête quand la carte <code>tab[j-1]</code> devient plus petite que l’élément à insérer. On insère alors cet élément juste après la case <code>j-1</code>, donc en <code>j</code>.</p><p id="r-483706" data-claire-element-id="483706">Une illustration pour mieux comprendre :</p><figure id="r-483708" data-claire-element-id="483709"><img id="r-483707" data-claire-element-id="483707" src="medias/uploads.siteduzero.com_files_229001_230000_229433.png" alt="Image utilisateur"/></figure><p id="r-483710" data-claire-element-id="483710">Il y a une remarque importante à faire : <code>taille_gauche</code> est la taille de la main gauche, mais ce n’est pas la taille du tableau <code>tab</code> : comme on rajoute un élément, on a besoin que le tableau <code>tab</code> ait au moins une case de plus. Sur le dessin, ça correspond à la présence d'une case verte supplémentaire, vide, au début de l'insertion.<br/> On suppose donc que la taille réelle de <code>tab</code> est toujours strictement supérieure à <code>taille_gauche</code>, et c’est pour cela qu’on s’autorise à écrire dans <code>tab[taille_gauche]</code> (au premier tour de boucle, quand <code>j</code> vaut <code>taille_gauche</code>). Quand on utilisera la fonction <code>inserer</code>, on vérifiera que la taille du tableau convient.</p><h2 id="r-tri-complet" data-claire-element-id="483730">Tri complet</h2><p id="r-483712" data-claire-element-id="483712">Il est maintenant très simple de coder le tri complet.</p><pre id="r-483713" data-claire-element-id="483713"><code data-claire-semantic="c">void tri_insertion(int tab[], int taille)
{
    int i;
    for(i = 1; i &lt; taille; ++i)
        inserer(tab[i], tab, i);
}</code></pre><p id="r-483714" data-claire-element-id="483714">Je parcours le tableau avec l’indice <code>i</code>.</p><p id="r-483715" data-claire-element-id="483715">L’idée, c’est que je considère que toutes les cartes avant <code>i</code> sont triées, et que toutes les cartes après <code>i</code> ne sont pas triées, <code>tab[i]</code> compris. <code>i</code> est donc la limite entre la main gauche et la main droite.<br/> Autrement dit, j'ai bien mes deux mains (heureusement !), mais ce ne sont pas deux mains séparées, elles sont ensembles dans un seul tableau : la main gauche est le début du tableau, qui est déjà trié, et la main droite le reste du tableau.</p><p id="r-483716" data-claire-element-id="483716">Jusqu'à présent, dans l'implémentation, je n'ai pas parlé de la main droite : on insérait seulement un élément. Cet élément est la première carte de la main droite. Par exemple, l'insertion que je vous ai montrée au départ faisait en fait partie du tri du tableau suivant, quand <code>i</code> vaut <code>4</code> :</p><figure id="r-483718" data-claire-element-id="483719"><img id="r-483717" data-claire-element-id="483717" src="medias/uploads.siteduzero.com_files_229001_230000_229423.png" alt="Image utilisateur"/></figure><p id="r-483720" data-claire-element-id="483720">Comme <code>i</code> est la limite entre la main droite et la main gauche, la carte d’indice <code>i</code> appartient avant l’insertion à la main droite, et après à la main gauche. Au début de la boucle, <code>[0...i-1]</code> est la main gauche, puis on insère <code>tab[i]</code> avec la fonction vue au-dessus, donc la main gauche devient <code>[0..i]</code>, et reste triée.</p><p id="r-483721" data-claire-element-id="483721">Illustration :</p><figure id="r-483723" data-claire-element-id="483724"><img id="r-483722" data-claire-element-id="483722" src="medias/uploads.siteduzero.com_files_229001_230000_229424.png" alt="Image utilisateur"/></figure><p id="r-483725" data-claire-element-id="483725">En faisant varier <code>i</code> de <code>1</code> à <code>taille-1</code> (<code>i &lt; taille</code> est la condition d’arrêt), on insère donc peu à peu toutes les cartes dans la main gauche. <br/> On remarque que la boucle commence à <code>1</code>, et non à <code>0</code>. La première carte, comme elle est toute seule, est déjà une liste triée, donc on peut l’inclure d’office dans la main gauche.</p><p id="r-483726" data-claire-element-id="483726">Vous remarquerez que la taille donnée à la fonction <code>inserer</code> est <code>i</code>. Ainsi, comme la plus grande valeur de <code>i</code> possible est <code>taille-1</code>, la plus grande taille donnée à insérer est <code>taille-1</code> aussi. J’avais dit qu’on ferait attention à ce que la taille donnée pour la main gauche soit toujours inférieure à la véritable taille du tableau, et vous pouvez maintenant le vérifier.</p><p id="r-483727" data-claire-element-id="483727">Voici une &quot;version longue&quot; (mais il n’y a pas de DVD bonus ;) ) du code, qui réunit les deux fonctions en une seule, et un petit exemple d’utilisation :</p><pre id="r-483728" data-claire-element-id="483728"><code data-claire-semantic="c">#include &lt;stdio.h&gt;

void tri_insertion(int tab[], int taille)
{
   int i, j;
   for (i = 1; i &lt; taille; ++i) {
       int elem = tab[i];
       for (j = i; j &gt; 0 &amp;&amp; tab[j-1] &gt; elem; j--)
           tab[j] = tab[j-1];
       tab[j] = elem;
   }
}

int main(void)
{
    int i;
    int tableau[10] = {9, 8, 6, 7, 5, 2, 4, 1, 3, 0};
    
    printf(&quot;avant le tri : &quot;);
    for(i = 0; i &lt; 10; i++) printf(&quot;%d &quot;, tableau[i]);
    printf(&quot;\n&quot;);
    
    tri_insertion(tableau, 10);
    
    printf(&quot;apres le tri : &quot;);
    for(i = 0; i &lt; 10; i++) printf(&quot;%d &quot;, tableau[i]);
    printf(&quot;\n&quot;);
    
    return 0;
}</code></pre><p id="r-483729" data-claire-element-id="483729">Remarque : écrire un tel code semble simple, mais il y a en fait plusieurs façons différentes de voir les choses qui donnent lieu à des codes très différents les uns des autres, et pas toujours aussi efficaces. J'ai toujours pris soin d'avoir un code simple à présenter et expliquer, mais une version précédente de ce tutoriel utilisait pour cela une implémentation nettement moins efficace en pratique (trois recopies pour chaque élément décalé dans la fonction d'insertion, au lieu d'une). La version actuelle est née des remarques de <a href="http://www.siteduzero.com/membres-294-15207.html">candide</a>, et permet de combiner efficacité et simplicité, quand on donne les explications adaptées.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion">Le tri par insertion</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/principe-50">
Principe
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/implementation-24">
Implémentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/complexite-9">
Complexité
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/principe-50">
<span class="arrow"></span>
<span class="next">Principe</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/complexite-9">
<span class="next">Complexité</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Complexit"></a><h2>Complexité</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/implementation-24">
<span class="arrow"></span>
<span class="next">Implémentation</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-483732" data-claire-element-id="483732">Comment peut-on évaluer la rapidité de cet algorithme ?<br/> On pourrait mesurer son temps d'exécution sur mon ordinateur, mais cela n'est pas fiable parce que si on change d'ordinateur, le temps d'exécution change aussi : il peut être très rapide chez mon voisin (qui a un super PC) et très lent chez moi.<br/> Une mesure plus rigoureuse de la &quot;rapidité&quot; de l'algorithme serait de mesurer le &quot;nombre d'opérations&quot; qu'il effectue : que ce soit chez moi ou chez mon voisin, pour trier le même tableau, il va effectuer le même nombre d'opérations, mais pas à la même vitesse.<br/> L'avantage de ce critère est qu'il permet de comparer efficacement les algorithmes entre eux, indépendamment de l'ordinateur qui les exécute : si un algorithme fait plus d'opérations que le mien, il sera plus lent et chez moi, et chez mon voisin ; même si le nouvel algorithme est plus rapide chez mon voisin que l'algorithme actuel chez moi, je saurais qu'il est moins bon.</p><p id="r-483733" data-claire-element-id="483733">Il reste à définir ce qu'est une &quot;opération&quot;. Plutôt que d'essayer de capturer absolument tous les détails du code (quand on incrémente une variable, quand on fait un test, etc.), on choisit une définition plus abstraite : on va dire que mon algorithme effectue une opération à chaque fois qu'il compare deux cartes entre elles.<br/> C'est un choix assez pertinent, car la comparaison des cartes est le coeur de mon algorithme de tri. En particulier, si les éléments que l'on trie sont longs à comparer entre eux (ce qui est assez souvent le cas, quand on ne trie pas seulement des entiers, mais des structures plus complexes), ce sont effectivement les comparaisons qui prendront le plus de temps, et non pas les incrémentations de variables dans les boucles for, par exemple.</p><p id="r-483734" data-claire-element-id="483734">Il s'agit donc de calculer le nombre de comparaisons totales effectuées par le programme.</p><p id="r-483735" data-claire-element-id="483735">Supposons que N est la taille du tableau à trier. Je fais ici une approche globale et un calcul exact.<br/> Si les maths vous ennuient, lisez juste l'approche.</p><h3 id="r-approche-1" data-claire-element-id="483738">Approche</h3><p id="r-483736" data-claire-element-id="483736">Si N est la taille de l'entrée, le contenu de la première boucle est exécuté (l'ordinateur fait ce qui est dedans) environ N fois (plus précisément, N-1 fois). <br/> À chaque fois qu'on exécute cette première boucle, on exécute la deuxième boucle entre 0 et i fois : on part de la case i, et on va jusqu'à la case 0, en s'arrêtant avant si on trouve une carte plus petite que l'élément à insérer. On a donc un nombre de comparaisons variant entre 0 et i, donc entre 0 et N.<br/> Le nombre total d'exécutions de la deuxième est donc plus grand que N * 0, et plus petit que N * N, entre 0 et N².</p><p id="r-483737" data-claire-element-id="483737">On dit donc que le nombre de calculs de cet algorithme est de l'ordre de N² (dans le calcul détaillé, vous verrez que c'est plutôt N² / 2, mais que la différence n'a pas grand sens).</p><h3 id="r-calcul-exact-dans-le-pire-cas" data-claire-element-id="483749">Calcul exact dans le pire cas</h3><p id="r-483739" data-claire-element-id="483739">Une bonne façon de mesurer la complexité de l'algorithme est de compter le nombre de calculs effectués &quot;dans le pire cas&quot;, c'est à dire dans la configuration qui donnera le plus de travail possible à l'algorithme. Si on connaît bien ce cas, on a une idée du temps maximal que peut prendre l'algorithme (et donc on sait que &quot;c'est toujours mieux que ...&quot;, ce qui est assez rassurant).</p><p id="r-483740" data-claire-element-id="483740">Dans le pire cas, il faut décaler à chaque fois toutes les cartes de la main gauche, et pas seulement une partie d'entre elles. À chaque tour de boucle on a donc <strong>i</strong> comparaisons (la taille de la main gauche).</p><p id="r-483741" data-claire-element-id="483741">Le nombre total de comparaisons est donc 1 + 2 + 3 + 4 + 5...+ N-1 (la dernière valeur de i est N-1).<br/> Combien vaut ce nombre ? Appelons-le S. On a :</p><pre id="r-483742" data-claire-element-id="483742"><code data-claire-semantic="bash">S =    1 + 2   + 3   + 4   + 5   + ... + N-5 + N-4 + N-3 + N-2 + N-1
S =  N-1 + N-2 + N-3 + N-4 + N-5 +.... + 5   + 4   + 3   + 2   + 1</code></pre><p id="r-483743" data-claire-element-id="483743">(J'ai renversé l'addition sur la deuxième ligne, ce qui ne change pas la valeur de S.)</p><p id="r-483744" data-claire-element-id="483744">En additionnant chaque somme des deux lignes &quot;en colonnes&quot;, on additionne S + S, le résultat est 2S :</p><pre id="r-483745" data-claire-element-id="483745"><code data-claire-semantic="bash">S =   1  +  2  +  3  +  4  +  5  + ... + N-5 + N-4 + N-3 + N-2 + N-1
S =  N-1 + N-2 + N-3 + N-4 + N-5 +.... +  5  +  4  +  3  +  2  +  1
2S =   N +  N  +  N  +  N  +  N  +  N  +  N  +  N  +  N  +  N  +  N</code></pre><p id="r-483746" data-claire-element-id="483746">On voit que 2S, c'est N ajouté à lui-même N-1 fois (de 1 à N-1, il y a N-1 termes).<br/> On a donc 2S = N(N-1) ou S = N(N-1)/2.</p><p id="r-483747" data-claire-element-id="483747">Quand N est très grand, N(N-1) est approximativement égal à N², et le nombre de comparaisons de l'algorithme est donc d'environ N²/2, ou N²*0.5 comparaisons.</p><p id="r-483748" data-claire-element-id="483748">Cependant, le facteur 0.5 n'a pas grand sens : sur un ordinateur deux fois plus rapide, on ira deux fois plus vite et sur un ordinateur 2 fois plus lent, deux fois moins vite.<br/> Pour estimer le temps mis par cet algorithme de manière indépendante de l'ordinateur, on dit donc que le nombre d'actions qu'il fait est &quot;de l'ordre de N²&quot;.</p><h3 id="r-conclusion-52" data-claire-element-id="483752">Conclusion</h3><p id="r-483750" data-claire-element-id="483750">En langage &quot;scientifique&quot;, on dira que la complexité du tri par insertion est de O(N²).</p><p id="r-483751" data-claire-element-id="483751">En pratique, cela signifie que si l'on double la taille du tableau, l'algorithme sera 4 fois plus lent, et si on la multiplie par 10, 100 fois plus lent.</p><h3 id="r-approximation-pratique" data-claire-element-id="483754">Approximation pratique</h3><p id="r-483753" data-claire-element-id="483753">En une seconde, sur un processeur à 1 Ghz, en supposant qu'une comparaison (et les remplacements ou non qui l'accompagnent) prend 100 cycles de processeur (après une comparaison, je fais des manips de variables, etc. cela prend plusieurs cycles ; 100 est une valeur crédible), en une seconde, on accomplit <strong>109</strong> cycles, soit 10 millions de comparaisons.<br/> La taille du tableau qui met une seconde à être trié sur un ordinateur à 1 Ghz est donc environ 3 000.<br/> (3000 * 3000 est proche de 10 millions.)</p><h3 id="r-aller-un-peu-plus-loin-2" data-claire-element-id="483757">Aller un peu plus loin</h3><p id="r-483755" data-claire-element-id="483755">J'ai dit que le pire cas possible était celui où chaque insertion décalait toutes les cartes de la main gauche. À quel genre de tableau en entrée cela correspond-il ? Si on doit décaler toutes les cartes, c'est que la carte qu'on veut insérer est plus petite que toutes les cartes de la main gauche : à chaque fois, la carte suivante est plus petite que toutes les autres. Cela correspond en fait à un tableau trié en ordre <em>décroissant</em> (du plus grand au plus petit), et donc exactement l'inverse que ce qu'on veut.</p><p id="r-483756" data-claire-element-id="483756">Il paraît assez naturel que le pire cauchemar d'une fonction de tri en ordre croissant soit une entrée triée dans l'autre sens, mais en réalité ce n'est pas le pire cas de toutes les fonctions de tris, il y en a qui s'en sortent très bien.</p><h3 id="r-remarque-6" data-claire-element-id="483759">Remarque</h3><p id="r-483758" data-claire-element-id="483758">Il est possible de coder tri-insertion avec des listes chaînées (si vous ne savez pas ce que c'est, sautez ce paragraphe) au lieu de tableaux. L'avantage, c'est que c'est très simple d'insérer un élément au milieu d'une liste chaînée : il n'y a pas besoin de décaler toutes les valeurs suivantes.<br/> L'algorithme est donc considérablement simplifié (mais la complexité ne change pas). Cependant, en C, on ne dispose pas de listes chaînées par défaut, j'utilise donc les tableaux à la place.</p><h3 id="r-pour-en-savoir-plus-1" data-claire-element-id="483763">Pour en savoir plus</h3><p id="r-483760" data-claire-element-id="483760">Tri par insertion : <a href="http://fr.wikipedia.org/wiki/Tri_par_insertion">http://fr.wikipedia.org/wiki/Tri_par_insertion</a><br/> Listes chaînées : <a href="http://fr.wikipedia.org/wiki/Liste_chaînée">http://fr.wikipedia.org/wiki/Liste_cha%C3%AEn%C3%A9e</a><br/> Complexité : <a href="http://fr.wikipedia.org/wiki/Complexité_algorithmique">http://fr.wikipedia.org/wiki/Complexit%C3%A9_algorithmique</a></p><p id="r-483761" data-claire-element-id="483762">Ce tutoriel est mis à disposition sous licence <a href="http://creativecommons.org/licenses/by-sa/2.0/fr/">creative commons <img id="r-483762" data-claire-element-id="483761" src="../../licensebuttons.net/l/by-sa/2.0/fr/88x31.png" alt="- Paternité - Partage des conditions à l'identique"/></a>. Ça signifie que vous pouvez librement copier et modifier ce tutoriel, à condition de citer l'auteur original et de conserver cette licence.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion">Le tri par insertion</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/principe-50">
Principe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/implementation-24">
Implémentation
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/complexite-9">
Complexité
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-tri-par-insertion/implementation-24">
<span class="arrow"></span>
<span class="next">Implémentation</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/le-tri-par-insertion.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 11:16:55 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/le-tri-par-insertion.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:49:05 GMT -->
</html>
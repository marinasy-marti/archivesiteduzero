<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/les-piles-et-les-files-en-c.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 00:30:05 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-piles-et-les-files-en-c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:18:40 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Les piles et les files en C++</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/les-piles-et-les-files-en-c.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Les piles et les files en C++</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#LespilesetlesfilesenC">Les piles et les files en C++</a><br/><a href="#Principe">Principe</a><br/><a href="#Lespiles">Les piles</a><br/><a href="#Lesfiles">Les files</a><br/><a href="#Exempled039utilisation">Exemple d&#039;utilisation</a><br/></div>
<a name="LespilesetlesfilesenC"></a><h2>Les piles et les files en C++</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/principe-44">
<span class="next">Principe</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-426954" data-claire-element-id="426954">Bonjour à tous !</p><p id="r-426955" data-claire-element-id="426955">Dans ce tutoriel, vous allez apprendre à vous servir des piles ainsi que des files en C++.</p><p id="r-426956" data-claire-element-id="426956">Avant de vous lancer dans la lecture, vous pouvez lire le tutoriel d'<strong>Octal</strong> sur <a href="http://www.siteduzero.com/tuto-3-16237-1-les-piles-les-files-en-langage-c.html">les piles et les files en C</a>, pour voir le principe. L'avantage en C++, c'est que l'implémentation et l'utilisation ont été considérablement simplifiées ! :-°</p><aside id="r-426958" data-claire-element-id="426958" data-claire-semantic="warning"><p id="r-426957" data-claire-element-id="426957">Il faut avoir lu au préalable le tutoriel de <strong>M@teo21</strong> sur le <a href="http://www.siteduzero.com/tuto-3-8-0-apprenez-a-programmer-en-c-c.html">C et C++</a> !</p></aside>
</div><a name="Principe"></a><h2>Principe</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-piles-8">
<span class="next">Les piles</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-426959" data-claire-element-id="426959">Avant de commencer à coder, voyons le principe de ces structures de données.</p><h3 id="r-les-piles-7" data-claire-element-id="426961">Les piles</h3><p id="r-426960" data-claire-element-id="426960">Tous les jours, on manipule des piles (et pas seulement dans la télécommande :D !).<br/> Prenons un exemple : une pile d'assiettes à laver. On les met les unes sur les autres et pour les laver, on prend celle du dessus. Un deuxième exemple : une pile de dossiers sur un bureau. On les met les uns au-dessus des autres et on retire le premier, donc le dernier arrivé. Les piles répondent à ce principe : <em>dernier arrivé, premier servi</em>, aussi connues sous le nom de LIFO pour <strong>L</strong><em>Last <strong>I</strong>n, <strong>F</strong>irst <strong>O</strong>ut</em>.</p><h3 id="r-les-files-4" data-claire-element-id="426963">Les files</h3><p id="r-426962" data-claire-element-id="426962">Pour les files, c'est exactement le contraire ! Un exemple tout simple : une file d'attente. Le premier arrivé est le premier à sortir (à être servi), aussi connues sous le nom de FIFO pour <strong>F</strong><em>First <strong>I</strong>n, <strong>F</strong>irst <strong>O</strong>ut</em>.</p><h3 id="r-la-stl-1" data-claire-element-id="426965">La STL</h3><p id="r-426964" data-claire-element-id="426964">STL pour <em><strong>S</strong>tandard <strong>T</strong>emplate <strong>L</strong>ibrary</em>. Les deux structures de données de ce tuto en font partie. Pour résumer, la STL est un ensemble de structures pouvant contenir n'importe quel type de données. Cela veut donc dire que, dans les piles et les files, on peut stocker tout type de données (entiers, réels, chaînes de caractères, ...) mais un seul type par structure : si je déclare une pile d'entiers, je ne pourrais pas empiler des chaînes de caractères !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c">Les piles et les files en C++</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/principe-44">
Principe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-piles-8">
Les piles
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-files-5">
Les files
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/exemple-d-utilisation-15">
Exemple d&#039;utilisation
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-piles-8">
<span class="next">Les piles</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lespiles"></a><h2>Les piles</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/principe-44">
<span class="arrow"></span>
<span class="next">Principe</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-files-5">
<span class="next">Les files</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-426967" data-claire-element-id="426967">Bien, voyons en détail les piles !</p><p id="r-426968" data-claire-element-id="426968">Voici tout d'abord les opérations possibles sur les piles :</p><ul id="r-426979" data-claire-element-id="426979"><li id="r-426970" data-claire-element-id="426970"><p id="r-426969" data-claire-element-id="426969">déterminer la taille de la pile ;</p></li><li id="r-426972" data-claire-element-id="426972"><p id="r-426971" data-claire-element-id="426971">déterminer si la pile est vide ou non ;</p></li><li id="r-426974" data-claire-element-id="426974"><p id="r-426973" data-claire-element-id="426973">ajouter une nouvelle donnée ;</p></li><li id="r-426976" data-claire-element-id="426976"><p id="r-426975" data-claire-element-id="426975">consulter la dernière donnée empilée ;</p></li><li id="r-426978" data-claire-element-id="426978"><p id="r-426977" data-claire-element-id="426977">supprimer la dernière donnée ajoutée.</p></li></ul><p id="r-426980" data-claire-element-id="426980">Bien, ça, c'est la version en français, passons à la version C++ !</p><p id="r-426981" data-claire-element-id="426981">Pour pouvoir utiliser les piles, il faut inclure l'en-tête stack.<br/> Le début du code est donc :</p><pre id="r-426982" data-claire-element-id="426982"><code data-claire-semantic="cpp">#include &lt;stack&gt;
using namespace std;</code></pre><p id="r-426983" data-claire-element-id="426983">Maintenant, pour pouvoir travailler avec une pile, il faut l'initialiser :</p><pre id="r-426984" data-claire-element-id="426984"><code data-claire-semantic="cpp">stack&lt;int&gt; i;     //pile d'entiers
stack&lt;string&gt; s;  //pile de chaînes de caractères
stack&lt;T&gt; p;       //remplacer le T par le type voulu</code></pre><p id="r-426985" data-claire-element-id="426985">Entre les chevrons (&lt; &gt;), il faut mettre le type de pile voulu. Si l'on désire une pile d'entiers, on met int ; pour une pile de chaînes, on met string, ...<br/> Voyons maintenant les différentes manipulations des piles.</p><h3 id="r-la-hauteur-de-la-pile" data-claire-element-id="426991">La hauteur de la pile</h3><p id="r-426986" data-claire-element-id="426986">Pour pouvoir boucler sur une pile, il faut connaître sa hauteur (ou sa taille). On utilise la fonction nomPile.size() qui renvoie le nombre d'éléments de la pile.</p><pre id="r-426987" data-claire-element-id="426987"><code data-claire-semantic="cpp">stack&lt;int&gt; i;
cout &lt;&lt; &quot;Le nombre d'éléments de la pile est : &quot; &lt;&lt; i.size() &lt;&lt; endl;</code></pre><p id="r-426988" data-claire-element-id="426988">Ce code affichera :</p><pre id="r-426989" data-claire-element-id="426989"><code data-claire-semantic="console">Le nombre d'éléments de la pile est : 0</code></pre><p id="r-426990" data-claire-element-id="426990">La taille est zéro car lorsqu'une pile est initialisée, elle est initialisée en tant que pile vide, donc elle ne contient aucun élément.</p><h3 id="r-l-etat-de-la-pile" data-claire-element-id="426994">L'état de la pile</h3><p id="r-426992" data-claire-element-id="426992">Si on ne veut pas connaître le nombre d'éléments présents dans la pile, mais juste savoir si elle est vide ou non, on utilise la fonction nomPile.empty() qui renvoie un booléen qui vaut true si la pile est vide et false sinon.</p><pre id="r-426993" data-claire-element-id="426993"><code data-claire-semantic="cpp">stack&lt;int&gt; i;
cout &lt;&lt; &quot;Etat de la pile : &quot;;
if(i.empty())
        cout &lt;&lt; &quot;vide&quot; &lt;&lt; endl;
else
        cout &lt;&lt; &quot;pas vide&quot; &lt;&lt; endl;</code></pre><h3 id="r-ajouter-empiler-un-element-dans-la-pile" data-claire-element-id="427003">Ajouter (empiler) un élément dans la pile</h3><p id="r-426995" data-claire-element-id="426995">Pour empiler un élément, on utilise la fonction nomPile.push(elt) qui prend en paramètre l'élément à empiler.</p><aside id="r-427001" data-claire-element-id="427001" data-claire-semantic="warning"><ul id="r-427000" data-claire-element-id="427000"><li id="r-426997" data-claire-element-id="426997"><p id="r-426996" data-claire-element-id="426996">L'élément à empiler doit être du même type que la pile !</p></li><li id="r-426999" data-claire-element-id="426999"><p id="r-426998" data-claire-element-id="426998">On ne donne pas le type de l'élément à empiler : par exemple, si nomPile est une pile d'entiers, on ne fait pas nomPile.push(int elt).</p></li></ul></aside><pre id="r-427002" data-claire-element-id="427002"><code data-claire-semantic="cpp">stack&lt;int&gt; i;  //pile d'entiers
 
int elt = 12;
i.push(2);         //je rajoute 2
i.push(elt);        //je rajoute le contenu de la variable elt, soit 12
i.push(&quot;Chaîne&quot;);  //erreur à la compilation car i est une pile de type entier et non chaîne</code></pre><h3 id="r-acceder-au-dernier-element-de-la-pile" data-claire-element-id="427010">Accéder au dernier élément de la pile</h3><p id="r-427004" data-claire-element-id="427004">Maintenant, si on veut accéder aux éléments de la pile, il faut obligatoirement prendre le dernier empilé, donc celui qui se trouve au sommet. Pour récupérer cet élément, on utilise la fonction nomPile.top().</p><aside id="r-427006" data-claire-element-id="427006" data-claire-semantic="warning"><p id="r-427005" data-claire-element-id="427005">Pour utiliser cette fonction, la pile ne doit pas être vide !</p></aside><pre id="r-427007" data-claire-element-id="427007"><code data-claire-semantic="cpp">stack&lt;int&gt; i;
i.push(2);
i.push(12);
 
cout &lt;&lt; &quot;Le premier élément est : &quot; &lt;&lt; i.top();</code></pre><aside id="r-427009" data-claire-element-id="427009" data-claire-semantic="information"><p id="r-427008" data-claire-element-id="427008">Comme vous le voyez, il est impossible d'afficher le second élément. Il faut donc supprimer le premier.</p></aside><h3 id="r-supprimer-depiler-le-dernier-element-de-la-pile" data-claire-element-id="427019">Supprimer (dépiler) le dernier élément de la pile</h3><p id="r-427011" data-claire-element-id="427011">Pour le supprimer, on utilise la fonction nomPile.pop().</p><aside id="r-427017" data-claire-element-id="427017" data-claire-semantic="warning"><ul id="r-427016" data-claire-element-id="427016"><li id="r-427013" data-claire-element-id="427013"><p id="r-427012" data-claire-element-id="427012">Pour utiliser pop, la pile ne doit pas être vide !</p></li><li id="r-427015" data-claire-element-id="427015"><p id="r-427014" data-claire-element-id="427014">Une fois l'élément dépilé, si on ne l'a pas sauvegardé, il est définitivement perdu !</p></li></ul></aside><pre id="r-427018" data-claire-element-id="427018"><code data-claire-semantic="cpp">stack&lt;int&gt; i;
i.push(2);
i.push(3);
 
cout &lt;&lt; &quot;Le premier élément est : &quot; &lt;&lt; i.top() &lt;&lt; endl;  // accès au dernier élément
i.pop();  // suppression du dernier élément
cout &lt;&lt; &quot;Le deuxième élément est : &quot; &lt;&lt; i.top() &lt;&lt; endl;  // accès au deuxième élément
i.pop();  // suppression du dernier élément ; maintenant la pile est vide !
 
cout &lt;&lt; &quot;Nombre d'éléments dans la pile : &quot; &lt;&lt; i.size() &lt;&lt; endl;</code></pre><h3 id="r-passage-de-parametres" data-claire-element-id="427027">Passage de paramètres</h3><p id="r-427020" data-claire-element-id="427020">Implicitement, le passage de paramètres se fait par valeurs. Une pile passée en paramètre d'un sous-programme est donc recopiée. Pour des raisons de performances, une pile en entrée d'une procédure ou d'une fonction est passée par référence en ajoutant un &quot;et commercial&quot; (&amp;) avant le nom du paramètre (exemple : stack&lt;int&gt;<strong>&amp;</strong> p).</p><p id="r-427021" data-claire-element-id="427021">Maintenant, vous savez tout sur les piles :D !</p><p id="r-427022" data-claire-element-id="427022">Je vais maintenant vous donner deux exemples sur le fonctionnement de la pile en utilisant toutes les fonctions que l'on a vues.<br/> Le premier est une procédure de remplissage et d'affichage d'une pile.</p><pre id="r-427023" data-claire-element-id="427023"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;
 
/* Procédure qui remplit la pile passée en paramètre. La pile est passée par référence, ce qui veut dire que quand on ajoute un élément, on agit directement sur la &quot;vraie&quot; pile déclarée dans le main */
 
void remplir(stack&lt;int&gt;&amp; p)
{
        int n;
        cout &lt;&lt; &quot;Entrez le nombre d'éléments de la pile : &quot;;
        cin &gt;&gt; n;
 
        int elt;
        for(int i = 0; i &lt; n; i++)
        {
                cout &lt;&lt; &quot;Entrez un élément : &quot;;
                cin &gt;&gt; elt;
                p.push(elt);
        }
}
 
 
/* Procédure qui affiche la pile donnée en paramètre. La pile est passée par référence et déclarée const pour être sûr de ne pas la modifier, car on travaille sur la &quot;vraie&quot; pile (elle n'est pas recopiée en mémoire) */
 
void afficher(const stack&lt;int&gt;&amp; p)
{
        stack&lt;int&gt; t = p;
        while(!t.empty())
        {
                cout &lt;&lt; t.top();
                t.pop();
                if(!t.empty())
                        cout &lt;&lt; &quot; , &quot;;
        }
}
 
int main()
{
        stack&lt;int&gt; p;
        remplir(p);
        cout &lt;&lt; &quot;Votre pile est : &quot;;
        afficher(p);
 
        return 0;
}</code></pre><p id="r-427024" data-claire-element-id="427024">Le deuxième exemple est un programme qui montre l'évolution de la pile.</p><pre id="r-427025" data-claire-element-id="427025"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;
 
void afficher(const stack&lt;int&gt;&amp; p)  
{
        stack&lt;int&gt; t = p;
        while(!t.empty())
        {
                cout &lt;&lt; t.top();
                t.pop();
                if(!t.empty())
                        cout &lt;&lt; &quot; , &quot;;
        }
}
 
int main()
{
        stack&lt;int&gt; p;
        cout &lt;&lt; &quot;Apres declaration p = &quot;;
        afficher(p);
        cout &lt;&lt; &quot;p.size() = &quot; &lt;&lt; p.size() &lt;&lt; endl;
        cout &lt;&lt; &quot;p.empty() = &quot; &lt;&lt; boolalpha &lt;&lt; p.empty() &lt;&lt; endl; /* boolalpha permet d'afficher true ou false pour la valeur d'un booléen (à la place de 1 ou 0) */
        p.push(10);
        p.push(20);
        p.push(30);
        cout &lt;&lt; endl &lt;&lt; &quot;Apres empilement de 10, 20 et 30 p = &quot;;
        afficher(p);
        cout &lt;&lt; &quot;p.size() = &quot; &lt;&lt; p.size() &lt;&lt; endl;
        cout &lt;&lt; &quot;p.empty() = &quot; &lt;&lt; boolalpha &lt;&lt; p.empty() &lt;&lt; endl;
        cout &lt;&lt; &quot;p.top() = &quot; &lt;&lt; p.top() &lt;&lt; endl;
 
        p.pop();
        cout &lt;&lt; endl &lt;&lt; &quot;Apres p.pop(), p = &quot;;
        afficher(p);
        cout &lt;&lt; &quot;p.size() = &quot; &lt;&lt; p.size() &lt;&lt; endl;
        cout &lt;&lt; &quot;p.empty() = &quot; &lt;&lt; boolalpha &lt;&lt; p.empty() &lt;&lt; endl;
        cout &lt;&lt; &quot;p.top() = &quot; &lt;&lt; p.top() &lt;&lt; endl;
 
        p.pop();
        cout &lt;&lt; endl &lt;&lt; &quot;Apres p.pop(), p = &quot;;
        afficher(p);
        cout &lt;&lt; &quot;p.size() = &quot; &lt;&lt; p.size() &lt;&lt; endl;
        cout &lt;&lt; &quot;p.empty() = &quot; &lt;&lt; boolalpha &lt;&lt; p.empty() &lt;&lt; endl;
        cout &lt;&lt; &quot;p.top() = &quot; &lt;&lt; p.top() &lt;&lt; endl;
        
        p.pop();
        cout &lt;&lt; endl &lt;&lt; &quot;Apres p.pop(), p = &quot;;
        afficher(p);
        cout &lt;&lt; &quot;p.size() = &quot; &lt;&lt; p.size() &lt;&lt; endl;
        cout &lt;&lt; &quot;p.empty() = &quot; &lt;&lt; boolalpha &lt;&lt; p.empty() &lt;&lt; endl;
 
        return 0;
}</code></pre><p id="r-427026" data-claire-element-id="427026">Voilà, la partie sur les piles est terminée. Passons maintenant aux files :D .</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c">Les piles et les files en C++</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/principe-44">
Principe
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-piles-8">
Les piles
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-files-5">
Les files
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/exemple-d-utilisation-15">
Exemple d&#039;utilisation
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/principe-44">
<span class="arrow"></span>
<span class="next">Principe</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-files-5">
<span class="next">Les files</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesfiles"></a><h2>Les files</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-piles-8">
<span class="arrow"></span>
<span class="next">Les piles</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/exemple-d-utilisation-15">
<span class="next">Exemple d&#039;utilisation</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-427029" data-claire-element-id="427029">Bien, les files maintenant !</p><p id="r-427030" data-claire-element-id="427030">Les opérations possibles sur les files sont :</p><ul id="r-427043" data-claire-element-id="427043"><li id="r-427032" data-claire-element-id="427032"><p id="r-427031" data-claire-element-id="427031">déterminer la taille de la file ;</p></li><li id="r-427034" data-claire-element-id="427034"><p id="r-427033" data-claire-element-id="427033">déterminer si la file est vide ou non ;</p></li><li id="r-427036" data-claire-element-id="427036"><p id="r-427035" data-claire-element-id="427035">ajouter une nouvelle donnée ;</p></li><li id="r-427038" data-claire-element-id="427038"><p id="r-427037" data-claire-element-id="427037">consulter la première donnée ;</p></li><li id="r-427040" data-claire-element-id="427040"><p id="r-427039" data-claire-element-id="427039">consulter la dernière donnée ;</p></li><li id="r-427042" data-claire-element-id="427042"><p id="r-427041" data-claire-element-id="427041">supprimer la première donnée.</p></li></ul><p id="r-427044" data-claire-element-id="427044">Voyons comment implémenter cela en C++.</p><aside id="r-427046" data-claire-element-id="427046" data-claire-semantic="information"><p id="r-427045" data-claire-element-id="427045">Plusieurs de ces fonctions ont un fonctionnement identique à celles des piles, je les passerai donc plus rapidement.</p></aside><p id="r-427047" data-claire-element-id="427047">Pour pouvoir utiliser les files, il faut inclure l'en-tête queue.<br/> Le début du code est donc :</p><pre id="r-427048" data-claire-element-id="427048"><code data-claire-semantic="cpp">#include &lt;queue&gt;
using namespace std;</code></pre><p id="r-427049" data-claire-element-id="427049">Pour initialiser une file, il faut la déclarer comme ceci :</p><pre id="r-427050" data-claire-element-id="427050"><code data-claire-semantic="cpp">queue&lt;int&gt; f;  // file d'entiers
queue&lt;T&gt; g;  //remplacer T par le type voulu</code></pre><p id="r-427051" data-claire-element-id="427051">Voyons maintenant les différentes fonctions.</p><aside id="r-427053" data-claire-element-id="427053" data-claire-semantic="information"><p id="r-427052" data-claire-element-id="427052">Pour les quatre fonctions qui vont suivre, je vais juste les citer pour la bonne et simple raison que j'ai déjà expliqué leur fonctionnement dans la partie sur les piles.</p></aside><h3 id="r-la-taille-de-la-file" data-claire-element-id="427055">La taille de la file</h3><p id="r-427054" data-claire-element-id="427054">On utilise la fonction nomFile.size().</p><h3 id="r-l-etat-de-la-file" data-claire-element-id="427057">L'état de la file</h3><p id="r-427056" data-claire-element-id="427056">On utilise la fonction nomFile.empty().<br/> Rappel : cette fonction renvoie un booléen.</p><h3 id="r-ajouter-un-nouvel-element" data-claire-element-id="427059">Ajouter un nouvel élément</h3><p id="r-427058" data-claire-element-id="427058">On utilise la fonction nomFile.push(elt).</p><h3 id="r-supprimer-la-premiere-donnee" data-claire-element-id="427063">Supprimer la première donnée</h3><p id="r-427060" data-claire-element-id="427060">On utilise la fonction nomFile.pop().</p><aside id="r-427062" data-claire-element-id="427062" data-claire-semantic="warning"><p id="r-427061" data-claire-element-id="427061">Pour utiliser cette fonction, la file ne doit pas être vide !</p></aside><h3 id="r-acceder-au-premier-et-au-dernier-element" data-claire-element-id="427083">Accéder au premier et au dernier élément</h3><aside id="r-427065" data-claire-element-id="427065" data-claire-semantic="warning"><p id="r-427064" data-claire-element-id="427064">Pour utiliser ces fonctions, la file ne doit pas être vide !</p></aside><p id="r-427066" data-claire-element-id="427066">Pour accéder au premier élément ajouté dans la pile (donc le premier à sortir), on utilise la fonction nomFile.front().<br/> Pour accéder au dernier élément ajouté dans la liste, on utilise la fonction nomFile.back().</p><p id="r-427067" data-claire-element-id="427067">Voici un exemple d'utilisation :</p><pre id="r-427068" data-claire-element-id="427068"><code data-claire-semantic="cpp">queue&lt;int&gt; i;
i.push(10);
i.push(20);
i.push(30);
i.push(40);
 
cout &lt;&lt; &quot;Le premier élément est : &quot; &lt;&lt; i.front() &lt;&lt; endl;
cout &lt;&lt; &quot;Le dernier élément est : &quot; &lt;&lt; i.back() &lt;&lt; endl;
 
i.pop();
cout &lt;&lt; &quot;Le premier élément est : &quot; &lt;&lt; i.front() &lt;&lt; endl;
cout &lt;&lt; &quot;Le dernier élément est : &quot; &lt;&lt; i.back() &lt;&lt; endl;</code></pre><p id="r-427069" data-claire-element-id="427069">Le résultat est :</p><pre id="r-427070" data-claire-element-id="427070"><code data-claire-semantic="console">Le premier élément est : 10
Le dernier élément est : 40
Le premier élément est : 20
Le dernier élément est : 40</code></pre><p id="r-427071" data-claire-element-id="427071">Pour mieux comprendre, on peut dessiner la file :</p><figure id="r-427073" data-claire-element-id="427074"><img id="r-427072" data-claire-element-id="427072" src="medias/uploads.siteduzero.com_files_75001_76000_75599.png" alt="Image utilisateur"/></figure><aside id="r-427076" data-claire-element-id="427076" data-claire-semantic="information"><p id="r-427075" data-claire-element-id="427075">Comme pour les piles, le passage de paramètres se fait de préférence par référence.</p></aside><p id="r-427077" data-claire-element-id="427077">Je termine cette partie sur les files avec deux exemples.</p><p id="r-427078" data-claire-element-id="427078">Le premier est une procédure d'affichage d'une file.</p><pre id="r-427079" data-claire-element-id="427079"><code data-claire-semantic="cpp">/* Procédure qui affiche la file donnée en paramètre. La file est passée par référence et déclarée const pour être sûr de ne pas la modifier, car on travaille sur la &quot;vraie&quot; file (elle n'est pas recopiée en mémoire) */
 
#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;
 
void afficher(const queue&lt;int&gt;&amp; f)
{
        queue&lt;int&gt; q = f;
        while(!q.empty())
        {
                cout &lt;&lt; q.front();
                q.pop();
                if(!q.empty())
                        cout &lt;&lt; &quot; , &quot;;
        }
}</code></pre><p id="r-427080" data-claire-element-id="427080">Le deuxième exemple utilise toutes les fonctions sur les files.</p><pre id="r-427081" data-claire-element-id="427081"><code data-claire-semantic="cpp">#include &lt;queue&gt;
#include &lt;iostream&gt;
using namespace std;
 
void afficher(const queue&lt;int&gt;&amp; f)
{
        queue&lt;int&gt; q = f;
        while(!q.empty())
        {
                cout &lt;&lt; q.front();
                q.pop();
                if(!q.empty())
                        cout &lt;&lt; &quot; , &quot;;
        }
}
 
int main()
{
        queue&lt;int&gt; q;
        
        cout &lt;&lt; &quot;Apres declaration q = &quot;;
        afficher(q);
        cout &lt;&lt; &quot;q.size() = &quot; &lt;&lt; q.size() &lt;&lt; endl;
        cout &lt;&lt; &quot;q.empty() = &quot; &lt;&lt; boolalpha &lt;&lt; q.empty() &lt;&lt; endl;  /* avec boolalpha, suivant la valeur du booléen, ça affiche true ou false */
 
        q.push(10);
        q.push(20);
        q.push(30);
        cout &lt;&lt; endl &lt;&lt; &quot;Apres ajout de 10, 20 et 30, q = &quot;;
        
        while(!q.empty())
        {
                afficher(q);
                cout &lt;&lt; &quot;q.size() = &quot; &lt;&lt; q.size() &lt;&lt; endl;
                cout &lt;&lt; &quot;q.front() = &quot; &lt;&lt; q.front() &lt;&lt; endl;
                cout &lt;&lt; &quot;q.back() = &quot; &lt;&lt; q.back() &lt;&lt; endl;
                q.pop();
                cout &lt;&lt; endl &lt;&lt; &quot;Apres q.pop(), q = &quot;;
        }
        
        afficher(q);
 
        return 0;
}</code></pre><p id="r-427082" data-claire-element-id="427082">Voilà, la partie sur les files est terminée, et en plus, ça n'a même pas été dur !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c">Les piles et les files en C++</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/principe-44">
Principe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-piles-8">
Les piles
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-files-5">
Les files
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/exemple-d-utilisation-15">
Exemple d&#039;utilisation
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-piles-8">
<span class="arrow"></span>
<span class="next">Les piles</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/exemple-d-utilisation-15">
<span class="next">Exemple d&#039;utilisation</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Exempled039utilisation"></a><h2>Exemple d&#039;utilisation</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-files-5">
<span class="arrow"></span>
<span class="next">Les files</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-427085" data-claire-element-id="427085">Bien, nous allons maintenant voir un exemple concret avec les piles (un exemple avec les files suivra dès que je l'aurai trouvé ! :D ).</p><h2 id="r-les-epf-expressions-post-fixees" data-claire-element-id="427148">Les EPF (Expressions Post-Fixées)</h2><p id="r-427086" data-claire-element-id="427086">Une expression est dite <em>post-fixée</em> ou écrite en <em>notation polonaise inversée</em> lorsque chaque opérateur est immédiatement précédé de ses deux opérandes.<br/> Les expressions suivantes en sont des exemples :</p><ul id="r-427093" data-claire-element-id="427093"><li id="r-427088" data-claire-element-id="427088"><p id="r-427087" data-claire-element-id="427087">1. 42+</p></li><li id="r-427090" data-claire-element-id="427090"><p id="r-427089" data-claire-element-id="427089">2. 32*54*+</p></li><li id="r-427092" data-claire-element-id="427092"><p id="r-427091" data-claire-element-id="427091">3. 1253+*+7-</p></li></ul><p id="r-427094" data-claire-element-id="427094">Commençons par évaluer manuellement ces 3 expressions.</p><p id="r-427095" data-claire-element-id="427095">Pour les évaluer, on applique la définition : chaque opérateur est précédé immédiatement de ses deux opérandes.</p><h3 id="r-exemple-1-42" data-claire-element-id="427097">Exemple 1 : 42+</h3><p id="r-427096" data-claire-element-id="427096">On parcours l'epf jusqu'au premier opérateur qui est + et on l'applique aux deux opérandes qui le précèdent, 4 et 2, ce qui donne au final 4+2=6.<br/> Bon, c'était le plus simple !</p><h3 id="r-exemple-2-32-54" data-claire-element-id="427103">Exemple 2 : 32*54*+</h3><p id="r-427098" data-claire-element-id="427098">Lorsque l'expression devient plus compliquée, il est plus simple de faire un petit schéma pour comprendre. Pour faire ce schéma, on écrit tous les chiffres sur la même ligne. Ensuite, on parcourt à nouveau l'epf jusqu'au premier opérateur et on l'applique aux deux opérandes juste avant. Et on continue jusqu'à ce que tous les opérateurs aient été traités. On peut les relier avec des flèches.<br/> Pour cet exemple, on obtient ceci :</p><figure id="r-427100" data-claire-element-id="427101"><img id="r-427099" data-claire-element-id="427099" src="medias/uploads.siteduzero.com_files_76001_77000_76668.png" alt="Image utilisateur"/></figure><p id="r-427102" data-claire-element-id="427102">Cela se traduit : (3*2)+(5*4) = 26.</p><h3 id="r-exemple-3-1253-7" data-claire-element-id="427110">Exemple 3 : 1253+*+7-</h3><p id="r-427104" data-claire-element-id="427104">Celui-ci est un peu plus complexe, mais en appliquant la méthode, on parvient au but très facilement. <br/> Pour cet exemple, le schéma est :</p><figure id="r-427106" data-claire-element-id="427107"><img id="r-427105" data-claire-element-id="427105" src="medias/uploads.siteduzero.com_files_76001_77000_76669.png" alt="Image utilisateur"/></figure><p id="r-427108" data-claire-element-id="427108">Cela se traduit par : (((5+3)*2)+1)-7 = 10.</p><p id="r-427109" data-claire-element-id="427109">Comme vous pouvez le constater, si les epf deviennent très longues, c'est aussi très long à calculer. Nous allons donc faire le programme qui les résout en nous aidant des piles.</p><h3 id="r-principe-45" data-claire-element-id="427147">Principe</h3><p id="r-427111" data-claire-element-id="427111">L'expression est lue de gauche à droite,</p><p id="r-427112" data-claire-element-id="427112">1. lorsqu'une valeur (opérande) est rencontrée, elle est empilée ;<br/> 2. lorsqu'un opérateur est rencontré :</p><div id="r-427114" data-claire-element-id="427114"><p id="r-427113" data-claire-element-id="427113">a) une première valeur est dépilée.<br/> b) une deuxième valeur est dépilée.<br/> c) on effectue l'opération correspondant à l'opérateur rencontré.<br/> d) on empile le résultat.</p></div><p id="r-427115" data-claire-element-id="427115">À la fin, il ne reste plus qu'une seule valeur dans la pile, il s'agit du résultat de l'évaluation de l'epf.</p><p id="r-427116" data-claire-element-id="427116">Pour faire ce programme, nous prendrons pour hypothèses :</p><ul id="r-427125" data-claire-element-id="427125"><li id="r-427118" data-claire-element-id="427118"><p id="r-427117" data-claire-element-id="427117">l'expression est considérée comme étant syntaxiquement correcte ;</p></li><li id="r-427120" data-claire-element-id="427120"><p id="r-427119" data-claire-element-id="427119">les opérandes sont comprises entre 0 et 9 et ne sont donc représentées que par un seul caractère ;</p></li><li id="r-427122" data-claire-element-id="427122"><p id="r-427121" data-claire-element-id="427121">seuls les opérateurs suivants sont considérés : + - * / ;</p></li><li id="r-427124" data-claire-element-id="427124"><p id="r-427123" data-claire-element-id="427123">aucun caractère d'espacement n'est introduit dans la chaîne.</p></li></ul><p id="r-427126" data-claire-element-id="427126">Avec ces conditions, ce n'est pas trop dur d'écrire le programme. La seule difficulté qu'il peut y avoir est de faire la différence entre un opérateur et une opérande. En effet, l'epf est donnée par l'utilisateur sous forme de string. Nous allons donc d'abord coder deux fonctions : une pour chercher les opérateurs et l'autre pour chercher les opérandes.<br/> Si vous avez regardé le tutoriel de M@teo21, vous avez sûrement pensé à la méthode itérative, c'est-à-dire avec une boucle. Je vais vous montrer une autre méthode.</p><p id="r-427127" data-claire-element-id="427127">Voici la nouvelle méthode : dans la fonction, on déclare une chaîne contenant les opérateurs. Nous appliquerons la méthode chaîne.find(char) sur cette chaîne. find prend un caractère en paramètre, et c'est elle qui va parcourir toute seule la chaîne pour chercher le caractère passé en paramètre. Si le caractère est présent, elle renvoie la première position de celui-ci, sinon, elle renvoie string::npos. Nous, nous allons utiliser le string::npos.</p><p id="r-427128" data-claire-element-id="427128">Voici le code de la fonction booléenne opérateur(const char c) qui renvoie vrai si le caractère c est un opérateur :</p><pre id="r-427129" data-claire-element-id="427129"><code data-claire-semantic="cpp">bool operateur(const char c)
{
        string op = &quot;+*-/&quot;;
        bool res = false;
        if(op.find(c) != string::npos)  //si on trouve le caractère c dans op
                res = true;
 
        return res;
}</code></pre><div id="r-427131" data-claire-element-id="427131" data-claire-semantic="question"><p id="r-427130" data-claire-element-id="427130">C'est quoi le caractère passé en paramètre ?</p></div><p id="r-427132" data-claire-element-id="427132">Ce caractère est celui lu dans l'epf. On lit les caractères de l'epf l'un après l'autre dans une procédure qui résout l'epf.</p><p id="r-427133" data-claire-element-id="427133">Passons maintenant à cette procédure. Elle est assez simple à écrire ; en effet, j'ai déjà donné la méthode plus haut ; il suffit de l'appliquer bêtement !</p><p id="r-427134" data-claire-element-id="427134">Pour commencer, cette procédure prend une chaîne de caractères en paramètre. C'est aussi dans cette procédure que l'on va initialiser la pile des opérandes et des différents résultats. Il nous faut également trois variables locales pour stocker la première et la deuxième valeur de la pile et le résultat du calcul de ces deux valeurs.</p><p id="r-427135" data-claire-element-id="427135">Voici le code de la procédure :</p><pre id="r-427136" data-claire-element-id="427136"><code data-claire-semantic="cpp">void eval(string epf)
{
        stack&lt;int&gt; p;
        int val1, val2, res;
 
        for(unsigned int i = 0; i &lt; epf.length(); i++)
        {
                if(!operateur(epf.at(i)))
                        p.push(epf.at(i)-'0');
                else
                {
                        val1 = p.top();
                        p.pop();
                        val2 = p.top();
                        p.pop();
                        if(epf.at(i) == '+')
                                res = val2 + val1;
                        else if (epf.at(i) == '-')
                                res = val2 - val1;
                        else if(epf.at(i) == '*')
                                res = val2 * val1;
                        else
                                res = val2 / val1;
                        p.push(res);
                }
        }
        cout &lt;&lt; &quot;Resultat : &quot; &lt;&lt; p.top() &lt;&lt; endl;
}</code></pre><p id="r-427137" data-claire-element-id="427137">Normalement, il doit y avoir quelque chose qui vous choque dans ce code. J'ai mis :</p><pre id="r-427138" data-claire-element-id="427138"><code data-claire-semantic="cpp">p.push(epf.at(i)-'0');</code></pre><p id="r-427139" data-claire-element-id="427139">C'est surtout le &quot; -'0' &quot; qui doit vous choquer. Je fais ça parce que epf.at(i) est un caractère et on ne peut pas utiliser le caractère comme un chiffre, même si le caractère en question représente un chiffre.<br/> Si on fait des calculs sur ce caractère, on fera les calculs avec les codes ASCII décimaux correspondants. Si on regarde une table ASCII, <a href="../../www.asciitable.com/asciifull.html">ici</a> par exemple, on voit que les codes ASCII décimaux des chiffres de 0 à 9 ont pour codes 48 pour 0... jusqu'à 57 pour 9. On remarque alors qu'il suffit de retirer 48 à ce code pour avoir un code correspondant au chiffre. Pour retirer 48 au code ASCII, il suffit de retirer le caractère 0, ce qui va retirer 48 au code ASCII du caractère auquel on applique cette soustraction.</p><p id="r-427140" data-claire-element-id="427140">Bien, comme je pense que vous avez bien souffert si vous lisez ceci, je vais vous donner le code complet du programme :</p><pre id="r-427141" data-claire-element-id="427141"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
 
using namespace std;
 
bool operateur(const char c)
{
        string op = &quot;*/-+&quot;;
        bool res = false;
        if(op.find(c) != string::npos)
                res = true;
 
        return res;
}
 
void eval(string epf)
{
        stack&lt;int&gt; p;
        int val1, val2, res;
 
        for(unsigned int i = 0; i &lt; epf.length(); i++)
        {
                if(!operateur(epf.at(i)))
                        p.push(epf.at(i)-'0');
                else
                {
                        val1 = p.top();
                        p.pop();
                        val2 = p.top();
                        p.pop();
                        if(epf.at(i) == '+')
                                res = val2 + val1;
                        else if (epf.at(i) == '-')
                                res = val2 - val1;
                        else if(epf.at(i) == '*')
                                res = val2 * val1;
                        else
                                res = val2 / val1;
                        p.push(res);
                }
        }
        cout &lt;&lt; &quot;Resultat : &quot; &lt;&lt; p.top() &lt;&lt; endl;
}
 
 
int main()
{
        string epf;
 
        cout &lt;&lt; &quot;Entrez votre EPF : &quot;;
        cin &gt;&gt; epf;
        eval(epf);
 
        return 0;
}</code></pre><p id="r-427142" data-claire-element-id="427142">Voilà, on arrive au terme de cet exemple concret.</p><p id="r-427143" data-claire-element-id="427143">Vous êtes arrivés au terme de ce tutoriel. En espérant que vous ayez tout compris, je vous dis :</p><p id="r-427144" data-claire-element-id="427144"><cite>Citation : Xav57</cite></p><blockquote id="r-427146" data-claire-element-id="427146"><p id="r-427145" data-claire-element-id="427145">Au revoir et à bientôt ! ;)</p></blockquote>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c">Les piles et les files en C++</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/principe-44">
Principe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-piles-8">
Les piles
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-files-5">
Les files
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/exemple-d-utilisation-15">
Exemple d&#039;utilisation
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-en-c/les-files-5">
<span class="arrow"></span>
<span class="next">Les files</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/les-piles-et-les-files-en-c.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 00:30:05 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-piles-et-les-files-en-c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:18:41 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/les-processeurs-orientes-objet.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Oct 2013 23:51:03 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-processeurs-orientes-objet.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:12:30 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Les processeurs orientés objet</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/les-processeurs-orientes-objet.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Les processeurs orientés objet</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Lesprocesseursorientsobjet">Les processeurs orientés objet</a><br/><a href="#Capability-BasedSystem">Capability-Based System</a><br/><a href="#Rekursiv">Rekursiv</a><br/><a href="#InteliAPX432">Intel iAPX 432</a><br/></div>
<a name="Lesprocesseursorientsobjet"></a><h2>Les processeurs orientés objet</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/capability-based-system">
<span class="next">Capability-Based System</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-343695" data-claire-element-id="343695">Si vous programmez depuis un certain temps, vous savez sûrement qu'il existe plusieurs paradigmes de programmation : le paradigme procédural, l'impératif, l'objet, le fonctionnel, etc. Chaque langage est plus ou moins rattaché à un (voire plusieurs) de ces paradigmes, et dispose de fonctionnalités plus ou moins diverses et variées. Mais ces langages ont pour but de créer des programmes exécutables par un ordinateur dont le matériel est plus ou moins évolué.</p><p id="r-343696" data-claire-element-id="343696">Au départ, les premiers ordinateurs étaient optimisés pour exécuter des langages de programmation impératifs très simples, et leur assembleur disposait de peu de fonctionnalités proches des langages de haut niveau : pas de support des tableaux, sous-programmes (les fameuses fonctions), et les types de haut niveau n'étaient pas supportés (pas de flottants ni de caractères, seul un type était accepté : le <em>word</em>). Au fil du temps, l'assembleur de ces processeurs et leur architecture ont évolué pour supporter les fonctionnalités de haut niveau dans leur assembleur : le nombre de types supportés par le processeur s'est étoffé, des instructions spéciales pour supporter les sous-programmes ont été inventées, et de nombreux modes d'adressage spécialement dédiés aux tableaux et structures ont fait leur apparition. Toutes ces améliorations ont fait que nos processeurs sont particulièrement adaptés à des langages procéduraux de haut niveau comme le C, le Pascal, le BASIC ou le Fortran.</p><p id="r-343697" data-claire-element-id="343697">Mais tous les processeurs existants n’ont pas forcément suivi cette logique et ne se sont pas adaptés qu'aux langages procéduraux. Par exemple, il existe de nombreuses architectures spécialement adaptées à l’exécution de langages fonctionnels ou logiques : les <strong>architectures <em>dataflow</em></strong>. Certains fabricants de processeurs sont allés plus loin : dans les années 1980, quand la programmation orientée objet s'est démocratisée, des chercheurs ou des fabricants de processeurs ont décidé de créer des processeurs prenant en charge une bonne partie des fonctionnalités des langages de programmation orientés objet directement dans leur matériel. Cela a donné lieu à quelques petites architectures plutôt sympas, dont certaines ont quitté les laboratoires pour finir par être commercialisées. Ce tutoriel va explorer l'architecture de certains de ces <strong>processeurs orientés objet</strong>, afin de montrer comment ces processeurs se sont adaptés pour supporter ce paradigme objet. Nous allons aborder une classe d'architectures de processeur permettant d’implémenter directement dans le silicium des langages de programmation orientés objet : ce sont les fameux <strong><em>Capability Based Systems</em></strong>.</p>
</div><a name="Capability-BasedSystem"></a><h2>Capability-Based System</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/rekursiv">
<span class="next">Rekursiv</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-343698" data-claire-element-id="343698">Pour commencer, nous allons voir les principes de base de ces processeurs orientés objet, et les différences qu'il peut y avoir avec les processeurs adaptés au paradigme procédural ou impératif. En réalité, le terme technique exact n'est pas « processeur orienté objet », mais <strong><em>Capability Based processor</em></strong>.</p><h2 id="r-processeurs-normaux" data-claire-element-id="343701">Processeurs normaux</h2><p id="r-343699" data-claire-element-id="343699">Sur les processeurs normaux, on ne peut pas manipuler directement des objets : on est obligé de manipuler des données dont la taille est fixée une fois pour toutes par l'architecture du processeur. Un processeur peut généralement gérer des données de 8 bits (caractères ASCII), 16 bits, 32 bits, etc. Ces données peuvent être stockées dans divers endroits : notre ordinateur contient de nombreux composants capables de stocker des données, que l'on appelle des mémoires. Généralement, il existe deux à trois grandes mémoires : la mémoires RAM, les registres (intégrés dans le processeur), et les mémoires de stockage (par exemple, le disque dur).</p><p id="r-343700" data-claire-element-id="343700">Lorsque l'on souhaite manipuler une de ces données, on est obligé de spécifier dans notre programme la localisation de la donnée à manipuler : autrement dit, dans quelle mémoire et à quelle position dans la mémoire se situe la donnée. Spécifier la localisation de la donnée ne se fait pas de la même manière suivant que la donnée est dans la mémoire RAM, dans un registre, ou sur le disque dur. Par exemple, une <strong>mémoire RAM</strong> est constituée de blocs de mémoire, ou cases mémoires, de taille fixe (généralement 8 bits), chacun identifié par un nombre : son <strong>adresse mémoire</strong>. Ainsi, les instructions de nos processeurs peuvent manipuler des adresses mémoire sans trop de problèmes.</p><h2 id="r-processeurs-orientes-objet" data-claire-element-id="343721">Processeurs orientés objet</h2><p id="r-343702" data-claire-element-id="343702">Sur les <em>Capability Based processors</em>, la notion même d'adresses mémoire n'existe pas (ou presque). À la place, chaque donnée manipulée par le processeur est stockée dans un objet, placé quelque part dans la mémoire, sans que l'on ait de moyen de savoir où. Cet objet peut être absolument n'importe quoi : cela peut être un objet spécifié par le programmeur, ou des objets prédéfinis lors de la fabrication du processeur. Par exemple, on peut considérer chaque périphérique comme un objet, auquel on a défini des méthodes bien particulières qui permettront de communiquer avec celui-ci ou de le commander. Sur d'autres architectures, chaque programme en cours d’exécution est considéré comme un objet, avec des méthodes permettant d'agir sur son état. On peut ainsi stopper l’exécution d'un programme via des méthodes adaptées, par exemple. Mais ce qui va nous permettre d'adapter des langages de programmation orientés objet sur de telles architectures, c'est la possibilité de créer soi-même des objets non définis lors de la fabrication du processeur.</p><h3 id="r-capability" data-claire-element-id="343705">Capability</h3><p id="r-343703" data-claire-element-id="343703">Au lieu d’utiliser des adresses mémoire et autres mécanismes divers et variés, chaque objet se voit attribuer un <strong>identifiant</strong> bien précis. Cet identifiant est unique à un objet (deux objets ne peuvent avoir le même identifiant), et il ne change pas au cours du temps : il est défini lorsqu'un objet est crée et ne peut être réutilisé pour un autre objet que lorsque l'objet possédant cet identifiant est détruit. En plus de cet identifiant, chaque objet se voit attribuer des <strong>droits d'accès</strong> : on peut ainsi interdire certaines manipulations dangereuses, ou limiter les droits d'accès à cet objet. L'identifiant et les droits d'accès sont rassemblés dans ce que l'on appelle une <em><strong>capability</strong></em>. Cette <em>capability</em> permet ainsi de nommer un objet, afin de pouvoir dire à notre ordinateur quel est l'objet à manipuler.</p><p id="r-343704" data-claire-element-id="343704">Les instructions de notre processeur ne manipuleront donc non pas des adresses mémoire, mais des <em>capability</em> : tout se passe comme si les <em>capability</em> remplaçaient les adresses mémoire. Contrairement aux processeurs adaptés au paradigme impératif ou procédural, cette <em>capability</em> ne dit strictement rien sur la localisation de la donnée en mémoire.</p><h3 id="r-un-peu-de-typage" data-claire-element-id="343709">Un peu de typage</h3><p id="r-343706" data-claire-element-id="343706">Sur ces architectures, il n'est pas rare que chaque <em>capability</em> ou chaque objet contienne des informations permettant de préciser le type d'un objet et permette à des instructions ou des fonctions d'avoir des comportements différents suivant l'objet manipulé. Dans ce cas, on dit que l'ordinateur est basé sur une <strong><em>tagged architecture</em></strong>.</p><p id="r-343707" data-claire-element-id="343707">Ces <em>tagged architectures</em> ne sont pas forcément des <em>capability based architectures</em> : de nombreux ordinateurs stockent des informations sur le type d'un objet dans celui-ci ou dans son adresse sans pour autant être des processeurs orientés objet : on peut par exemple citer le cas des <a href="http://fr.wikipedia.org/wiki/Machine_Lisp">machines LISP</a>, optimisées pour le langage <a href="http://fr.wikipedia.org/wiki/Lisp">LISP</a>. Ces <em>tagged architectures</em> permettent de supporter directement en <em>hardware</em> des fonctionnalités comme le typage dynamique et quelques autres fonctionnalités de certains langages de programmation (les unions, par exemple).</p><p id="r-343708" data-claire-element-id="343708">Souvent, la partie de l'objet ou de la <em>capability</em> spécifiant le type permet d'identifier certains types prédéfinis, mais peut aussi être configurée de façon à utiliser des types définis par le programmeur : sa signification dépendra alors de ce qu'a décidé le programmeur.</p><h3 id="r-capability-list" data-claire-element-id="343717">Capability list</h3><p id="r-343710" data-claire-element-id="343710">La base de la programmation objet n'est autre que l'encapsulation : il est interdit de modifier directement les données d'un objet et les seules manipulations autorisées sur cet objet sont définies par un certain nombre de fonctions ou de méthodes bien précises. Ainsi, chaque objet ne peut être modifié que par certaines entités logicielles bien précises.</p><p id="r-343711" data-claire-element-id="343711">Nos processeurs orientés objet doivent donc contenir un moyen quelconque de faire en sorte qu'un objet ne puisse être manipulé que par les entités autorisées à le faire. Pour cela, chaque programme, fonction, ou tout autre entité logicielle qui peut être inventée, a accès à un certain nombre d'objets : elle peut manipuler certains objets et pas d'autres. Pour chacune de ces entités, les <em>capability</em> qui permettent d'identifier chacun de ces objets accessibles sont rassemblées dans une sorte de tableau de <em>capability</em>, que l'on appelle la <em><strong>capability list</strong></em>.</p><figure id="r-343713" data-claire-element-id="343714"><img id="r-343712" data-claire-element-id="343712" src="medias/uploads.siteduzero.com_files_353001_354000_353176.png" alt="Image utilisateur"/></figure><p id="r-343715" data-claire-element-id="343715">Lorsque l'on veut spécifier l'objet à manipuler, il suffit de dire à quel indice de ce tableau est localisée la <em>capability</em> de l'objet à manipuler.</p><p id="r-343716" data-claire-element-id="343716">C'est le seul moyen pour accéder à un objet : les <em>capability</em> pointant vers un objet ne sont pas disponibles dans les <em>capability list</em> des fonctions, programmes, etc. pouvant le manipuler. Ce mécanisme interdit donc à tout sous-programme ou programme de modifier un objet qu'il n'est pas autorisé à manipuler : si celui-ci n'est pas dans sa <em>capability list</em>, il ne peut pas y avoir accès. Avec ce genre de mécanisme, il devient difficile d’exécuter certains types d'attaques, ce qui est un gage de sureté de fonctionnement indéniable. Du moins, c'est la théorie : tout repose sur l'intégrité de chaque <em>capability list</em> : si on peut modifier celle-ci, alors il devient facile de pouvoir accéder à des objets auxquels on aurait pas eu droit.</p><h3 id="r-instructions-d-appels-de-fonction-pour-le-support-de-l-heritage-et-autres-fonctionnalites" data-claire-element-id="343720">Instructions d'appels de fonction pour le support de l'héritage et autres fonctionnalités</h3><p id="r-343718" data-claire-element-id="343718">Divers mécanismes dépendants du processeur permettent d'implémenter l'héritage ou d'autres fonctionnalités objet en autorisant des manipulations, accès, copies ou partages temporaires de <em>capability lists</em>. Généralement, ce genre de fonctionnalité objet est géré directement au niveau des instructions du processeur : notre processeur contient pour ce faire des instructions spéciales.</p><p id="r-343719" data-claire-element-id="343719">Ces instructions sont souvent des <strong>instructions d'appels de fonction</strong> particulières. Pour ceux qui ne le savent pas, une instruction d'appel de fonction sert à demander au processeur d’exécuter une fonction bien précise. Sur les processeurs optimisés pour les langages procéduraux, une fonction est identifiée par son adresse, tandis que nos <em>capability-based processors</em> fournissent sa <em>capability</em> à l'instruction chargée d’exécuter notre fonction. Sur nos <em>capability based processors</em>, de nombreuses instructions d'appel de fonction sont disponibles : par exemple, l'instruction pour appeler une fonction définie dans la classe de l'objet qu'elle va manipuler ne sera pas la même de celle devant appeler une fonction héritée d'une autre classe (il faudra en effet faire quelques accès pour modifier ou accéder à des <em>capability list</em> extérieures, etc.).</p><h2 id="r-et-comment-on-fait-pour-localiser-les-donnees" data-claire-element-id="343723">Et comment on fait pour localiser les données ?</h2><p id="r-343722" data-claire-element-id="343722">Seul problème : il faut bien accéder aux données de notre objet un jour ou l'autre, ce qui implique fatalement de savoir quelle est l'adresse de la donnée à manipuler. Pour cela, il faudra convertir notre identifiant d'objet en une adresse mémoire. Cette conversion dépend de la conception du processeur, aussi il sera difficile de faire des généralités sur le sujet. Néanmoins, on peut préciser que ces techniques s'appuient souvent sur une technique de gestion de la mémoire que l'on appelle la <strong>segmentation</strong>.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet">Les processeurs orientés objet</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/capability-based-system">
Capability-Based System
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/rekursiv">
Rekursiv
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/intel-iapx-432">
Intel iAPX 432
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/rekursiv">
<span class="next">Rekursiv</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Rekursiv"></a><h2>Rekursiv</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/capability-based-system">
<span class="arrow"></span>
<span class="next">Capability-Based System</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/intel-iapx-432">
<span class="next">Intel iAPX 432</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-343725" data-claire-element-id="343725">Nous allons commencer par aborder le processeur <strong>Rekursiv</strong>. Ne soyez pas perturbé par son nom : il ne s'agit pas d'une coïncidence, comme on le verra plus tard.</p><h2 id="r-histoire-1" data-claire-element-id="343727">Histoire</h2><p id="r-343726" data-claire-element-id="343726">Ce processeur fut inventé par la compagnie Linn Product, un fabricant de matériel Hi-Fi, qui voulait améliorer ses chaînes de production automatisées. Celles-ci fonctionnaient avec un ordinateur DEC VAX assez correct pour l'époque. Cette compagnie avait lancé un grand projet de rajeunissement de sa chaîne de production. Au tout début, le projet consistait simplement à créer de nouveaux outils logiciels pour faciliter le fonctionnement de la chaîne de production. Au cours de ce projet, un langage de programmation orienté objet, le Lingo, fut créé dans ce but. Mais les programmes créés dans ce langage fonctionnaient vraiment lentement sur les DEC VAX de l'entreprise. L'entreprise, qui n'avait pas hésité à créer un nouveau langage de programmation pour ce projet, prit ce problème de performances à bras le corps et décida carrément d'inventer un nouveau processeur spécialement adapté à Lingo. Décidément, ça ne rigolait pas en ce temps-là. :p Ainsi naquit le processeur Rekursiv, premier processeur orienté objet de son genre.</p><h2 id="r-un-apercu-de-l-architecture" data-claire-element-id="343757">Un aperçu de l'architecture</h2><p id="r-343728" data-claire-element-id="343728">Vu de loin, ce processeur ressemble à un processeur tout à fait normal. Un processeur est souvent découpé en plusieurs circuits bien distincts, chacun chargé d'effectuer des manipulations bien précises. Cela permet de faciliter sa fabrication et sa conception en le décomposant en morceaux que l'on peut créer indépendamment. Généralement, les processeurs assez évolués sont découpés en au moins trois grands circuits :</p><ul id="r-343737" data-claire-element-id="343737"><li id="r-343730" data-claire-element-id="343730"><p id="r-343729" data-claire-element-id="343729">une <strong>unité de calcul</strong>, qui est un circuit chargé d'effectuer des calculs et de manipuler des données ;</p></li><li id="r-343732" data-claire-element-id="343732"><p id="r-343731" data-claire-element-id="343731">un <strong>séquenceur</strong> qui est chargé de commander et de donner des ordres aux unités de calcul pour qu'elles effectuent ce qu'il faut ;</p></li><li id="r-343734" data-claire-element-id="343734"><p id="r-343733" data-claire-element-id="343733">d'un circuit chargé de gérer la mémoire : la <strong>MMU</strong> ;</p></li><li id="r-343736" data-claire-element-id="343736"><p id="r-343735" data-claire-element-id="343735">et parfois quelques circuits supplémentaires.</p></li></ul><p id="r-343738" data-claire-element-id="343738">Notre processeur Rekursiv ne fait pas exception à cette règle, et il est découpé en quatre grands circuits principaux :</p><ul id="r-343747" data-claire-element-id="343747"><li id="r-343740" data-claire-element-id="343740"><p id="r-343739" data-claire-element-id="343739"><strong>Numerik</strong> : l'unité de calcul ;</p></li><li id="r-343742" data-claire-element-id="343742"><p id="r-343741" data-claire-element-id="343741"><strong>Logik</strong> : le séquenceur ;</p></li><li id="r-343744" data-claire-element-id="343744"><p id="r-343743" data-claire-element-id="343743"><strong>Objekt</strong> : une MMU orientée objet ;</p></li><li id="r-343746" data-claire-element-id="343746"><p id="r-343745" data-claire-element-id="343745">et <strong>Klock</strong>, une unité regroupant des circuits assez divers (des <em>timers</em> entre autres).</p></li></ul><p id="r-343748" data-claire-element-id="343748">Le support du paradigme objet était géré par Logik et par Objekt, aussi nous verrons plus en détail leurs possibilités dans la suite de ce tutoriel. Mais nous n'allons pas passer sous silence Numerik et Klock, et en parler assez brièvement.</p><h3 id="r-klock" data-claire-element-id="343750">Klock</h3><p id="r-343749" data-claire-element-id="343749"><em>Klock</em> est chargée de synchroniser les différents composants de ce processeur. Plus précisément, elle contient des <em>timers</em>, des composants permettant de mesurer des durées, et de quoi générer <strong>le signal d'horloge du processeur</strong>. Ce signal d'horloge a une fréquence d'environ 10 Mhz, ce qui n'était pas si mal pour l'époque.</p><h3 id="r-numerik" data-claire-element-id="343753">Numerik</h3><p id="r-343751" data-claire-element-id="343751">Numerik est le nom donné à l'ALU de ce processeur. Son jeu d'instructions est donc assez limité. On peut néanmoins dire que cette unité de calcul contient un circuit capable d'effectuer des multiplications ainsi qu'un <em>barrel shifter</em>, un circuit capable d'effectuer des instructions de décalage et de rotation. Cette unité de calcul est rattachée à 16 registres 32 bits, rassemblés dans un seul composant que l'on appelle un <strong><em>register file</em></strong>.</p><p id="r-343752" data-claire-element-id="343752">Numerik est capable de manipuler des nombres de 32 bits. Cette unité de calcul est un peu particulière : elle est formée de petites unités de calcul 4 bits, de marque AMD : des AMD2900, pour être précis. Ces unités de calculs AMD de 4 bits sont reliées entre elles pour former Numerik. Cette technique qui consiste à créer des unités de calcul plus grosses à partir d’unités de calcul plus élémentaires s'appelle en jargon technique du <em><strong>Bit Slicing</strong></em>.</p><h3 id="r-la-pile-1" data-claire-element-id="343756">La pile</h3><p id="r-343754" data-claire-element-id="343754">Vous le savez sûrement, mais nos ordinateurs réservent souvent une partie de notre mémoire RAM (ou certains registres du processeur) pour stocker ce que l'on appelle la <strong>pile d'appels</strong>. Cette pile sert à stocker les différents paramètres, variables locales et autres informations un peu spéciales, qui permettent d’exécuter des fonctions.</p><p id="r-343755" data-claire-element-id="343755">Cela peut paraître bizarre pour ceux qui sont habitués aux architectures X86, mais ce processeur implémentait deux piles. Eh oui, deux piles ! Ces deux piles avaient des rôles bien ciblés : la première servait à stocker les paramètres d'une fonction/méthode et ses variables locales, tandis que la seconde servait à stocker l'endroit où reprendre dans notre programme une fois la fonction/méthode terminée (les adresses de retour) et à sauvegarder les registres du processeur utilisés par la fonction.</p><h2 id="r-logik" data-claire-element-id="343766">Logik</h2><p id="r-343758" data-claire-element-id="343758">Rekursiv possède un grand nombre d'instructions machine plus ou moins évoluées. Par contre, Numerik contient de quoi exécuter un petit nombre d'instructions plus ou moins simples (additions, multiplications, et autres opérations arithmétiques et logiques simples), et ne peut pas faire plus. On pourrait croire que cela entre en contradiction avec la simplicité de l’unité de calcul, mais il n'en est rien. Les instructions de Rekursiv sont ce que l'on appelle des <strong>instructions micro-codées</strong> : il n'existe pas de circuits capables d’exécuter ces instructions dans le processeur. À la place, ces instructions sont émulées par une suite d'instructions exécutables par les unités de calcul du processeur que l'on nomme <strong>micro-opérations</strong>. Ces suites de micro-opérations sont stockées dans une petite mémoire de type ROM intégrée au processeur : cette mémoire s'appelle le <em><strong>Control Store</strong></em>.</p><p id="r-343759" data-claire-element-id="343759">Le <em>Control Store</em> de Rekursiv n'est autre qu'une mémoire d'environ 64 kibioctets. Elle possédait une petite particularité : on pouvait modifier son contenu si besoin. Et cette possibilité était poussée à l’extrême : il était parfaitement possible de reprogrammer le jeu d'instructions du processeur sans grandes restrictions. Cela pouvait même se faire à l’exécution : cela pouvait servir à adapter le jeu d'instructions à un langage particulier, voire l'adapter temporairement à un objet que l'on était en train de manipuler. L'ensemble des instructions du processeur (son <strong>jeu d'instructions</strong>) était donc <em>programmable </em>! Bien évidemment, on pouvait malgré tout supprimer les changements effectués sur le jeu d'instructions du processeur pour revenir à son jeu d'instructions originel.</p><p id="r-343760" data-claire-element-id="343760">Ce processeur possédait même une petite particularité : on pouvait, de par l'organisation de son micro-code, créer des instructions <a href="http://www.siteduzero.com/tutoriel-3-36703-la-recursivite.html">récursives</a> ! Ainsi, les instructions de copie ou de recherche dans un arbre ou une liste présentes dans son jeu d'instructions étaient codées via ce genre d'instructions récursives.</p><h3 id="r-le-jeu-d-instructions" data-claire-element-id="343765">Le jeu d'instructions</h3><p id="r-343761" data-claire-element-id="343761">Certaines des instructions du processeur étaient adaptées au paradigme objet et permettaient de gérer plus simplement les diverses fonctionnalités orientées objet au niveau du matériel. Ces instructions étaient toutes micro-codées, bien évidemment. Par exemple, il existait des instructions <strong>CREATE</strong>, chacune capable de créer un objet d'une certaine classe. Cette instruction n'était autre qu'un constructeur pour un certain type d'objet. Elle avait besoin de certaines données pour fonctionner (sa taille, son type et les valeurs initiales de ses attributs) qui étaient passés par la pile vue ci-dessus. Il existait aussi des instructions de transfert de messages entre objets (comme <strong>SEND</strong>), des instructions pour accéder à un champ d'un objet localisé sur la pile (<strong>GET</strong>), pour modifier un champ dans l'objet (<strong>PUT</strong>), et bien pire encore.</p><p id="r-343762" data-claire-element-id="343762">On peut signaler que ces instructions ne pouvaient opérer que sur certains types d'objets : certaines instructions ne pouvaient ainsi manipuler que des objets d'une certaine classe et pas d'une autre.</p><aside id="r-343764" data-claire-element-id="343764" data-claire-semantic="information"><p id="r-343763" data-claire-element-id="343763">Plus d’informations sur ce jeu d'instructions dans le lien suivant : <a href="http://www.ncl.ac.uk/computing/research/seminars/pdfs/chapters/129.pdf">Rekursiv</a>.</p></aside><h2 id="r-le-modele-memoire" data-claire-element-id="343772">Le modèle mémoire</h2><p id="r-343767" data-claire-element-id="343767">Mais ce qui fait que Rekursiv était un processeur orienté objet ne vient pas seulement de son jeu d'instructions : le principal intérêt de Rekursiv tient dans son unité chargée de gérer la mémoire.</p><p id="r-343768" data-claire-element-id="343768">Les <em>capability</em> de ce processeur était codées sur 40 bits. Lorsqu'une instruction devait manipuler un objet, elle demandait à la MMU d’accéder à l'objet via sa <em>capability</em>. Objekt, la MMU, se chargeait alors de convertir cette <em>capability</em> en une adresse mémoire de façon transparente pour les instructions : seule la MMU manipulait des adresses mémoire. La MMU stockait diverses informations sur chaque objet : ainsi, la MMU pouvait retrouver l'adresse mémoire de l'objet, son type, et sa taille à partir de l'identifiant. Ces informations étaient stockées dans la mémoire.</p><p id="r-343769" data-claire-element-id="343769">Un objet gardait en permanence la même <em>capability</em> : elle lui était attribuée à sa création (lors de l'appel de son constructeur) pour une libération ultérieure lors de la destruction. Cela permettait une chose assez sympathique : on pouvait déplacer l'objet dans la mémoire, son identifiant restait le même (alors que son adresse mémoire changeait).</p><p id="r-343770" data-claire-element-id="343770">Objekt implémentait un <em>Garbage Collector</em> matériel assez simple, mais suffisamment efficace. Pour rappel, un <em>garbage collector</em>, ou ramasse-miettes, est un programme ou un système matériel qui se charge de supprimer de la mémoire les objets ou données dont on n'a plus besoin. Dans certains langages de programmation comme le C ou le C++ , on est obligé de libérer la mémoire à la main. Ce n'est pas le cas pour certains langages orientés objet, comme JAVA ou Lingo : un garbage collector permet de gérer la mémoire automatiquement, sans demander au programmeur de se fatiguer à le faire lui-même (du moins, en théorie). Ce <em>garbage collector</em> avait souvent besoin de déplacer des objets pour faire un peu de place en mémoire, et compacter les objets ensemble, pour faire de la place. Le fait que les objets soient manipulés avec une <em>capability</em> facilitait énormément le travail du <em>garbage collector</em> matériel.</p><p id="r-343771" data-claire-element-id="343771">De même, la MMU pouvait décider de déplacer un objet sur le disque dur sans que le programme manipulant cet objet ne s'en aperçoive. Ainsi, si notre programme avait besoin de mémoire, la MMU pouvait déplacer un ou plusieurs objets sur le disque dur pour faire de la place. En cas de besoin, la MMU pouvait alors récupérer cet objet et le copier dans la RAM depuis le disque dur toute seule, sans demander à un quelconque système d'exploitation de le faire à sa place.</p><h2 id="r-un-echec-commercial" data-claire-element-id="343774">Un échec commercial</h2><p id="r-343773" data-claire-element-id="343773">Rekursiv était au départ prévu pour être utilisé sur des stations de travail <a href="http://en.wikipedia.org/wiki/Sun-3">Sun 3</a>. Mais malgré ses nombreuses qualités, Rekursiv ne s'est pas beaucoup vendu dans le monde : à peine 20 exemplaires furent vendus. La majorité des acheteurs étaient des chercheurs en architecture des ordinateurs, et rares furent les entreprises qui achetèrent des processeurs Rekursiv. Il faut dire que ce processeur était relativement spécialisé et difficile à utiliser, sans compter que d'autres processeurs concurrents firent leur apparition, comme l'Intel 432. Ce processeur fut donc un échec commercial retentissant, malgré une réussite technique indéniable.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet">Les processeurs orientés objet</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/capability-based-system">
Capability-Based System
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/rekursiv">
Rekursiv
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/intel-iapx-432">
Intel iAPX 432
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/capability-based-system">
<span class="arrow"></span>
<span class="next">Capability-Based System</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/intel-iapx-432">
<span class="next">Intel iAPX 432</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="InteliAPX432"></a><h2>Intel iAPX 432</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/rekursiv">
<span class="arrow"></span>
<span class="next">Rekursiv</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-343776" data-claire-element-id="343776">Passons maintenant à un autre processeur orienté objet un peu plus connu : l'Intel iAPX 432. Oui, vous avez bien lu : Intel a bel et bien réalisé un processeur orienté objet dans sa jeunesse. La conception du processeur Intel iAPX 432 commença en 1975, afin de créer un successeur digne de ce nom aux processeurs <a href="http://en.wikipedia.org/wiki/Intel_8008">8008</a> et <a href="http://en.wikipedia.org/wiki/Intel_8080">8080</a>.</p><h2 id="r-le-modele-memoire-1" data-claire-element-id="343802">Le modèle mémoire</h2><p id="r-343777" data-claire-element-id="343777">Ce processeur utilisait ce que l'on appelle <strong>la segmentation</strong> pour définir ses objets. Cette technique consiste à découper notre mémoire en gros blocs de mémoire que l'on appelle segments. Généralement, on ne découpe pas ces blocs n'importe comment : on préfère que ce découpage soit logique et reflète un peu l'organisation du programme que l'on est en train de découper en segments.</p><h3 id="r-segments-et-objets" data-claire-element-id="343781">Segments et objets</h3><p id="r-343778" data-claire-element-id="343778">Sur l'Intel iAPX432, chaque objet était stocké dans un segment : toutes ses données et autres informations permettant de déterminer intégralement l'état d'un objet étaient regroupées dans un de ces segments. Chacun de ces segments est découpé en deux parties de tailles égales : une partie contenant les données d'un objet, et des informations supplémentaires destinées à gérer l'objet correctement. Ces informations pouvaient être des <em>capability</em> pointant vers d'autres objets (pour créer des objets assez complexes), par exemple. Au fait : sur ce processeur, les <em>capability</em> sont appelées des <strong><em>Access Descriptors</em></strong>.</p><p id="r-343779" data-claire-element-id="343779">Sur l'Intel iAPX432, chaque segment (et donc chaque objet) pouvait mesurer jusqu'à 64 kibioctets : c'est très peu, mais suffisant pour stocker des objets suffisamment gros pour que cela ne pose pas vraiment de problèmes. Notre processeur pouvait gérer jusqu'à 2^{24} segments différents. Chacun de ces segments peut être placé n'importe où en mémoire physique. Un segment n'a donc pas d'adresse bien fixée en mémoire physique et peut être déplacé comme bon nous semble. Mais par contre, l'organisation, la place des données dans un segment n'est pas modifiée.</p><p id="r-343780" data-claire-element-id="343780">Pour le désigner, chacun de ces segments se voit attribuer un numéro qui permet de l'identifier parmi tous les autres : ce numéro de segment permet ainsi d'identifier un segment, et donc l'objet qui est stocké dedans. On comprend aisément qu'un objet est donc identifié par le numéro du segment qui lui est attribué, et que ce numéro fait partie de l'identifiant, de la <em>capability</em> de l'objet. De même, on peut sélectionner une donnée à l’intérieur d'un segment en connaissant la place de la donnée dans le segment. Ainsi, l'identifiant d'un objet permet de localiser une donnée à l'intérieur d'un segment, et il est découpé en deux parties : une qui identifie le numéro du segment contenant la donnée, et une autre qui spécifie la position de la donnée dans notre segment.</p><h3 id="r-relocation-1" data-claire-element-id="343788">Relocation</h3><p id="r-343782" data-claire-element-id="343782">Chacun de ces segments peut être placé n'importe où en mémoire physique. C'est le premier avantage de la segmentation : un segment n'a pas d'adresse bien fixée en mémoire physique et peut être déplacé comme bon nous semble. Par contre, l'organisation des données dans un segment n'est pas modifiée.</p><figure id="r-343784" data-claire-element-id="343785"><img id="r-343783" data-claire-element-id="343783" src="../../user.oc-static.com/files/350001_351000/350133.png" alt="Image utilisateur"/></figure><p id="r-343786" data-claire-element-id="343786">Généralement, lorsque l'on veut charger un segment en mémoire à partir du disque dur, celui-ci sera placé quelque part en mémoire RAM, à une certaine adresse. C'est le système d'exploitation qui gère le placement des segments dans la mémoire physique : il décide où placer le segment dans la mémoire RAM.</p><p id="r-343787" data-claire-element-id="343787">Ainsi, le numéro d'un segment ne dit rien sur la place en mémoire physique du segment en question. C'est cette propriété qui est utilisée pour faire en sorte que nos <em>capability</em> ne puissent pas spécifier la place en mémoire physique d'un objet.</p><h3 id="r-object-descriptor" data-claire-element-id="343794">Object descriptor</h3><div id="r-343790" data-claire-element-id="343790" data-claire-semantic="question"><p id="r-343789" data-claire-element-id="343789">Mais comment s'effectue cette traduction de la <em>capability</em> en adresse mémoire ?</p></div><p id="r-343791" data-claire-element-id="343791">Comme je l'ai dit plus haut, un objet est un segment, c'est-à-dire un morceau de mémoire qui commence à une certaine adresse (l'adresse de base). Chaque segment/objet se voit attribuer un numéro pour l'identifier, qui fait partie intégrante de la <em>capability</em> (enfin presque, disons plutôt que l'on peut déduire ce numéro à partir d'elle, mais passons ce genre de détails pour le moment).</p><p id="r-343792" data-claire-element-id="343792">Il nous faut donc se souvenir pour chaque segment (pour chaque objet, donc) de son adresse de base, l'adresse à laquelle il commence. Pour cela, la solution retenue sur ce processeur consiste à stocker, pour chaque objet, l'adresse à laquelle commence le segment qui le contient. Cette adresse, entre autres informations, est codée dans ce que l'on appelle un <em><strong>object descriptor</strong></em> qui pèse 128 bits.</p><p id="r-343793" data-claire-element-id="343793">Il contient entre autres la taille du morceau de segment qui contient les données, la taille du morceau de segment qui contient les <em>capability</em> de l'objet, l'adresse à laquelle commence le segment, quel est le type de l'objet, et beaucoup d'autres informations plus ou moins pertinentes.</p><h3 id="r-object-table" data-claire-element-id="343801">Object table</h3><p id="r-343795" data-claire-element-id="343795">Tous ces <em>object descriptor</em> sont stockés dans une table de correspondance qui permet de stocker l'<em>object descriptor</em> associé à chaque <em>access descriptor</em> (les<em> capability</em>). Cette table de correspondance, l'<em>object table</em>, est stockée en mémoire RAM et elle est consultée à chaque accès à un objet.</p><figure id="r-343797" data-claire-element-id="343798"><img id="r-343796" data-claire-element-id="343796" src="medias/uploads.siteduzero.com_files_353001_354000_353463.png" alt="Image utilisateur"/></figure><p id="r-343799" data-claire-element-id="343799">Pour déduire l'adresse mémoire du segment qui contient l'objet, il suffit de regarder la case de ce tableau d'<em>objects descriptors</em> qui correspond au numéro de segment indiqué par la <em>capability</em> : on trouvera alors l'<em>object descriptor</em> de l'objet contenu dans le segment ayant ce numéro, et on connaîtra son adresse de base. Il suffira alors d'ajouter la position de la donnée à cette adresse de base pour connaître l'adresse physique de notre objet/segment.</p><p id="r-343800" data-claire-element-id="343800">Il faut toutefois préciser que chaque programme possède son propre ensemble d'objets qu'il est le seul à pouvoir manipuler. Aussi, chaque <em>object table</em> n'est valable que pour un seul programme.</p><h2 id="r-support-de-la-poo" data-claire-element-id="343818">Support de la POO</h2><p id="r-343803" data-claire-element-id="343803">L'Intel 432 est conçu pour permettre l'utilisation de « types », de classes de base, déjà implémentées dans le processeur, mais cela ne suffit évidemment pas à supporter la programmation orientée objet. Pour cela, le processeur permet de définir ses propres classes, utilisables au besoin, et définies par le programmeur.</p><h3 id="r-domain-object" data-claire-element-id="343812">Domain object</h3><p id="r-343804" data-claire-element-id="343804">Notre Intel 432 permet, à partir de fonctions définies par le programmeur, de créer des <em><strong>domains objects</strong></em>, qui contiennent un ensemble de <em>capability</em> pointant chacune vers des fonctions. Chacune de ces fonctions peut accéder à un nombre restreint d'objets, tous du même type, et à rien d'autre. <br/> Chaque <em>domain object</em> est divisé en deux parties :</p><ul id="r-343809" data-claire-element-id="343809"><li id="r-343806" data-claire-element-id="343806"><p id="r-343805" data-claire-element-id="343805">une partie publique, qui contient des <em>capability</em> identifiant les fonctions exécutables au besoin par tout morceau de code ayant accès au <em>domain object</em> ;</p></li><li id="r-343808" data-claire-element-id="343808"><p id="r-343807" data-claire-element-id="343807">et une partie privée, qui contient des <em>capability</em> identifiant des fonctions/méthodes internes au <em>domain object</em> : seules les fonctions déclarées dans la partie publique possèdent des <em>capability</em> pointant vers ces fonctions et donc, seules ces fonctions de la partie publique peuvent les utiliser.</p></li></ul><p id="r-343810" data-claire-element-id="343810">En clair, ces <em>domains objects</em> ne sont rien de moins que l'ensemble des méthodes d'une classe ! Chacun de ces <em>domain objects</em> possédait une <em>capability</em> rien que pour lui, qui permettait de l'identifier et que l'on devait utiliser pour accéder aux fonctions qu'il contient.</p><p id="r-343811" data-claire-element-id="343811">Évidemment, ce processeur supportait de nombreuses instructions et fonctionnalités permettant à des <em>capability</em> pointant vers des fonctions publiques d’être présentes dans des <em>domains objects</em> différents. Celles-ci pouvaient être paramétrées de façon plus ou moins fine afin de choisir quelles fonctions d'un <em>domain object</em> devaient être partagées ou non. Cela permettait de supporter des fonctionnalités objet telles que l'héritage, l'<em>inheritance</em>, etc.</p><h3 id="r-de-nombreux-objets-predefinis" data-claire-element-id="343814">De nombreux objets prédéfinis</h3><p id="r-343813" data-claire-element-id="343813">Sur ce processeur, chaque processus est considéré comme un objet à part entière. De même, l'état du processeur (le programme qu'il est en train d’exécuter, son état, etc.) est défini par un objet, stocké en mémoire, qu'il est possible de manipuler : toute manipulation de cet objet permettra d'effectuer une action particulière sur notre processeur. Il en est de même pour chaque fonction présente en mémoire : elle était encapsulée dans un objet, sur lequel seules quelques manipulations étaient possibles (l’exécuter, notamment). Et ne parlons pas des appels de fonctions qui stockaient l'état de l'appelé directement dans un objet spécial. Bref, de nombreux objets système sont prédéfinis par le processeur : les objets stockant des fonctions, les objets stockant des processus, etc.</p><h3 id="r-typage-des-objets" data-claire-element-id="343817">Typage des objets</h3><p id="r-343815" data-claire-element-id="343815">Il est aussi possible pour le programmeur de définir de nouveaux types non supportés par le processeur, en faisant appel au système d'exploitation de l'ordinateur. Au niveau du processeur, chaque objet est typé au niveau de son <em>object descriptor</em> : celui-ci contient des informations qui permettent de déterminer le type de l'objet.</p><p id="r-343816" data-claire-element-id="343816">Chaque type se voit attribuer un <em>domain object</em> qui contient toutes les fonctions capables de manipuler les objets de ce type et que l'on appelle le <strong><em>type manager</em></strong>. Lorsque l'on veut manipuler un objet d'un certain type, il suffit d'accéder à une <em>capability</em> spéciale (le <strong>TCO</strong>) qui pointera dans ce <em>type manager</em> et qui précisera quel est l'objet à manipuler (en sélectionnant la bonne entrée dans la <em>capability list</em>). Le type d'un objet prédéfini par le processeur est ainsi spécifié par une suite de 8 bits, tandis que le type d'un objet défini par le programmeur est défini par la <em>capability</em> spéciale pointant vers son <em>type manager</em>.</p><h2 id="r-garbage-collector" data-claire-element-id="343820"><em>Garbage collector</em></h2><p id="r-343819" data-claire-element-id="343819">L'Intel 432 possédait dans ses circuits un <em>garbage collector</em> matériel. Pour faciliter son fonctionnement, certains bits de l'<em>object descriptor</em> des objets permettaient de savoir si l'objet en question pouvait être supprimé ou non.</p><h2 id="r-jeu-d-instructions" data-claire-element-id="343837">Jeu d'instructions</h2><p id="r-343821" data-claire-element-id="343821">Ce processeur est capable d’exécuter pas moins de 230 instructions différentes. Chacune de ces instructions peut manipuler des données de types divers : caractères ASCII, entiers, nombres flottants, tableaux, structures de données ou objets. Le processeur supporte certains objets de base, prédéfinis dans le processeur. Il fournit des instructions spécialement dédiées à la manipulation de ces objets, et contient notamment des instructions d'appel de fonction assez élaborées. Il contient aussi des instructions n'ayant rien à voir avec nos objets, qui permettent de manipuler des nombres entiers, des caractères, des chaînes de caractères, des tableaux, etc. Mais ces instructions sont un peu spéciales vu que le processeur ne contient strictement aucun registre capable de stocker des données : tout passe par la pile, que l'on a vue plus haut. Il s'agit donc d'une <a href="http://www.siteduzero.com/tutoriel-3-509195-registres-ou-pile.html#ss_part_2"><strong>machine à pile</strong></a> !</p><p id="r-343822" data-claire-element-id="343822">Ce processeur contenait aussi des instructions spécialement dédiés à la programmation système et idéales pour programmer des systèmes d'exploitation. De nombreuses instructions permettaient ainsi de commuter des processus, faire des transferts de messages entre processus, etc. Environ 40 % du micro-code était ainsi spécialement dédié à ces instructions spéciales. Ces instructions chargées de prendre en charge le travail d'un système d'exploitation étaient des manipulations comme un changement de contexte ou un passage de message entre processus et se contentaient de faire des manipulations sur des objets représentant le processeur, des processus, ou d'autres choses dans le genre.</p><p id="r-343823" data-claire-element-id="343823">Beaucoup de ces instructions sont micro-codées, comme sur le processeur Rekursiv : on peut notamment remarquer que toutes les instructions permettant de faciliter la programmation de systèmes d'exploitation le sont. Mais les possibilités sont moindres : il n'est pas aussi simple de reprogrammer le micro-code du processeur pour ajouter des instructions, et de sérieuses limitations ont été posées pour éviter que n'importe quel programmeur puisse aller faire n'importe quoi dans le micro-code.</p><h3 id="r-encodage-des-instructions" data-claire-element-id="343836">Encodage des instructions</h3><p id="r-343824" data-claire-element-id="343824">On peut aussi préciser que ces instructions sont de longueur variable. Si vous ne le savez pas, une instruction est stockée en mémoire sous la forme d'une suite de bits bien précise. Pour chaque instruction, cette suite de bits contient un certain nombre de bits. Sur certains processeurs, la taille de cette suite de bits est fixe et ne change pas suivant l'instruction. Mais l'Intel iAPX 432 ne fonctionne pas comme cela : ses instructions ont un nombre de bits qui peut varier. Sur un processeur normal, les instructions ont une longueur qui est souvent multiple d'un octet, mais notre Intel iAPX 432 fait exception à cette règle : ses instructions peuvent prendre n'importe quelle taille comprise entre 10 et 300 bits, sans vraiment de restriction de taille.</p><p id="r-343825" data-claire-element-id="343825">Les bits représentant une instruction sont organisés d'une façon différente suivant le processeur. Sur l'Intel iAPX 432, ces bits sont regroupés en 4 grands blocs, 4 champs, qui ont chacun une signification particulière. Comme vous allez le voir dans un instant, l'encodage des instructions reflète directement l'organisation de la mémoire en segments : le jeu d'instructions a dû s'adapter à l'organisation de la mémoire.</p><figure id="r-343827" data-claire-element-id="343828"><img id="r-343826" data-claire-element-id="343826" src="medias/uploads.siteduzero.com_files_353001_354000_353473.png" alt="Image utilisateur"/></figure><p id="r-343829" data-claire-element-id="343829">Le premier champ s'appelle <strong><em>classe</em></strong>. Il permet de dire combien de données différentes l'instruction va devoir manipuler, et quelles seront leurs tailles.</p><p id="r-343830" data-claire-element-id="343830">Le second champ, le champ <em><strong>format</strong></em>, n'utilise que 4 bits et a pour but de préciser si les données à manipuler sont en mémoire ou sur la pile.</p><p id="r-343831" data-claire-element-id="343831">Le troisième champ, <strong><em>reference</em></strong>, doit être interprété différemment suivant la donnée à manipuler. Si cette donnée est un entier, un caractère ou un flottant, ce champ indique l'emplacement de la donnée en mémoire. Alors que si l'instruction manipule un objet, ce champ spécifie la <em>capability</em> de l'objet en question. Ce champ est assez complexe et il est sacrément bien organisé.</p><figure id="r-343833" data-claire-element-id="343834"><img id="r-343832" data-claire-element-id="343832" src="medias/uploads.siteduzero.com_files_353001_354000_353476.png" alt="Image utilisateur"/></figure><p id="r-343835" data-claire-element-id="343835">Le dernier champ s'appelle l'<strong>opcode</strong> et permet d’identifier l'instruction à effectuer : s'agit-il d'une addition, d'une création d'objet, d'un passage de message entre deux processus, d'une copie d'un objet sur la pile, etc.</p><h2 id="r-un-echec-commercial-le-retour" data-claire-element-id="343848">Un échec commercial : le retour !</h2><p id="r-343838" data-claire-element-id="343838">Eh oui, la tragédie qui a eu lieu avec Rekursiv s'est reproduite avec l'Intel 432 : il s'est très faiblement vendu.</p><p id="r-343839" data-claire-element-id="343839">Il faut dire que ce processeur avait des performances assez désastreuses et quelques petits défauts techniques qui l'empêchaient d'être performant. Par exemple, ce processeur ne contenait pas de mémoire cache : autant dire que ce processeur courait vraiment au casse-pipe ! On peut aussi citer le fait que ce processeur n'avait pas de registres : tout se faisait uniquement en mémoire RAM. Autre détail : ce processeur ne pouvait pas effectuer directement de calculs avec des constantes entières autres que 0 et 1 (une sombre histoire de mode d'adressage immédiat non supporté, bref). Et ces problèmes techniques ne sont que l'arbre qui cache la forêt...</p><p id="r-343840" data-claire-element-id="343840">De plus, celui-ci avait été conçu pour exécuter en grande partie le langage ADA, un langage de programmation orienté objet très sécurisé et très utilisé dans le domaine de l'embarqué pour ses qualités intrinsèques. Malheureusement, le compilateur qui traduisait les codes sources écrits en ADA en programmes compréhensibles par le processeur était assez mauvais et avait une certaine tendance à massacrer les performances. Sans compter que l'ADA n'était pas très populaire chez les programmeurs et n'était utilisé que par les militaires et les entreprises travaillant sur des systèmes embarqués ou critiques, ce qui n'a pas aidé à faire vendre ce processeur.</p><p id="r-343841" data-claire-element-id="343841">Qui sait, si ce processeur avait été plus performant, nous manipulerions tous des processeurs orientés objet de nos jours. :p</p><p id="r-343842" data-claire-element-id="343842">Voilà, cette introduction aux processeurs orientés objet se termine. Pour finir, je tiens à préciser qu'il existe d'autres processeurs orientés objet, bien que ceux-ci soient assez rares. Ce sont souvent des processeurs assez anciens, bien que quelques exceptions existent. Par exemple, il semblerait qu'il existe des projets de processeurs MIPS orientés objet du nom d'OOMIPS. Pour ceux qui veulent en savoir plus sur ces architectures, je conseille la lecture des liens suivants :</p><ul id="r-343847" data-claire-element-id="343847"><li id="r-343844" data-claire-element-id="343844"><p id="r-343843" data-claire-element-id="343843"><a href="http://www.cs.washington.edu/homes/levy/capabook/"><strong>http://www.cs.washington.edu/homes/levy/capabook/</strong></a> ;</p></li><li id="r-343846" data-claire-element-id="343846"><p id="r-343845" data-claire-element-id="343845"><a href="http://www.ee.cityu.edu.hk/~hisc/HISC.pdf">le processeur HISC</a>.</p></li></ul>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet">Les processeurs orientés objet</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/capability-based-system">
Capability-Based System
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/rekursiv">
Rekursiv
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/intel-iapx-432">
Intel iAPX 432
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-processeurs-orientes-objet/rekursiv">
<span class="arrow"></span>
<span class="next">Rekursiv</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/les-processeurs-orientes-objet.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Oct 2013 23:51:04 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-processeurs-orientes-objet.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:12:31 GMT -->
</html>
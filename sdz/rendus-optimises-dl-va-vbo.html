<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/rendus-optimises-dl-va-vbo.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 02:19:32 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/rendus-optimises-dl-va-vbo.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:33:06 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Rendus optimisés : DL, VA, VBO</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/rendus-optimises-dl-va-vbo.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Rendus optimisés : DL, VA, VBO</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#RendusoptimissDLVAVBO">Rendus optimisés : DL, VA, VBO</a><br/><a href="#Lesdisplaylists">Les display lists</a><br/><a href="#Qu039est-cedonc">Qu&#039;est-ce donc ?</a><br/><a href="#Crerunedisplaylist">Créer une display list</a><br/><a href="#Remplirunedisplaylist">Remplir une display list</a><br/><a href="#Afficherunedisplaylist">Afficher une display list</a><br/><a href="#Limitesdesdisplaylists">Limites des display lists</a><br/><a href="#Lesvertexarrays">Les vertex arrays</a><br/><a href="#Fonctionnement">Fonctionnement</a><br/><a href="#Spcificationdetableaux">Spécification de tableaux</a><br/><a href="#Effectuerunrendu">Effectuer un rendu</a><br/><a href="#Utilisationd039indices">Utilisation d&#039;indices</a><br/><a href="#LesVertexBufferObjects">Les Vertex Buffer Objects</a><br/><a href="#LesVBOdesdonnesctserveur">Les VBO, des données côté serveur</a><br/><a href="#Crationd039unobjettampon">Création d&#039;un objet tampon</a><br/><a href="#Hbergerdesdonnes">Héberger des données</a><br/><a href="#Exploiterdesdonneshberges">Exploiter des données hébergées</a><br/><a href="#Hbergementetutilisationd039untableaud039indices">Hébergement et utilisation d&#039;un tableau d&#039;indices</a><br/><a href="#Mettrejouruntampon">Mettre à jour un tampon</a><br/></div>
<a name="RendusoptimissDLVAVBO"></a><h2>Rendus optimisés : DL, VA, VBO</h2><div class="content" role="article">
<p id="r-538031" data-claire-element-id="538031">Vos rendus 3D avec OpenGL sont lents alors que vous possédez le dernier cri en matière de carte graphique ? Ou bien votre vieille machine vous fait des caprices avec vos codes OpenGL trop gourmands pour elle ? Ou encore vous souhaiteriez découvrir une nouvelle façon d'afficher des polygones avec OpenGL ?</p><p id="r-538032" data-claire-element-id="538032">Si c'est le cas, bienvenue dans ce tutoriel, il est fait pour vous ! :) <br/> Ici, je vais tenter de vous faire connaître les différentes façons de procéder à un rendu avec OpenGL, leurs avantages ainsi que leurs inconvénients.</p><p id="r-538033" data-claire-element-id="538033">Bonne lecture !</p><aside id="r-538035" data-claire-element-id="538035" data-claire-semantic="information"><p id="r-538034" data-claire-element-id="538034">Ce tutoriel nécessite la lecture préalable du <a href="http://www.siteduzero.com/tuto-3-5616-0-creez-des-programmes-en-3d-avec-opengl.html">cours sur OpenGL</a> de <a href="http://www.siteduzero.com/membres-294-5.html">Kayl</a>.<br/> Les exemples de code seront écrits en langage C. Par conséquent les questions relatives à ce tutoriel devront être posées dans le <a href="http://www.siteduzero.com/forum-81-126-langage-c.html">forum approprié</a>.</p></aside>
</div>
<div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1358423835269-0" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1358423835269-0');
        });
    }
    </script>
</div><a name="Lesdisplaylists"></a><h2>Les display lists</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
<span class="next">Qu&#039;est-ce donc ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-538036" data-claire-element-id="538036">Bienvenue dans le premier chapitre de ce tutoriel. :)</p><p id="r-538037" data-claire-element-id="538037">Ici, nous allons découvrir une méthode de rendu particulière, destinée à améliorer les performances et la rapidité d'affichage de vos scènes 3D avec OpenGL. Nous étudierons ensuite les avantages que cette méthode présente, et les limites qu'elle implique.</p>
</div><a name="Qu039est-cedonc"></a><h2>Qu&#039;est-ce donc ?</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">
<span class="arrow"></span>
<span class="next">Les display lists</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
<span class="next">Créer une display list</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-qu-est-ce-donc" data-claire-element-id="538064">Qu'est-ce donc ?</h4><p id="r-538038" data-claire-element-id="538038">Une display list est, comme son nom l'indique, une liste d'affichage. :p <br/> En pratique, vous pouvez vous représenter cela comme une zone de stockage d'informations.</p><p id="r-538039" data-claire-element-id="538039">Une display list a pour but d'enregistrer vos appels au pilote de votre carte graphique dans une zone mémoire réservée par OpenGL, à laquelle vous pouvez faire appel quand vous le souhaitez.</p><div id="r-538041" data-claire-element-id="538041" data-claire-semantic="question"><p id="r-538040" data-claire-element-id="538040">Cool, et ça sert à quoi ?</p></div><p id="r-538042" data-claire-element-id="538042">À afficher des polygones, tiens !<br/> Mais pas n'importe comment. ;) <br/> En effet, une display list s'exécute beaucoup plus rapidement qu'une suite d'appels à <em>glVertex*()</em>.</p><div id="r-538044" data-claire-element-id="538044" data-claire-semantic="question"><p id="r-538043" data-claire-element-id="538043">Enregistrer, pilote, exécuter, glVertex... je n'y comprends rien. o_O</p></div><p id="r-538045" data-claire-element-id="538045">Un petit dessin s'impose :</p><figure id="r-538047" data-claire-element-id="538048"><img id="r-538046" data-claire-element-id="538046" src="medias/uploads.siteduzero.com_files_69001_70000_69066.jpg" alt="Image utilisateur"/></figure><p id="r-538049" data-claire-element-id="538049">Dans une display list on peut stocker des informations quelconques (il y a des restrictions toutefois, nous verrons cela plus bas).</p><p id="r-538050" data-claire-element-id="538050">Qui d'entre vous n'a jamais rêvé de pouvoir afficher son cube texturé en un appel de fonction, sans construire lui-même la fonction ? Personne. :p <br/> Prenons un exemple simple, un carré + un triangle, simplement colorés :</p><pre id="r-538051" data-claire-element-id="538051"><code data-claire-semantic="c">glBegin(GL_TRIANGLES);
        glColor3f(1.0, 1.0, 1.0); glVertex2f(0.0, 0.9);
        glColor3f(1.0, 0.0, 0.0); glVertex2f(-0.5, 0.3);
        glColor3f(0.0, 1.0, 0.0); glVertex2f(0.5, 0.3);
    glEnd();
    glBegin(GL_QUADS);
        glColor3f(1.0, 0.0, 0.0); glVertex2f(-0.5, -0.8);
        glColor3f(0.0, 1.0, 0.0); glVertex2f(0.5, -0.8);
        glColor3f(0.0, 1.0, 0.0); glVertex2f(0.5, 0.3);
        glColor3f(1.0, 0.0, 0.0); glVertex2f(-0.5, 0.3);
    glEnd();</code></pre><p id="r-538052" data-claire-element-id="538052">(Oh la jolie maison... :-° )<br/> Je voudrais que cette maison se dessine à chaque frame : rien de plus simple me direz-vous, on place cela dans une fonction <code data-claire-semantic="c">dessiner_maison() </code> et hop, le tour est joué.<br/> Cependant, ce code ne sera pas très optimisé pour une simple raison : deux appels à <code data-claire-semantic="c">glBegin() </code> se font ressentir.<br/><code data-claire-semantic="c">glBegin() </code> a en quelque sorte pour effet « d'ouvrir » le pilote graphique et de le tenir prêt pour un rendu. Les appels au pilote graphique sont lourds et coûtent cher en ressources ; une des premières optimisations à faire dans tout programme 3D utilisant le hardware (carte graphique) est de limiter ceux-ci.</p><p id="r-538053" data-claire-element-id="538053">Certains me diront qu'avec une utilisation judicieuse de <code data-claire-semantic="c">GL_TRIANGLES </code> (et même <code data-claire-semantic="c">GL_TRIANGLE_STRIP/FAN </code>), on peut n'effectuer qu'un seul appel à <code data-claire-semantic="c">glBegin() </code> dans ce dessin, et ils auront raison. Cette maison est uniquement là à titre d'exemple.<br/> En effet, lorsque l'on veut rendre plusieurs sortes de primitives, on doit obligatoirement faire plusieurs appels au pilote, quelle que soit la méthode utilisée. Mais généralement les graphistes triangularisent leurs modèles, d'une part parce que les triangles sont la seule primitive supportée nativement par les cartes graphiques, et ensuite pour n'effectuer qu'un seul appel au pilote lors du rendu, ces deux points font gagner déjà beaucoup en matière de performances.</p><p id="r-538054" data-claire-element-id="538054">Revenons-en à nos display lists.<br/> Supposons que je sois un flemmard (et pas la peine de le supposer d'ailleurs, j'en suis un :-° ) et que je n'aie pas envie de me creuser la cervelle pour optimiser mon code, que fais-je ? Une display list ! Au lieu de mettre mes <code data-claire-semantic="c">glVertex*() </code> dans une fonction, je vais les mettre dans une display list. (Oui, oui, vous avez bien entendu lu.)<br/> Complétons notre schéma, vu plus haut :</p><figure id="r-538056" data-claire-element-id="538057"><img id="r-538055" data-claire-element-id="538055" src="medias/uploads.siteduzero.com_files_69001_70000_69067.jpg" alt="Image utilisateur"/></figure><p id="r-538058" data-claire-element-id="538058">Hé oui, ces fameuses informations que notre display list peut stocker, ce ne sont rien d'autre que des appels de fonctions. :)</p><div id="r-538060" data-claire-element-id="538060" data-claire-semantic="question"><p id="r-538059" data-claire-element-id="538059">Hein ?! Depuis quand on peut &quot;stocker&quot; des fonctions en C ??</p></div><p id="r-538061" data-claire-element-id="538061">Demandez à OpenGL. :p En réalité, OpenGL n'enregiste pas les fonctions elles-mêmes, mais plutôt leur effet.<br/> Attention cependant, OpenGL n'accepte pas toutes ses fonctions. Vous trouverez dans la page de man de <code data-claire-semantic="c"><a href="http://www.opengl.org/sdk/docs/man/xhtml/glNewList.xml">glNewList() </a></code> la liste des fonctions non acceptées.</p><p id="r-538062" data-claire-element-id="538062">Pour en revenir au fonctionnement du stockage des fonctions dans une display list, je vais tenter une brève explication.<br/> Tout d'abord, il faut dire à OpenGL que l'on souhaite rentrer en mode &quot;display list&quot;. À partir de là, les appels de fonctions sont enregistrés dans un cache de commandes. Pour afficher le contenu de la liste, il suffit ensuite de dire à OpenGL d'exécuter les commandes enregistrées dans ce cache. Ce cache se situe en mémoire vive, et de préférence dans celle de la carte graphique.</p><p id="r-538063" data-claire-element-id="538063">Puisqu'à présent les présentations sont faites, et que vous savez ce que l'on peut faire avec une display list, je vous propose de passer aux exemples de code. :)</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">
<span class="arrow"></span>
<span class="next">Les display lists</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
<span class="next">Créer une display list</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Crerunedisplaylist"></a><h2>Créer une display list</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
<span class="arrow"></span>
<span class="next">Qu&#039;est-ce donc ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
<span class="next">Remplir une display list</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-creer-une-display-list" data-claire-element-id="538092">Créer une display list</h4><p id="r-538065" data-claire-element-id="538065">Une display list OpenGL n'est rien d'autre qu'un objet OpenGL.<br/> Les objets OpenGL sont des <strong>GLuint</strong> (entiers non signés). Par exemple, une texture est un objet OpenGL.</p><pre id="r-538066" data-claire-element-id="538066"><code data-claire-semantic="c">GLuint obj_id; /* identifiant de notre objet */</code></pre><p id="r-538067" data-claire-element-id="538067">Les objets OpenGL ont des fonctions de manipulation de base, qui ont des noms très similaires.</p><ul id="r-538074" data-claire-element-id="538074"><li id="r-538069" data-claire-element-id="538069"><p id="r-538068" data-claire-element-id="538068"><code data-claire-semantic="c">void glGen*(GLsizei nb, GLuint *objs) </code> : crée <em>nb</em> identifiants dans <em>objs</em> ;</p></li><li id="r-538071" data-claire-element-id="538071"><p id="r-538070" data-claire-element-id="538070"><code data-claire-semantic="c">GLboolean glIs*(GLuint id) </code> : renvoie <code data-claire-semantic="c">GL_TRUE </code> si l'identifiant est un identifiant d'objet valide ;</p></li><li id="r-538073" data-claire-element-id="538073"><p id="r-538072" data-claire-element-id="538072"><code data-claire-semantic="c">void glDelete*(GLsizei nb, GLuint *objs) </code> : supprime <em>nb</em> objets dans <em>objs</em>.</p></li></ul><p id="r-538075" data-claire-element-id="538075">Exemple simple :</p><pre id="r-538076" data-claire-element-id="538076"><code data-claire-semantic="c">GLuint texture; /* voici notre identifiant */

/* cree une texture et place son identifiant dans la variable texture */
glGenTextures(1, &amp;texture);

/* ce if a toutes les chances de reussir, si ce n'est pas le cas,
   il y a probablement une saturation memoire */
if(glIsTexture(texture))
    printf(&quot;identifiant valide, texture creee avec succes\n&quot;);

/* utilisation ... */

/* on supprime notre objet */
glDeleteTextures(1, &amp;texture);</code></pre><p id="r-538077" data-claire-element-id="538077">Il en va de même pour tous les types d'objets OpenGL, il suffit de remplacer <em>Textures</em> par le nom du type de l'objet que l'on souhaite manipuler.<br/> Malheureusement, il existe des exceptions, et les display list en sont justement une. :'(</p><p id="r-538078" data-claire-element-id="538078">Allons, allons, les différences ne sont pas si grandes, et ne devraient pas trop vous poser de problèmes. ;)</p><p id="r-538079" data-claire-element-id="538079">Voici le prototype de la fonction permettant de créer un identifiant de display list :</p><pre id="r-538080" data-claire-element-id="538080"><code data-claire-semantic="c">GLuint glGenLists(GLsizei range);</code></pre><ul id="r-538083" data-claire-element-id="538083"><li id="r-538082" data-claire-element-id="538082"><p id="r-538081" data-claire-element-id="538081"><code data-claire-semantic="c"><strong>range </strong></code> : représente le nombre d'identifiants contigus à créer.<br/> La valeur retournée est le premier index de cette suite d'identifiants (appelés plus communément <em>index</em> dans le cas des display lists).</p></li></ul><p id="r-538084" data-claire-element-id="538084">Si nous voulons créer une liste, nous allons faire comme cela :</p><pre id="r-538085" data-claire-element-id="538085"><code data-claire-semantic="c">GLuint list;

list = glGenLists(1);

/* utilisation ... */</code></pre><p id="r-538086" data-claire-element-id="538086">La suppression d'une liste s'effectue avec la fonction suivante :</p><pre id="r-538087" data-claire-element-id="538087"><code data-claire-semantic="c">void glDeleteLists(GLuint list, GLsizei range);</code></pre><p id="r-538088" data-claire-element-id="538088">Son fonctionnement diffère des fonctions habituelles pour la manipulation d'objets OpenGL, mais si vous avez compris la création d'une liste, vous ne devriez pas avoir de problème avec sa suppression.<br/> La suppression d'une liste la vide de son contenu et rend inutilisé l'index list, précédemment réservé par <code data-claire-semantic="c">glGenLists() </code>.</p><aside id="r-538090" data-claire-element-id="538090" data-claire-semantic="information"><p id="r-538089" data-claire-element-id="538089">Le type <code data-claire-semantic="c">GLsizei </code> est défini comme ceci dans gl.h : <code data-claire-semantic="c">typedef int GLsizei; </code> Rien de bien méchant donc.</p></aside><p id="r-538091" data-claire-element-id="538091">Maintenant que nous savons créer une display list, il est temps de savoir s'en servir. :)</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
<span class="arrow"></span>
<span class="next">Qu&#039;est-ce donc ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
<span class="next">Remplir une display list</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Remplirunedisplaylist"></a><h2>Remplir une display list</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
<span class="arrow"></span>
<span class="next">Créer une display list</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
<span class="next">Afficher une display list</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-remplir-une-display-list" data-claire-element-id="538136">Remplir une display list</h4><p id="r-538093" data-claire-element-id="538093">Nous l'avons vu ci-dessus sur notre schéma, une display list est une zone de stockage de fonctions.<br/> Le stockage de ces fonctions se fait de manière plutôt sympathique et intuitive. :) <br/> Il vous suffit... d'appeler ces fonctions. Cependant, avant de les appeler, il est nécessaire de prévenir OpenGL que ces appels devront non pas êtres exécutés mais stockés dans une liste.<br/> Il existe deux modes de stockage :</p><ul id="r-538098" data-claire-element-id="538098"><li id="r-538095" data-claire-element-id="538095"><p id="r-538094" data-claire-element-id="538094"><code data-claire-semantic="c">GL_COMPILE </code> : stockage brut dans la display list ;</p></li><li id="r-538097" data-claire-element-id="538097"><p id="r-538096" data-claire-element-id="538096"><code data-claire-semantic="c">GL_COMPILE_AND_EXECUTE </code> : stocke et exécute les fonctions fournies.</p></li></ul><p id="r-538099" data-claire-element-id="538099">Ces deux constantes s'utilisent avec la fonction <code data-claire-semantic="c">glNewList() </code>, dont voici le prototype :</p><pre id="r-538100" data-claire-element-id="538100"><code data-claire-semantic="c">void glNewList(GLuint list, GLenum mode);</code></pre><ul id="r-538105" data-claire-element-id="538105"><li id="r-538102" data-claire-element-id="538102"><p id="r-538101" data-claire-element-id="538101"><code data-claire-semantic="c"><strong>list </strong></code> : représente l'index de votre liste ;</p></li><li id="r-538104" data-claire-element-id="538104"><p id="r-538103" data-claire-element-id="538103"><code data-claire-semantic="c"><strong>mode </strong></code> : doit être positionné à l'une des constantes énumérées ci-dessus.</p></li></ul><p id="r-538106" data-claire-element-id="538106">Cet appel de fonction peut se traduire ainsi :</p><p id="r-538107" data-claire-element-id="538107">à partir de maintenant, tous mes appels de fonctions OpenGL seront stockés dans <em>list</em>.</p><p id="r-538108" data-claire-element-id="538108">Lorsque vous avez fini de construire votre liste, il existe une fonction très simple, pour revenir en mode normal :</p><pre id="r-538109" data-claire-element-id="538109"><code data-claire-semantic="c">void glEndList(void);</code></pre><p id="r-538110" data-claire-element-id="538110">Je pense que cette fonction se passe de commentaire. :-° <br/> En revanche, le fonctionnement global a bien besoin d'un petit résumé.</p><ol id="r-538123" data-claire-element-id="538123"><li id="r-538112" data-claire-element-id="538112"><p id="r-538111" data-claire-element-id="538111">Créez un identifiant de liste grâce à <code data-claire-semantic="c">glGenLists() </code>.</p></li><li id="r-538114" data-claire-element-id="538114"><p id="r-538113" data-claire-element-id="538113">Marquez le début du remplissage de votre liste avec <code data-claire-semantic="c">glNewList() </code>.</p></li><li id="r-538116" data-claire-element-id="538116"><p id="r-538115" data-claire-element-id="538115">Appelez les fonctions OpenGL que vous souhaitez voir stockées dans votre liste (<code data-claire-semantic="c">glVertex*() </code>, <code data-claire-semantic="c">glColor*() </code>, etc.).</p></li><li id="r-538118" data-claire-element-id="538118"><p id="r-538117" data-claire-element-id="538117">Marquez la fin du remplissage de votre liste.</p></li><li id="r-538120" data-claire-element-id="538120"><p id="r-538119" data-claire-element-id="538119">Utilisez votre liste à votre guise (on verra ça plus bas).</p></li><li id="r-538122" data-claire-element-id="538122"><p id="r-538121" data-claire-element-id="538121">Supprimez votre liste lorsque vous êtes sûrs que vous ne vous en servirez plus : pour ce faire, appellez <code data-claire-semantic="c">glDeleteLists() </code>.</p></li></ol><p id="r-538124" data-claire-element-id="538124">Toutes ces indications barbares peuvent se schématiser (j'en profite pour exalter mes talents de graphiste 2D :-° ) :</p><figure id="r-538126" data-claire-element-id="538127"><img id="r-538125" data-claire-element-id="538125" src="medias/uploads.siteduzero.com_files_69001_70000_69068.jpg" alt="Image utilisateur"/></figure><p id="r-538128" data-claire-element-id="538128">Voici un exemple de code complet :</p><pre id="r-538129" data-claire-element-id="538129"><code data-claire-semantic="c">/* voici notre identifiant */
    GLuint list;
    
    /* on cree un objet et on recupere son identifiant */
    list = glGenLists(1);
    if(list == 0)
    {
        fprintf(stderr, &quot;erreur lors de la creation de la liste\n&quot;);
        return (-1); /* ou autre fonction adequate selon la situation */
    }
    
    /* remplissage de notre liste */
    glNewList(list, GL_COMPILE); /* start */
        glBegin(GL_TRIANGLES);
            glColor3f(1.0, 1.0, 1.0); glVertex2f(0.0, 0.9);
            glColor3f(1.0, 0.0, 0.0); glVertex2f(-0.5, 0.3);
            glColor3f(0.0, 1.0, 0.0); glVertex2f(0.5, 0.3);
        glEnd();
        glBegin(GL_QUADS);
            glColor3f(1.0, 0.0, 0.0); glVertex2f(-0.5, -0.8);
            glColor3f(0.0, 1.0, 0.0); glVertex2f(0.5, -0.8);
            glColor3f(0.0, 1.0, 0.0); glVertex2f(0.5, 0.3);
            glColor3f(1.0, 0.0, 0.0); glVertex2f(-0.5, 0.3);
        glEnd();
    glEndList(); /* stop */
    
    /* utilisation ... */
    
    ...
    
    /* quand notre liste n'est plus utilisee, on peut la detruire */
    glDeleteLists(list, 1);</code></pre><p id="r-538130" data-claire-element-id="538130">Ce code n'a pour effet que de stocker les informations de dessin de notre jolie maison dans une display list nommée <em>list</em>.<br/> Ensuite, il détruit l'objet.</p><h5 id="r-construction-structuree" data-claire-element-id="538135">Construction structurée</h5><p id="r-538131" data-claire-element-id="538131">Il est possible d'utiliser des fonctions et des instructions standards dans une liste d'affichage. Et tant mieux, sinon les listes d'affichage n'auraient pas grand intérêt.<br/> Par exemple, ce code est tout à fait correct :</p><pre id="r-538132" data-claire-element-id="538132"><code data-claire-semantic="c">glNewList(list, GL_COMPILE);
    /* positionnement en bas a gauche de l'ecran */
    glTranslatef(-0.5, -0.5, 0.0);
    
    /* changement d'echelle */
    glScalef(0.3, 0.3, 0.3);
    
    for(i=0; i&lt;3; i++)
    {
        glTranslatef(1.0, 1.0, 0.0);
        dessiner_maison();
    }
glEndList();</code></pre><p id="r-538133" data-claire-element-id="538133">Tout est permis dans une liste d'affichage, seules les fonctions OpenGL avec leurs paramètres seront retenues au sein de notre display list.</p><p id="r-538134" data-claire-element-id="538134">Intéressons-nous à présent au rendu de notre liste à l'écran. :)</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
<span class="arrow"></span>
<span class="next">Créer une display list</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
<span class="next">Afficher une display list</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Afficherunedisplaylist"></a><h2>Afficher une display list</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
<span class="arrow"></span>
<span class="next">Remplir une display list</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
<span class="next">Limites des display lists</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-afficher-une-display-list" data-claire-element-id="538158">Afficher une display list</h4><p id="r-538137" data-claire-element-id="538137">Ouf, nous y sommes enfin !<br/> Je pense que le plus dur est fait : à partir de là, ça va couler comme de l'eau de source. :p</p><h5 id="r-rendu-simple" data-claire-element-id="538146">Rendu simple</h5><p id="r-538138" data-claire-element-id="538138">Alors - voyons voir -, nous savons à peu près tout sur les display list, mais on ne sait toujours pas comment faire un rendu. :'( <br/> Rassurez-vous, il n'y a pas 36 façons de procéder ; en réalité, cela se tient en un seul appel de fonction :</p><pre id="r-538139" data-claire-element-id="538139"><code data-claire-semantic="c">void glCallList(GLuint list);</code></pre><div id="r-538141" data-claire-element-id="538141" data-claire-semantic="question"><p id="r-538140" data-claire-element-id="538140">Quoi ?! Toute une sous-partie juste pour nous dévoiler cette fonction (dont j'ai découvert le fonctionnement tout seul comme un grand) ?</p></div><p id="r-538142" data-claire-element-id="538142">Meuh non. :p</p><p id="r-538143" data-claire-element-id="538143">Au cas où certains d'entre vous n'auraient tout de même pas cerné le fonctionnement, je vais mettre un bout de code.<br/> Remplacez les '...' du code vu dans la précédente partie, par ceci :</p><pre id="r-538144" data-claire-element-id="538144"><code data-claire-semantic="c">glCallList(list);</code></pre><p id="r-538145" data-claire-element-id="538145">... et vous verrez une jolie maison se dessiner. :p <br/> Voilà, rien de plus compliqué (pour l'instant).<br/> Cette fonction peut donc s'appeler n'importe quand, à l'instar de notre fonction <em>dessiner_maison()</em>, comme nous allons le voir.</p><h5 id="r-rendus-imbriques" data-claire-element-id="538157">Rendus imbriqués</h5><p id="r-538147" data-claire-element-id="538147">Maintenant que vous maîtrisez la création et l'affichage d'une liste, le code ci-dessous devrait vous paraître relativement simple :</p><pre id="r-538148" data-claire-element-id="538148"><code data-claire-semantic="c">GLuint list2;

/* creation */
list2 = glGenLists(1);

/* imbrication */
glNewList(list2, GL_COMPILE);
    glScalef(0.3, 0.3, 0.3);
    
    glTranslatef(-2.0, -2.0, 0.0);
    glCallList(list);
    
    glTranslatef(4.0, 0.0, 0.0);
    glCallList(list);
    
    glTranslatef(0.0, 4.0, 0.0);
    glCallList(list);
    
    glTranslatef(-4.0, 0.0, 0.0);
    glCallList(list);
glEndList();</code></pre><p id="r-538149" data-claire-element-id="538149">Hé oui, on peut stocker des listes dans des listes. :)</p><p id="r-538150" data-claire-element-id="538150">Cela peut avoir un avantage non négligeable. Imaginez que vous vouliez dessiner plusieurs voitures, elles ont toutes les mêmes roues, mais différentes carrosseries. Il suffit de stocker l'affichage d'une roue dans une display list, l'affichage des différentes carrosseries dans d'autres, puis, pour afficher les voitures tout entières, vous n'aurez qu'à construire une liste par voiture qui contiendra l'imbrication de quatre appels à la liste d'une roue, avec modifications matricielles entre ceux-ci afin de positionner les roues correctement par rapport à votre carrosserie, que vous dessinerez ensuite (ou avant, aucune importance).</p><p id="r-538151" data-claire-element-id="538151">Comme vous le voyez, les display lists acceptent également le stockage de fonctions de manipulation des matrices OpenGL.<br/> Attention toutefois, je n'ai fait aucune sauvegarde de la matrice (<code data-claire-semantic="c">glPushMatrix() </code> / <code data-claire-semantic="c">glPopMatrix() </code>) à l'intérieur de la display list ; pensez donc à le faire, soit dans la display list, soit dans le code de rendu, comme ceci :</p><pre id="r-538152" data-claire-element-id="538152"><code data-claire-semantic="c">glPushMatrix();
    glCallList(list2);
glPopMatrix();</code></pre><p id="r-538153" data-claire-element-id="538153">Et le résultat en image, de nos quatre maisons ainsi dessinées :</p><figure id="r-538155" data-claire-element-id="538156"><img id="r-538154" data-claire-element-id="538154" src="medias/uploads.siteduzero.com_files_69001_70000_69065.jpg" alt="Image utilisateur"/></figure>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
<span class="arrow"></span>
<span class="next">Remplir une display list</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
<span class="next">Limites des display lists</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Limitesdesdisplaylists"></a><h2>Limites des display lists</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
<span class="arrow"></span>
<span class="next">Afficher une display list</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">
<span class="next">Les vertex arrays</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-limites-des-display-lists" data-claire-element-id="538169">Limites des display lists</h4><p id="r-538159" data-claire-element-id="538159">Les display lists constituent la méthode de rendu la plus rapide avec OpenGL.<br/> En effet, les informations de rendu sont stockées de façon intelligente en un code binaire lisible très rapidement par OpenGL, qui peut ainsi l'envoyer de manière efficace et quasi-instantanée au pilote graphique.<br/> Cependant, elles ont quelques défauts, et sont très peu, voir pas du tout utilisées dans les applications 3D récentes.</p><p id="r-538160" data-claire-element-id="538160">Pourquoi, me direz-vous ?</p><p id="r-538161" data-claire-element-id="538161">Premièrement, il est impossible de mettre à jour le contenu d'une display list, une display list créée n'est pas modifiable. Cela pose problème lors d'un rendu animé, comme pour un personnage par exemple.<br/> Il est possible d'utiliser les display lists avec un rendu animé, la seule solution est de supprimer (<code data-claire-semantic="c">glDeleteLists() </code>) puis de recréer la liste avec les nouvelles données, mais cette opération est très lourde et coûte beaucoup en ressources, elle n'est donc pas utilisée.</p><p id="r-538162" data-claire-element-id="538162">Les display lists sont en revanche très adaptées pour n'importe quel rendu statique (terrain, bâtiment, ...) : ne vous en privez donc surtout pas si vous avez une scène comportant des objets statiques. ;) <br/> Gardez également à l'esprit que les modifications matricielles appelées en dehors ou à l'intérieur d'un <code data-claire-semantic="c">glCallList() </code> sont appliquées sur <strong>tout</strong> ce que vous dessinerez ensuite, y compris les listes d'affichage ; donc si votre animation se résume à un simple déplacement, les display lists sont également appropriées.</p><p id="r-538163" data-claire-element-id="538163">Malgré tout, aucun jeu récent ne s'en sert pour afficher un terrain : avec la constante évolution des machines, les moteurs physiques permettent de plus en plus d'interactions avec le monde environnant, et cela implique une modification de la géométrie, ce que ne supportent pas les display lists.<br/> Les display lists n'existent pas sous DirectX, ce qui explique aussi leur absence fréquente (voire permanente) puisque DirectX est la bibliothèque multimédia la plus utilisée pour les jeux.</p><p id="r-538164" data-claire-element-id="538164">Dernière chose, de par leur géométrie statique, aucune optimisation de scène (frustum culling, octrees, ...) n'est très possible sur un <em>mesh</em> (traduisez par maillage) stocké dans une display list.</p><p id="r-538165" data-claire-element-id="538165">Voilà, le premier chapitre est terminé.</p><p id="r-538166" data-claire-element-id="538166">Pour clore ce chapitre, je dirais que si vous avez l'occasion de vous servir des display lists, ne vous en privez pas, j'ai eu les meilleurs FPS (Frames Per Second) avec ces dernières.<br/> Elles sont également très utilisées pour réaliser des exemples de code, car elles permettent d'alléger facilement et rapidement un code d'exemple OpenGL, ce qui a pour effet de faciliter sa compréhension (pour un tuto par exemple ;) ).</p><p id="r-538167" data-claire-element-id="538167">Pour plus d'informations, je vous suggère d'aller consulter <a href="http://www.opengl.org/resources/faq/technical/displaylist.htm">la FAQ Display Lists</a> du site d'OpenGL.</p><p id="r-538168" data-claire-element-id="538168">Je vous invite à présent à venir voir le second chapitre de ce tutoriel, qui montre une façon moins optimisée et plus difficile à appréhender, mais beaucoup plus flexible, de procéder à un rendu de polygones.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
<span class="arrow"></span>
<span class="next">Afficher une display list</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">
<span class="next">Les vertex arrays</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesvertexarrays"></a><h2>Les vertex arrays</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
<span class="arrow"></span>
<span class="next">Limites des display lists</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
<span class="next">Fonctionnement</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-538171" data-claire-element-id="538171">Allez, on enchaîne avec les vertex arrays.</p><p id="r-538172" data-claire-element-id="538172">Nous allons tout d'abord voir ce que représentent ces &quot;vertex arrays&quot; si intrigants, puis je vous expliquerai leur fonctionnement et vous montrerai des exemples d'utilisation au sein d'un programme OpenGL.<br/> Ce chapitre est essentiel pour la compréhension du suivant, lisez-le donc attentivement. ;)</p>
</div><a name="Fonctionnement"></a><h2>Fonctionnement</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">
<span class="arrow"></span>
<span class="next">Les vertex arrays</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
<span class="next">Spécification de tableaux</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-fonctionnement-32" data-claire-element-id="538226">Fonctionnement</h4><p id="r-538173" data-claire-element-id="538173">Les Vertex Arrays sont loin de s'apparenter aux display lists que nous avons vus dans le chapitre précédent.</p><p id="r-538174" data-claire-element-id="538174">En effet, comme leur nom l'indique, il s'agit de <strong>tableaux de sommets</strong>.</p><div id="r-538176" data-claire-element-id="538176" data-claire-semantic="question"><p id="r-538175" data-claire-element-id="538175">Qu'est-ce qu'un &quot;sommet&quot; ?</p></div><p id="r-538177" data-claire-element-id="538177">Un sommet est un ensemble de données. Voici de quoi est composé <strong>un</strong> sommet :</p><ul id="r-538210" data-claire-element-id="538210"><li id="r-538179" data-claire-element-id="538179"><p id="r-538178" data-claire-element-id="538178">une position (<code data-claire-semantic="c">glVertex*() </code>) ;</p></li><li id="r-538181" data-claire-element-id="538181"><p id="r-538180" data-claire-element-id="538180">une normale (<code data-claire-semantic="c">glNormal*() </code>) ;</p></li><li id="r-538183" data-claire-element-id="538183"><p id="r-538182" data-claire-element-id="538182">une couleur (<code data-claire-semantic="c">glColor*() </code>) ;</p></li><li id="r-538185" data-claire-element-id="538185"><p id="r-538184" data-claire-element-id="538184">une couleur secondaire (<code data-claire-semantic="c">glSecondaryColor*() </code>) ;</p></li><li id="r-538187" data-claire-element-id="538187"><p id="r-538186" data-claire-element-id="538186">un indicateur de contour (<code data-claire-semantic="c">glEdgeFlag*() </code>) ;</p></li><li id="r-538189" data-claire-element-id="538189"><p id="r-538188" data-claire-element-id="538188">des coordonnées pour l'unité de texture 0 (<code data-claire-semantic="c">glTexCoord*() </code>) ;</p></li><li id="r-538191" data-claire-element-id="538191"><p id="r-538190" data-claire-element-id="538190">coordonnées de texture 1 (<code data-claire-semantic="c">glTexCoord*() </code>) ;</p></li><li id="r-538193" data-claire-element-id="538193"><p id="r-538192" data-claire-element-id="538192">coordonnées de texture 2 (<code data-claire-semantic="c">glTexCoord*() </code>) ;</p></li><li id="r-538195" data-claire-element-id="538195"><p id="r-538194" data-claire-element-id="538194">coordonnées de texture 3 (<code data-claire-semantic="c">glTexCoord*() </code>) ;</p></li><li id="r-538197" data-claire-element-id="538197"><p id="r-538196" data-claire-element-id="538196">coordonnées de texture 4 (<code data-claire-semantic="c">&lt;italique&gt;&lt;/italique&gt; </code>) ;</p></li><li id="r-538199" data-claire-element-id="538199"><p id="r-538198" data-claire-element-id="538198">coordonnées de texture 5 (<code data-claire-semantic="c">glTexCoord*() </code>) ;</p></li><li id="r-538201" data-claire-element-id="538201"><p id="r-538200" data-claire-element-id="538200">coordonnées de texture 6 (<code data-claire-semantic="c">glTexCoord*() </code>) ;</p></li><li id="r-538203" data-claire-element-id="538203"><p id="r-538202" data-claire-element-id="538202">coordonnées de texture 7 (<code data-claire-semantic="c">glTexCoord*() </code>) ;</p></li><li id="r-538205" data-claire-element-id="538205"><p id="r-538204" data-claire-element-id="538204">coordonnées de texture 8 (<code data-claire-semantic="c">glTexCoord*() </code>), ... ;</p></li><li id="r-538207" data-claire-element-id="538207"><p id="r-538206" data-claire-element-id="538206">attribut de sommet 0 (<code data-claire-semantic="c">glVertexAttrib*() </code>) ;</p></li><li id="r-538209" data-claire-element-id="538209"><p id="r-538208" data-claire-element-id="538208">attribut de sommet 1, ...</p></li></ul><aside id="r-538212" data-claire-element-id="538212" data-claire-semantic="information"><p id="r-538211" data-claire-element-id="538211">Je ne donnerai volontairement pas l'explication de l'utilité de chacun de ces types de données, cela n'a pas de rapport avec le sujet traité ici. Vous en connaissez déjà certains, comme les coordonnées de texture, les positions de sommet et leur couleur.</p></aside><p id="r-538213" data-claire-element-id="538213">Sommet se traduit par <em>vertex</em> en anglais.<br/> Un vertex <strong>ne représente pas</strong>, contrairement à ce que l'on pourrait croire, des coordonnées dans l'espace, le nom donné à la fonction <code data-claire-semantic="c">glVertex*() </code> induit en erreur.<br/> La fonction <code data-claire-semantic="c">glVertex*() </code> a pour effet de valider la création d'un sommet, dont les attributs seront les valeurs précédemment envoyées aux fonctions <code data-claire-semantic="c">glTexCoord*() </code> et compagnie, avec les coordonnées spatiales du sommet. Étant donné que les coordonnées spatiales sont les informations minimales nécessaires à la création d'un sommet, le nom donné à la fonction <code data-claire-semantic="c">glVertex*() </code> est compréhensible (mais nécessite une explication ;) ).</p><p id="r-538214" data-claire-element-id="538214">Les attributs de sommet (vus à la fin de la liste ci-dessus : <code data-claire-semantic="c">glVertexAttrib*() </code>) se prolongent jusqu'à une limite, dépendant de votre implémentation d'OpenGL.<br/> Comme toutes les limites, il est possible de la connaître. Envoyez le paramètre <code data-claire-semantic="c">GL_MAX_VERTEX_ATTRIBS </code> à <code data-claire-semantic="c">glGetIntegerv() </code> pour connaître le nombre maximum d'attributs qu'accepte votre carte graphique pour un sommet.</p><pre id="r-538215" data-claire-element-id="538215"><code data-claire-semantic="c">int max_attribs;
glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;max_attribs);</code></pre><p id="r-538216" data-claire-element-id="538216">Les coordonnées de texture ne se limitent pas toujours à 8, cela dépend du nombre maximum d'unités de textures supporté par votre carte graphique. Envoyez <code data-claire-semantic="c">GL_MAX_TEXTURES_UNITS_ARB </code> à <code data-claire-semantic="c">glGetIntegerv() </code> pour connaître cette limite.</p><p id="r-538217" data-claire-element-id="538217">Bien, maintenant que les présentations sont faites, passons au vif du sujet.<br/> Allez-y, posez-moi la question cruciale. :p</p><div id="r-538219" data-claire-element-id="538219" data-claire-semantic="question"><p id="r-538218" data-claire-element-id="538218">Qu'est-ce qu'un vertex array ?</p></div><p id="r-538220" data-claire-element-id="538220">Un tableau. :)</p><pre id="r-538221" data-claire-element-id="538221"><code data-claire-semantic="c">float vertices[NB];</code></pre><aside id="r-538223" data-claire-element-id="538223" data-claire-semantic="information"><p id="r-538222" data-claire-element-id="538222">Attention donc, si vous ne maîtrisez pas la partie du <a href="http://www.siteduzero.com/tuto-3-8-0-apprenez-a-programmer-en-c-c.html">cours de M@teo21</a> sur les <a href="http://www.siteduzero.com/tuto-3-4086-1-les-tableaux.html">tableaux</a>ET<a href="http://www.siteduzero.com/tuto-3-3828-1-a-l-assaut-des-pointeurs.html">les pointeurs</a>, vous risquez d'avoir du mal à comprendre ce chapitre.</p></aside><p id="r-538224" data-claire-element-id="538224">L'idée est en fait de stocker nos données dans des tableaux, puis de donner ceux-ci à manger à OpenGL pour qu'il se débrouille avec. Il faudra cependant (et logiquement) donner des instructions à OpenGL sur la nature de nos données afin qu'il puisse les utiliser convenablement et comme on l'entend.</p><p id="r-538225" data-claire-element-id="538225">Avec <code data-claire-semantic="c">glVertex*() </code>, <code data-claire-semantic="c">glColor*() </code>, <code data-claire-semantic="c">glTexCoord*() </code> et compagnie, on envoie les données une par une, et chaque envoi nécessite un appel de fonction ; cette méthode est extrêmement lourde et peu flexible. L'envoi de données par tableaux est beaucoup plus efficace comme nous allons le voir. ;)</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">
<span class="arrow"></span>
<span class="next">Les vertex arrays</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
<span class="next">Spécification de tableaux</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Spcificationdetableaux"></a><h2>Spécification de tableaux</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
<span class="arrow"></span>
<span class="next">Fonctionnement</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
<span class="next">Effectuer un rendu</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-specification-de-tableaux" data-claire-element-id="538452">Spécification de tableaux</h4><p id="r-538227" data-claire-element-id="538227">Comme je l'ai dit, l'envoi des données se fait par le biais de tableaux.<br/> Cela permet de maintenir nos données à jour facilement, puisque dorénavant il suffira de modifier nos tableaux et les modifications lors du rendu seront immédiatement appliquées.</p><p id="r-538228" data-claire-element-id="538228">Cette fois-ci, aucun objet OpenGL n'est à manipuler comme avec les display lists, tout se passe dans une relation client / serveur très étroite.</p><h5 id="r-la-relation-client-serveur" data-claire-element-id="538233">La relation client / serveur</h5><h6 id="r-le-client-3" data-claire-element-id="538230">Le client</h6><p id="r-538229" data-claire-element-id="538229">C'est vous. :p <br/> Vos instructions représentent généralement celles effectuées côté client, c'est-à-dire au niveau du CPU et de la mémoire centrale (RAM).<br/> Vous êtes donc le client... mais le client de qui ? o_O</p><h6 id="r-le-serveur-5" data-claire-element-id="538232">Le serveur</h6><p id="r-538231" data-claire-element-id="538231">Dans un programme OpenGL, le serveur représente la carte graphique.<br/> En effet, vous êtes son client : autrement dit, vous lui donnez des instructions pour afficher des choses à l'écran. OpenGL n'est rien d'autre qu'une passerelle entre vous et le driver graphique. C'est par le biais d'OpenGL que vous allez interagir avec votre carte graphique.</p><h5 id="r-les-vertex-arrays-des-donnees-cote-client" data-claire-element-id="538371">Les vertex arrays, des données côté client</h5><p id="r-538234" data-claire-element-id="538234">Les données sont de votre côté puisque vous définissez vos tableaux comme ceci :</p><pre id="r-538235" data-claire-element-id="538235"><code data-claire-semantic="c">float *data = malloc(sizeof *data * NB);</code></pre><aside id="r-538237" data-claire-element-id="538237" data-claire-semantic="information"><p id="r-538236" data-claire-element-id="538236">Nous verrons dans le prochain chapitre pourquoi et comment traiter nos données côté serveur.</p></aside><p id="r-538238" data-claire-element-id="538238">Nous allons commencer par gérer les données côté client, d'une part parce que c'est plus simple, et d'autre part parce que cela constitue une étape indispensable pour passer au chapitre suivant.</p><p id="r-538239" data-claire-element-id="538239">La construction d'un vertex array prêt à être dessiner peut se décomposer en 3 étapes :</p><ul id="r-538246" data-claire-element-id="538246"><li id="r-538241" data-claire-element-id="538241"><p id="r-538240" data-claire-element-id="538240">la création de nos données. Cette étape n'a lieu qu'une seule fois pour tous les rendus. Les données sont généralement récupérées à partir d'un fichier ;</p></li><li id="r-538243" data-claire-element-id="538243"><p id="r-538242" data-claire-element-id="538242">l'activation des tableaux de sommets. On indique à OpenGL qu'on souhaite lui envoyer des données qui sont sous forme d'un tableau côté client ;</p></li><li id="r-538245" data-claire-element-id="538245"><p id="r-538244" data-claire-element-id="538244">la spécification explicite de l'emplacement de nos données via leur(s) adresse(s) mémoire.</p></li></ul><h6 id="r-creation-recuperation-de-donnees" data-claire-element-id="538251">Création / récupération de données</h6><p id="r-538247" data-claire-element-id="538247">Nous allons commencer simplement.<br/> Si vous arrivez à bien comprendre le fonctionnement des vertex arrays, il sera facile pour vous ensuite de créer votre propre chargeur de fichiers 3D. Il existe de nombreux formats, les plus simples étant les fichiers textes, tels .obj ou .ase, les plus complexes étant souvent en binaire et comportant pleins d'informations (lumières, caméras, ...) tels .3ds, pour 3D Studio Max, ou encore .blend pour Blender.</p><p id="r-538248" data-claire-element-id="538248">En attendant, nos données seront statiques et déclarées sous forme d'un simple tableau au sein même de notre programme.<br/> Voici le tableau qui définira la position de nos sommets (<code data-claire-semantic="c">glVertex*() </code>) :</p><pre id="r-538249" data-claire-element-id="538249"><code data-claire-semantic="c">#define N_VERTS 4
#define V_SIZE 2

float vertices[N_VERTS*V_SIZE] =
{
    -0.8, -0.8,  /* sommet 0 */
    0.8, -0.8,   /* sommet 1 */
    0.8, 0.8,    /* sommet 2 */
    -0.8, 0.8    /* sommet 3 */
};</code></pre><p id="r-538250" data-claire-element-id="538250">Si vous commencez à y voir déjà un peu plus clair à la lecture de ce code, c'est bon signe, sinon, patientez, il faut attendre de tout connaître pour bien comprendre le principe des vertex arrays, qui n'est pas si simple. ;)</p><h6 id="r-activation-des-tableaux-cote-client" data-claire-element-id="538270">Activation des tableaux côté client</h6><p id="r-538252" data-claire-element-id="538252">Seconde étape.<br/> Ici, rien de bien méchant, on va juste dire à OpenGL que l'on souhaite pouvoir lui envoyer des données via des tableaux.<br/> On va commencer par activer simplement les tableaux des positions de sommet :</p><pre id="r-538253" data-claire-element-id="538253"><code data-claire-semantic="c">glEnableClientState(GL_VERTEX_ARRAY);</code></pre><p id="r-538254" data-claire-element-id="538254">Ici on peut retrouver le principe de fonctionnement d'OpenGL avec le nom de la fonction appelée : <code data-claire-semantic="c">glEnable </code><code data-claire-semantic="c"><strong>Client </strong></code><code data-claire-semantic="c">State() </code>. Son paramètre désigne le type des données que l'on souhaite activer, <code data-claire-semantic="c">GL_VERTEX_ARRAY </code> désigne les positions de sommet.</p><p id="r-538255" data-claire-element-id="538255">Voici la liste des types de tableaux qui peuvent être activés via <code data-claire-semantic="c">glEnableClientState() </code> :</p><ul id="r-538268" data-claire-element-id="538268"><li id="r-538257" data-claire-element-id="538257"><p id="r-538256" data-claire-element-id="538256"><code data-claire-semantic="c">GL_VERTEX_ARRAY </code> : positions de sommet (<code data-claire-semantic="c">glVertex*() </code>) ;</p></li><li id="r-538259" data-claire-element-id="538259"><p id="r-538258" data-claire-element-id="538258"><code data-claire-semantic="c">GL_NORMAL_ARRAY </code> : normales de sommet (<code data-claire-semantic="c">glNormal*() </code>) ;</p></li><li id="r-538261" data-claire-element-id="538261"><p id="r-538260" data-claire-element-id="538260"><code data-claire-semantic="c">GL_TEXTURE_COORD_ARRAY </code> : coordonnées de texture des sommets (<code data-claire-semantic="c">glTexCoord*() </code>) ;</p></li><li id="r-538263" data-claire-element-id="538263"><p id="r-538262" data-claire-element-id="538262"><code data-claire-semantic="c">GL_COLOR_ARRAY </code> : couleurs de sommet (<code data-claire-semantic="c">glColor*() </code>) ;</p></li><li id="r-538265" data-claire-element-id="538265"><p id="r-538264" data-claire-element-id="538264"><code data-claire-semantic="c">GL_INDEX_ARRAY </code> : couleurs indexées (quasi-obsolète, les couleurs en mode indexées ne sont plus utilisées en 3D moderne, la puissance des cartes graphique nous permet d'oublier ces subtilités) ;</p></li><li id="r-538267" data-claire-element-id="538267"><p id="r-538266" data-claire-element-id="538266"><code data-claire-semantic="c">GL_EDGE_FLAG_ARRAY </code> : indicateur de contour (<code data-claire-semantic="c">glEdgeFlag*() </code>).</p></li></ul><p id="r-538269" data-claire-element-id="538269">Une fois que vous aurez activé les types de tableaux que vous souhaitez envoyer à OpenGL pour le rendu, vous pouvez passer à l'étape suivante. :)</p><h6 id="r-specification-des-donnees" data-claire-element-id="538370">Spécification des données</h6><p id="r-538271" data-claire-element-id="538271">Nous voici arrivés à l'étape la plus rigolote mais aussi, et surtout, la moins facile.<br/> Résumons, histoire d'y voir un peu plus clair.<br/> Nous avons nos données, si vous avez pris la peine de les examiner, vous aurez constaté qu'elles constituent un simple carré. Nous avons également activé un état OpenGL pour dire qu'on souhaite lui envoyer des données qui se trouvent côté client.</p><p id="r-538272" data-claire-element-id="538272">Bien, je crois qu'un code complet s'impose :</p><pre id="r-538273" data-claire-element-id="538273"><code data-claire-semantic="c">#include &lt;stdio.h&gt;
#include &lt;SDL/SDL.h&gt;
#include &lt;GL/gl.h&gt;

/* dimensions de la fenetre */
#define W 640
#define H 480

/* initialise opengl */
void init_gl(void);


int main(int argc, char **argv)
{
    int loop = 1;       /* booleen du 'main loop' */
    SDL_Event ev;       /* structure d'evenement(s) SDL */
    
    #define N_VERTS 4
    #define V_SIZE 2
    
    /* nos donnees */
    float vertices[N_VERTS*V_SIZE] =
    {
        -0.8, -0.8,  /* sommet 0 */
        0.8, -0.8,   /* sommet 1 */
        0.8, 0.8,    /* sommet 2 */
        -0.8, 0.8    /* sommet 3 */
    };
    
    
    /* initialisation de la SDL en mode OpenGL */
    SDL_Init(SDL_INIT_VIDEO);
    SDL_SetVideoMode(W, H, 32, SDL_OPENGL);
    
    /* nom de la fenetre */
    SDL_WM_SetCaption(&quot;Vertex Arrays GL&quot;, NULL);
    
    /* initialisation d'opengl */
    init_gl();
    
    /* boucle d'affichage principale */
    while(loop)
    {
        /* recuperation d'un evenement */
        SDL_WaitEvent(&amp;ev);
        
        /* analyse */
        switch(ev.type)
        {
            case SDL_QUIT:
                loop = 0;
                break;
            
            default:;
        }
        
        glClear(GL_COLOR_BUFFER_BIT);
        
        /* activation des tableaux de donnees */
        glEnableClientState(GL_VERTEX_ARRAY);
        
        /* dessin ... a venir */
        
        /* on flip les tampons */
        glFlush();
        SDL_GL_SwapBuffers();
    }
    
    return 0;
}


void init_gl(void)
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}</code></pre><p id="r-538274" data-claire-element-id="538274">Vous pouvez compiler et exécuter ce code, vous verrez c'est passionnant : il ne se passe rien. :p</p><p id="r-538275" data-claire-element-id="538275">Bon, fini de rire ! :diable: Passons aux choses sérieuses.</p><p id="r-538276" data-claire-element-id="538276">Nous voulons donc envoyer nos données au serveur.<br/> Pour cela, nous avons plusieurs fonctions, chacune destinée à un type de données en particulier. Voici un prototype de base (fonction utilisée pour envoyer la position des sommets) :</p><pre id="r-538277" data-claire-element-id="538277"><code data-claire-semantic="c">void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *data);</code></pre><ul id="r-538286" data-claire-element-id="538286"><li id="r-538279" data-claire-element-id="538279"><p id="r-538278" data-claire-element-id="538278"><code data-claire-semantic="c"><strong>size </strong></code> : représente le nombre de variables dans un groupe de données. Dans notre cas, nos positions de sommets sont en 2D, elles comprennent donc 2 variables. J'ai défini la macro <code data-claire-semantic="c">V_SIZE </code> à cette valeur comme vous avez pu le voir.</p></li><li id="r-538281" data-claire-element-id="538281"><p id="r-538280" data-claire-element-id="538280"><code data-claire-semantic="c"><strong>type </strong></code> : ça, c'est le type de nos variables. Dans notre cas, il s'agit de <code data-claire-semantic="c">GL_FLOAT </code>.</p></li><li id="r-538283" data-claire-element-id="538283"><p id="r-538282" data-claire-element-id="538282"><code data-claire-semantic="c"><strong>stride </strong></code> : paramètre qui, à première vue, ne peut servir qu'à déstabiliser le néophyte. :-° Cette valeur représente le décalage en bytes entre deux groupes de données. Si nos données se suivent dans notre tableau, nous placerons cette valeur à 0.</p></li><li id="r-538285" data-claire-element-id="538285"><p id="r-538284" data-claire-element-id="538284"><code data-claire-semantic="c"><strong>data </strong></code> : c'est notre tableau. :)</p></li></ul><p id="r-538287" data-claire-element-id="538287">Voici les prototypes des autres fonctions, les paramètres sont similaires, et parfois même il y en a moins :</p><pre id="r-538288" data-claire-element-id="538288"><code data-claire-semantic="c">void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *data);

void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *data);

void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *data);

void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *data);

void glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *data);

void glEdgeFlagPointer(GLsizei stride, const GLvoid *data);</code></pre><p id="r-538289" data-claire-element-id="538289">Vous l'aurez peut-être remarqué, chaque fonction correspond à une des constantes énumérées plus haut (<code data-claire-semantic="c">GL_VERTEX_ARRAY </code>, etc.).<br/> Ci-dessous, les spécialisations de chaque fonction. En effet, certaines sont capricieuses sur certains paramètres :</p><table id="r-538348" data-claire-element-id="538348"><thead id="r-538297" data-claire-element-id="538297"><tr id="r-538296" data-claire-element-id="538296"><th id="r-538291" data-claire-element-id="538291"><p id="r-538290" data-claire-element-id="538290">Fonction</p></th><th id="r-538293" data-claire-element-id="538293"><p id="r-538292" data-claire-element-id="538292">Valeurs acceptables pour <code data-claire-semantic="c">size</code></p></th><th id="r-538295" data-claire-element-id="538295"><p id="r-538294" data-claire-element-id="538294">Valeurs acceptables pour <code data-claire-semantic="c">type</code></p></th></tr></thead><tbody id="r-538347" data-claire-element-id="538347"><tr id="r-538304" data-claire-element-id="538304"><td id="r-538299" data-claire-element-id="538299"><p id="r-538298" data-claire-element-id="538298"><code data-claire-semantic="c">glEdgeFlagPointer</code></p></td><td id="r-538301" data-claire-element-id="538301"><p id="r-538300" data-claire-element-id="538300">1</p></td><td id="r-538303" data-claire-element-id="538303"><p id="r-538302" data-claire-element-id="538302">pas d'argument, le type doit être <code data-claire-semantic="c">GLboolean</code></p></td></tr><tr id="r-538311" data-claire-element-id="538311"><td id="r-538306" data-claire-element-id="538306"><p id="r-538305" data-claire-element-id="538305"><code data-claire-semantic="c">glFogCoordPointer</code></p></td><td id="r-538308" data-claire-element-id="538308"><p id="r-538307" data-claire-element-id="538307">1</p></td><td id="r-538310" data-claire-element-id="538310"><p id="r-538309" data-claire-element-id="538309"><code data-claire-semantic="c">GL_FLOAT </code>, <code data-claire-semantic="c">GL_DOUBLE</code></p></td></tr><tr id="r-538318" data-claire-element-id="538318"><td id="r-538313" data-claire-element-id="538313"><p id="r-538312" data-claire-element-id="538312"><code data-claire-semantic="c">glTexCoordPointer</code></p></td><td id="r-538315" data-claire-element-id="538315"><p id="r-538314" data-claire-element-id="538314">1, 2, 3, 4</p></td><td id="r-538317" data-claire-element-id="538317"><p id="r-538316" data-claire-element-id="538316"><code data-claire-semantic="c">GL_SHORT </code>, <code data-claire-semantic="c">GL_INT </code>, <code data-claire-semantic="c">GL_FLOAT </code>, <code data-claire-semantic="c">GL_DOUBLE</code></p></td></tr><tr id="r-538325" data-claire-element-id="538325"><td id="r-538320" data-claire-element-id="538320"><p id="r-538319" data-claire-element-id="538319"><code data-claire-semantic="c">glNormalPointer</code></p></td><td id="r-538322" data-claire-element-id="538322"><p id="r-538321" data-claire-element-id="538321">3</p></td><td id="r-538324" data-claire-element-id="538324"><p id="r-538323" data-claire-element-id="538323"><code data-claire-semantic="c">GL_BYTE </code>, <code data-claire-semantic="c">GL_SHORT </code>, <code data-claire-semantic="c">GL_INT </code>, <code data-claire-semantic="c">GL_FLOAT </code>, <code data-claire-semantic="c">GL_DOUBLE</code></p></td></tr><tr id="r-538332" data-claire-element-id="538332"><td id="r-538327" data-claire-element-id="538327"><p id="r-538326" data-claire-element-id="538326"><code data-claire-semantic="c">glIndexPointer</code></p></td><td id="r-538329" data-claire-element-id="538329"><p id="r-538328" data-claire-element-id="538328">1</p></td><td id="r-538331" data-claire-element-id="538331"><p id="r-538330" data-claire-element-id="538330"><code data-claire-semantic="c">GL_UNSIGNED_BYTE </code>, <code data-claire-semantic="c">GL_SHORT </code>, <code data-claire-semantic="c">GL_INT </code>, <code data-claire-semantic="c">GL_FLOAT </code>, <code data-claire-semantic="c">GL_DOUBLE</code></p></td></tr><tr id="r-538339" data-claire-element-id="538339"><td id="r-538334" data-claire-element-id="538334"><p id="r-538333" data-claire-element-id="538333"><code data-claire-semantic="c">glColorPointer</code></p></td><td id="r-538336" data-claire-element-id="538336"><p id="r-538335" data-claire-element-id="538335">3, 4</p></td><td id="r-538338" data-claire-element-id="538338"><p id="r-538337" data-claire-element-id="538337"><code data-claire-semantic="c">GL_BYTE </code>, <code data-claire-semantic="c">GL_UNSIGNED_BYTE </code>, <code data-claire-semantic="c">GL_SHORT </code>, <code data-claire-semantic="c">GL_UNSIGNED_SHORT </code>,<br/><code data-claire-semantic="c">GL_INT </code>, <code data-claire-semantic="c">GL_UNSIGNED_INT </code>, <code data-claire-semantic="c">GL_FLOAT </code>, <code data-claire-semantic="c">GL_DOUBLE</code></p></td></tr><tr id="r-538346" data-claire-element-id="538346"><td id="r-538341" data-claire-element-id="538341"><p id="r-538340" data-claire-element-id="538340"><code data-claire-semantic="c">glVertexPointer</code></p></td><td id="r-538343" data-claire-element-id="538343"><p id="r-538342" data-claire-element-id="538342">2, 3, 4</p></td><td id="r-538345" data-claire-element-id="538345"><p id="r-538344" data-claire-element-id="538344"><code data-claire-semantic="c">GL_SHORT </code>, <code data-claire-semantic="c">GL_INT </code>, <code data-claire-semantic="c">GL_FLOAT </code>, <code data-claire-semantic="c">GL_DOUBLE</code></p></td></tr></tbody></table><aside id="r-538350" data-claire-element-id="538350" data-claire-semantic="warning"><p id="r-538349" data-claire-element-id="538349">Il est <strong>impératif</strong> de respecter les mille et un désirs de ces dames nos fonctions ! Sinon il se produira des résultat indéterminés, et généralement pas très triviaux... Veillez à respecter ce tableau.</p></aside><p id="r-538351" data-claire-element-id="538351">Dans notre cas, nous aurons juste besoin de <code data-claire-semantic="c">glVertexPointer( </code>, puisque nous avons décidé de n'envoyer que les positions des sommets. Nous allons donc rajouter ceci dans notre code :</p><pre id="r-538352" data-claire-element-id="538352"><code data-claire-semantic="c">glVertexPointer(V_SIZE, GL_FLOAT, 0, vertices);</code></pre><div id="r-538354" data-claire-element-id="538354" data-claire-semantic="question"><p id="r-538353" data-claire-element-id="538353">Et on ne spécifie pas la taille que fait le tableau <code data-claire-semantic="c">vertices </code> ? À savoir, <code data-claire-semantic="c">N_VERTS </code> ?</p></div><p id="r-538355" data-claire-element-id="538355">Non. ^^ <br/> La raison est simple et évidente, et vous allez voir pourquoi lors de la prochaine sous-partie concernant le rendu.</p><p id="r-538356" data-claire-element-id="538356">Vous l'aurez sans doute remarqué, il n'existe qu'une seule fonction pour envoyer des coordonnées de texture (<code data-claire-semantic="c">glTexCoordPointer() </code>). Pour le multi-texturing, nous allons utiliser <code data-claire-semantic="c">glClientActiveTexture() </code> qui définit l'unité de texturage qui sera affectée par le prochain appel à <code data-claire-semantic="c">glTexCoordPointer() </code> :</p><pre id="r-538357" data-claire-element-id="538357"><code data-claire-semantic="c">void glClientActiveTexture(GLenum unit);</code></pre><ul id="r-538360" data-claire-element-id="538360"><li id="r-538359" data-claire-element-id="538359"><p id="r-538358" data-claire-element-id="538358"><code data-claire-semantic="c"><strong>unit </strong></code> : constante symbolique représentant l'unité de texturage à activer.</p></li></ul><p id="r-538361" data-claire-element-id="538361">Voici un exemple :</p><pre id="r-538362" data-claire-element-id="538362"><code data-claire-semantic="c">glClientActiveTexture(GL_TEXTURE0);
glTexCoordPointer( ... ); /* envoie les coordonnees pour l'unite de texture 0 */

glClientActiveTexture(GL_TEXTURE0 + 4);
glTexCoordPointer( ... ); /* envoie les coordonnees pour l'unite de texture 4 */</code></pre><p id="r-538363" data-claire-element-id="538363">Deux choses sont à retenir :</p><ol id="r-538368" data-claire-element-id="538368"><li id="r-538365" data-claire-element-id="538365"><p id="r-538364" data-claire-element-id="538364">par défaut, l'unité de texturage active est 0, le premier appel dans mon exemple de code est donc théoriquement inutile, à moins qu'il y ait déjà eu un précédent appel à <code data-claire-semantic="c">glClientActiveTexture() </code> ;</p></li><li id="r-538367" data-claire-element-id="538367"><p id="r-538366" data-claire-element-id="538366"><code data-claire-semantic="c">GL_TEXTURE0 </code>représente l'unité de texture 0, <code data-claire-semantic="c">GL_TEXTURE1 </code> l'unité 1, etc. jusqu'au nombre maximal d'unités de textures que votre matériel supporte (nous l'avons vu plus haut). Cependant, OpenGL a conçu ses constantes de façon à ce que vous puissiez procéder comme dans mon exemple, ce qui est un gain de temps et de lignes de code.</p></li></ol><p id="r-538369" data-claire-element-id="538369">Bien, je crois que nous avons passé en revue les 3 étapes de la création d'un vertex array. :) Intéressons-nous maintenant de plus près à ces fonctions <code data-claire-semantic="c">gl*Pointer() </code>, car leur fonctionnement n'est pas si simple et nécessite quelques explications.</p><h5 id="r-des-donnees-structurees" data-claire-element-id="538451">Des données structurées</h5><p id="r-538372" data-claire-element-id="538372">Il est important de comprendre avec exactitude l'effet des paramètres envoyés à <code data-claire-semantic="c">gl*Pointer() </code>, car ils constituent la définition même de la structure de nos données, je vous ai gratifiés pour cela de quelques schémas dont j'ai le secret de la qualité graphique. :-°</p><figure id="r-538374" data-claire-element-id="538375"><img id="r-538373" data-claire-element-id="538373" src="medias/uploads.siteduzero.com_files_69001_70000_69071.gif" alt="Image utilisateur"/></figure><ul id="r-538380" data-claire-element-id="538380"><li id="r-538377" data-claire-element-id="538377"><p id="r-538376" data-claire-element-id="538376">En rouge: c'est un sommet.</p></li><li id="r-538379" data-claire-element-id="538379"><p id="r-538378" data-claire-element-id="538378">En bleu : c'est une composante du sommet, soit une variable.</p></li></ul><p id="r-538381" data-claire-element-id="538381">Ceci est un tableau de données de type quelconque. Nous avons 2 variables par sommet. Ce tableau peut être de n'importe quel type (<code data-claire-semantic="c">float </code>, <code data-claire-semantic="c">short </code>, <code data-claire-semantic="c">int </code>, ...).<br/> Pour l'envoi d'un tel tableau, nous allons donc appeler une fonction <code data-claire-semantic="c">gl*Pointer() </code> comme ceci :</p><pre id="r-538382" data-claire-element-id="538382"><code data-claire-semantic="c">glVertexPointer(2, /* type inconnu */, 0, pointer);</code></pre><p id="r-538383" data-claire-element-id="538383">Ici, nous avons dit à OpenGL qu'il s'agissait d'un tableau représentant les positions des sommets (bicoz le nom de la fonction est <code data-claire-semantic="c">gl </code><code data-claire-semantic="c"><strong>Vertex </strong></code><code data-claire-semantic="c">Pointer() </code>).<br/> Soit, définissons notre tableau ainsi :</p><pre id="r-538384" data-claire-element-id="538384"><code data-claire-semantic="c">float pos[4 * 2] =
{
    /* ... */
};</code></pre><p id="r-538385" data-claire-element-id="538385">Là, j'ai décidé que le type sera <code data-claire-semantic="c"><strong>float </strong></code>, nous allons donc mettre <code data-claire-semantic="c">GL_FLOAT </code> pour le paramètre <code data-claire-semantic="c">type </code> de la fonction <code data-claire-semantic="c">glVertexPointer() </code> :</p><pre id="r-538386" data-claire-element-id="538386"><code data-claire-semantic="c">glVertexPointer(2, GL_FLOAT, 0, pos);</code></pre><p id="r-538387" data-claire-element-id="538387">À présent, nous voudrions un rendu coloré, nous allons donc devoir rajouter un tableau qui contiendra les données de couleur de nos sommets. Seulement celui-ci aura une taille de 3, pour nos trois composantes R, G et B :</p><figure id="r-538389" data-claire-element-id="538390"><img id="r-538388" data-claire-element-id="538388" src="medias/uploads.siteduzero.com_files_69001_70000_69072.gif" alt="Image utilisateur"/></figure><p id="r-538391" data-claire-element-id="538391">Je l'implémente de la manière suivante dans mon code :</p><pre id="r-538392" data-claire-element-id="538392"><code data-claire-semantic="c">float colors[4 * 3] =
{
    /* ... */
};

...

glColorPointer(3, GL_FLOAT, 0, colors);</code></pre><aside id="r-538394" data-claire-element-id="538394" data-claire-semantic="information"><p id="r-538393" data-claire-element-id="538393">Les couleurs stockées sur des flottants doivent avoir une valeur comprise entre 0.0 et 1.0 inclus.</p></aside><p id="r-538395" data-claire-element-id="538395">Nous avons à présent des sommets qui sont composés :</p><ul id="r-538400" data-claire-element-id="538400"><li id="r-538397" data-claire-element-id="538397"><p id="r-538396" data-claire-element-id="538396">d'une position (<code data-claire-semantic="c">glVertex*() </code>) ;</p></li><li id="r-538399" data-claire-element-id="538399"><p id="r-538398" data-claire-element-id="538398">d'une couleur (<code data-claire-semantic="c">glColor*() </code>).</p></li></ul><p id="r-538401" data-claire-element-id="538401">OpenGL prend les sommets dans l'ordre dans lequel on les lui envoie : autrement dit, <strong>les 3 premières valeurs du tableau <code data-claire-semantic="c">colors </code> seront associées aux 2 premières valeurs du tableau <code data-claire-semantic="c">pos </code>.</strong><br/> Il est primordial que vous reteniez cela. Encore une fois, un petit schéma ne sera pas de refus :</p><figure id="r-538403" data-claire-element-id="538404"><img id="r-538402" data-claire-element-id="538402" src="medias/uploads.siteduzero.com_files_69001_70000_69073.gif" alt="Image utilisateur"/></figure><ul id="r-538407" data-claire-element-id="538407"><li id="r-538406" data-claire-element-id="538406"><p id="r-538405" data-claire-element-id="538405">En vert : un sommet composé de ses types de données (nous en avons spécifié deux).</p></li></ul><p id="r-538408" data-claire-element-id="538408">Comme vous le voyez, nos sommets sont indexés comme dans un tableau (ils partent de 0). Si vous avez l'habitude de manipuler des tableaux, cela ne devrait pas vous poser de problèmes.</p><p id="r-538409" data-claire-element-id="538409">Ah, on commence à avoir un rangement de données structuré. :)</p><p id="r-538410" data-claire-element-id="538410">Bien, il nous reste encore un paramètre des fonctions <code data-claire-semantic="c">gl*Pointer() </code> à étudier, <code data-claire-semantic="c">stride </code>.</p><p id="r-538411" data-claire-element-id="538411">Voyons voir : j'ai finalement décidé que notre modèle ne serait composé que de deux sommets. Mais, on voudrait que ces sommets soient les <code data-claire-semantic="c">vertices </code> 0 et 2 qui sont actuellement dans nos tableaux.</p><div id="r-538413" data-claire-element-id="538413" data-claire-semantic="question"><p id="r-538412" data-claire-element-id="538412">Simple, tu modifies les tableaux <code data-claire-semantic="c">pos </code> et <code data-claire-semantic="c">colors </code> !</p></div><p id="r-538414" data-claire-element-id="538414">Non ! Supposez que la géométrie soit livrée par un fichier, la modification manuelle est impossible. On va donc se servir du paramètre <code data-claire-semantic="c">stride </code>. Ce dernier représente le décalage en bytes de chaque sommet consécutif, en partant du début du sommet, jusqu'au début du suivant. La marge par défaut, qui est la taille d'un vertex, soit <code data-claire-semantic="c">size </code> * <code data-claire-semantic="c">sizeof </code>(<code data-claire-semantic="c"><em>TYPE </em></code>), est ignorée si <code data-claire-semantic="c">stride </code> est différent de 0. Si <code data-claire-semantic="c">stride </code> est égal à la taille d'un sommet (<code data-claire-semantic="c">size </code> * <code data-claire-semantic="c">sizeof </code>(<code data-claire-semantic="c"><em>TYPE </em></code>)), son utilisation n'a aucun effet.<br/> Voici pour l'explication littéraire, mais ne vous inquiétez pas, je vous ai à nouveau mijoté de petits schémas. :p</p><p id="r-538415" data-claire-element-id="538415">Donc reprenons, <code data-claire-semantic="c">stride </code> représente le nombre de bytes qui sépare deux sommets ; si on donne à manger à notre <code data-claire-semantic="c">glVertexPointer() </code> ceci :</p><pre id="r-538416" data-claire-element-id="538416"><code data-claire-semantic="c">glVertexPointer(2, GL_FLOAT, 2*sizeof(float), pos);</code></pre><p id="r-538417" data-claire-element-id="538417">il se passera cela :</p><figure id="r-538419" data-claire-element-id="538420"><img id="r-538418" data-claire-element-id="538418" src="medias/uploads.siteduzero.com_files_69001_70000_69074.gif" alt="Image utilisateur"/></figure><p id="r-538421" data-claire-element-id="538421">c'est-à-dire rien, comme je l'avais annoncé si on donne la taille d'un sommet.</p><ul id="r-538424" data-claire-element-id="538424"><li id="r-538423" data-claire-element-id="538423"><p id="r-538422" data-claire-element-id="538422">En vert : c'est ce que va lire OpenGL en le considérant comme les données (de position en l'occurrence) d'<strong>un</strong> sommet.</p></li></ul><p id="r-538425" data-claire-element-id="538425">Maintenant, pour obtenir le résultat que nous voulions, qui est de sauter <strong>2</strong> sommets pour se retrouver avec les sommets 0 et 2 consécutifs, nous allons positionner <code data-claire-semantic="c">stride </code> à <strong>2</strong>*(<code data-claire-semantic="c">size </code> * <code data-claire-semantic="c">sizeof </code>(<code data-claire-semantic="c"><em>TYPE </em></code>)) comme cela :</p><pre id="r-538426" data-claire-element-id="538426"><code data-claire-semantic="c">glVertexPointer(2, GL_FLOAT, 2*2*sizeof(float), pos);</code></pre><p id="r-538427" data-claire-element-id="538427">Ce qui a pour effet ceci :</p><figure id="r-538429" data-claire-element-id="538430"><img id="r-538428" data-claire-element-id="538428" src="medias/uploads.siteduzero.com_files_69001_70000_69075.gif" alt="Image utilisateur"/></figure><p id="r-538431" data-claire-element-id="538431">J'espère que c'est compréhensible. ;) Vous comprenez maintenant pourquoi il est important de maîtriser les pointeurs et les tableaux.</p><aside id="r-538433" data-claire-element-id="538433" data-claire-semantic="information"><p id="r-538432" data-claire-element-id="538432">Ici, <code data-claire-semantic="c">stride </code> encadre deux sommets, mais comme le paramètre <code data-claire-semantic="c">size </code> de <code data-claire-semantic="c">glVertexPointer() </code> est positionné à 2, OpenGL ne va lire que <strong>deux</strong> valeurs. Les deux autres seront simplement ignorées.</p></aside><h6 id="r-exercice-59" data-claire-element-id="538440">Exercice</h6><div id="r-538435" data-claire-element-id="538435" data-claire-semantic="question"><p id="r-538434" data-claire-element-id="538434">Quoi ?! Déjà !? o_O</p></div><p id="r-538436" data-claire-element-id="538436">Ouais, allez au boulot. :p</p><p id="r-538437" data-claire-element-id="538437"><strong>Énoncé</strong></p><p id="r-538438" data-claire-element-id="538438">J'aimerais que vous me construisiez un seul et unique tableau de données qui contiendra les positions des sommets <strong>et</strong> les couleurs des sommets. Vous utiliserez un appel à <code data-claire-semantic="c">glVertexPointer() </code> et un appel a <code data-claire-semantic="c">glColorPointer() </code> avec une utilisation judicieuse de <code data-claire-semantic="c">&lt;italique&gt;&lt;/italique&gt; </code>. Ce tableau devra comporter trois sommets qui seront chacun constitués de couleurs RGB et de 2 coordonnées dans l'espace. <br/> Je laisse votre esprit créatif trouver les couleurs et les positions qui vous plairont le plus. :-°</p><p id="r-538439" data-claire-element-id="538439">À vos EDI ! :pirate:</p><h6 id="r-correction-186" data-claire-element-id="538450">Correction</h6><p id="r-538441" data-claire-element-id="538441">Les explications (peu nombreuses puisque tout est normalement déjà expliqué) sont incluses dans le code.</p><p id="r-538442" data-claire-element-id="538442"></p><div id="r-538445" data-claire-element-id="538445"><div id="r-538444" data-claire-element-id="538444"><pre id="r-538443" data-claire-element-id="538443"><code data-claire-semantic="c">/* nombre de sommets */
    #define N_VERTS 3
    
    /* nombre de variables dans un sommet de type position */
    #define P_SIZE 2
    
    /* nombre de variables dans un sommet de type couleur */
    #define C_SIZE 3
    
    /* tableau des donnees */
    float vertices[N_VERTS*P_SIZE + N_VERTS*C_SIZE] =
    {
        /* sommet 0 */ /* taille  =  (V_SIZE + C_SIZE) * sizeof(vertices[0]) */
        -0.8, -0.8,     /* position 0 */
        1.0, 0.0, 0.0,  /* couleur 0 */
        
        /* sommet 1 */
        0.8, -0.8,      /* position 1 */
        0.0, 1.0, 0.0,  /* couleur 1 */
        
        /* sommet 2 */
        0.0, 0.8,       /* positions 2 */
        0.0, 0.0, 1.0   /* couleurs 2 */
    };
    
    /* ... */
    
    
    /* activation des tableaux de sommets */
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_COLOR_ARRAY);
    
    glVertexPointer(P_SIZE, GL_FLOAT, (C_SIZE+P_SIZE)*sizeof(vertices[0]), vertices);
    
    /* ici c'est particulier, en effet, on envoie l'adresse de la premiere
       zone memoire ou se situe les premieres informations de couleur */
    glColorPointer(C_SIZE, GL_FLOAT, (C_SIZE+P_SIZE)*sizeof(vertices[0]), &amp;vertices[P_SIZE]);</code></pre></div></div><p id="r-538446" data-claire-element-id="538446">Ce que nous venons de faire là, c'est un tableau de données entrelacées. :) Il existe une fonction spécialement conçue pour accueillir des données entrelacées dont je n'ai pas parlé ici, il s'agit de <code data-claire-semantic="c">glInterleavedArrays() </code>. Son fonctionnement est inadéquat pour une utilisation telle que nous le verrons dans le prochain chapitre ; toutefois, voici sa documentation : <a href="http://www.opengl.org/documentation/specs/man_pages/hardcopy/GL/html/gl/interleavedarrays.html">http://www.opengl.org/documentation/sp [...] edarrays.html</a>.</p><aside id="r-538448" data-claire-element-id="538448" data-claire-semantic="information"><p id="r-538447" data-claire-element-id="538447">N'hésitez pas à relire et à re-relire ce dernier passage, qui est plutôt corsé à comprendre, mais important. J'ai mis du temps à m'y faire personnellement, mais à force de persévérer j'ai fini par m'y habituer. ;) Faites-en autant !</p></aside><p id="r-538449" data-claire-element-id="538449">Bien, maintenant que vous avez assimilé (enfin je l'espère :p ) le fonctionnement de l'envoi des données à OpenGL, nous allons pouvoir passer au rendu. :)</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
<span class="arrow"></span>
<span class="next">Fonctionnement</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
<span class="next">Effectuer un rendu</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Effectuerunrendu"></a><h2>Effectuer un rendu</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
<span class="arrow"></span>
<span class="next">Spécification de tableaux</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
<span class="next">Utilisation d&#039;indices</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-effectuer-un-rendu" data-claire-element-id="538508">Effectuer un rendu</h4><p id="r-538453" data-claire-element-id="538453">Le rendu de nos tableaux, nous y voilà enfin !<br/> Si vous avez correctement compris l'étape de l'envoi des données, vous ne devriez pas avoir de mal ici. ;)</p><h5 id="r-rendu-simple-1" data-claire-element-id="538489">Rendu simple</h5><p id="r-538454" data-claire-element-id="538454">Comme nous l'avons vu, nos sommets sont stockés dans un ordre bien précis. Cet ordre va définir l'ordre d'affichage de nos sommets, et donc de nos polygones.</p><p id="r-538455" data-claire-element-id="538455">Bien : passons tout de suite aux présentations, un prototype vaut mieux qu'on long discours. :)</p><pre id="r-538456" data-claire-element-id="538456"><code data-claire-semantic="c">void glDrawArrays(GLenum primType, GLint first, GLsizei nombre);</code></pre><ul id="r-538463" data-claire-element-id="538463"><li id="r-538458" data-claire-element-id="538458"><p id="r-538457" data-claire-element-id="538457"><code data-claire-semantic="c"><strong>primType </strong></code> : représente une des constantes symboliques d'un type de primitive (<code data-claire-semantic="c">GL_LINES </code>, <code data-claire-semantic="c">GL_TRIANGLES </code>, etc.). La liste des types de primitives supportées par OpenGL est disponible sur le tuto de Kayl : <a href="http://www.siteduzero.com/tuto-3-6094-1-notions-de-base.html#ss_part_2">là.</a></p></li><li id="r-538460" data-claire-element-id="538460"><p id="r-538459" data-claire-element-id="538459"><code data-claire-semantic="c"><strong>first </strong></code> : c'est le numéro du premier sommet que l'on voudra afficher.</p></li><li id="r-538462" data-claire-element-id="538462"><p id="r-538461" data-claire-element-id="538461"><code data-claire-semantic="c"><strong>nombre </strong></code> : c'est le nombre de sommets que l'on voudra afficher en partant de <code data-claire-semantic="c">first </code>. Le nombre total de sommets qui seront affichés sera égal à <code data-claire-semantic="c">nombre </code>.</p></li></ul><aside id="r-538465" data-claire-element-id="538465" data-claire-semantic="warning"><p id="r-538464" data-claire-element-id="538464">Prenez garde lorsque vous manipulerez vos valeurs <code data-claire-semantic="c">first </code> et <code data-claire-semantic="c">nombre </code> à ne pas donner de valeurs qui provoqueront un dépassement de tableau ! Si votre tableau a moins de &quot;cases&quot; que <code data-claire-semantic="c">first </code> + <code data-claire-semantic="c">nombre </code>, alors vous encourez un risque de voir un beau &quot;Segmentation Fault&quot; apparaître à l'écran !</p></aside><p id="r-538466" data-claire-element-id="538466">Voici un code complet pour que vous compreniez mieux. ;)</p><pre id="r-538467" data-claire-element-id="538467"><code data-claire-semantic="c">#include &lt;stdio.h&gt;
#include &lt;SDL/SDL.h&gt;
#include &lt;GL/gl.h&gt;

/* dimensions de la fenetre */
#define W 640
#define H 480

/* initialise opengl */
void init_gl(void);


int main(int argc, char **argv)
{
    int loop = 1;       /* booleen du 'main loop' */
    SDL_Event ev;       /* structure d'evenement(s) SDL */
    
    /* nombre de sommets */
    #define N_VERTS 3
    
    /* nombre de variables dans un sommet de type position */
    #define P_SIZE 2
    
    /* nombre de variables dans un sommet de type couleur */
    #define C_SIZE 3
    
    /* tableau des donnees */
    float vertices[N_VERTS*P_SIZE + N_VERTS*C_SIZE] =
    {
        /* sommet 0 */ /* taille  =  (V_SIZE + C_SIZE) * sizeof(vertices[0]) */
        -0.8, -0.8,     /* position 0 */
        1.0, 0.0, 0.0,  /* couleur 0 */
        
        /* sommet 1 */
        0.8, -0.8,      /* position 1 */
        0.0, 1.0, 0.0,  /* couleur 1 */
        
        /* sommet 2 */
        0.0, 0.8,       /* position 2 */
        0.0, 0.0, 1.0   /* couleur 2 */
    };
    
    
    /* initialisation de la SDL en mode OpenGL */
    SDL_Init(SDL_INIT_VIDEO);
    SDL_SetVideoMode(W, H, 32, SDL_OPENGL);
    
    /* nom de la fenetre */
    SDL_WM_SetCaption(&quot;Vertex Arrays GL&quot;, NULL);
    
    /* initialisation d'opengl */
    init_gl();
    
    /* boucle d'affichage principale */
    while(loop)
    {
        /* recuperation d'un evenement */
        SDL_WaitEvent(&amp;ev);
        
        /* analyse */
        switch(ev.type)
        {
            case SDL_QUIT:
                loop = 0;
                break;
            
            default:;
        }
        
        glClear(GL_COLOR_BUFFER_BIT);
        
        /* activation des tableaux de sommets */
        glEnableClientState(GL_VERTEX_ARRAY);
        glEnableClientState(GL_COLOR_ARRAY);
        
        /* on specifie l'adresse de nos donnees */
        glVertexPointer(P_SIZE, GL_FLOAT, (C_SIZE+P_SIZE)*sizeof(vertices[0]), vertices);
        glColorPointer(C_SIZE, GL_FLOAT, (C_SIZE+P_SIZE)*sizeof(vertices[0]), &amp;vertices[P_SIZE]);
        
        /* dessin de nos tableaux. Ici, on part du premier sommet (0)
           pour arriver au dernier (N_VERTS) */
        glDrawArrays(GL_TRIANGLES, 0, N_VERTS);
        
        /* on échange les tampons */
        glFlush();
        SDL_GL_SwapBuffers();
    }
    
    return 0;
}


void init_gl(void)
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}</code></pre><p id="r-538468" data-claire-element-id="538468">Bien entendu, comme à l'habitude, je vous ai préparé de petits dessins. :)</p><p id="r-538469" data-claire-element-id="538469">En reprenant notre code vu ci-dessus, voici ce qui se passe lorsqu'on modifie notre fonction <code data-claire-semantic="c">glDrawArrays() </code> comme ceci :</p><table id="r-538478" data-claire-element-id="538478"><tbody id="r-538477" data-claire-element-id="538477"><tr id="r-538473" data-claire-element-id="538473"><td id="r-538471" data-claire-element-id="538472"><img id="r-538472" data-claire-element-id="538471" src="medias/uploads.siteduzero.com_files_69001_70000_69076.gif" alt="Image utilisateur"/><img id="r-538470" data-claire-element-id="538470" src="medias/uploads.siteduzero.com_files_69001_70000_69076.gif" alt="Image utilisateur"/></td></tr><tr id="r-538476" data-claire-element-id="538476"><td id="r-538475" data-claire-element-id="538475"><pre id="r-538474" data-claire-element-id="538474"><code data-claire-semantic="c">glDrawArrays(GL_LINES, 1, 2);</code></pre></td></tr></tbody></table><p id="r-538479" data-claire-element-id="538479">Cela affichera une simple ligne, je pense qu'un dessin dans ce cas-là serait plus qu'inutile. ;)</p><aside id="r-538481" data-claire-element-id="538481" data-claire-semantic="warning"><p id="r-538480" data-claire-element-id="538480"><strong>Important</strong> : le traitement des sommets commence à <code data-claire-semantic="c">first </code> et se termine à <code data-claire-semantic="c">first </code> + <code data-claire-semantic="c">nombre </code> - 1 ; dans notre cas, nous envoyons deux sommets (vertex 1 et vertex 2) pour le traitement.</p></aside><h6 id="r-desactiver-les-tableaux-de-sommets" data-claire-element-id="538488">Désactiver les tableaux de sommets</h6><p id="r-538482" data-claire-element-id="538482">Oui, vous avez bien lu. :) <br/> Tout comme <code data-claire-semantic="c">glEnable() </code> possède son opposé <code data-claire-semantic="c">glDisable() </code>, <code data-claire-semantic="c">glEnableClientState() </code> possède lui aussi sa fonction inverse.</p><pre id="r-538483" data-claire-element-id="538483"><code data-claire-semantic="c">void glDisableClientState(GLenum cap);</code></pre><p id="r-538484" data-claire-element-id="538484">Rappelez-vous toujours ceci lorsque vous programmerez avec OpenGL : <a href="http://jeux.developpez.com/faq/opengl/?page=optimisations#OPTIMISATIONS_ameliorer_perfs">OpenGL comme machine à états.</a></p><p id="r-538485" data-claire-element-id="538485">Il nous suffira donc de rajouter ceci après notre <code data-claire-semantic="c">glDrawArrays() </code> :</p><pre id="r-538486" data-claire-element-id="538486"><code data-claire-semantic="c">/* desactivation des tableaux de sommet */
glDisableClientState(GL_COLOR_ARRAY);
glDisableClientState(GL_VERTEX_ARRAY);</code></pre><p id="r-538487" data-claire-element-id="538487">Et voilà, c'est tout pour le rendu simple. :)</p><h5 id="r-rendus-imbriques-1" data-claire-element-id="538507">Rendus imbriqués</h5><p id="r-538490" data-claire-element-id="538490">Allez, on va un peu corser la chose. :p</p><div id="r-538492" data-claire-element-id="538492" data-claire-semantic="question"><p id="r-538491" data-claire-element-id="538491">Tu nous fais un remake de l'imbrication des display lists ?</p></div><p id="r-538493" data-claire-element-id="538493">Pas tout à fait.<br/> En fait, il s'agit plus d'un gadget que d'une fonction réellement utile. Personnellement, je ne m'en suis jamais servi.<br/> Voici la fonction permettant d'effectuer &quot;plusieurs&quot; rendus en un seul :</p><pre id="r-538494" data-claire-element-id="538494"><code data-claire-semantic="c">void glMultiDrawArrays(GLenum primType, GLint *firsts, GLsizei *nombres, GLsizei num_nombres);</code></pre><ul id="r-538501" data-claire-element-id="538501"><li id="r-538496" data-claire-element-id="538496"><p id="r-538495" data-claire-element-id="538495"><code data-claire-semantic="c"><strong>firsts </strong></code> : représente la liste des <code data-claire-semantic="c">first </code> que l'on passait habituellement à <code data-claire-semantic="c">glDrawArrays() </code>.</p></li><li id="r-538498" data-claire-element-id="538498"><p id="r-538497" data-claire-element-id="538497"><code data-claire-semantic="c"><strong>nombres </strong></code> : représente la liste des <code data-claire-semantic="c">nombre </code> que l'on passait habituellement à <code data-claire-semantic="c">glDrawArrays() </code>.</p></li><li id="r-538500" data-claire-element-id="538500"><p id="r-538499" data-claire-element-id="538499"><code data-claire-semantic="c"><strong>num_nombres </strong></code> : nombre de rendus (taille des tableaux <code data-claire-semantic="c">nombres </code> et <code data-claire-semantic="c">firsts </code>).</p></li></ul><p id="r-538502" data-claire-element-id="538502">La fonction <code data-claire-semantic="c">glMultiDrawArrays() </code> a pour effet d'être équivalente à plusieurs appels à <code data-claire-semantic="c">glDrawArrays() </code>, et peut être codée facilement :</p><pre id="r-538503" data-claire-element-id="538503"><code data-claire-semantic="c">GLsizei i;

for(i=0; i&lt;num_nombres; i++)
    glDrawArrays(primType, firsts[i], nombres[i]);</code></pre><p id="r-538504" data-claire-element-id="538504">Bien sûr, cela ne se passe probablement pas comme cela en interne dans OpenGL, mais le principe est exactement celui-ci. ;)</p><p id="r-538505" data-claire-element-id="538505">Voilà : c'est tout pour le rendu simple. :) <br/> Nous allons à présent voir une forme d'optimisation très pratique, l'utilisation d'<strong>indices</strong> pour dé-référencer les sommets.</p><p id="r-538506" data-claire-element-id="538506">(N.B. : nous verrons dans le prochain chapitre comment se passe plus en détail le transfert des données vers la carte graphique pour le rendu.)</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
<span class="arrow"></span>
<span class="next">Spécification de tableaux</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
<span class="next">Utilisation d&#039;indices</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Utilisationd039indices"></a><h2>Utilisation d&#039;indices</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
<span class="arrow"></span>
<span class="next">Effectuer un rendu</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">
<span class="next">Les Vertex Buffer Objects</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-utilisation-d-indices" data-claire-element-id="538585">Utilisation d'indices</h4><p id="r-538509" data-claire-element-id="538509">Si vous avez bien compris le concept de stockage des données, l'utilisation des indices devrait être on ne peut plus simple à comprendre. :)</p><p id="r-538510" data-claire-element-id="538510">Nous avons vu que nos vertices (sommets) étaient rangés dans un tableau commençant à 0 et se terminant... là où on le veut, tout dépend du paramètre <code data-claire-semantic="c">nombre </code> passé à <code data-claire-semantic="c">glDrawArrays() </code>.<br/> Nous allons à présent rajouter un autre tableau, celui-ci contiendra simplement les indices de nos sommets, c'est-à-dire leur position dans le tableau de sommets.</p><aside id="r-538512" data-claire-element-id="538512" data-claire-semantic="warning"><p id="r-538511" data-claire-element-id="538511">Les tableaux d'indices doivent êtres des tableaux d'entiers non signés. Et c'est important, sinon ça ne fonctionne pas.</p></aside><p id="r-538513" data-claire-element-id="538513">Reprenons notre schéma de base :</p><figure id="r-538515" data-claire-element-id="538516"><img id="r-538514" data-claire-element-id="538514" src="medias/uploads.siteduzero.com_files_69001_70000_69073.gif" alt="Image utilisateur"/></figure><p id="r-538517" data-claire-element-id="538517">Notre tableau a 4 cases, soit 4 sommets, soit un quadrilatère.<br/> Les indices permettent de dire explicitement quand on souhaite rendre tel ou tel sommet. C'est un peu flou dans votre tête ? C'est normal. :p</p><p id="r-538518" data-claire-element-id="538518">Voyons, je vais créer le tableau d'indices suivant :</p><table id="r-538527" data-claire-element-id="538527"><tbody id="r-538526" data-claire-element-id="538526"><tr id="r-538521" data-claire-element-id="538521"><td id="r-538520" data-claire-element-id="538520"><pre id="r-538519" data-claire-element-id="538519"><code data-claire-semantic="c">unsigned int index[N_VERTS] =
{
    0, 1, 2, 3
};</code></pre></td></tr><tr id="r-538525" data-claire-element-id="538525"><td id="r-538523" data-claire-element-id="538524"><img id="r-538524" data-claire-element-id="538523" src="medias/uploads.siteduzero.com_files_69001_70000_69077.jpg" alt="Image utilisateur"/><img id="r-538522" data-claire-element-id="538522" src="medias/uploads.siteduzero.com_files_69001_70000_69077.jpg" alt="Image utilisateur"/></td></tr></tbody></table><p id="r-538528" data-claire-element-id="538528">En lisant ce tableau, OpenGL va voir :</p><ul id="r-538537" data-claire-element-id="538537"><li id="r-538530" data-claire-element-id="538530"><p id="r-538529" data-claire-element-id="538529">1er sommet à rendre : numéro 0 ;</p></li><li id="r-538532" data-claire-element-id="538532"><p id="r-538531" data-claire-element-id="538531">2e sommet à rendre : numéro 1 ;</p></li><li id="r-538534" data-claire-element-id="538534"><p id="r-538533" data-claire-element-id="538533">3e sommet à rendre : numéro 2 ;</p></li><li id="r-538536" data-claire-element-id="538536"><p id="r-538535" data-claire-element-id="538535">etc.</p></li></ul><p id="r-538538" data-claire-element-id="538538">En utilisant ce tableau d'indices, il ne se produit rien de différent au rendu, puisque vous demandez à OpenGL de prendre les sommets dans l'ordre dans lequel ils apparaissent normalement.<br/> Créons maintenant un tableau d'indices constitué comme suit :</p><table id="r-538547" data-claire-element-id="538547"><tbody id="r-538546" data-claire-element-id="538546"><tr id="r-538541" data-claire-element-id="538541"><td id="r-538540" data-claire-element-id="538540"><pre id="r-538539" data-claire-element-id="538539"><code data-claire-semantic="c">unsigned int index[N_VERTS] =
{
    1, 0, 3, 2
};</code></pre></td></tr><tr id="r-538545" data-claire-element-id="538545"><td id="r-538543" data-claire-element-id="538544"><img id="r-538544" data-claire-element-id="538543" src="medias/uploads.siteduzero.com_files_69001_70000_69078.jpg" alt="Image utilisateur"/><img id="r-538542" data-claire-element-id="538542" src="medias/uploads.siteduzero.com_files_69001_70000_69078.jpg" alt="Image utilisateur"/></td></tr></tbody></table><p id="r-538548" data-claire-element-id="538548">Ah, ça devient déjà plus intéressant. :p <br/> Comme vous le voyez, l'ordre de dessin a changé. En effet, à présent, voici ce que va lire OpenGL :</p><ul id="r-538557" data-claire-element-id="538557"><li id="r-538550" data-claire-element-id="538550"><p id="r-538549" data-claire-element-id="538549">1er sommet à rendre : numéro 1 ;</p></li><li id="r-538552" data-claire-element-id="538552"><p id="r-538551" data-claire-element-id="538551">2e sommet à rendre : numéro 0 ;</p></li><li id="r-538554" data-claire-element-id="538554"><p id="r-538553" data-claire-element-id="538553">3e sommet à rendre : numéro 3 ;</p></li><li id="r-538556" data-claire-element-id="538556"><p id="r-538555" data-claire-element-id="538555">etc.</p></li></ul><p id="r-538558" data-claire-element-id="538558">Voici le code complet permettant d'obtenir ce résultat :</p><pre id="r-538559" data-claire-element-id="538559"><code data-claire-semantic="c">#include &lt;stdio.h&gt;
#include &lt;SDL/SDL.h&gt;
#include &lt;GL/gl.h&gt;

/* dimensions de la fenetre */
#define W 300
#define H 200

/* initialise opengl */
void init_gl(void);


int main(int argc, char **argv)
{
    int loop = 1;       /* booleen du 'main loop' */
    SDL_Event ev;       /* structure d'evenement(s) SDL */
    
    /* nombre de sommets */
    #define N_VERTS 4
    
    /* nombre de variables dans un sommet de type position */
    #define P_SIZE 2
    
    /* nombre de variables dans un sommet de type couleur */
    #define C_SIZE 3
    
    /* tableau des donnees */
    float pos[N_VERTS*P_SIZE] =
    {
        -0.8, -0.8,     /* position 0 */
        0.8, -0.8,      /* position 1 */
        0.8, 0.8,       /* position 2 */
        -0.8, 0.8       /* position 3 */
    };
    
    float colors[N_VERTS*C_SIZE] =
    {
        1.0, 0.0, 0.0,  /* couleur 0 */
        0.0, 1.0, 0.0,  /* couleur 1 */
        0.0, 0.0, 1.0,  /* couleur 2 */
        1.0, 1.0, 1.0   /* couleur 3 */
    };
    
    unsigned int index[N_VERTS] =
    {
        1, 0, 3, 2
    };
    
    
    /* initialisation de la SDL en mode OpenGL */
    SDL_Init(SDL_INIT_VIDEO);
    SDL_SetVideoMode(W, H, 32, SDL_OPENGL);
    
    /* nom de la fenetre */
    SDL_WM_SetCaption(&quot;Vertex Arrays GL&quot;, NULL);
    
    /* initialisation d'opengl */
    init_gl();
    
    /* boucle d'affichage principale */
    while(loop)
    {
        /* recuperation d'un evenement */
        SDL_WaitEvent(&amp;ev);
        
        /* analyse */
        switch(ev.type)
        {
            case SDL_QUIT:
                loop = 0;
                break;
            
            default:;
        }
        
        glClear(GL_COLOR_BUFFER_BIT);
        
        /* activation des tableaux de sommets */
        glEnableClientState(GL_VERTEX_ARRAY);
        glEnableClientState(GL_COLOR_ARRAY);
        
        /* envoi des donnees */
        glVertexPointer(P_SIZE, GL_FLOAT, 0, pos);
        glColorPointer(C_SIZE, GL_FLOAT, 0, colors);
        
        /* rendu indice */
        glDrawElements(GL_LINE_STRIP, N_VERTS, GL_UNSIGNED_INT, index);
        
        /* desactivation des tableaux de sommet */
        glDisableClientState(GL_COLOR_ARRAY);
        glDisableClientState(GL_VERTEX_ARRAY);
        
        /* on échange les tampons */
        glFlush();
        SDL_GL_SwapBuffers();
    }
    
    return 0;
}


void init_gl(void)
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}</code></pre><p id="r-538560" data-claire-element-id="538560">Ce qu'il y a de nouveau ici, c'est <code data-claire-semantic="c">glDrawElements() </code>, c'est aussi une fonction de rendu. :) Mais pas n'importe quel rendu, elle permet d'effectuer un rendu indicé (dans un ordre défini).</p><pre id="r-538561" data-claire-element-id="538561"><code data-claire-semantic="c">void glDrawElements(GLenum primType, GLsizei nombre, GLenum index_type, const GLvoid *indices);</code></pre><ul id="r-538568" data-claire-element-id="538568"><li id="r-538563" data-claire-element-id="538563"><p id="r-538562" data-claire-element-id="538562"><code data-claire-semantic="c"><strong>nombre </strong></code> : c'est le nombre de cases de notre tableau index à explorer, soit le nombre de sommets à rendre.</p></li><li id="r-538565" data-claire-element-id="538565"><p id="r-538564" data-claire-element-id="538564"><code data-claire-semantic="c"><strong>index_type </strong></code> : c'est le type des variables dont est constitué notre tableau d'indices ; dans notre cas, il s'agit d'<em>unsigned int</em>, représenté par la constante <code data-claire-semantic="c">GL_UNSIGNED_INT </code>.</p></li><li id="r-538567" data-claire-element-id="538567"><p id="r-538566" data-claire-element-id="538566"><code data-claire-semantic="c"><strong>indices </strong></code> : c'est notre tableau d'indices. :)</p></li></ul><p id="r-538569" data-claire-element-id="538569">En fait, <code data-claire-semantic="c">indices </code> est un tableau de valeurs qui représentent le numéro du sommet à afficher. Puisque nos sommets sont rangés dans des tableaux, il est facile de les dé-référencer à l'aide d'une seule valeur entière. :)</p><p id="r-538570" data-claire-element-id="538570">Plus généralement, les indices sont utilisés pour éviter de dupliquer des sommets en mémoire. Imaginez que vous ayez deux polygones qui utilisent le même sommet (donc, la même couleur, même position, etc.), les indices représentent une méthode efficace pour éviter de le copier deux fois. En effet, au lieu de le copier, vous n'aurez qu'à le dé-référencer deux fois dans votre tableau d'indices : une première fois pour afficher votre premier polygone, et une deuxième fois pour votre second polygone.</p><p id="r-538571" data-claire-element-id="538571">Voici un exemple concret d'utilisation :</p><pre id="r-538572" data-claire-element-id="538572"><code data-claire-semantic="c">/* nombre de donnees vectorielles */
    #define N_DATAS 6
    
    /* nombre de variables dans un sommet de type position */
    #define P_SIZE 2
    
    /* nombre de variables dans un sommet de type couleur */
    #define C_SIZE 3
    
    /* tableau des donnees */
    float pos[N_DATAS*P_SIZE] =
    {
        0.0, -0.9,      /* position 0 */
        0.0, 0.5,       /* position 1 */
        
        0.9, 0.9,       /* position 2 */
        -0.9, 0.9,      /* position 3 */
        0.9, -0.5,      /* position 4 */
        -0.9, -0.5      /* position 5 */
    };
    
    float colors[N_DATAS*C_SIZE] =
    {
        1.0, 0.0, 0.0,  /* couleur 0 */
        1.0, 0.0, 0.0,  /* couleur 1 */
        
        1.0, 0.0, 0.0,  /* couleur 2 */
        0.0, 1.0, 0.0,  /* couleur 3 */
        0.0, 0.0, 1.0,  /* couleur 4 */
        1.0, 1.0, 1.0   /* couleur 5 */
    };
    
    /* nombre total de sommets (a envoyer a glDrawElements en tant que count) */
    #define NUM_VERTICES 8
    
    unsigned char index[NUM_VERTICES] =
    {
        /* polygone 0 */
        0, 1, 2, 4,
        
        /* polygone 1 */
        0, 1, 3, 5
    };
    
    /* NOTE: remarquez les deux premiers indices (0, 1) qui sont
             presents dans le polygone 0 et 1, ce sont nos vertices
             doubles, mais non-dupliques grace aux indices :) */
    
    ...
    
    glDrawElements(GL_QUADS, NUM_VERTICES, GL_UNSIGNED_BYTE, index);</code></pre><p id="r-538573" data-claire-element-id="538573">Et le résultat :</p><figure id="r-538575" data-claire-element-id="538576"><img id="r-538574" data-claire-element-id="538574" src="medias/uploads.siteduzero.com_files_69001_70000_69079.jpg" alt="Image utilisateur"/></figure><aside id="r-538578" data-claire-element-id="538578" data-claire-semantic="information"><p id="r-538577" data-claire-element-id="538577">Vous noterez également que j'ai passé les indices sur des <code data-claire-semantic="c">char </code> (bytes), cela fait gagner en performances, car utilise moins d'espace (<code data-claire-semantic="c">sizeof(char) </code> au lieu de <code data-claire-semantic="c">sizeof(int) </code>).</p></aside><p id="r-538579" data-claire-element-id="538579">Il est important de savoir que si vos sommets ne sont pas parfaitement identiques - admettons que leur coordonnée de texture soit différente -, vous serez obligés de les dupliquer. En effet, les indices dé-référencent des sommets, pas les tableaux que nous envoyons à <code data-claire-semantic="c">gl*Pointer() </code>.</p><p id="r-538580" data-claire-element-id="538580">Certains formats de modèles 3D livrent un tableau d'indices en plus des données qu'ils contiennent, afin d'utiliser correctement ces dernières.</p><p id="r-538581" data-claire-element-id="538581">Nous voici arrivés au bout d'un long et périlleux chapitre. :p</p><p id="r-538582" data-claire-element-id="538582">Mais ça en vaudra la peine dans le prochain où nous apprendrons à améliorer considérablement les performances des vertex arrays. ;) En effet, au lieu d'héberger nos données chez le client, nous les hébergerons directement sur le serveur. :) Cela nous évitera des aller-retour entre le CPU et le GPU, et apporte donc un gain de bande passante.</p><p id="r-538583" data-claire-element-id="538583">Pour conclure, les vertex arrays c'est bien, mais pas très optimisé si les données restent, comme dans notre cas, chez le client.</p><p id="r-538584" data-claire-element-id="538584"><em>Certains tableaux descriptifs sont inspirés de <a href="http://www.cs.rit.edu/~ncs/Courses/570/UserGuide/OpenGLonWin-15.html">cette page</a>.<br/> Je vous conseille d'ailleurs d'aller y jeter un oeil, il se peut<br/> que vous y trouviez des informations complémentaires intéressantes.</em></p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
<span class="arrow"></span>
<span class="next">Effectuer un rendu</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">
<span class="next">Les Vertex Buffer Objects</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="LesVertexBufferObjects"></a><h2>Les Vertex Buffer Objects</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
<span class="arrow"></span>
<span class="next">Utilisation d&#039;indices</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
<span class="next">Les VBO, des données côté serveur</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-538587" data-claire-element-id="538587">Les Vertex Buffer Objects, abrégés VBO, sont des zones mémoire où l'on peut stocker des données de sommet (d'où le mot Vertex). Cette mémoire a la particularité d'être rapidement accessible à votre carte graphique, puisqu'il s'agit en fait de sa propre mémoire.</p><p id="r-538588" data-claire-element-id="538588">En effet, comme je l'ai dit au cours du précédent chapitre, avec les vertex arrays les données étaient situées du côté du client, alors qu'avec les VBO, on héberge les données du côté du serveur. Nous allons donc commencer par étudier les différentes façon de procéder à cet hébergement (innombrables ^^ ), puis nous verrons comment exploiter efficacement nos données hébergées. :)</p><aside id="r-538590" data-claire-element-id="538590" data-claire-semantic="information"><p id="r-538589" data-claire-element-id="538589">La lecture préalable du chapitre précédent traitant des vertex arrays est primordiale.</p></aside><p id="r-538591" data-claire-element-id="538591">C'est parti. :)</p>
</div><a name="LesVBOdesdonnesctserveur"></a><h2>Les VBO, des données côté serveur</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">
<span class="arrow"></span>
<span class="next">Les Vertex Buffer Objects</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
<span class="next">Création d&#039;un objet tampon</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-les-vbo-des-donnees-cote-serveur" data-claire-element-id="538614">Les VBO, des données côté serveur</h4><p id="r-538592" data-claire-element-id="538592">Dans le dernier chapitre, nous avons vu que nos données étaient stockées côté client. Eh bien ici ce sera l'inverse, c'est ce qui fait la puissance des VBO. :)</p><p id="r-538593" data-claire-element-id="538593">Résumons le principe des vertex arrays :</p><ol id="r-538602" data-claire-element-id="538602"><li id="r-538595" data-claire-element-id="538595"><p id="r-538594" data-claire-element-id="538594">activation ;</p></li><li id="r-538597" data-claire-element-id="538597"><p id="r-538596" data-claire-element-id="538596">spécification des données ;</p></li><li id="r-538599" data-claire-element-id="538599"><p id="r-538598" data-claire-element-id="538598">rendu ;</p></li><li id="r-538601" data-claire-element-id="538601"><p id="r-538600" data-claire-element-id="538600">désactivation.</p></li></ol><p id="r-538603" data-claire-element-id="538603">Lors de la seconde étape, OpenGL ne fait que retenir un pointeur (une adresse mémoire) et des informations sur la structuration des données (<code data-claire-semantic="c">stride </code>, <code data-claire-semantic="c">type </code> et <code data-claire-semantic="c">size </code>). À la 3e étape, OpenGL envoie les informations au serveur pour le traitement (upload).</p><p id="r-538604" data-claire-element-id="538604">Un peu vaseux comme explication ? Ok :D :</p><figure id="r-538606" data-claire-element-id="538607"><img id="r-538605" data-claire-element-id="538605" src="medias/uploads.siteduzero.com_files_69001_70000_69083.gif" alt="Image utilisateur"/></figure><p id="r-538608" data-claire-element-id="538608">Comme vous pouvez le voir, les données sont dupliquées en mémoire vidéo, dans le cas des vertex arrays, puis sont traitées pour enfin être affichées à l'écran. Ce processus a lieu à chaque rendu (<code data-claire-semantic="c">glDraw*() </code>) : si vous avez beaucoup de géométrie à envoyer à votre carte graphique, je vous laisse imaginer le topo... Le transfert d'un million de vertices (par exemple) à chaque rendu mènerait à une saturation de la bande passante, et donc à une limitation de <em>frame rate</em>.<br/> L'idée des VBO est simple : on met les données directement du côté du serveur, et elles y restent. :D Cela nous économisera le transfert des données à chaque <em>frame</em>, ce qui est un énorme gain de performance. ;)</p><p id="r-538609" data-claire-element-id="538609">Voici ce qui se passe dans le cas des VBO :</p><figure id="r-538611" data-claire-element-id="538612"><img id="r-538610" data-claire-element-id="538610" src="medias/uploads.siteduzero.com_files_69001_70000_69084.gif" alt="Image utilisateur"/></figure><p id="r-538613" data-claire-element-id="538613">Les données ne sont ni dupliquées, ni transférées à chaque rendu. :) Du coup, lors d'un appel à <code data-claire-semantic="c">glDraw*() </code>, OpenGL ira directement chercher nos données en mémoire vidéo. Que demande le peuple ?</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">
<span class="arrow"></span>
<span class="next">Les Vertex Buffer Objects</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
<span class="next">Création d&#039;un objet tampon</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Crationd039unobjettampon"></a><h2>Création d&#039;un objet tampon</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
<span class="arrow"></span>
<span class="next">Les VBO, des données côté serveur</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
<span class="next">Héberger des données</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-creation-d-un-objet-tampon" data-claire-element-id="538664">Création d'un objet tampon</h4><p id="r-538615" data-claire-element-id="538615">Un VBO est un objet, un objet OpenGL, donc un <strong>GLuint</strong>.<br/> Celui-ci se manipule comme tous les objets OpenGL, sans exception apparente, avec des fonctions préfixées <code data-claire-semantic="c">Gen </code>, <code data-claire-semantic="c">Is </code>, <code data-claire-semantic="c">Delete </code> et <code data-claire-semantic="c">Bind </code>.</p><p id="r-538616" data-claire-element-id="538616">Voici comment créer un identifiant pour un objet tampon :</p><pre id="r-538617" data-claire-element-id="538617"><code data-claire-semantic="c">GLuint buf;

glGenBuffers(1, &amp;buf);</code></pre><p id="r-538618" data-claire-element-id="538618">Rien de bien sorcier. :)</p><p id="r-538619" data-claire-element-id="538619">Lorsque nous voudrons appliquer des modifications à notre tampon (envoi de données, modifications diverses...) nous devrons, comme pour tout objet OpenGL, le <em>binder</em>. Voici le prototype de la fonction permettant le <em>binding</em> d'un objet tampon :</p><pre id="r-538620" data-claire-element-id="538620"><code data-claire-semantic="c">void glBindBuffer(GLenum target, GLuint id);</code></pre><div id="r-538622" data-claire-element-id="538622" data-claire-semantic="question"><p id="r-538621" data-claire-element-id="538621">C'est quoi ce paramètre <code data-claire-semantic="c">target </code> ? Il me fait peur. :euh:</p></div><p id="r-538623" data-claire-element-id="538623">Il s'agit de placer ici une constante symbolique, nous nous en tiendrons à <code data-claire-semantic="c">GL_ARRAY_BUFFER </code> pour le moment.</p><p id="r-538624" data-claire-element-id="538624">Bien, commençons la création d'un code source complet, que nous compléterons au fur et à mesure :) :</p><pre id="r-538625" data-claire-element-id="538625"><code data-claire-semantic="c">#include &lt;SDL/SDL.h&gt;
#include &lt;GL/glew.h&gt;

/* dimensions de la fenetre */
#define W 300
#define H 200

int main(int argc, char **argv)
{
    int loop = 1;       /* booleen du 'main loop' */
    SDL_Event ev;       /* structure d'evenement(s) SDL */
    GLuint buf;         /* identifiant de notre objet tampon */
    
    /* initialisation de la SDL en mode OpenGL */
    SDL_Init(SDL_INIT_VIDEO);
    SDL_SetVideoMode(W, H, 32, SDL_OPENGL);
    
    /* nom de la fenetre */
    SDL_WM_SetCaption(&quot;Vertex Buffer Objects GL&quot;, NULL);
    
    /* initialisation de glew */
    glewInit();
    
    /* creation d'un objet tampon et recuperation de son identifiant */
    glGenBuffers(1, &amp;buf);
    
    /* boucle d'affichage principale */
    while(loop)
    {
        /* recuperation d'un evenement */
        SDL_WaitEvent(&amp;ev);
        
        /* analyse */
        if(ev.type == SDL_QUIT)
            loop = 0;
        
        glClear(GL_COLOR_BUFFER_BIT);
        
        /* rendu ... */
        
        /* on flip les tampons */
        glFlush();
        SDL_GL_SwapBuffers();
    }
    
    return 0;
}</code></pre><p id="r-538626" data-claire-element-id="538626">Notez la présence du fichier glew.h à la place de gl.h.<br/> En effet, les Vertex Buffer Objects sont en réalité une <strong>extension</strong> d'OpenGL.</p><div id="r-538628" data-claire-element-id="538628" data-claire-semantic="question"><p id="r-538627" data-claire-element-id="538627">C'est quoi, une extension d'OpenGL ?</p></div><p id="r-538629" data-claire-element-id="538629">Je vous conseille d'aller lire <a href="http://www.siteduzero.com/tuto-3-17911-1-opengl-les-extensions.html">mon tutoriel sur la gestion des extensions d'OpenGL</a>, il vous expliquera entre autres la présence de glew.h à la place de gl.h. Sa lecture est indispensable si vous souhaitez pouvoir utiliser les VBO.<br/> L'extension des VBO s'appelle <code data-claire-semantic="c"><strong>GL_ARB_vertex_buffer_object </strong></code>.</p><h5 id="r-allouer-un-espace-de-stockage" data-claire-element-id="538663">Allouer un espace de stockage</h5><p id="r-538630" data-claire-element-id="538630">Comme nous le savons à présent, les VBO sont des <em>buffers</em> (tampons) contenant des données qui se trouvent du côté de la mémoire du serveur. Comme pour toute gestion de mémoire, il faut commencer par l'allouer. Nous allons donc allouer de la mémoire côté serveur, pour y placer ensuite les données de nos sommets.<br/> Voici la fonction permettant d'allouer de la mémoire pour un VBO :</p><pre id="r-538631" data-claire-element-id="538631"><code data-claire-semantic="c">void glBufferData(GLenum target, GLsizei size, const GLvoid *data, GLenum mode);</code></pre><ul id="r-538640" data-claire-element-id="538640"><li id="r-538633" data-claire-element-id="538633"><p id="r-538632" data-claire-element-id="538632"><code data-claire-semantic="c"><strong>target </strong></code> : dans notre cas, il s'agit de <code data-claire-semantic="c">GL_ARRAY_BUFFER </code>. Attention, un buffer bindé avec cette constante doit toujours être utilisé avec la même ; donc à partir de maintenant, partout où vous verrez <code data-claire-semantic="c">target </code>, il faudra mettre le <code data-claire-semantic="c">target </code> de votre buffer. Un buffer ne peut avoir qu'un seul <code data-claire-semantic="c">target </code>.</p></li><li id="r-538635" data-claire-element-id="538635"><p id="r-538634" data-claire-element-id="538634"><code data-claire-semantic="c"><strong>size </strong></code> : c'est la taille de vos données, en bytes.</p></li><li id="r-538637" data-claire-element-id="538637"><p id="r-538636" data-claire-element-id="538636"><code data-claire-semantic="c"><strong>data </strong></code> : ceci désigne l'emplacement de vos données ; pour l'instant nous ne mettrons rien, la fonction <code data-claire-semantic="c">glBufferData() </code> est surtout destinée à réserver un espace mémoire.</p></li><li id="r-538639" data-claire-element-id="538639"><p id="r-538638" data-claire-element-id="538638"><code data-claire-semantic="c"><strong>mode </strong></code> : paramètre un peu particulier. Il sert à définir le mode de traitement de vos données lors de leur mise à jour.</p></li></ul><p id="r-538641" data-claire-element-id="538641">Comme je viens de le dire, le dernier paramètre est un peu bizarre... En fait, il définit votre fréquence d'accès à vos données (voir dernière partie de ce chapitre sur la mise à jour d'un VBO). Voyons la liste des constantes acceptées pour <code data-claire-semantic="c">mode </code> :</p><ul id="r-538648" data-claire-element-id="538648"><li id="r-538643" data-claire-element-id="538643"><p id="r-538642" data-claire-element-id="538642"><code data-claire-semantic="c">GL_STREAM_DRAW </code> : vous mettez vos données à jour à chaque affichage (<code data-claire-semantic="c">glDraw*() </code>) ;</p></li><li id="r-538645" data-claire-element-id="538645"><p id="r-538644" data-claire-element-id="538644"><code data-claire-semantic="c">GL_DYNAMIC_DRAW </code> : vous mettez fréquemment à jour vos données (plus d'une fois par affichage) ;</p></li><li id="r-538647" data-claire-element-id="538647"><p id="r-538646" data-claire-element-id="538646"><code data-claire-semantic="c">GL_STATIC_DRAW </code> : vous mettez peu souvent - voire jamais - vos données à jour.</p></li></ul><p id="r-538649" data-claire-element-id="538649">Nous nous contenterons de <code data-claire-semantic="c">GL_STREAM_DRAW </code> pour l'instant, qui s'adapte très bien à toutes les situations. ;)</p><div id="r-538651" data-claire-element-id="538651" data-claire-semantic="question"><p id="r-538650" data-claire-element-id="538650">Euh, où est-ce qu'on dit à cette fonction qu'on veut appliquer nos modifications sur notre objet <code data-claire-semantic="c">buf </code> et non ailleurs ?</p></div><p id="r-538652" data-claire-element-id="538652">Comme pout tout objet OpenGL, il est nécessaire de le binder (<code data-claire-semantic="c">glBindBuffer() </code> dans notre cas) pour spécifier l'objet actif, et ainsi appliquer toutes les modifications futures sur cet objet et non sur un autre. Afin de dire à OpenGL qu'aucun objet tampon n'est actif, appelez <code data-claire-semantic="c">glBindBuffer() </code> avec un identifiant de 0 :</p><pre id="r-538653" data-claire-element-id="538653"><code data-claire-semantic="c">glBindBuffer(GL_ARRAY_BUFFER, 0);</code></pre><aside id="r-538655" data-claire-element-id="538655" data-claire-semantic="information"><p id="r-538654" data-claire-element-id="538654">Cela fonctionne pareil pour tous les objets OpenGL, exemple pour les textures : <code data-claire-semantic="c">glBindTexture(GL_TEXTURE_2D, 0) </code>.</p></aside><p id="r-538656" data-claire-element-id="538656">Voyons à présent à quoi ressemble notre code :</p><pre id="r-538657" data-claire-element-id="538657"><code data-claire-semantic="c">#include &lt;SDL/SDL.h&gt;
#include &lt;GL/glew.h&gt;

/* dimensions de la fenetre */
#define W 300
#define H 200

int main(int argc, char **argv)
{
    int loop = 1;       /* booleen du 'main loop' */
    SDL_Event ev;       /* structure d'evenement(s) SDL */
    GLuint buf;         /* identifiant de notre objet tampon */
    
    #define N_VERTS 3
    #define P_SIZE 2
    #define C_SIZE 3
    
    float pos[N_VERTS*P_SIZE] =
    {
        -0.8, -0.8,
        0.8, -0.8,
        0.0, 0.8
    };
    
    float colors[N_VERTS*C_SIZE] =
    {
        1.0, 0.0, 0.0,
        0.0, 1.0, 0.0,
        0.0, 0.0, 1.0
    };
    
    
    /* initialisation de la SDL en mode OpenGL */
    SDL_Init(SDL_INIT_VIDEO);
    SDL_SetVideoMode(W, H, 32, SDL_OPENGL);
    
    /* nom de la fenetre */
    SDL_WM_SetCaption(&quot;Vertex Buffer Objects GL&quot;, NULL);
    
    /* initialisation de glew */
    glewInit();
    
    /* creation d'un objet tampon et recuperation de son identifiant */
    glGenBuffers(1, &amp;buf);
    
    /* on bind le buffer afin que glBufferData s'applique sur buf */
    glBindBuffer(GL_ARRAY_BUFFER, buf);
    
    /* on alloue de l'espace */
    glBufferData(GL_ARRAY_BUFFER,                   /* target */
                  (N_VERTS*P_SIZE*sizeof *pos) +    /* taille des positions */
                  (N_VERTS*C_SIZE*sizeof *colors),  /* taille des couleurs */
                 NULL,                              /* ... */
                 GL_STREAM_DRAW);                   /* mode */
    
    /* boucle d'affichage principale */
    while(loop)
    {
        /* recuperation d'un evenement */
        SDL_WaitEvent(&amp;ev);
        
        /* analyse */
        if(ev.type == SDL_QUIT)
            loop = 0;
        
        glClear(GL_COLOR_BUFFER_BIT);
        
        /* rendu ... */
        
        /* on flip les tampons */
        glFlush();
        SDL_GL_SwapBuffers();
    }
    
    /* suppression de l'objet tampon */
    glDeleteBuffers(1, &amp;buf);
    
    return 0;
}</code></pre><p id="r-538658" data-claire-element-id="538658">La suppression d'un objet tampon se fait en toute simplicité :</p><pre id="r-538659" data-claire-element-id="538659"><code data-claire-semantic="c">glDeleteBuffers(1, &amp;buf);</code></pre><div id="r-538661" data-claire-element-id="538661" data-claire-semantic="question"><p id="r-538660" data-claire-element-id="538660">Et on ne libère pas la mémoire (<code data-claire-semantic="c">free() </code>) ?</p></div><p id="r-538662" data-claire-element-id="538662">OpenGL s'en charge lors de l'appel à <code data-claire-semantic="c">glDeleteBuffers() </code>. ;)</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
<span class="arrow"></span>
<span class="next">Les VBO, des données côté serveur</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
<span class="next">Héberger des données</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Hbergerdesdonnes"></a><h2>Héberger des données</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
<span class="arrow"></span>
<span class="next">Création d&#039;un objet tampon</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
<span class="next">Exploiter des données hébergées</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-heberger-des-donnees" data-claire-element-id="538708">Héberger des données</h4><div id="r-538666" data-claire-element-id="538666" data-claire-semantic="question"><p id="r-538665" data-claire-element-id="538665">Bon, c'est bien joli tout ça, je sais créer un VBO, lui allouer de la mémoire sur le serveur, le détruire, mais je ne sais toujours pas quoi faire de mes tableaux de sommets !</p></div><p id="r-538667" data-claire-element-id="538667">Nous y voilà. ^^</p><p id="r-538668" data-claire-element-id="538668">Pour ceux qui maîtriseraient déjà la création et la manipulation des textures, vous devriez savoir que <code data-claire-semantic="c">glTexImage*() </code>, c'est pour allouer un espace, <code data-claire-semantic="c">glTexSubImage*() </code> pour remplir / mettre à jour cet espace.<br/> Eh bien avec les VBO, c'est pareil. :)</p><pre id="r-538669" data-claire-element-id="538669"><code data-claire-semantic="c">glBufferSubData(GLenum target, GLint first, GLsizei size, const GLvoid *data);</code></pre><pre id="r-538670" data-claire-element-id="538670"><code data-claire-semantic="c">target</code></pre><p id="r-538671" data-claire-element-id="538671">, <code data-claire-semantic="c">size </code> et <code data-claire-semantic="c">data </code> sont équivalents à ceux de la fonction <code data-claire-semantic="c">glBufferData() </code>. Ici, nous avons droit à un nouveau paramètre : <code data-claire-semantic="c">first </code>.</p><ul id="r-538674" data-claire-element-id="538674"><li id="r-538673" data-claire-element-id="538673"><p id="r-538672" data-claire-element-id="538672"><code data-claire-semantic="c"><strong>first </strong></code> : indique l'emplacement mémoire (en bytes) dans le VBO où commencer le stockage des données.</p></li></ul><p id="r-538675" data-claire-element-id="538675">Au début, cette valeur sera logiquement à zéro (début de la mémoire de notre VBO, OpenGL y additionnera automatiquement la véritable adresse de notre buffer). Mais supposons que nous voulions ajouter des données par la suite : pour éviter d'écraser les précédentes, il faudra spécifier explicitement via <code data-claire-semantic="c">first </code> où commencer la copie des données dans la mémoire du VBO.</p><div id="r-538677" data-claire-element-id="538677" data-claire-semantic="question"><p id="r-538676" data-claire-element-id="538676">J'ai rien compris...</p></div><p id="r-538678" data-claire-element-id="538678">Je vous propose de reprendre mes super schémas. :p <br/> Voici la mémoire du VBO, sa taille est égale à celle spécifiée dans <code data-claire-semantic="c">glBufferData() </code> :</p><figure id="r-538680" data-claire-element-id="538681"><img id="r-538679" data-claire-element-id="538679" src="medias/uploads.siteduzero.com_files_69001_70000_69085.gif" alt="Image utilisateur"/></figure><p id="r-538682" data-claire-element-id="538682">Bien, nous allons commencer simplement.<br/> Tout d'abord, nous allons y stocker nos positions de sommet :</p><table id="r-538691" data-claire-element-id="538691"><tbody id="r-538690" data-claire-element-id="538690"><tr id="r-538685" data-claire-element-id="538685"><td id="r-538684" data-claire-element-id="538684"><pre id="r-538683" data-claire-element-id="538683"><code data-claire-semantic="c">glBufferSubData(GL_ARRAY_BUFFER,
                0,                            /* emplacement des donnees dans le VBO (first) */
                (N_VERTS*P_SIZE*sizeof *pos), /* taille des donnees (size) */
                pos);                         /* adresse des donnees */</code></pre></td></tr><tr id="r-538689" data-claire-element-id="538689"><td id="r-538687" data-claire-element-id="538688"><img id="r-538688" data-claire-element-id="538687" src="medias/uploads.siteduzero.com_files_69001_70000_69086.gif" alt="Image utilisateur"/><img id="r-538686" data-claire-element-id="538686" src="medias/uploads.siteduzero.com_files_69001_70000_69086.gif" alt="Image utilisateur"/></td></tr></tbody></table><p id="r-538692" data-claire-element-id="538692">Voilà qui est fait. :)</p><p id="r-538693" data-claire-element-id="538693">En fait, c'est ici que le transfert des données (upload) de la mémoire centrale vers la mémoire vidéo a lieu.</p><p id="r-538694" data-claire-element-id="538694">Bien. Puisque nous avons stocké avec succès nos positions de sommets, faisons de même avec les couleurs :</p><table id="r-538703" data-claire-element-id="538703"><tbody id="r-538702" data-claire-element-id="538702"><tr id="r-538697" data-claire-element-id="538697"><td id="r-538696" data-claire-element-id="538696"><pre id="r-538695" data-claire-element-id="538695"><code data-claire-semantic="c">glBufferSubData(GL_ARRAY_BUFFER,
                (N_VERTS*P_SIZE*sizeof *pos),   /* emplacement (first) */
                (N_VERTS*C_SIZE*sizeof *colors),/* taille (size) */
                colors);                        /* donnees */</code></pre></td></tr><tr id="r-538701" data-claire-element-id="538701"><td id="r-538699" data-claire-element-id="538700"><img id="r-538700" data-claire-element-id="538699" src="medias/uploads.siteduzero.com_files_69001_70000_69087.gif" alt="Image utilisateur"/><img id="r-538698" data-claire-element-id="538698" src="medias/uploads.siteduzero.com_files_69001_70000_69087.gif" alt="Image utilisateur"/></td></tr></tbody></table><p id="r-538704" data-claire-element-id="538704">Comme vous le voyez (j'espère :p ) nous avons dû spécifier explicitement à partir d'où OpenGL avait le droit de stocker nos données dans la mémoire du VBO. Puisque nous avions déjà stocké nos positions de sommet, si on avait laissé <code data-claire-semantic="c">first </code> à zéro, il y aurait eu un écrasement de données (écrasement de <code data-claire-semantic="c">pos </code> par <code data-claire-semantic="c">colors </code>).</p><div id="r-538706" data-claire-element-id="538706" data-claire-semantic="question"><p id="r-538705" data-claire-element-id="538705">Pourquoi OpenGL ne gère-t-il pas tout seul le stockage de nos données ?</p></div><p id="r-538707" data-claire-element-id="538707">Parce qu'OpenGL est une API bas niveau, il faut donc que vous puissiez faire un maximum de choses, imaginez que vous vouliez mettre à jour vos données, comment feriez-vous ? OpenGL vous laisse l'opportunité de vous gourer, mais aussi de faire ce que vous voulez ;)</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
<span class="arrow"></span>
<span class="next">Création d&#039;un objet tampon</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
<span class="next">Exploiter des données hébergées</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Exploiterdesdonneshberges"></a><h2>Exploiter des données hébergées</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
<span class="arrow"></span>
<span class="next">Héberger des données</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
<span class="next">Hébergement et utilisation d&#039;un tableau d&#039;indices</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-exploiter-des-donnees-hebergees" data-claire-element-id="538744">Exploiter des données hébergées</h4><p id="r-538709" data-claire-element-id="538709">Faisons le point. :)</p><ul id="r-538718" data-claire-element-id="538718"><li id="r-538711" data-claire-element-id="538711"><p id="r-538710" data-claire-element-id="538710">Nous savons créer un VBO.</p></li><li id="r-538713" data-claire-element-id="538713"><p id="r-538712" data-claire-element-id="538712">Nous savons lui allouer de l'espace mémoire sur le serveur.</p></li><li id="r-538715" data-claire-element-id="538715"><p id="r-538714" data-claire-element-id="538714">Nous savons remplir cet espace convenablement.</p></li><li id="r-538717" data-claire-element-id="538717"><p id="r-538716" data-claire-element-id="538716">Nous savons détruire un VBO (cela implique la destruction des données du côté serveur).</p></li></ul><p id="r-538719" data-claire-element-id="538719">C'est bien me direz-vous, mais comment on va afficher ça ?</p><h5 id="r-specifier-une-adresse-memoire-situee-du-cote-serveur" data-claire-element-id="538740">Spécifier une adresse mémoire située du côté serveur</h5><p id="r-538720" data-claire-element-id="538720">En fait ce n'est rien de bien compliqué, vous allez voir. Pour tout vous dire, l'explication tient en deux phrases. :-°</p><ol id="r-538725" data-claire-element-id="538725"><li id="r-538722" data-claire-element-id="538722"><p id="r-538721" data-claire-element-id="538721">Bindez votre buffer (<code data-claire-semantic="c">glBindBuffer() </code>).</p></li><li id="r-538724" data-claire-element-id="538724"><p id="r-538723" data-claire-element-id="538723">Appelez <code data-claire-semantic="c">gl*Pointer() </code> avec pour adresse... 0.</p></li></ol><p id="r-538726" data-claire-element-id="538726">Ça mérite bien quelques explications, tout de même. En effet, lors de l'appel à <code data-claire-semantic="c">glBindBuffer() </code> avec un identifiant valide, OpenGL passe en mode VBO et tous les appels à <code data-claire-semantic="c">gl*Pointer() </code> pointent alors sur les données de notre VBO gentiment bindé.</p><p id="r-538727" data-claire-element-id="538727">Vous allez voir, avec un exemple ça ira tout de suite mieux :</p><pre id="r-538728" data-claire-element-id="538728"><code data-claire-semantic="c">#define BUFFER_OFFSET(a) ((char*)NULL + (a))

/* on passe en mode VBO */
glBindBuffer(GL_ARRAY_BUFFER, buf);

glVertexPointer(P_SIZE, GL_FLOAT, 0, BUFFER_OFFSET(0));
glColorPointer(C_SIZE, GL_FLOAT, 0, BUFFER_OFFSET(N_VERTS*P_SIZE*sizeof *pos));</code></pre><div id="r-538730" data-claire-element-id="538730" data-claire-semantic="question"><p id="r-538729" data-claire-element-id="538729"><code data-claire-semantic="c">BUFFER_OFFSET </code> ? Avons-nous été présentés ?</p></div><p id="r-538731" data-claire-element-id="538731">Non, effectivement. Il s'agit d'une macro fournie par les spécifications qui vous permet de donner un <code data-claire-semantic="c">offset </code> et non une adresse.<br/> En fait, au lieu de donner notre tableau à <code data-claire-semantic="c">gl*Pointer() </code>, nous donnons sa position de stockage dans le VBO...</p><div id="r-538735" data-claire-element-id="538735" data-claire-semantic="question"><p id="r-538732" data-claire-element-id="538732">Son</p><pre id="r-538733" data-claire-element-id="538733"><code data-claire-semantic="c">first</code></pre><p id="r-538734" data-claire-element-id="538734">!</p></div><p id="r-538736" data-claire-element-id="538736">Tout à fait. ;)</p><p id="r-538737" data-claire-element-id="538737">Voici notre code à présent complété :</p><pre id="r-538738" data-claire-element-id="538738"><code data-claire-semantic="c">#include &lt;SDL/SDL.h&gt;
#include &lt;GL/glew.h&gt;

/* dimensions de la fenetre */
#define W 300
#define H 200

#define BUFFER_OFFSET(a) ((char*)NULL + (a))

int main(int argc, char **argv)
{
    int loop = 1;       /* booleen du 'main loop' */
    SDL_Event ev;       /* structure d'evenement(s) SDL */
    GLuint buf;         /* identifiant de notre objet tampon */
    
    #define N_VERTS 3
    #define P_SIZE 2
    #define C_SIZE 3
    
    float pos[N_VERTS*P_SIZE] =
    {
        -0.8, -0.8,
        0.8, -0.8,
        0.0, 0.8
    };
    
    float colors[N_VERTS*C_SIZE] =
    {
        1.0, 0.0, 0.0,
        0.0, 1.0, 0.0,
        0.0, 0.0, 1.0
    };
    
    
    /* initialisation de la SDL en mode OpenGL */
    SDL_Init(SDL_INIT_VIDEO);
    SDL_SetVideoMode(W, H, 32, SDL_OPENGL);
    
    /* nom de la fenetre */
    SDL_WM_SetCaption(&quot;Vertex Buffer Objects GL&quot;, NULL);
    
    /* initialisation de glew */
    glewInit();
    
    /* creation d'un objet tampon et recuperation de son identifiant */
    glGenBuffers(1, &amp;buf);
    
    
    /** creation de notre VBO **/
    
    /* on bind le buffer */
    glBindBuffer(GL_ARRAY_BUFFER, buf);
    
    /* on alloue un espace */
    glBufferData(GL_ARRAY_BUFFER,                   /* target */
                    (N_VERTS*P_SIZE*sizeof *pos) +  /* taille des positions */
                    (N_VERTS*C_SIZE*sizeof *colors),/* taille des couleurs */
                    NULL,                           /* ... */
                    GL_STREAM_DRAW);                /* mode */
    
    /* on specifie les donnees */
    glBufferSubData(GL_ARRAY_BUFFER,
                    0,                            /* emplacement des donnees dans le VBO */
                    (N_VERTS*P_SIZE*sizeof *pos), /* taille des donnees */
                    pos);                         /* adresse des donnees */
    
    glBufferSubData(GL_ARRAY_BUFFER,
                    (N_VERTS*P_SIZE*sizeof *pos),   /* emplacement */
                    (N_VERTS*C_SIZE*sizeof *colors),/* taille */
                    colors);                        /* donnees */
    
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    
    /** fin **/
    
    /* boucle d'affichage principale */
    while(loop)
    {
        /* recuperation d'un evenement */
        SDL_WaitEvent(&amp;ev);
        
        /* analyse */
        if(ev.type == SDL_QUIT)
            loop = 0;
        
        glClear(GL_COLOR_BUFFER_BIT);
        
        /* on passe en mode VBO */
        glBindBuffer(GL_ARRAY_BUFFER, buf);
        
        glVertexPointer(P_SIZE, GL_FLOAT, 0, BUFFER_OFFSET(0));
        glColorPointer(C_SIZE, GL_FLOAT, 0, BUFFER_OFFSET(N_VERTS*P_SIZE*sizeof *pos));
        
        /* activation des tableaux de sommets */
        glEnableClientState(GL_VERTEX_ARRAY);
        glEnableClientState(GL_COLOR_ARRAY);
        
        glDrawArrays(GL_TRIANGLES, 0, 3);
        
        /* desactivation des tableaux de sommets */
        glDisableClientState(GL_COLOR_ARRAY);
        glDisableClientState(GL_VERTEX_ARRAY);
        
        /* on flip les tampons */
        glFlush();
        SDL_GL_SwapBuffers();
    }
    
    glDeleteBuffers(1, &amp;buf);
    
    return 0;
}</code></pre><p id="r-538739" data-claire-element-id="538739">Hé oui, j'en ai profité pour rajouter un petit <code data-claire-semantic="c">glDrawArrays() </code>. En effet, le rendu est à présent possible puisque nous avons spécifié nos données à <code data-claire-semantic="c">gl*Pointer() </code>. ;)</p><h5 id="r-utiliser-plusieurs-vbo-en-meme-temps" data-claire-element-id="538743">Utiliser plusieurs VBO en même temps</h5><p id="r-538741" data-claire-element-id="538741">Sachez que c'est tout à fait possible, et même conseillé dans certains cas.<br/> Imaginez que vous avez fait un programme qui permet à l'utilisateur d'activer et de désactiver la couleur à volonté. Lorsqu'elle est désactivée, l'utilisation des informations de coloration est inutile et s'avèrerait être une perte de performance plus qu'autre chose.<br/> Nous allons donc séparer nos couleurs de nos positions de sommets. Je pense que pour l'occasion, un bout de code vaut mieux qu'un long discours ; si vous avez bien compris l'utilisation d'un VBO, ce code ne devrait pas vous poser de problèmes :</p><pre id="r-538742" data-claire-element-id="538742"><code data-claire-semantic="c">GLuint buf_pos, buf_col;
    
    ...
    
    
    /* creation de nos VBO */
    glGenBuffers(1, &amp;buf_pos);
    glGenBuffers(1, &amp;buf_col);
    
    
    /* on bind le buffer des positions de sommets */
    glBindBuffer(GL_ARRAY_BUFFER, buf_pos);
    
    /* on alloue un espace */
    glBufferData(GL_ARRAY_BUFFER, (N_VERTS*P_SIZE*sizeof *pos), NULL, GL_STREAM_DRAW);
    /* on specifie les donnees */
    glBufferSubData(GL_ARRAY_BUFFER, 0, (N_VERTS*P_SIZE*sizeof *pos), pos);
    
    
    /* on bind le buffer des positions de sommets */
    glBindBuffer(GL_ARRAY_BUFFER, buf_col);
    
    /* on alloue un espace */
    glBufferData(GL_ARRAY_BUFFER, (N_VERTS*C_SIZE*sizeof *colors), NULL, GL_STREAM_DRAW);
    /* on specifie les donnees */
    glBufferSubData(GL_ARRAY_BUFFER, 0, (N_VERTS*C_SIZE*sizeof *colors), colors);
    
    
    /* plus aucun buffer n'est a utiliser */
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    
    ...
    
    
    /* specification du buffer des positions de sommets */
    glBindBuffer(GL_ARRAY_BUFFER, buf_pos);
    glVertexPointer(P_SIZE, GL_FLOAT, 0, BUFFER_OFFSET(0));
    
    /* specification du buffer des couleurs de sommets */
    glBindBuffer(GL_ARRAY_BUFFER, buf_col);
    glColorPointer(C_SIZE, GL_FLOAT, 0, BUFFER_OFFSET(0));
    
    ...
    
    
    /* suppression de nos VBO */
    glDeleteBuffers(1, &amp;buf_col);
    glDeleteBuffers(1, &amp;buf_pos);</code></pre>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
<span class="arrow"></span>
<span class="next">Héberger des données</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
<span class="next">Hébergement et utilisation d&#039;un tableau d&#039;indices</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Hbergementetutilisationd039untableaud039indices"></a><h2>Hébergement et utilisation d&#039;un tableau d&#039;indices</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
<span class="arrow"></span>
<span class="next">Exploiter des données hébergées</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
<span class="next">Mettre à jour un tampon</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-hebergement-et-utilisation-d-un-tableau-d-indices" data-claire-element-id="538755">Hébergement et utilisation d'un tableau d'indices</h4><p id="r-538745" data-claire-element-id="538745">Eh oui, à nouveau ces fameux indices : sachez qu'ils sont tout à fait adaptés avec l'utilisation des VBO. :) <br/> Tout comme nos sommets, nos indices seront également hébergés sur notre serveur.</p><h5 id="r-heberger-un-tableau-d-indices" data-claire-element-id="538754">Héberger un tableau d'indices</h5><p id="r-538746" data-claire-element-id="538746">Cela se passe exactement comme pour héberger un tableau de données quelconques. :) À quelques exceptions près.<br/> Vous vous souvenez de <code data-claire-semantic="c">target </code>, ce paramètre à priori inutile ? Eh bien dans le cas des index buffers (ou tableau d'indices, ou encore tampon d'indices), il va falloir placer ce paramètre à <code data-claire-semantic="c">GL_ELEMENT_ARRAY_BUFFER </code>.</p><aside id="r-538748" data-claire-element-id="538748" data-claire-semantic="information"><p id="r-538747" data-claire-element-id="538747">Nous appellerons donc ces buffers des IBO (Index Buffer Objects), car ils hébergent des indices (index), et non des sommets (vertex).</p></aside><h6 id="r-exemple-d-utilisation-18" data-claire-element-id="538753">Exemple d'utilisation</h6><p id="r-538749" data-claire-element-id="538749">Nous allons sauter les étapes de stockage des tableaux de sommets, vous les connaissez suffisamment bien :</p><pre id="r-538750" data-claire-element-id="538750"><code data-claire-semantic="c">GLuint buf_index;
    
    ...
    
    
    glGenBuffers(1, &amp;buf_index);
    
    /* construction du IBO */
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buf_index);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, N_VERTS * sizeof *index, NULL, GL_STREAM_DRAW);
    glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, 0, N_VERTS * sizeof *index, index);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
    
    ...
    
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, buf_index);
    glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, BUFFER_OFFSET(0));
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);</code></pre><p id="r-538751" data-claire-element-id="538751">À l'instar d'un appel à <code data-claire-semantic="c">glBindBuffer() </code> avec <code data-claire-semantic="c">GL_ARRAY_BUFFER </code>, lorsqu'on met <code data-claire-semantic="c">GL_ELEMENT_ARRAY_BUFFER </code> c'est la fonction <code data-claire-semantic="c">glDrawElements() </code> qui est affectée et qui pointe alors vers le tampon (IBO) actif.<br/> Je pense que le reste se passe aisément de commentaires, surtout si vous avez bien compris le concept des VBO. ;)</p><p id="r-538752" data-claire-element-id="538752">Le stockage des indices dans un tampon côté serveur n'est pas obligatoire, mais cela a de fortes chances d'augmenter les performances de votre application. ;)</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
<span class="arrow"></span>
<span class="next">Exploiter des données hébergées</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
<span class="next">Mettre à jour un tampon</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Mettrejouruntampon"></a><h2>Mettre à jour un tampon</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
<span class="arrow"></span>
<span class="next">Hébergement et utilisation d&#039;un tableau d&#039;indices</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-mettre-a-jour-un-tampon" data-claire-element-id="538785">Mettre à jour un tampon</h4><p id="r-538756" data-claire-element-id="538756">Il nous reste un dernier point à éclaircir, et nous aurons fait le tour des VBO et de leur utilisation en général. :)</p><p id="r-538757" data-claire-element-id="538757">Supposons que vous vouliez faire une animation (celle d'un personnage, ou n'importe quel maillage animé), il va bien falloir déplacer vos sommets. Ce n'est pas tant le déplacement en lui-même qui nous intéresse, mais plutôt la façon de mettre à jour nos vertex buffers, qui sont perdus au fin fond de la mémoire de notre carte graphique.</p><h5 id="r-lire-et-ecrire-dans-un-vbo" data-claire-element-id="538784">Lire et écrire dans un VBO</h5><p id="r-538758" data-claire-element-id="538758">Bien, raisonnons logiquement.<br/> Si nous voulons accéder à nos données, il va falloir trouver leur adresse. Simple, il suffit de la demander à OpenGL. :) La fonction <code data-claire-semantic="c">glMapBuffer() </code> est là pour ça :</p><pre id="r-538759" data-claire-element-id="538759"><code data-claire-semantic="c">void* glMapBuffer(GLenum target, GLenum mode);</code></pre><ul id="r-538764" data-claire-element-id="538764"><li id="r-538761" data-claire-element-id="538761"><p id="r-538760" data-claire-element-id="538760"><code data-claire-semantic="c"><strong>target </strong></code> : bon, maintenant, celui-là vous le connaissez ;) ; si c'est pour mettre à jour un vertex buffer, vous mettrez <code data-claire-semantic="c">GL_ARRAY_BUFFER </code>, si c'est pour mettre à jour un index buffer, vous mettrez <code data-claire-semantic="c">GL_ELEMENT_ARRAY_BUFFER </code>.</p></li><li id="r-538763" data-claire-element-id="538763"><p id="r-538762" data-claire-element-id="538762"><code data-claire-semantic="c"><strong>&lt;italique&gt;&lt;/italique&gt; </strong></code>: ça, c'est déjà un paramètre un peu plus subtil, il vous permet de définir le mode d'accès à vos données. On peut comparer ce mode aux modes d'ouverture d'un fichier en C.</p></li></ul><p id="r-538765" data-claire-element-id="538765">Constantes symboliques acceptables pour <code data-claire-semantic="c">mode </code> :</p><ul id="r-538772" data-claire-element-id="538772"><li id="r-538767" data-claire-element-id="538767"><p id="r-538766" data-claire-element-id="538766"><code data-claire-semantic="c">GL_READ_ONLY </code> : les données seront accessibles en lecture seule ;</p></li><li id="r-538769" data-claire-element-id="538769"><p id="r-538768" data-claire-element-id="538768"><code data-claire-semantic="c">GL_WRITE_ONLY </code> : les données seront accessibles en écriture seule ;</p></li><li id="r-538771" data-claire-element-id="538771"><p id="r-538770" data-claire-element-id="538770"><code data-claire-semantic="c">GL_READ_WRITE </code> : les données seront accessibles en lecture et en écriture.</p></li></ul><p id="r-538773" data-claire-element-id="538773"><code data-claire-semantic="c">glMapBuffer() </code> renvoie un pointeur sur votre VBO.</p><p id="r-538774" data-claire-element-id="538774">En sup<code data-claire-semantic="c">posa</code>nt que vous ayez gardé une copie de vos données dans votre mémoire centrale (ce qui est le cas dans nos exemples ci-dessus : en effet, les tableaux pos et <code data-claire-semantic="c">colors </code> existent toujours), vous pouvez procéder à une mise à jour de vos données côté serveur de cette façon :</p><pre id="r-538775" data-claire-element-id="538775"><code data-claire-semantic="c">#include &lt;string.h&gt;

...


float *pos_vbo = NULL;

glBindBuffer(GL_ARRAY_BUFFER, buf_pos);
pos_vbo = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
if(pos_vbo == NULL)
{
    fprintf(stderr, &quot;impossible d'acceder aux donnees du vbo!\n&quot;);
    exit(EXIT_FAILURE);
}

/* transfert */
memcpy(pos_vbo, pos, N_VERTS * P_SIZE * sizeof *pos);

glUnmapBuffer(GL_ARRAY_BUFFER);
pos_vbo = NULL;</code></pre><p id="r-538776" data-claire-element-id="538776">Nouveauté du jour, la fonction <code data-claire-semantic="c">glUnmapBuffer() </code>. Elle a pour effet de rendre invalide le pointeur renvoyé par <code data-claire-semantic="c">glMapBuffer() </code>, je place donc logiquement mon pointeur à <code data-claire-semantic="c">NULL </code> après l'appel à <code data-claire-semantic="c">glUnmapBuffer() </code>.<br/> Autre détail important : il se peut (mais c'est rare, ou alors l'erreur provient de vous) que la récupération de l'adresse de votre VBO via <code data-claire-semantic="c">glMapBuffer() </code> échoue ; dans ce cas, <code data-claire-semantic="c">glMapBuffer() </code> renvoie <code data-claire-semantic="c">NULL </code>. C'est important de le vérifier, car écrire dans <code data-claire-semantic="c">NULL </code> provoque une erreur de segmentation (segmentation fault) assurée. ;)</p><p id="r-538777" data-claire-element-id="538777">Les VBO représentent à l'heure actuelle, et pour encore longtemps, la meilleure méthode de rendu et la plus utilisée. Les VBO combinent à merveille performances et flexibilité. Le fait de stocker nos données dans la mémoire de la carte graphique nous permet de libérer la nôtre (client) et d'optimiser le transfert des données pour procéder au rendu : en fait, plus aucun transfert n'a lieu, les données restent chez le serveur.<br/> Les VBO sont les plus utilisés dans les rendus 3D récents, et possèdent leur équivalent chez DirectX.<br/> Je vous conseille par-dessus tout les VBO (et IBO) pour effectuer vos rendus, vous verrez que lorsqu'on les maîtrise, il nous devient impossible de s'en passer. ;)</p><p id="r-538778" data-claire-element-id="538778">Et voilà, c'est la fin de ce tutoriel.</p><p id="r-538779" data-claire-element-id="538779">J'espère que vous aurez su en tirer le meilleur profit. :)</p><p id="r-538780" data-claire-element-id="538780"><em>Merci à G-Truc Création pour <a href="http://www.g-truc.net/article/vbo-fr.pdf">son excellent tutoriel sur les VBO</a> (pdf en français),<br/> par le biais duquel j'ai moi-même appris à m'en servir.</em> ;)</p><p id="r-538781" data-claire-element-id="538781">Il n'est pas improbable que ce tutoriel contienne quelques erreurs, des incohérences ou d'autres petites choses qui m'auraient échappé : si vous en décelez une, n'hésitez pas à m'en faire part. Si vous trouvez que certains passages ne sont pas clairs, ou que tout simplement vous avez du mal à les comprendre et que vous mettez en cause la qualité didactique, les commentaires de tutoriels sont là pour ça.</p><div id="r-538783" data-claire-element-id="538783"><p id="r-538782" data-claire-element-id="538782"><em>Merci à <a href="http://www.siteduzero.com/membres-294-23709.html">Nab</a> ainsi qu'à <a href="http://www.siteduzero.com/membres-294-30233.html">Kevin Leonhart</a> pour leurs relectures attentives</em> ;)</p></div>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo">Rendus optimisés : DL, VA, VBO</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Méthodes de rendu optimisé avec OpenGL
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-display-lists">Les display lists</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/qu-est-ce-donc">
Qu&#039;est-ce donc ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creer-une-display-list">
Créer une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/remplir-une-display-list">
Remplir une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/afficher-une-display-list">
Afficher une display list
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/limites-des-display-lists">
Limites des display lists
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-arrays">Les vertex arrays</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/fonctionnement-32">
Fonctionnement
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/specification-de-tableaux">
Spécification de tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/effectuer-un-rendu">
Effectuer un rendu
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/utilisation-d-indices">
Utilisation d&#039;indices
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vertex-buffer-objects">Les Vertex Buffer Objects</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/les-vbo-des-donnees-cote-serveur">
Les VBO, des données côté serveur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/creation-d-un-objet-tampon">
Création d&#039;un objet tampon
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/heberger-des-donnees">
Héberger des données
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/exploiter-des-donnees-hebergees">
Exploiter des données hébergées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
Hébergement et utilisation d&#039;un tableau d&#039;indices
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/mettre-a-jour-un-tampon">
Mettre à jour un tampon
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/rendus-optimises-dl-va-vbo/hebergement-et-utilisation-d-un-tableau-d-indices">
<span class="arrow"></span>
<span class="next">Hébergement et utilisation d&#039;un tableau d&#039;indices</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/rendus-optimises-dl-va-vbo.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 02:19:43 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/rendus-optimises-dl-va-vbo.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:33:10 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/compilez-sous-gnu-linux.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 02:19:28 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/compilez-sous-gnu-linux.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:33:04 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Compilez sous GNU/Linux !</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/compilez-sous-gnu-linux.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Compilez sous GNU/Linux !</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#CompilezsousGNU_Linux">Compilez sous GNU/Linux !</a><br/><a href="#LecompilateurGCCsousLinux">Le compilateur GCC sous Linux</a><br/><a href="#CompilerdesbibliothquesavecGCC">Compiler des bibliothèques avec GCC</a><br/><a href="#LacommandemakeetlefichierMakefile-Prsentation">La commande make et le fichier Makefile - Présentation</a><br/><a href="#Makefileunprprocesseur">Makefile : un préprocesseur ?</a><br/><a href="#Pourallerplusloin...">Pour aller plus loin...</a><br/></div>
<a name="CompilezsousGNU_Linux"></a><h2>Compilez sous GNU/Linux !</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/le-compilateur-gcc-sous-linux">
<span class="next">Le compilateur GCC sous Linux</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-379508" data-claire-element-id="379508">Bonjour à tous, petits développeurs linuxiens.</p><p id="r-379509" data-claire-element-id="379509">Vous trouvez votre IDE limité, moche, lourd ? Ou simplement vous aimeriez comprendre qu'est-ce qui se passe derrière quand vous compilez ? Vous êtes un défenseur de la console façe aux outils clickodrome ? Vous n'envisagez pas de coder sans vim ou emacs ? Ce tutoriel est fait pour vous !</p><p id="r-379510" data-claire-element-id="379510">A l'issue de ce tutoriel, vous serez capable de compiler vos programmes avec une simple console, grâce aux merveilleux outils GNU que sont gcc et make.</p>
</div><a name="LecompilateurGCCsousLinux"></a><h2>Le compilateur GCC sous Linux</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/compiler-des-bibliotheques-avec-gcc">
<span class="next">Compiler des bibliothèques avec GCC</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-un-peu-de-culture-1" data-claire-element-id="379514">Un peu de culture</h2><p id="r-379511" data-claire-element-id="379511">GCC signifie <em>GNU Compiler Collection</em>, autrefois un compilateur C (&quot;GNU C Compiler&quot;) devenu multilangage, est un compilateur sous Linux, permettant de compiler du C, du C++, du Java, et j'en passe...<br/> Pour plus de détails, : <a href="http://fr.wikipedia.org/wiki/GNU Compiler Collection">gcc sur wikipedia.</a></p><aside id="r-379513" data-claire-element-id="379513" data-claire-semantic="information"><p id="r-379512" data-claire-element-id="379512">Je prendrai comme exemple la compilation en C sous Debian &amp; consorts, mais vous pourrez utiliser les informations de ce tuto pour d'autres langages et sous d'autres distributions !</p></aside><h2 id="r-compilez-avec-gcc" data-claire-element-id="379533">Compilez avec GCC</h2><h3 id="r-installer-gcc" data-claire-element-id="379520">Installer GCC</h3><p id="r-379515" data-claire-element-id="379515">Tout d'abord, avant d'entrer dans le vif du sujet, il faut que vous ayez gcc installé !</p><p id="r-379516" data-claire-element-id="379516">Sous Ubuntu ou Debian, vous pouvez faire (en root) :</p><pre id="r-379517" data-claire-element-id="379517"><code data-claire-semantic="console">apt-get install build-essential</code></pre><p id="r-379518" data-claire-element-id="379518">Ceci installera gcc (pour langage C) et g++ (pour langage C++), mais aussi make qui sera utile pour la suite !</p><p id="r-379519" data-claire-element-id="379519">Pour les autres, vous avez sûrement un gestionnaire de paquets. Recherchez donc les paquets gcc et g++ (pour java, prenez gcj, pour fortran prenez g77 ou gfortran).</p><h3 id="r-utiliser-gcc" data-claire-element-id="379532">Utiliser gcc</h3><p id="r-379521" data-claire-element-id="379521">gcc s'utilise en console (c'est en trois lettres, ça commence par g mais ce n'est pas gui !). C'est une commande qui prend des arguments :<br/><strong>gcc</strong> [<em>arguments</em>] [<em>fichiers à compiler</em>] (<strong>-o</strong><em>fichier de sortie</em>)</p><p id="r-379522" data-claire-element-id="379522">Sans arguments, gcc fait toute la compilation jusqu'à l'exécutable.<br/> L'argument -o permettra de spécifier le nom du fichier de sortie, quels que soient les autres arguments, et donc quel que soit son type !</p><p id="r-379523" data-claire-element-id="379523">Imaginons que notre projet soit constitué d'un main.c gérant le programme et d'un fonctions.c (avec fonctions.h) pour les fonctions qu'il appelle !</p><pre id="r-379524" data-claire-element-id="379524"><code data-claire-semantic="console">gcc main.c fonctions.c -o Programme</code></pre><p id="r-379525" data-claire-element-id="379525">Ceci créera l'exécutable Programme basé sur main.c et fonctions.c.</p><aside id="r-379527" data-claire-element-id="379527" data-claire-semantic="information"><p id="r-379526" data-claire-element-id="379526">Lorsque les headers sont dans le même répertoire que les sources, il est inutile de les préciser.</p></aside><p id="r-379528" data-claire-element-id="379528">Et en C++ ?<br/> Eh bien c'est pareil, sauf que vous utiliserez g++ au lieu de gcc :</p><pre id="r-379529" data-claire-element-id="379529"><code data-claire-semantic="console">g++ main.cpp fonctions.cpp -o Programme</code></pre><p id="r-379530" data-claire-element-id="379530">Pour lancer le programme, il suffit de taper :</p><pre id="r-379531" data-claire-element-id="379531"><code data-claire-semantic="console">./Programme</code></pre><h2 id="r-les-arguments-de-gcc" data-claire-element-id="379560">Les arguments de GCC</h2><p id="r-379534" data-claire-element-id="379534">La liste est non-exhaustive. Le nombre d'arguments de la fonction gcc est astronomique ! Je ne liste ici que les plus courants (et j'en oublie probablement).</p><p id="r-379535" data-claire-element-id="379535"><strong>-c</strong> : indique à GCC de ne pas linker.<br/> Vous obtiendrez alors un fichier objet (.o).</p><p id="r-379536" data-claire-element-id="379536">Exemple :</p><pre id="r-379537" data-claire-element-id="379537"><code data-claire-semantic="console">gcc -c main.c -o main.o</code></pre><p id="r-379538" data-claire-element-id="379538"><strong>-v</strong> : mode verbeux.<br/> Affiche plus de détails.<br/> Si vous voulez tout savoir : les infos sur le processus de compilation, le MD5 de la cible obtenue, ...</p><p id="r-379539" data-claire-element-id="379539"><strong>-I</strong> : spécifie le ou les répertoire(s) des headers.<br/> Indique à gcc où rechercher les fichiers .h.</p><p id="r-379540" data-claire-element-id="379540">Par exemple, si vos .c sont dans le dossier sources et vos .h sont dans le dossier headers, il vous faudra entrer :</p><pre id="r-379541" data-claire-element-id="379541"><code data-claire-semantic="console">gcc sources/*.c -I headers -o Programme</code></pre><p id="r-379542" data-claire-element-id="379542"><strong>-pipe</strong> : avec cette option, GCC ne génère pas de fichier temporaire entre chaque étape.<br/> Utilise des tubes (comme les « | » en shell) de façon à ne générer que le fichier cible.</p><p id="r-379543" data-claire-element-id="379543"><strong>-Ox</strong> : indique le degré d'optimisation (x varie de 1 a 6).<br/>gcc optimise votre code, c'est-à-dire qu'il va modifier le code source de façon à ce que le programme ait le même résultat par le chemin le plus court. En somme, il dit « t'aurais mieux fait de programmer cette fonction comme ça ! ».<br/> Plus le degré est fort, plus l'optimisation est bonne, mais plus la compilation est longue et gourmande en mémoire !</p><p id="r-379544" data-claire-element-id="379544">Remplacez <strong>x</strong> par <strong>s</strong> (<strong>-Os</strong>) et gcc organisera votre code de manière à ce qu'il soit le plus court possible.</p><p id="r-379545" data-claire-element-id="379545"><strong>-w</strong> : supprime tous les avertissements.<br/> Je suis un tueur en programmation, je suis plus un gamin ! Na !</p><p id="r-379546" data-claire-element-id="379546"><strong>-W</strong> : GCC plus exigeant quant aux warnings.<br/> Si votre programme se compile mais ne fait pas ce qu'il devrait faire, essayez avec cet argument !</p><p id="r-379547" data-claire-element-id="379547"><strong>-Wall</strong> : GCC est encore plus exigeant !<br/> La solution ultime !<br/> Attention tout de même : avec cette option, le compilateur peut trouver des erreurs dans des bibliothèques externes qu'on utilise !</p><p id="r-379548" data-claire-element-id="379548"><strong>-Werror</strong> : tous les warnings deviennent des erreurs.<br/> Seul le code parfait compilera !</p><p id="r-379549" data-claire-element-id="379549"><strong>-g</strong> : mode Debugger.<br/> Ajoute des informations de déboggage à l'exécutable. Ces informations peuvent être utilisées par le deboggueur GDB. A noter que vous trouverez un tutoriel sur GDB sur ce site : <a href="http://www.siteduzero.com/tutoriel-3-38738-deboguer-son-programme-avec-gdb.html">http://www.siteduzero.com/tutoriel-3-3 [...] avec-gdb.html</a></p><p id="r-379550" data-claire-element-id="379550"><strong>-o</strong> [fichier] : spécifie la cible.<br/> J'en ai parlé plus haut, sachez simplement que le fichier cible peut être aussi bien un exécutable qu'un fichier objet ou que-sais-je, suivant les autres arguments.<br/> Enfin, c'est un argument comme un autre, vous n'êtes pas obligés de le mettre à la fin comme je l'ai fait :</p><pre id="r-379551" data-claire-element-id="379551"><code data-claire-semantic="console">gcc -o main.o -c main.c</code></pre><p id="r-379552" data-claire-element-id="379552">équivaut à :</p><pre id="r-379553" data-claire-element-id="379553"><code data-claire-semantic="console">gcc -c main.c -o main.o</code></pre><p id="r-379554" data-claire-element-id="379554">Personnellement, je le mets à la fin car ça me semble plus clair, mais c'est vous qui choisissez !</p><p id="r-379555" data-claire-element-id="379555">Si vous ne spécifiez pas de cible, la cible par défaut sera a.out dans le cas d'un exécutable, (<em>nom du fichier c</em>).o dans le cas d'un objet.</p><div id="r-379557" data-claire-element-id="379557" data-claire-semantic="question"><p id="r-379556" data-claire-element-id="379556">C'est tout ?</p></div><p id="r-379558" data-claire-element-id="379558">Vous en voulez plus ? Tapez <code data-claire-semantic="console">man gcc</code> en console.<br/> Pour les anglophobes, vous avez la même chose en français <a href="http://www.linux-kheops.com/doc/man/manfr/man-html-0.9/man1/gcc.1.html">en cliquant ici.</a><br/> Tous les arguments y sont... De quoi perdre la tête !</p><p id="r-379559" data-claire-element-id="379559">Sous debian, pour avoir le man, il vous faut le paquet gcc-doc dans les dépôts non-free (licence <a href="http://fr.wikipedia.org/wiki/GFDL">GFDL</a>).</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux">Compilez sous GNU/Linux !</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/le-compilateur-gcc-sous-linux">
Le compilateur GCC sous Linux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/compiler-des-bibliotheques-avec-gcc">
Compiler des bibliothèques avec GCC
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/la-commande-make-et-le-fichier-makefile-presentation">
La commande make et le fichier Makefile - Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/makefile-un-preprocesseur">
Makefile : un préprocesseur ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/pour-aller-plus-loin-27">
Pour aller plus loin...
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/compiler-des-bibliotheques-avec-gcc">
<span class="next">Compiler des bibliothèques avec GCC</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="CompilerdesbibliothquesavecGCC"></a><h2>Compiler des bibliothèques avec GCC</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/le-compilateur-gcc-sous-linux">
<span class="arrow"></span>
<span class="next">Le compilateur GCC sous Linux</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/la-commande-make-et-le-fichier-makefile-presentation">
<span class="next">La commande make et le fichier Makefile - Présentation</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-379562" data-claire-element-id="379562">Le compilateur gcc vous permet aussi de compiler les bibliothèques (certains disent &quot;librairies&quot;, car &quot;library&quot; en anglais).</p><p id="r-379563" data-claire-element-id="379563">Il existe deux types de bibliothèques : les bibliothèques statiques et les bibliothèques dynamiques.</p><h2 id="r-les-bibliotheques-statiques" data-claire-element-id="379570">Les bibliothèques statiques</h2><p id="r-379564" data-claire-element-id="379564">Une bibliothèque statique (généralement d'extension .a) est une bibliothèque qui sera intégrée à l'exécutable lors de la compilation.<br/> L'avantage est que l'exécutable produit est autonome et ne nécessite rien de plus pour fonctionner. La bibliothèque se comporte comme un autre fichier objet.</p><p id="r-379565" data-claire-element-id="379565">Si vous voulez faire une bibliothèque statique avec machin.c et machin.h, il suffit de faire :</p><pre id="r-379566" data-claire-element-id="379566"><code data-claire-semantic="console">gcc -c machin.c -o machin.o
ar -q libmachin.a machin.o</code></pre><p id="r-379567" data-claire-element-id="379567">La première commande crée le fichier objet (ça, on connait). La commande ar archive tout simplement ce fichier.<br/> Pour plus de détails, lisez <a href="http://www.linux-kheops.com/doc/man/manfr/man-html-0.9/man1/ar.1.html">man ar en français.</a></p><p id="r-379568" data-claire-element-id="379568">La bibliothèque se liera comme n'importe quel fichier objet :</p><pre id="r-379569" data-claire-element-id="379569"><code data-claire-semantic="console">gcc bidule1.o bidule2.o bidule3.o libmachin.a -o Programme</code></pre><h2 id="r-les-bibliotheques-dynamiques" data-claire-element-id="379604">Les bibliothèques dynamiques</h2><p id="r-379571" data-claire-element-id="379571">Les bibliothèques dynamiques - .so (Sharing Object) sous Linux ou .dll (Dynamic Link Library) sous Windows - sont des bibliothèques qui ne sont pas intégrées à l'exécutable lors de l'édition de liens. L'exécutable appelle alors la bibliothèque pour exécuter les fonctions.<br/> Il en ressort plusieurs avantages :</p><ul id="r-379578" data-claire-element-id="379578"><li id="r-379573" data-claire-element-id="379573"><p id="r-379572" data-claire-element-id="379572">si la bibliothèque est utilisée par plusieurs programmes, elle n'est chargée qu'une fois en mémoire ;</p></li><li id="r-379575" data-claire-element-id="379575"><p id="r-379574" data-claire-element-id="379574">l'exécutable est plus léger ;</p></li><li id="r-379577" data-claire-element-id="379577"><p id="r-379576" data-claire-element-id="379576">on peut la mettre à jour sans recompiler le programme (à condition de ne pas modifier le header).</p></li></ul><p id="r-379579" data-claire-element-id="379579">En revanche, il faudra fournir la bibliothèque, sans quoi le programme ne pourra pas fonctionner.</p><p id="r-379580" data-claire-element-id="379580">Pour créer une bibliothèque dynamique, il faut utiliser</p><pre id="r-379581" data-claire-element-id="379581"><code data-claire-semantic="console">gcc -c -fPIC truc -o truc.o
gcc -shared -fPIC truc.o -o libtruc.so</code></pre><p id="r-379582" data-claire-element-id="379582">L'option -fPIC (Position Independent Code) compile sans indiquer d'adresse mémoire dans le code, car en fonction du programme qui l'utilisera, les adresses pourront être différentes. Ceci évitera des conflits entre les bibliothèques.</p><p id="r-379583" data-claire-element-id="379583">L'option -shared indique que c'est une bibliothèque partagée (autre façon de dire dynamique).</p><p id="r-379584" data-claire-element-id="379584">On compilera encore de la même manière (avec -fPIC en plus, par sécurité) :</p><pre id="r-379585" data-claire-element-id="379585"><code data-claire-semantic="console">gcc -fPIC bidule1.o bidule2.o bidule3.o libtruc.so -o Programme</code></pre><p id="r-379586" data-claire-element-id="379586">Hélas, l'exécutable n'est pas prêt à être utilisé. En effet, lorsqu'un programme appelle une bibliothèque, Linux cherche si la bibliothèque est installée dans un répertoire par défaut, mais pas dans le répertoire courant.</p><p id="r-379587" data-claire-element-id="379587">Pour pouvoir utiliser ce programme, il y a 2 solutions :</p><ul id="r-379599" data-claire-element-id="379599"><li id="r-379591" data-claire-element-id="379591"><p id="r-379588" data-claire-element-id="379588">LA MAUVAISE : copier la bibliothèque dans /lib ou dans /usr/lib</p><pre id="r-379589" data-claire-element-id="379589"><code data-claire-semantic="console">cp libtruc.so /lib</code></pre><p id="r-379590" data-claire-element-id="379590">(nécessite d'être root)<br/> On laisse ces répertoires aux programmes fournis et suivis par la distribution Linux. On ne pollue pas le système avec nos programmes personnels.<br/> Pour les programmes personnels (ou du voisin, ou que-sais-je), on utilise le répertoire /usr/local.<br/> On copiera donc les bibliothèques dans /usr/local/lib !<br/> Hélas, ce répertoire ne sera pas trouvé non plus par le système lorsque le programme appellera la bibliothèque !</p></li><p id="r-379592" data-claire-element-id="379592">On utilisera donc :</p><li id="r-379598" data-claire-element-id="379598"><p id="r-379593" data-claire-element-id="379593">LA BONNE MÉTHODE : utiliser la variable LD_LIBRARY_PATH. Cette variable donne les autres chemins où sont appelés les bibliothèques. Elle est sous la forme chemin1:chemin2:chemin3. Vous pouvez voir sa valeur en utilisant :</p><pre id="r-379594" data-claire-element-id="379594"><code data-claire-semantic="console">echo $LD_LIBRARY_PATH</code></pre><p id="r-379595" data-claire-element-id="379595">Généralement par défaut, elle n'est pas définie, la commande affichera alors un blanc. Pour ajouter un dossier, il suffit de mettre</p><pre id="r-379596" data-claire-element-id="379596"><code data-claire-semantic="console">export LD_LIBRARY_PATH=chemin:$LD_LIBRARY_PATH</code></pre><p id="r-379597" data-claire-element-id="379597">Pour indiquer le répertoire courant, utilisez le point (.).</p></li></ul><p id="r-379600" data-claire-element-id="379600">Si vous ne voulez pas refaire la manip après chaque démarrage du système, éditez le fichier /home/moi/.profile (n'affecte que l'utilisateur &quot;moi&quot;) ou bien /etc/profile (affecte tous les utilisateurs, nécessite donc d'être root pour le modifier).<br/> Rajoutez la ligne export LD_LIBRARY_PATH=chemin:$LD_LIBRARY_PATH, et voilà !</p><p id="r-379601" data-claire-element-id="379601">Remarquez, vous pouvez le faire en une ligne de commande :</p><pre id="r-379602" data-claire-element-id="379602"><code data-claire-semantic="console">echo export LD_LIBRARY_PATH=chemin:$LD_LIBRARY_PATH &gt;&gt; ~/.profile</code></pre><p id="r-379603" data-claire-element-id="379603">Cependant, ceci rajoutera la ligne à la fin du fichier. Les fichiers .profile (s'il existe) et /etc/profile étant structurés, il est préférable de les éditer à la main.</p><h2 id="r-les-noms-usuels" data-claire-element-id="379615">Les noms usuels</h2><p id="r-379605" data-claire-element-id="379605">J'ai donné comme nom à mes exemples libmachin.a et libtruc.so. J'aurais très bien plus les appeler machin.lib et truc.dll : on est sous Linux, tout est permis !</p><p id="r-379606" data-claire-element-id="379606">Cependant, on utilisera plutôt par convention, des noms du même type que mes exemples. De plus, cela vous permettra de compiler en utilisant les options -l et -L :</p><ul id="r-379611" data-claire-element-id="379611"><li id="r-379608" data-claire-element-id="379608"><p id="r-379607" data-claire-element-id="379607">-lmachin pour libmachin.a ou -ltruc pour libtruc.so,<br/>-l rajoute automatiquement lib devant et .a ou .so derrière ;</p></li><li id="r-379610" data-claire-element-id="379610"><p id="r-379609" data-claire-element-id="379609">-Lchemin pour indiquer le chemin ; <br/> non nécessaire si le chemin est /lib ou /usr/lib (mais ça ne devrait pas !) ou dans LD_LIBRARY_PATH.</p></li></ul><p id="r-379612" data-claire-element-id="379612">Exemple :</p><pre id="r-379613" data-claire-element-id="379613"><code data-claire-semantic="console">gcc -fPIC bidule.o -L. -lbidule -o Programme</code></pre><p id="r-379614" data-claire-element-id="379614">gcc créera l'exécutable Programme en liant l'objet bidule.o avec la bibliothèque libbidule.so (ou libbidule.a s'il ne trouve pas le so), située dans le répertoire courant.</p><h2 id="r-mettre-a-jour-une-bibliotheque" data-claire-element-id="379652">Mettre à jour une bibliothèque</h2><h3 id="r-ld-soname" data-claire-element-id="379621">ld -soname</h3><p id="r-379616" data-claire-element-id="379616">Maintenant, vous savez faire des bibliothèques dynamiques ; mais comment différencier deux versions de la même bibliothèque et faire en sorte que la nouvelle version fonctionne avec un programme compilé avec la première version ?</p><p id="r-379617" data-claire-element-id="379617">Par exemple, je compile le programme bidule avec la bibliothèque libtruc.so.1.1. Plus tard, je veux installer (pour un autre programme) libtruc.so.1.2. Mais je veux que le programme bidule puisse l'utiliser.</p><p id="r-379618" data-claire-element-id="379618">On utilise pour cela l'option -Wl,-soname, pour définir le lien libtruc.so.1 comme cela :</p><pre id="r-379619" data-claire-element-id="379619"><code data-claire-semantic="console">gcc -Wl,-soname, libtruc.so.1 -o libtruc.so.1.1</code></pre><p id="r-379620" data-claire-element-id="379620">Ceci créera la bibliothèque libtruc.so.1.1, à partir de libtruc.so.1, et cette bibliothèque sera reconnue comme libtruc.so.1 !</p><h3 id="r-quelques-explications-10" data-claire-element-id="379624">Quelques explications</h3><p id="r-379622" data-claire-element-id="379622">Je ne vous l'avais pas dit, mais gcc ne fait pas l'édition de liens ! Il appelle pour cela la commande ld !<br/> Pour passer des options à ld avec gcc on utilise -Wl,option,</p><p id="r-379623" data-claire-element-id="379623">L'option -soname libtruc.so.1 permettra à l'OS de reconnaître une bibliothèque comme s'appelant libtruc.so.1.<br/> Le nom <em>libtruc.so.1</em> sera intégré dans la cible (libtruc.so.1.1) et sera lu par ldconfig.</p><h3 id="r-ldconfig" data-claire-element-id="379651">ldconfig</h3><p id="r-379625" data-claire-element-id="379625">ldconfig crée des liens symboliques entre les -soname et les bibliothèques concernées.</p><p id="r-379626" data-claire-element-id="379626">Il inspecte les bibliothèques dans les emplacements suivants :</p><ul id="r-379635" data-claire-element-id="379635"><li id="r-379628" data-claire-element-id="379628"><p id="r-379627" data-claire-element-id="379627">/lib</p></li><li id="r-379630" data-claire-element-id="379630"><p id="r-379629" data-claire-element-id="379629">/usr/lib</p></li><li id="r-379632" data-claire-element-id="379632"><p id="r-379631" data-claire-element-id="379631">les chemins indiqués dans /etc/ld.so.conf (vous pouvez l'éditer si vous êtes root) ;</p></li><li id="r-379634" data-claire-element-id="379634"><p id="r-379633" data-claire-element-id="379633">les chemins de LD_LIBRARY_PATH.</p></li></ul><p id="r-379636" data-claire-element-id="379636">Il crée pour chaque bibliothèque un lien ayant comme nom le -soname et ayant comme cible la bibliothèque. Si deux bibliothèques ont le même -soname, il fera le lien vers la version la plus récente.</p><aside id="r-379638" data-claire-element-id="379638" data-claire-semantic="warning"><p id="r-379637" data-claire-element-id="379637">Faites attention aux points suivants :</p></aside><ul id="r-379649" data-claire-element-id="379649"><li id="r-379640" data-claire-element-id="379640"><p id="r-379639" data-claire-element-id="379639">le nom de la bibliothèque doit être du type <strong>libnom.so.</strong><em>version</em> pour être reconnue par ldconfig ;</p></li><li id="r-379642" data-claire-element-id="379642"><p id="r-379641" data-claire-element-id="379641">si vous éditez /etc/ld.so.conf, vous n'avez plus besoin de LD_LIBRARY_PATH ;</p></li><li id="r-379644" data-claire-element-id="379644"><p id="r-379643" data-claire-element-id="379643">une bibliothèque de ce type ne sera pas reconnue avec l'option -l, qui nécessite un type libnom.so (sans rien derrière) ;</p></li><li id="r-379646" data-claire-element-id="379646"><p id="r-379645" data-claire-element-id="379645">il existe certaines conventions : pour mettre à jour une bibliothèque il faut que les prototypes des fonctions soient identiques, si vous rajoutez une fonction à cette bibliothèque, il faudra mettre à votre bibliothèque -soname libtruc.so.2 ! Elle sera alors différente de libtruc.so.1 !</p></li><li id="r-379648" data-claire-element-id="379648"><p id="r-379647" data-claire-element-id="379647">il faudra exécuter ldconfig en console avant de lancer le programme.</p></li></ul><p id="r-379650" data-claire-element-id="379650">Note : la commande ldd Programme liste les bibliothèques utilisées par votre programme.</p><h2 id="r-compiler-avec-des-bibliotheques-tierces" data-claire-element-id="379676">Compiler avec des bibliothèques tierces</h2><p id="r-379653" data-claire-element-id="379653">Si vous avez installé une bibliothèque tierce (GTK ou SDL par exemple), vous vous demandez sûrement où se trouve les fameux .so !<br/> La réponse est qu'il n'y a pas à se poser la question !<br/> On utilise dans ce cas la commande pkg-config.</p><p id="r-379654" data-claire-element-id="379654">pkg-config est un utilitaire qui donne des informations sur les bibliothèques installées.</p><p id="r-379655" data-claire-element-id="379655">Ainsi :</p><pre id="r-379656" data-claire-element-id="379656"><code data-claire-semantic="console">pkg-config --cflags [bibliothèque]</code></pre><p id="r-379657" data-claire-element-id="379657">donne la liste des dossiers des headers de [bibliothèque]</p><pre id="r-379658" data-claire-element-id="379658"><code data-claire-semantic="console">pkg-config --libs [bibliothèque]</code></pre><p id="r-379659" data-claire-element-id="379659">donne la liste des fichiers de [bibliothèque]</p><aside id="r-379661" data-claire-element-id="379661" data-claire-semantic="information"><p id="r-379660" data-claire-element-id="379660">Certaines bibliothèques fournissent un outil spécifique pour elle-mêmes. Par exemple, avec sdl, on peut utiliser sdl-config.<br/> sdl-config --cflags équivaut à pkg-config --cflags sdl</p></aside><p id="r-379662" data-claire-element-id="379662">pkg-config donne la liste telle qu'elle peut être comprise par gcc (avec des -I et des -l). On peut donc l'intégrer directement à une commande gcc.<br/> Donc, pour compiler un programme main.c qui utilise GTK+, on fera :</p><pre id="r-379663" data-claire-element-id="379663"><code data-claire-semantic="console">gcc -c main.c $(pkg-config --cflags gtk+-2.0) -o main.o
gcc main.o $(pkg-config --libs gtk+-2.0) -o Programme</code></pre><p id="r-379664" data-claire-element-id="379664">(Le « <strong>$</strong> » permet de renvoyer la valeur de ce qu'il y a entre parenthèses à la commande)</p><p id="r-379665" data-claire-element-id="379665">On peut aussi le faire en une seule commande :</p><pre id="r-379666" data-claire-element-id="379666"><code data-claire-semantic="console">gcc main.c $(pkg-config --cflags --libs gtk+-2.0) -o Programme</code></pre><div id="r-379668" data-claire-element-id="379668" data-claire-semantic="question"><p id="r-379667" data-claire-element-id="379667">Et comment je fais pour savoir que c'est gtk+-2.0 et non gtk2.0 ou encore gtk+ ?</p></div><p id="r-379669" data-claire-element-id="379669">pkg-config cherche dans /usr/lib/pkgconfig le fichier [bibliothèque].pc.<br/> Il vous suffit de trouver le fichier de votre bibliothèque dans ce dossier.</p><p id="r-379670" data-claire-element-id="379670">Vous pouvez même rajouter vos propres .pc si vous constuisez des bibliothèques, en vous inspirant de la syntaxe des fichiers présents sur votre système. Vous pouvez mettre vos .pc dans un autre dossier (par exemple /usr/local/lib/pkgconfig), il faut pour celà définir le chemin dans la variable PKG_CONFIG_PATH.</p><p id="r-379671" data-claire-element-id="379671">Petit problème de compréhension ? Envie d'en savoir plus ?<br/><a href="http://www.linux-kheops.com/doc/man/manfr/man-html-0.9/man1/ldd.1.html">man ldd</a><br/><a href="http://pwet.fr/man/linux/administration_systeme/ld_so">man ld.so</a><br/><a href="http://pwet.fr/man/linux/administration_systeme/ldconfig">man ldconfig</a><br/><a href="http://linux.die.net/man/1/pkg-config">man pkg-config</a> (désolé, je ne l'ai pas trouvé en français celui-là)</p><p id="r-379672" data-claire-element-id="379672">Ça y est ! Vous maîtrisez gcc !</p><div id="r-379674" data-claire-element-id="379674" data-claire-semantic="question"><p id="r-379673" data-claire-element-id="379673">Ouah ! Mais j'ai un big programme à compiler, moi !<br/> Faut que je me tape toutes ces commandes ?</p></div><p id="r-379675" data-claire-element-id="379675">Heureusement non, ce serait le comble du programmeur de taper sans cesse les mêmes commandes !<br/> Il existe un outil permettant d'automatiser un peu tout ça. J'ai nommé : <strong>make</strong> !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux">Compilez sous GNU/Linux !</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/le-compilateur-gcc-sous-linux">
Le compilateur GCC sous Linux
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/compiler-des-bibliotheques-avec-gcc">
Compiler des bibliothèques avec GCC
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/la-commande-make-et-le-fichier-makefile-presentation">
La commande make et le fichier Makefile - Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/makefile-un-preprocesseur">
Makefile : un préprocesseur ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/pour-aller-plus-loin-27">
Pour aller plus loin...
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/le-compilateur-gcc-sous-linux">
<span class="arrow"></span>
<span class="next">Le compilateur GCC sous Linux</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/la-commande-make-et-le-fichier-makefile-presentation">
<span class="next">La commande make et le fichier Makefile - Présentation</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="LacommandemakeetlefichierMakefile-Prsentation"></a><h2>La commande make et le fichier Makefile - Présentation</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/compiler-des-bibliotheques-avec-gcc">
<span class="arrow"></span>
<span class="next">Compiler des bibliothèques avec GCC</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/makefile-un-preprocesseur">
<span class="next">Makefile : un préprocesseur ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-what-does-make-make" data-claire-element-id="379690">What does make make ?</h2><p id="r-379678" data-claire-element-id="379678">Vous commencez à vous demander ce que sont ces <em>Makefiles</em> et ces <em>makes</em> que vous voyez partout.<br/> Vous vous y êtes peut-être confrontés si vous avez téléchargé des programmes sous Linux au format tar.gz.</p><p id="r-379679" data-claire-element-id="379679">La commande make va tout simplement faire une série de commandes, située dans un fichier appelé Makefile.<br/> En gros, ça ressemble au bon vieux script bash (à quelques exceptions près) :</p><ul id="r-379688" data-claire-element-id="379688"><li id="r-379681" data-claire-element-id="379681"><p id="r-379680" data-claire-element-id="379680">la syntaxe de make sera plus adaptée aux commandes de compilation ;</p></li><li id="r-379683" data-claire-element-id="379683"><p id="r-379682" data-claire-element-id="379682">make effectue les commandes en fonction des fichiers les plus récents ;</p></li><li id="r-379685" data-claire-element-id="379685"><p id="r-379684" data-claire-element-id="379684">make gère les dépendances ;</p></li><li id="r-379687" data-claire-element-id="379687"><p id="r-379686" data-claire-element-id="379686">et j'en passe...</p></li></ul><p id="r-379689" data-claire-element-id="379689">Comment ? Eh bien c'est ce qu'on va voir !</p><h2 id="r-la-syntaxe-du-makefile" data-claire-element-id="379766">La syntaxe du Makefile</h2><p id="r-379691" data-claire-element-id="379691">Le fichier Makefile est celui dans lequel on met les commandes qui seront exécutées par make.<br/> Vous devez donc avoir make installé (relancez votre gestionnaire de paquets si nécessaire).</p><h3 id="r-les-regles-4" data-claire-element-id="379707">Les règles</h3><p id="r-379692" data-claire-element-id="379692">La structure de base du Makefile est :</p><pre id="r-379693" data-claire-element-id="379693"><code data-claire-semantic="bash">cible: dependances
        commandes
        ...</code></pre><p id="r-379694" data-claire-element-id="379694">où :</p><ul id="r-379701" data-claire-element-id="379701"><li id="r-379696" data-claire-element-id="379696"><p id="r-379695" data-claire-element-id="379695">cible est le nom du fichier créé (par exemple, Programme) ;</p></li><li id="r-379698" data-claire-element-id="379698"><p id="r-379697" data-claire-element-id="379697">dependances représente la liste des fichiers (ou règles) nécessaires à la construction de la cible ;</p></li><li id="r-379700" data-claire-element-id="379700"><p id="r-379699" data-claire-element-id="379699">commandes représente les commandes à effectuer pour créer la cible.</p></li></ul><p id="r-379702" data-claire-element-id="379702">Notez bien que la cible n'est construite que si le fichier source est plus récent.<br/> On appelle cette structure une règle.<br/> Le fichier Makefile n'est rien de plus qu'un ensemble de règles.</p><p id="r-379703" data-claire-element-id="379703">Retenez bien ce vocabulaire, c'est important pour la suite !<br/> Sinon, ne pleurez pas si vous vous sentez perdus !</p><div id="r-379705" data-claire-element-id="379705" data-claire-semantic="question"><p id="r-379704" data-claire-element-id="379704">Hein ? J'ai pas tout compris ! Comment ça marche ?</p></div><p id="r-379706" data-claire-element-id="379706">Ca ira mieux avec un petit exemple :</p><h3 id="r-un-makefile-minimal" data-claire-element-id="379729">Un Makefile minimal</h3><p id="r-379708" data-claire-element-id="379708">Reprenons mon exemple de tout à l'heure !<br/> Nous avons trois fichiers : main.c, fonctions.c et fonctions.h.</p><p id="r-379709" data-claire-element-id="379709">Les commandes à exécuter pour compiler seront :</p><pre id="r-379710" data-claire-element-id="379710"><code data-claire-semantic="console">gcc -c fonctions.c -o fonctions.o
gcc -c main.c -o main.o
gcc main.o fonctions.o -o Programme</code></pre><p id="r-379711" data-claire-element-id="379711">Le Makefile sera structuré comme tel :</p><pre id="r-379712" data-claire-element-id="379712"><code data-claire-semantic="bash">Programme : main.o fonctions.o
        gcc main.o fonctions.o -o Programme
 
main.o : main.c fonctions.c
        gcc -c main.c -o main.o
 
fonctions.o : fonctions.c
        gcc -c fonctions.c -o fonctions.o</code></pre><aside id="r-379714" data-claire-element-id="379714" data-claire-semantic="warning"><p id="r-379713" data-claire-element-id="379713">Les tabulations avant les lignes de commandes sont obligatoires !<br/> Eh oui ! Ne me demandez pas pourquoi, ce n'est pas moi qui ai créé make !</p></aside><p id="r-379715" data-claire-element-id="379715">Regardons de plus près sur cet exemple comment fonctionne un Makefile.<br/> Nous cherchons à créer le fichier exécutable Programme, la première dépendance (main.o) est la cible d'une des régles de notre Makefile, nous évaluons donc cette règle. Comme aucune dépendance de main.o n'est une règle, aucune autre règle n'est à évaluer pour compléter celle-ci.</p><p id="r-379716" data-claire-element-id="379716">Deux cas se présentent ici : soit le fichier main.c est plus récent que le fichier main.o, la commande est alors exécutée et main.o est construit ; soit main.o est plus récent que main.c et la commande n'est pas exécutée. L'évaluation de la règle main.o est terminée.</p><p id="r-379717" data-claire-element-id="379717">Les autres dépendances de la règle Programme (en l'occurrence ici : fonctions.o) sont examinées de la même manière (si fonctions.c est plus récent que fonctions.o, la commande qui construit ce dernier est exécutée).</p><p id="r-379718" data-claire-element-id="379718">Enfin, si nécessaire (si un des objets est plus récent que Programme), la commande de la règle Programme est exécutée et Programme est construit.</p><p id="r-379719" data-claire-element-id="379719">En résumé, les règles seront exécutées dans l'ordre inverse de l'écriture du Makefile, selon que les dépendances soient ou non plus récentes que leur cible !</p><div id="r-379721" data-claire-element-id="379721" data-claire-semantic="question"><p id="r-379720" data-claire-element-id="379720">Et comment je le lance ?</p></div><p id="r-379722" data-claire-element-id="379722">Il suffit d'enregistrer le projet sous Makefile (sans extension) puis de lancer dans un terminal :</p><pre id="r-379723" data-claire-element-id="379723"><code data-claire-semantic="console">make Programme</code></pre><p id="r-379724" data-claire-element-id="379724">Facile, non ?</p><p id="r-379725" data-claire-element-id="379725">Notez que la commande make sans arguments exécute la première règle du Makefile, vous pouviez donc taper simplement :</p><pre id="r-379726" data-claire-element-id="379726"><code data-claire-semantic="console">make</code></pre><aside id="r-379728" data-claire-element-id="379728" data-claire-semantic="information"><p id="r-379727" data-claire-element-id="379727">Si vous utilisez vim, tapez :make pour lancer la compilation. S'il y a une erreur, le curseur se placera sur la ligne correspondante.</p></aside><h3 id="r-un-makefile-enrichi" data-claire-element-id="379765">Un Makefile enrichi</h3><p id="r-379730" data-claire-element-id="379730">On peut, avec cette syntaxe, ajouter d'autres fonctions à notre Makefile.</p><p id="r-379731" data-claire-element-id="379731">Par exemple, une fonction clean qui permet de supprimer les fichiers temporaires (objets), et une fonction mrproper qui permet un <em>rebuild</em> complet.<br/> Pour les faire, c'est très simple, Makefile permet aussi d'exécuter des commandes du shell, c'est-à-dire les commandes classiques que vous entrez en ligne de commande (mkdir, rm, ls,...).</p><p id="r-379732" data-claire-element-id="379732">Notre Makefile devient alors :</p><pre id="r-379733" data-claire-element-id="379733"><code data-claire-semantic="bash"># création de l'exécutable 'Programme'
all: main.o fonctions.o
        gcc main.o fonctions.o -o Programme
 
main.o: main.c fonctions.h
        gcc -c main.c -o main.o
 
fonctions.o: fonctions.c
        gcc -c fonctions.c -o fonctions.o
 
# suppression des fichiers temporaires
clean:
        rm -rf *.o
 
# suppression de tous les fichiers, sauf les sources,
# en vue d'une reconstruction complète
mrproper: clean
        rm -rf Programme</code></pre><p id="r-379734" data-claire-element-id="379734">Vous remarquez que j'ai remplacé le nom de la première règle (Programme) par <strong>all</strong>.<br/> C'est parce que on utilise des conventions dans les Makefile :</p><ul id="r-379749" data-claire-element-id="379749"><li id="r-379736" data-claire-element-id="379736"><p id="r-379735" data-claire-element-id="379735">all : compile tous les fichiers source pour créer l'exécutable principal ;</p></li><li id="r-379738" data-claire-element-id="379738"><p id="r-379737" data-claire-element-id="379737">install: exécute all, et copie l'exécutable, les librairies, les datas, et les fichiers en-tête s'il y en a dans les répertoires de destination ;</p></li><li id="r-379740" data-claire-element-id="379740"><p id="r-379739" data-claire-element-id="379739">uninstall : détruit les fichiers créés lors de l'installation, mais pas les fichiers du répertoire d'installation (où se trouvent les fichiers source et le Makefile) ;</p></li><li id="r-379742" data-claire-element-id="379742"><p id="r-379741" data-claire-element-id="379741">clean : détruit tout les fichiers créés par all ;</p></li><li id="r-379744" data-claire-element-id="379744"><p id="r-379743" data-claire-element-id="379743">info : génère un fichier info ;</p></li><li id="r-379746" data-claire-element-id="379746"><p id="r-379745" data-claire-element-id="379745">dvi : génère un fichier dvi ;</p></li><li id="r-379748" data-claire-element-id="379748"><p id="r-379747" data-claire-element-id="379747">dist : crée un fichier tar de distribution.</p></li></ul><p id="r-379750" data-claire-element-id="379750">Revenons maintenant à mon exemple : pour l'exécuter, il suffit de mettre en console</p><pre id="r-379751" data-claire-element-id="379751"><code data-claire-semantic="console">make all</code></pre><p id="r-379752" data-claire-element-id="379752">pour créer l'exécutable Programme</p><pre id="r-379753" data-claire-element-id="379753"><code data-claire-semantic="console">make clean</code></pre><p id="r-379754" data-claire-element-id="379754">pour supprimer les fichiers temporaires</p><pre id="r-379755" data-claire-element-id="379755"><code data-claire-semantic="console">make mrproper</code></pre><p id="r-379756" data-claire-element-id="379756">pour préparer une reconstruction complète.</p><aside id="r-379758" data-claire-element-id="379758" data-claire-semantic="information"><p id="r-379757" data-claire-element-id="379757">Le shell Linux permet de combiner les commandes !<br/> On peut donc tout envoyer en une seule ligne de commande !</p></aside><p id="r-379759" data-claire-element-id="379759">Je vous rappelle que make seul équivaut à make all.<br/> On obtient alors :</p><pre id="r-379760" data-claire-element-id="379760"><code data-claire-semantic="console">make &amp;&amp; make clean</code></pre><p id="r-379761" data-claire-element-id="379761">pour installer le programme sans laisser de fichiers temporaires.</p><p id="r-379762" data-claire-element-id="379762">Encore plus fort !</p><pre id="r-379763" data-claire-element-id="379763"><code data-claire-semantic="console">make mrproper &amp;&amp; make</code></pre><p id="r-379764" data-claire-element-id="379764">fera une reconstruction complète du programme.</p><h2 id="r-les-directives-1" data-claire-element-id="379786">Les directives</h2><p id="r-379767" data-claire-element-id="379767">Dans certains cas, le Makefile tel que ci-dessus peut présenter quelques problèmes.<br/> Nous allons voir lesquels et comment y pallier.</p><h3 id="r-cibles-particulieres-phony" data-claire-element-id="379776">Cibles particulières : .PHONY</h3><p id="r-379768" data-claire-element-id="379768">Reprenons la règle clean :</p><pre id="r-379769" data-claire-element-id="379769"><code data-claire-semantic="bash">clean:
        rm -rf *.o</code></pre><p id="r-379770" data-claire-element-id="379770">Vous remarquerez que cette règle ne présente pas de dépendance.<br/>make accepte ces règles, le fichier est alors considéré comme à jour s'il existe.</p><div id="r-379772" data-claire-element-id="379772" data-claire-semantic="question"><p id="r-379771" data-claire-element-id="379771">Mais il n'y a pas de fichiers clean ?</p></div><p id="r-379773" data-claire-element-id="379773">Justement, s'il y a dans le répertoire courant un fichier nommé clean, la commande ne sera jamais effectuée.</p><p id="r-379774" data-claire-element-id="379774">On définit alors la cible clean comme étant une cible particulière avec la directive .PHONY !<br/> On ajoutera simplement une ligne au Makefile avant clean, voire même en tête du fichier.<br/> Dans notre exemple, on définira clean et mrproper comme cibles spéciales :</p><pre id="r-379775" data-claire-element-id="379775"><code data-claire-semantic="bash">.PHONY: clean, mrproper</code></pre><h3 id="r-les-regles-implicites" data-claire-element-id="379785">Les règles implicites</h3><p id="r-379777" data-claire-element-id="379777">En fait, je ne vous l'avait pas dit, mais make est capable de générer certains fichiers même si on ne lui indique pas la commande !</p><p id="r-379778" data-claire-element-id="379778">Reprenons la règle all et ses dépendances.<br/> Je vous la remets pour mémoire :</p><pre id="r-379779" data-claire-element-id="379779"><code data-claire-semantic="bash">all: main.o fonctions.o
        gcc main.o fonctions.o -o Programme
 
main.o: main.c fonctions.h
        gcc -c main.c -o main.o
 
fonctions.o: fonctions.c
        gcc -c fonctions.c -o fonctions.o</code></pre><p id="r-379780" data-claire-element-id="379780">Si on supprime la règle main.o, make trouvera tout seul comme un grand comment créer main.o à partir de main.c. Pour des projets très simples, on peut même utiliser make sans Makefile !</p><p id="r-379781" data-claire-element-id="379781">On appelle cela les règles implicites. Ces règles - inexistantes dans le Makefile mais appliquées - peuvent poser des problèmes avec certains Makefile plus complexes.<br/> On mettra alors la directive .SUFFIXES en tête du Makefile pour être tranquilles !</p><p id="r-379782" data-claire-element-id="379782">Mon Makefile devient alors :</p><pre id="r-379783" data-claire-element-id="379783"><code data-claire-semantic="bash"># définition des cibles particulières
.PHONY: clean, mrproper
 
# désactivation des règles implicites
.SUFFIXES:
 
 
# all
all: main.o fonctions.o
        gcc main.o fonctions.o -o Programme
 
main.o: main.c fonctions.h
        gcc -c main.c -o main.o
 
fonctions.o: fonctions.c
        gcc -c fonctions.c -o fonctions.o
 
 
# clean
clean:
        rm -rf *.bak rm -rf *.o
 
# mrproper
mrproper: clean
        rm -rf Programme</code></pre><p id="r-379784" data-claire-element-id="379784">Ces directives ne sont pas obligatoires, mais il vaut mieux prendre l'habitude de les mettre par sécurité.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux">Compilez sous GNU/Linux !</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/le-compilateur-gcc-sous-linux">
Le compilateur GCC sous Linux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/compiler-des-bibliotheques-avec-gcc">
Compiler des bibliothèques avec GCC
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/la-commande-make-et-le-fichier-makefile-presentation">
La commande make et le fichier Makefile - Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/makefile-un-preprocesseur">
Makefile : un préprocesseur ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/pour-aller-plus-loin-27">
Pour aller plus loin...
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/compiler-des-bibliotheques-avec-gcc">
<span class="arrow"></span>
<span class="next">Compiler des bibliothèques avec GCC</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/makefile-un-preprocesseur">
<span class="next">Makefile : un préprocesseur ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Makefileunprprocesseur"></a><h2>Makefile : un préprocesseur ?</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/la-commande-make-et-le-fichier-makefile-presentation">
<span class="arrow"></span>
<span class="next">La commande make et le fichier Makefile - Présentation</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/pour-aller-plus-loin-27">
<span class="next">Pour aller plus loin...</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-379788" data-claire-element-id="379788">Nous avons vu comment réaliser un Makefile simple permettant de contenir les informations pour compiler un programme. Cependant, nous sommes encore soumis à certaines limites :</p><ul id="r-379795" data-claire-element-id="379795"><li id="r-379790" data-claire-element-id="379790"><p id="r-379789" data-claire-element-id="379789">si on a 120 fichiers main.c, on aura 120 règles à définir ;</p></li><li id="r-379792" data-claire-element-id="379792"><p id="r-379791" data-claire-element-id="379791">s'ils sont répartis dans 50 répertoires, le Makefile va être imposant ;</p></li><li id="r-379794" data-claire-element-id="379794"><p id="r-379793" data-claire-element-id="379793">si on veut compiler avec un autre compilateur, ou bien ajouter des arguments à gcc, il faudra corriger toutes les commandes.</p></li></ul><p id="r-379796" data-claire-element-id="379796">Heureusement pour nous, il existe des moyens de simplifier tout ça.</p><h2 id="r-les-variables-21" data-claire-element-id="379869">Les variables</h2><h3 id="r-variables-personnalisees" data-claire-element-id="379849">Variables personnalisées</h3><p id="r-379797" data-claire-element-id="379797">On peut introduire des variables dans make.<br/> Bon d'accord, ce n'est pas vraiment des variables car leur valeur ne change pas !<br/> En fait, ça ressemble aux macro-commandes #define en C !</p><p id="r-379798" data-claire-element-id="379798">On introduit une variable sous la forme NOM = VALEUR.<br/> On appelle ensuite sa valeur avec $(NOM).</p><p id="r-379799" data-claire-element-id="379799">Un petit exemple pour être plus clair.<br/> Définissons la variable CC pour définir le compilateur : CC = gcc.<br/> on remplace alors gcc par $(CC) dans les commandes.</p><p id="r-379800" data-claire-element-id="379800">De même, imaginons qu'on veuille mettre des arguments à gcc pour la compilation.<br/> Par exemple gcc -W -Wall -v.<br/> On définit pareillement CFLAGS = -W -Wall -v.<br/> On ajoute $(CFLAGS) aux commandes.</p><p id="r-379801" data-claire-element-id="379801">Mettons ça sur notre Makefile (toujours le même) :</p><pre id="r-379802" data-claire-element-id="379802"><code data-claire-semantic="bash"># définition des cibles particulières
.PHONY: clean, mrproper
 
# désactivation des règles implicites
.SUFFIXES:
 
# définition des variables
CC = gcc
CFLAGS = -W -Wall -v
 
 
 
# all
all: main.o fonctions.o
        $(CC) main.o fonctions.o -o Programme
 
main.o: main.c fonctions.h
        $(CC) -c main.c -o main.o $(CFLAGS)
 
fonctions.o: fonctions.c
        $(CC) -c fonctions.c -o fonctions.o $(CFLAGS)
 
 
# clean
clean:
        rm -rf *.bak rm -rf *.o
 
# mrproper
mrproper: clean
        rm -rf Programme</code></pre><p id="r-379803" data-claire-element-id="379803">Et voilà !<br/> Maintenant, si on veut utiliser d'autres arguments, il suffira de changer la valeur de CFLAGS en tête du fichier !</p><p id="r-379804" data-claire-element-id="379804">Pour les variables, on utilisera là aussi des conventions.</p><p id="r-379805" data-claire-element-id="379805">Pour les noms d'exécutables et d'arguments :</p><ul id="r-379824" data-claire-element-id="379824"><li id="r-379807" data-claire-element-id="379807"><p id="r-379806" data-claire-element-id="379806">AR : programme de maintenance d'archive (ar) ;</p></li><li id="r-379809" data-claire-element-id="379809"><p id="r-379808" data-claire-element-id="379808">CC : compilateur C (gcc) ;</p></li><li id="r-379811" data-claire-element-id="379811"><p id="r-379810" data-claire-element-id="379810">CXX : compilateur C++ (g++) ;</p></li><li id="r-379813" data-claire-element-id="379813"><p id="r-379812" data-claire-element-id="379812">RM : commande pour effacer un fichier (rm) ;</p></li><li id="r-379815" data-claire-element-id="379815"><p id="r-379814" data-claire-element-id="379814">TEX : programme pour créer un fichier TeX dvi à partir d'un source TeX (latex) ;</p></li><li id="r-379817" data-claire-element-id="379817"><p id="r-379816" data-claire-element-id="379816">ARFLAGS : paramètres à passer au programme de maintenance d'archives ;</p></li><li id="r-379819" data-claire-element-id="379819"><p id="r-379818" data-claire-element-id="379818">CFLAGS : paramètres à passer au compilateur C ;</p></li><li id="r-379821" data-claire-element-id="379821"><p id="r-379820" data-claire-element-id="379820">CXXFLAGS : paramètres à passer au compilateur C++ ;</p></li><li id="r-379823" data-claire-element-id="379823"><p id="r-379822" data-claire-element-id="379822">LDFLAGS : paramètres à passer au compilateur pour l'éditions de liens.</p></li></ul><p id="r-379825" data-claire-element-id="379825">Pour les noms de répertoires et les destinations :</p><ul id="r-379848" data-claire-element-id="379848"><li id="r-379827" data-claire-element-id="379827"><p id="r-379826" data-claire-element-id="379826">prefix : racine du répertoire d'installation (= /usr/local) ;</p></li><li id="r-379829" data-claire-element-id="379829"><p id="r-379828" data-claire-element-id="379828">exec_prefix : racine pour les binaires (= $(prefix)) ;</p></li><li id="r-379831" data-claire-element-id="379831"><p id="r-379830" data-claire-element-id="379830">bindir : répertoire d'installation des binaires (= $(exec_prefix)/bin);</p></li><li id="r-379833" data-claire-element-id="379833"><p id="r-379832" data-claire-element-id="379832">libdir : répertoire d'installation des librairies (= $(exec_prefix)/lib) ;</p></li><li id="r-379835" data-claire-element-id="379835"><p id="r-379834" data-claire-element-id="379834">datadir : répertoire d'installation des données statiques pour le programme (= $(exec_prefix)/lib) ;</p></li><li id="r-379837" data-claire-element-id="379837"><p id="r-379836" data-claire-element-id="379836">statedir : répertoire d'installation des données modifiables par le programme (= $(prefix)/lib);</p></li><li id="r-379839" data-claire-element-id="379839"><p id="r-379838" data-claire-element-id="379838">includedir : répertoire d'installation des en-têtes (= $(prefix)/include) ;</p></li><li id="r-379841" data-claire-element-id="379841"><p id="r-379840" data-claire-element-id="379840">mandir : répertoire d'installation des fichiers de manuel (= $(prefix)/man) ;</p></li><li id="r-379843" data-claire-element-id="379843"><p id="r-379842" data-claire-element-id="379842">manxdir : répertoire d'installation des fichiers de la section x du manuel (= $(prefix)/manx) ;</p></li><li id="r-379845" data-claire-element-id="379845"><p id="r-379844" data-claire-element-id="379844">infodir : répertoire d'installation des fichiers info (= $(prefix)/info) ;</p></li><li id="r-379847" data-claire-element-id="379847"><p id="r-379846" data-claire-element-id="379846">srcdir: répertoire d'installation des fichiers sources (= $(prefix)/src).</p></li></ul><h3 id="r-les-variables-automatiques" data-claire-element-id="379868">Les variables automatiques</h3><p id="r-379850" data-claire-element-id="379850">Makefile permet aussi l'utilisation de variables automatiques, calculées lors de l'exécution de chaque règle.</p><ul id="r-379861" data-claire-element-id="379861"><li id="r-379852" data-claire-element-id="379852"><p id="r-379851" data-claire-element-id="379851">$@ : nom de la cible ;</p></li><li id="r-379854" data-claire-element-id="379854"><p id="r-379853" data-claire-element-id="379853">$&lt; : première dépendance de la liste des dépendances ;</p></li><li id="r-379856" data-claire-element-id="379856"><p id="r-379855" data-claire-element-id="379855">$? : les dépendances plus récentes que la cible ;</p></li><li id="r-379858" data-claire-element-id="379858"><p id="r-379857" data-claire-element-id="379857">$^ : toutes les dépendances ;</p></li><li id="r-379860" data-claire-element-id="379860"><p id="r-379859" data-claire-element-id="379859">$* : correspond au ' * ' simple dans le shell, i.e. représente n'importe quel nom.</p></li></ul><p id="r-379862" data-claire-element-id="379862">On peut alors (encore !) remplacer notre Makefile par :</p><pre id="r-379863" data-claire-element-id="379863"><code data-claire-semantic="bash"># all
all: main.o fonctions.o
        $(CC) $^ -o Programme $(CFLAGS)
 
main.o: main.c fonctions.h
        $(CC) -c $&lt; -o $@ $(CFLAGS)
 
fonctions.o: fonctions.c
        $(CC) -c $&lt; -o $@ $(CFLAGS)</code></pre><p id="r-379864" data-claire-element-id="379864">Pour plus de clarté, je n'ai repris que la partie qui nous intéresse ici.</p><div id="r-379866" data-claire-element-id="379866" data-claire-semantic="question"><p id="r-379865" data-claire-element-id="379865">J'ai pas l'impression que ça soit utile.<br/> Ça sert pas juste à compliquer mon Makefile ?</p></div><p id="r-379867" data-claire-element-id="379867">Les variables internes sont utiles lorsqu'elles sont combinées avec ce que je vais vous apprendre tout de suite.</p><h2 id="r-les-regles-d-inference" data-claire-element-id="379895">Les règles d'inférence</h2><p id="r-379870" data-claire-element-id="379870">Nous pouvons spécifier des règles génériques.<br/> Par exemple, vous avez remarqué que les règles main.o et fonctions.o se ressemblent.<br/> On peut alors définir une seule et même règle !</p><p id="r-379871" data-claire-element-id="379871">On utilisera comme notation : %.o: %.c.<br/>make lira alors &quot;fais-moi des .o avec tous les .c à l'aide de la commande suivante&quot;.</p><p id="r-379872" data-claire-element-id="379872">Notre Makefile est alors simplifié.</p><pre id="r-379873" data-claire-element-id="379873"><code data-claire-semantic="bash"># all
all: main.o fonctions.o
        $(CC) $^ -o Programme $(CFLAGS)
 
%.o: %.c
        $(CC) -c $&lt; -o $@ $(CFLAGS)</code></pre><p id="r-379874" data-claire-element-id="379874">Une ligne de moins, ça fait plaisir !</p><p id="r-379875" data-claire-element-id="379875">Cependant, il y a un problème ici.<br/> Vous n'avez rien remarqué ?<br/> Le header a maintenant disparu des dépendances.</p><p id="r-379876" data-claire-element-id="379876">On peut corriger ça en spécifiant des dépendances en dehors des règles d'inférence :</p><pre id="r-379877" data-claire-element-id="379877"><code data-claire-semantic="bash">all: main.o fonctions.o
        $(CC) $^ -o Programme $(CFLAGS)
 
 
main.o: fonctions.h
 
%.o: %.c
        $(CC) -c $&lt; -o $@ $(CFLAGS)</code></pre><div id="r-379879" data-claire-element-id="379879" data-claire-semantic="question"><p id="r-379878" data-claire-element-id="379878">Et pourquoi je mets pas des * au lieu des % ?</p></div><p id="r-379880" data-claire-element-id="379880">Pour spécifier &quot;tous les fichiers de type .c&quot;, on utilisera :</p><ul id="r-379887" data-claire-element-id="379887"><li id="r-379882" data-claire-element-id="379882"><p id="r-379881" data-claire-element-id="379881">%.c pour les cibles ;</p></li><li id="r-379884" data-claire-element-id="379884"><p id="r-379883" data-claire-element-id="379883">%.c dans les dépendances;</p></li><li id="r-379886" data-claire-element-id="379886"><p id="r-379885" data-claire-element-id="379885">$*.c dans les commandes.</p></li></ul><p id="r-379888" data-claire-element-id="379888">Les bons élèves me diront :</p><div id="r-379890" data-claire-element-id="379890" data-claire-semantic="question"><p id="r-379889" data-claire-element-id="379889">Mais dans la commande clean de tout à l'heure<br/> on avait utilisé *.o (et non $*.o) ?</p></div><p id="r-379891" data-claire-element-id="379891">Je le rappelle pour mémoire :</p><pre id="r-379892" data-claire-element-id="379892"><code data-claire-semantic="bash"># clean
clean:
        rm -rf *.o</code></pre><p id="r-379893" data-claire-element-id="379893">La commande rm -rf *.o est une commande du shell.<br/> Ici le caractère * est géré par le shell et non pas par make.</p><p id="r-379894" data-claire-element-id="379894">En fait on peut remplacer les caractères joker de make (% et $*) par celui du shell (*) SAUF POUR LES CIBLES !<br/> On appelle les caractères % et $* des <em>patterns</em>.<br/> En général, lorsqu'on utilise les patterns pour la cible, on les utilise dans toute la règle. Sinon on utilisera le caractère * du shell.</p><h2 id="r-les-conditions-23" data-claire-element-id="379905">Les conditions</h2><p id="r-379896" data-claire-element-id="379896">Pour optimiser notre Makefile, nous pouvons utiliser des conditions.<br/> Nous avons vu que les variables fonctionnaient comme des #define en C !</p><p id="r-379897" data-claire-element-id="379897">Et qui dit #define, dit macros, dit #ifdef !<br/> Je crois qu'en une phrase j'ai tout dit !</p><p id="r-379898" data-claire-element-id="379898">Dans un Makefile on utilsera la structure :</p><pre id="r-379899" data-claire-element-id="379899"><code data-claire-semantic="bash">ifeq ($(VARIABLE),valeur)
        # Actions
 
else
        # Actions
endif</code></pre><p id="r-379900" data-claire-element-id="379900">Par exemple, imaginons que l'on veuille pouvoir compiler en mode debugger (debug) ou en mode distribution (release).</p><p id="r-379901" data-claire-element-id="379901">On définit une variable DEBUG dans le Makefile suivant :</p><pre id="r-379902" data-claire-element-id="379902"><code data-claire-semantic="bash"># définition des variables
CC = gcc
EXEC = Programme
DEBUG = yes
 
ifeq ($(DEBUG),yes)
        CFLAGS = -g -W -Wall
else
        CFLAGS =
endif
 
 
# all conditionnel
all : $(EXEC)
ifeq ($DEBUG),yes)
        @echo &quot;Génération en mode Debug&quot;
else
        @echo &quot;Génération en mode Release&quot;
endif
 
Programme: main.o fonctions.o
        $(CC) $^ -o $(EXEC)
 
 
main.o: fonctions.h
 
%.o: %.c
        $(CC) -c $&lt; -o $@ $(CFLAGS)</code></pre><p id="r-379903" data-claire-element-id="379903">Facile, non ?</p><p id="r-379904" data-claire-element-id="379904">Non ? Bon allez, encore une dernière ligne droite et vous serez des pros du Makefile !</p><h2 id="r-l-appel-recursif" data-claire-element-id="379930">L'appel récursif</h2><p id="r-379906" data-claire-element-id="379906">Il est possible d'appeler make à l'intérieur d'un Makefile.</p><p id="r-379907" data-claire-element-id="379907">Je vais prendre comme exemple cette fois un programme plus compliqué.</p><p id="r-379908" data-claire-element-id="379908">Nous avons un fichier main.c dans le répertoire main.<br/> Nous avons fonctions1.c, fonctions2.c, fonctions3.c dans le répertoire fonctions (avec les headers correspondants).</p><p id="r-379909" data-claire-element-id="379909">On veut créer un Makefile dans chaque répertoire, et un autre qui y fera appel.</p><p id="r-379910" data-claire-element-id="379910">make peut appeler un autre Makefile avec la commande make -C [répertoire].<br/> Ex. :</p><pre id="r-379911" data-claire-element-id="379911"><code data-claire-semantic="console">make -C main all</code></pre><p id="r-379912" data-claire-element-id="379912">va exécuter la règle all dans le Makefile situé dans main.</p><p id="r-379913" data-claire-element-id="379913">On peut donc faire nos Makefile comme ceci :</p><pre id="r-379914" data-claire-element-id="379914"><code data-claire-semantic="bash"># Makefile racine
.SUFFIXES:
.PHONY:
 
LD = gcc
LDFLAGS =
OBJ = fonctions/*.o main/*.o
 
all:
        $(LD) $(OBJ) -o Programme
 
%.o
        make -C main
        make -C fonctions
 
clean:
        make -C main clean
        make -C fonctions clean
        rm -rf *.o</code></pre><pre id="r-379915" data-claire-element-id="379915"><code data-claire-semantic="bash"># main/Makefile
.SUFFIXES:
.PHONY: clean
 
CC = gcc
CFLAGS = -W
OBJ = main.o
 
all: $(OBJ)
 
%o: %c
        $(CC) -c $^ -o $@ $(CFLAGS)
 
clean:
        rm -rf *.o</code></pre><pre id="r-379916" data-claire-element-id="379916"><code data-claire-semantic="bash"># fonctions/Makefile
.SUFFIXES:
.PHONY: clean
 
CC =gcc
CFLAGS = -W
OBJ = fonctions1.o fonctions2.o fonctions3.o
 
 
all: $(OBJ)
 
%o: %c
        $(CC) -c $^ -o $@ $(CFLAGS)
 
clean: 
        rm -rf *.o</code></pre><p id="r-379917" data-claire-element-id="379917">Note : j'aurais pu remplacer make -C main par cd main &amp;&amp; make.<br/> Ça revient au même.</p><p id="r-379918" data-claire-element-id="379918">Pour aller jusqu'au bout :</p><ul id="r-379929" data-claire-element-id="379929"><li id="r-379920" data-claire-element-id="379920"><p id="r-379919" data-claire-element-id="379919">-n : liste ce que make va faire, sans le faire ;</p></li><li id="r-379922" data-claire-element-id="379922"><p id="r-379921" data-claire-element-id="379921">-f : indique le fichier Makefile ;</p></li><li id="r-379924" data-claire-element-id="379924"><p id="r-379923" data-claire-element-id="379923">-j3 : parallélise l'exécution de make (très utile sur biprocesseur) ;</p></li><li id="r-379926" data-claire-element-id="379926"><p id="r-379925" data-claire-element-id="379925">-p : liste les règles implicites ;</p></li><li id="r-379928" data-claire-element-id="379928"><p id="r-379927" data-claire-element-id="379927">Voyez <a href="http://man.developpez.com/man1/make.1.php">man make</a></p></li></ul>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux">Compilez sous GNU/Linux !</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/le-compilateur-gcc-sous-linux">
Le compilateur GCC sous Linux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/compiler-des-bibliotheques-avec-gcc">
Compiler des bibliothèques avec GCC
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/la-commande-make-et-le-fichier-makefile-presentation">
La commande make et le fichier Makefile - Présentation
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/makefile-un-preprocesseur">
Makefile : un préprocesseur ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/pour-aller-plus-loin-27">
Pour aller plus loin...
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/la-commande-make-et-le-fichier-makefile-presentation">
<span class="arrow"></span>
<span class="next">La commande make et le fichier Makefile - Présentation</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/pour-aller-plus-loin-27">
<span class="next">Pour aller plus loin...</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Pourallerplusloin..."></a><h2>Pour aller plus loin...</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/makefile-un-preprocesseur">
<span class="arrow"></span>
<span class="next">Makefile : un préprocesseur ?</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-379932" data-claire-element-id="379932">Tout d'abord, pour aller plus loin, n'hésitez pas à consulter les documentations de références sur le sujet.<br/> En plus des pages de manuel, vous pouvez visiter <a href="http://gcc.gnu.org/">le site de GCC</a> et parcourir <a href="http://www.gnu.org/prep/standards/">The GNU coding standards</a></p><p id="r-379933" data-claire-element-id="379933">Ici, je vous donne quelques pistes pour vous « plonger » dans la compilation linuxienne.<br/> Ne voulant pas trop parler sur des sujets que je ne maîtrise pas, je ne donnerai qu'un bref aperçu des différentes méthodes, avec quelques liens.</p><p id="r-379934" data-claire-element-id="379934">Si vous trouvez de meilleurs liens, veuillez me les envoyer par MP. Bien sûr, libre à vous de faire un tuto sur le sujet.</p><h2 id="r-des-makefile-automatiques-les-autotools" data-claire-element-id="379947">Des Makefile automatiques : les autotools</h2><p id="r-379935" data-claire-element-id="379935">Il existe des outils appelés automake, autoconf et d'autres noms barbares, qui permettent de créer un Makefile à partir d'un Makefile « de base » et à l'aide d'un script généralement appelé configure.</p><p id="r-379936" data-claire-element-id="379936">C'est très utile lorsque les sources à compiler sont importantes. De plus, le configure peut vérifier les dépendances, et peut prendre des arguments qui permettront de modifier le Makefile en conséquence, en fonction de la configuration de la machine sur laquelle on veut installer le programme.<br/> C'est pourquoi cette méthode est largement utilisée pour la distribution de sources. Si vous avez déjà téléchargé les sources d'un programme, vous les compilez généralement en faisant :</p><pre id="r-379937" data-claire-element-id="379937"><code data-claire-semantic="console">./configure
make
make install</code></pre><p id="r-379938" data-claire-element-id="379938">Vous avez un aperçu de cette méthode sur <a href="http://www-igm.univ-mlv.fr/~dr/XPOSE/Breugnot/">cette page</a>.<br/> Si vous maitrisez la langue de shakespeare, voyez (entre autres) :</p><ul id="r-379945" data-claire-element-id="379945"><li id="r-379940" data-claire-element-id="379940"><p id="r-379939" data-claire-element-id="379939"><a href="http://airs.com/ian/configure/configure_toc.html">http://airs.com/ian/configure/configure_toc.html</a></p></li><li id="r-379942" data-claire-element-id="379942"><p id="r-379941" data-claire-element-id="379941"><a href="http://www.amath.washington.edu/~lf/tutorials/autoconf/toolsmanual_toc.html">http://www.amath.washington.edu/~lf/tu [...] nual_toc.html</a></p></li><li id="r-379944" data-claire-element-id="379944"><p id="r-379943" data-claire-element-id="379943"><a href="http://sources.redhat.com/automake/automake.html">http://sources.redhat.com/automake/automake.html</a> (ou « info automake » en console)</p></li></ul><p id="r-379946" data-claire-element-id="379946">À noter aussi que l'IDE anjuta utilise cette méthode pour compiler les programmes que vous faites avec, si vous voulez regarder la syntaxe des différents fichiers...</p><h2 id="r-creer-un-paquet" data-claire-element-id="379970">Créer un paquet</h2><p id="r-379948" data-claire-element-id="379948">Si vous voulez faire un paquet pour votre distribution, il existe plusieurs méthodes.</p><h3 id="r-checkinstall" data-claire-element-id="379960">checkinstall</h3><p id="r-379949" data-claire-element-id="379949">checkinstall est une commande permettant de créer un paquet à partir des binaires et du Makefile qui les a générés, plus particulièrement la cible install.</p><p id="r-379950" data-claire-element-id="379950">Une fois que vous avez fait make (et peut-être ./configure avant !), utilisez simplement la commande :</p><p id="r-379951" data-claire-element-id="379951">pour un paquet debian .deb (debian, ubuntu, knoppix...) :</p><pre id="r-379952" data-claire-element-id="379952"><code data-claire-semantic="console">checkinstall -D make install</code></pre><p id="r-379953" data-claire-element-id="379953">pour un paquet .rpm (fedora, mandriva...) :</p><pre id="r-379954" data-claire-element-id="379954"><code data-claire-semantic="console">checkinstall -R make install</code></pre><p id="r-379955" data-claire-element-id="379955">pour un paquet .tgz (slackware, backtrack...) :</p><pre id="r-379956" data-claire-element-id="379956"><code data-claire-semantic="console">checkinstall -S make install</code></pre><p id="r-379957" data-claire-element-id="379957">Cette méthode à l'avantage d'etre facile à utiliser, mais n'est pas la plus appropriée, et ne fonctionne pas toujours : <a href="http://wiki.slackbuilds.net/faq#je_suis_propre_moi_j_utilise_checkinstall">http://wiki.slackbuilds.net/faq#je_sui [...] _checkinstall</a></p><p id="r-379958" data-claire-element-id="379958">Checkinstall est en général utilisé quand on compile pour une seule machine, car c'est toujours plus propre qu'un make install brut, et n'est pas plus compliqué à faire. On ne trouvera pas de paquets créés avec checkinstall dans les dépots.</p><p id="r-379959" data-claire-element-id="379959">On préfèrera donc utiliser les outils de création de paquet fournis avec sa distribution :</p><h3 id="r-a-la-sauce-debian" data-claire-element-id="379965">À la sauce debian</h3><p id="r-379961" data-claire-element-id="379961">Il existe une méthode spécifique debian (et dérivés), qui consiste à faire un Makefile un peu particulier, nommé rules et associé à d'autres fichiers, le tout mis dans un répertoire debian.<br/> On retrouve un peu la structure du Makefile, mais on n'utilise pas make, c'est un script exécutable directement.<br/> On peut donc construire le paquet avec la commande :</p><pre id="r-379962" data-claire-element-id="379962"><code data-claire-semantic="console">./debian/rules binary</code></pre><p id="r-379963" data-claire-element-id="379963">Les autres fichiers du répertoire debian sont tous liés à la création du paquet par cette méthode, qui se veut la méthode &quot;officielle&quot; sous Debian.</p><p id="r-379964" data-claire-element-id="379964">Vous trouverez plus de renseignements sur le <a href="http://www.debian.org/doc/maint-guide/index.fr.html">guide du nouveau responsable Debian</a> et sur <a href="http://doc.ubuntu-fr.org/tutoriel/creer_un_paquet">la page &quot;créer un paquet&quot; de la doc Ubuntu</a>.<br/> Vous pouvez aussi jeter un oeil au <a href="http://forum.debian-fr.org/viewtopic.php?t=4691">tuto sur debian-fr</a></p><h3 id="r-facon-slackware" data-claire-element-id="379969">Façon slackware</h3><p id="r-379966" data-claire-element-id="379966">Slackware a aussi sa méthode de création de paquet, avec la commande makepkg. Pour faire un paquet correctement il faut faire un Slackbuild : c'est un script qui compile le programme et lance makepkg, en faisant les vérifications nécessaires.</p><p id="r-379967" data-claire-element-id="379967">La méthode est décrite dans le <a href="http://wiki.slackware-fr.org/administration:articles:manuel_empaquetage_slackware">Nano-manuel d'empaquetage slackware (sur slackfr.org)</a>. Voir aussi <a href="http://wiki.slackbuilds.net/">le wiki de slackbuild.net (fr)</a> et <a href="http://www.slackwiki.org/Writing_A_SlackBuild_Script">le HOWTO:Writing a Slackbuild script (en)</a></p><p id="r-379968" data-claire-element-id="379968">D'autres docs sont disponibles sur le net, surtout si vous n'avez pas peur de l'anglais...</p><h2 id="r-compiler-via-make-sous-windows" data-claire-element-id="379975">Compiler via make sous Windows</h2><p id="r-379971" data-claire-element-id="379971">Vous voulez faire un projet multiplateforme ?<br/> Vous voulez faire un programme pour Windows et les IDE vous font vomir ?</p><p id="r-379972" data-claire-element-id="379972">Ne vous inquiétez pas, la solution existe : MinGW (Minimal GNU for Windows).<br/> MinGW est un portage de gcc et make sous Windows.</p><p id="r-379973" data-claire-element-id="379973">Vous êtes enfin arrivé à la fin de ce tutoriel. J'espère qu'il vous a plu (ou au moins, qu'il vous a servi). ;)</p><p id="r-379974" data-claire-element-id="379974">Je reste toujours prêt à corriger d'éventuelles erreurs et/ou à le remanier selon vos commentaires (ne soyez pas trop pressés quand même).</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux">Compilez sous GNU/Linux !</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/le-compilateur-gcc-sous-linux">
Le compilateur GCC sous Linux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/compiler-des-bibliotheques-avec-gcc">
Compiler des bibliothèques avec GCC
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/la-commande-make-et-le-fichier-makefile-presentation">
La commande make et le fichier Makefile - Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/makefile-un-preprocesseur">
Makefile : un préprocesseur ?
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/pour-aller-plus-loin-27">
Pour aller plus loin...
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/compilez-sous-gnu-linux/makefile-un-preprocesseur">
<span class="arrow"></span>
<span class="next">Makefile : un préprocesseur ?</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/compilez-sous-gnu-linux.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 02:19:28 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/compilez-sous-gnu-linux.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:33:04 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/les-identificateurs.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 06:12:32 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-identificateurs.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:07:36 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Les identificateurs</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/les-identificateurs.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Les identificateurs</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Lesidentificateurs">Les identificateurs</a><br/><a href="#Prsentation">Présentation</a><br/><a href="#Porteespacesdenomsetmasquage">Portée, espaces de noms et masquage</a><br/><a href="#Liaisonsetdfinitions">Liaisons et définitions</a><br/><a href="#Lesnoms">Les noms</a><br/></div>
<a name="Lesidentificateurs"></a><h2>Les identificateurs</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/presentation-142">
<span class="next">Présentation</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-560818" data-claire-element-id="560818">Bonjour à tous,</p><p id="r-560819" data-claire-element-id="560819">Le but de ce petit tutoriel est de vous expliquer en profondeur la notion d'identificateur en langage C.</p><div id="r-560821" data-claire-element-id="560821" data-claire-semantic="question"><p id="r-560820" data-claire-element-id="560820">Qu'est ce qu'un identificateur ?</p></div><p id="r-560822" data-claire-element-id="560822">Un identificateur peut être défini comme un nom permettant de désigner, de faire référence à une entité du langage. Un exemple d'identificateur que vous connaissez bien est le nom d'une variable ou d'une fonction.</p><div id="r-560824" data-claire-element-id="560824" data-claire-semantic="question"><p id="r-560823" data-claire-element-id="560823">Attend, tu veux dire que tu as créé un tutoriel juste pour nous parler des noms de variable et de fonction ? o_O</p></div><p id="r-560825" data-claire-element-id="560825">Oui, enfin pas tout à fait. ^^ <br/> Vous allez voir qu'un identificateur est plus qu'un simple nom : il peut désigner bien plus d'éléments. Mais j'en ai assez dit, entrons à présent dans le vif du sujet.</p>
</div><a name="Prsentation"></a><h2>Présentation</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/portee-espaces-de-noms-et-masquage">
<span class="next">Portée, espaces de noms et masquage</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-560826" data-claire-element-id="560826">Comme je vous l'ai dit dans l'introduction, un identificateur est un nom qui permet de désigner une entité du langage. Oui, mais quelles entités ? La norme C11 nous en donne huit1 (en comptant les membres de structures/unions/énumérations à part).</p><ul id="r-560843" data-claire-element-id="560843"><li id="r-560828" data-claire-element-id="560828"><p id="r-560827" data-claire-element-id="560827">un objet ;</p></li><li id="r-560830" data-claire-element-id="560830"><p id="r-560829" data-claire-element-id="560829">une fonction ;</p></li><li id="r-560832" data-claire-element-id="560832"><p id="r-560831" data-claire-element-id="560831">une étiquette de structure/union/énumération, qui correspond au nom que vous donnez à votre structure/union/énumération ;</p></li><li id="r-560834" data-claire-element-id="560834"><p id="r-560833" data-claire-element-id="560833">un membre de structure/union/énumération ;</p></li><li id="r-560836" data-claire-element-id="560836"><p id="r-560835" data-claire-element-id="560835">une définition de type (<code data-claire-semantic="c">typedef</code>) ;</p></li><li id="r-560838" data-claire-element-id="560838"><p id="r-560837" data-claire-element-id="560837">une étiquette, utilisée pour l'instruction de saut <code data-claire-semantic="c">goto</code> ;</p></li><li id="r-560840" data-claire-element-id="560840"><p id="r-560839" data-claire-element-id="560839">une macro ;</p></li><li id="r-560842" data-claire-element-id="560842"><p id="r-560841" data-claire-element-id="560841">un paramètre de macro.</p></li></ul><aside id="r-560845" data-claire-element-id="560845" data-claire-semantic="information"><p id="r-560844" data-claire-element-id="560844">Pour rappel (ou non), en C, un objet est une zone mémoire pouvant contenir des données2.</p></aside><p id="r-560846" data-claire-element-id="560846">Comme un exemple vaut souvent mieux qu'un long discours, voici un code <strong>déclarant</strong> un identificateur pour chacune des entités présentées ci-dessus.</p><pre id="r-560847" data-claire-element-id="560847"><code data-claire-semantic="c">#define identificateur_de_macro(identificateur_de_parametre_de_macro)

struct identificateur_d_etiquette_de_structure {
	identificateur_de_membre_de_structure;
};

typedef int identificateur_de_definition_de_type;

void
identificateur_de_fonction(void)
{
	int identificateur_d_objet;

identificateur_d_etiquette:
	;
}</code></pre><p id="r-560848" data-claire-element-id="560848">Notez que je ne parlerai pas des identificateurs de macro et de paramètre de macro dans la suite du tutoriel, ces derniers n'existant plus après le traitement du code par le préprocesseur.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs">Les identificateurs</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/presentation-142">
Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/portee-espaces-de-noms-et-masquage">
Portée, espaces de noms et masquage
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/liaisons-et-definitions">
Liaisons et définitions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/les-noms">
Les noms
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/portee-espaces-de-noms-et-masquage">
<span class="next">Portée, espaces de noms et masquage</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Porteespacesdenomsetmasquage"></a><h2>Portée, espaces de noms et masquage</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/presentation-142">
<span class="arrow"></span>
<span class="next">Présentation</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/liaisons-et-definitions">
<span class="next">Liaisons et définitions</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-560850" data-claire-element-id="560850">Vous avez peut-être remarqué que j'ai utilisé le terme « déclaration » dans la présentation, ce n'est pas anodin, il s'agit d'un concept fondamental du langage C permettant la création d'identificateurs.</p><h2 id="r-la-notion-de-portee" data-claire-element-id="560876">La notion de portée</h2><p id="r-560851" data-claire-element-id="560851">Une déclaration déclare un identificateur, c'est à dire qu'elle le rend utilisable, visible pour la suite du programme. On dit qu'une déclaration confère une <strong>portée</strong> à l'identificateur, c'est à dire une portion du programme où il sera utilisable. Il existe quatre types de portée3 :</p><ul id="r-560860" data-claire-element-id="560860"><li id="r-560853" data-claire-element-id="560853"><p id="r-560852" data-claire-element-id="560852">au niveau d'un bloc ;</p></li><li id="r-560855" data-claire-element-id="560855"><p id="r-560854" data-claire-element-id="560854">au niveau d'un fichier ;</p></li><li id="r-560857" data-claire-element-id="560857"><p id="r-560856" data-claire-element-id="560856">au niveau d'une fonction ;</p></li><li id="r-560859" data-claire-element-id="560859"><p id="r-560858" data-claire-element-id="560858">au niveau d'un prototype.</p></li></ul><p id="r-560861" data-claire-element-id="560861">Cependant, je n'aborderai pas la portée au niveau d'un prototype dans la suite de ce cours, étant donné le peu d'intérêt de cette dernière.</p><h3 id="r-au-niveau-d-un-bloc" data-claire-element-id="560867">Au niveau d'un bloc</h3><p id="r-560862" data-claire-element-id="560862">Une portée au niveau d'un bloc signifie qu'un identificateur est utilisable, visible de sa déclaration jusqu'à la fin du bloc dans lequel il est déclaré. Ainsi, dans le code suivant :</p><pre id="r-560863" data-claire-element-id="560863"><code data-claire-semantic="c">void
f(void)
{
	int n = 10;
}


void
g(void)
{
	n = 20; /* Incorrect */
}</code></pre><p id="r-560864" data-claire-element-id="560864">L'identificateur « n » ne peut pas être utilisé dans le bloc de la fonction g car il a une portée limitée au bloc de la fonction f. De même, le code suivant est erroné :</p><pre id="r-560865" data-claire-element-id="560865"><code data-claire-semantic="c">int *p = &amp;a; /* Incorrect */
int a = 10;</code></pre><p id="r-560866" data-claire-element-id="560866">car au moment de la déclaration de l'identificateur « p », l'identificateur « a » n'est pas encore déclaré, il est donc utilisé en dehors de sa portée.</p><h3 id="r-au-niveau-d-un-fichier" data-claire-element-id="560871">Au niveau d'un fichier</h3><p id="r-560868" data-claire-element-id="560868">Une portée au niveau d'un fichier signifie qu'un identificateur est utilisable, visible de sa déclaration jusqu'à la fin du fichier dans lequel il est déclaré. Pour obtenir un identificateur ayant une portée au niveau d'un fichier, il est nécessaire de le déclarer en dehors de tout bloc, par exemple comme ceci :</p><pre id="r-560869" data-claire-element-id="560869"><code data-claire-semantic="c">int n;

void
f(void)
{
	n = 10;
}

void
g(void)
{
	n = 20;
}</code></pre><p id="r-560870" data-claire-element-id="560870">Dans ce code, l'identificateur « n » a une portée au niveau du fichier et peut par conséquent être aussi bien utilisé dans la fonction f que dans la fonction g.</p><h3 id="r-au-niveau-d-une-fonction" data-claire-element-id="560875">Au niveau d'une fonction</h3><p id="r-560872" data-claire-element-id="560872">Une portée au niveau d'une fonction signifie qu'un identificateur est utilisable, visible dans toute la fonction où il est déclaré et ce, peu importe la position de sa déclaration. Cette portée est propre aux identificateurs d'étiquette, utilisés par l'instruction de saut <code data-claire-semantic="c">goto</code>.</p><pre id="r-560873" data-claire-element-id="560873"><code data-claire-semantic="c">int
main(void)
{
	int n = 0;

test:
	if (!n)
		goto dix;
	else
		goto fin;

dix:
	n = 10;
	goto test;

fin:
	return 0;
}</code></pre><p id="r-560874" data-claire-element-id="560874">Comme vous le voyez, les identificateurs « dix » et « fin » peuvent être utilisés avant leur déclaration car ils ont une portée au niveau de la fonction main.</p><h2 id="r-la-notion-d-espaces-de-noms" data-claire-element-id="560912">La notion d'espaces de noms</h2><p id="r-560877" data-claire-element-id="560877">Une règle importante à retenir est qu'il ne peut pas exister deux identificateurs de même nom dans la même portée, à moins qu'ils ne fassent partie d'<strong>espaces de noms</strong> différents4.</p><div id="r-560879" data-claire-element-id="560879" data-claire-semantic="question"><p id="r-560878" data-claire-element-id="560878">C'est quoi, un espace de noms ? o_O</p></div><p id="r-560880" data-claire-element-id="560880">Bonne question. :-° <br/> Le concept n'est pas facile à définir, mais est par contre très facile à comprendre avec un exemple. Sachez tout d'abord qu'il existe quatre espaces de noms5 :</p><ul id="r-560889" data-claire-element-id="560889"><li id="r-560882" data-claire-element-id="560882"><p id="r-560881" data-claire-element-id="560881">un dédié aux identificateurs d'étiquettes ;</p></li><li id="r-560884" data-claire-element-id="560884"><p id="r-560883" data-claire-element-id="560883">un dédié aux identificateurs d'étiquettes de structures/unions/énumérations ;</p></li><li id="r-560886" data-claire-element-id="560886"><p id="r-560885" data-claire-element-id="560885">un dédié aux identificateurs de membres de structures ou unions ;</p></li><li id="r-560888" data-claire-element-id="560888"><p id="r-560887" data-claire-element-id="560887">un dédié à tous les autres identificateurs.</p></li></ul><p id="r-560890" data-claire-element-id="560890">Comme promis, voici un exemple.</p><pre id="r-560891" data-claire-element-id="560891"><code data-claire-semantic="c">int
main(void)
{
	struct test {
		int test;
	};

	struct test test;

	goto test;
test:
	test.test = 10;
	return 0;
}</code></pre><p id="r-560892" data-claire-element-id="560892">Comme vous le voyez, il y a quatre identificateurs déclarés avec le nom « test » :</p><ul id="r-560901" data-claire-element-id="560901"><li id="r-560894" data-claire-element-id="560894"><p id="r-560893" data-claire-element-id="560893">un identificateur d'étiquette de structure (<code data-claire-semantic="c">struct test</code>, ligne 4) ;</p></li><li id="r-560896" data-claire-element-id="560896"><p id="r-560895" data-claire-element-id="560895">un identificateur de membre de structure (<code data-claire-semantic="c">int test</code>, ligne 5) ;</p></li><li id="r-560898" data-claire-element-id="560898"><p id="r-560897" data-claire-element-id="560897">un identificateur d'objet (<code data-claire-semantic="c">struct test test</code>, ligne 8) ;</p></li><li id="r-560900" data-claire-element-id="560900"><p id="r-560899" data-claire-element-id="560899">un identificateur d'étiquette (<code data-claire-semantic="c">test:</code>, ligne 11).</p></li></ul><p id="r-560902" data-claire-element-id="560902">Ces quatre identificateurs ont tous une portée au niveau du bloc de la fonction main. Ce code ne pose pourtant aucun problème, tout simplement parce que ces derniers appartiennent à quatre espaces de noms différents. Tout risque de confusion est évité de par :</p><ul id="r-560911" data-claire-element-id="560911"><li id="r-560904" data-claire-element-id="560904"><p id="r-560903" data-claire-element-id="560903">le contexte d'utilisation de l'identificateur (l'instruction <code data-claire-semantic="c">goto</code> attend un identificateur d'étiquette) ;</p></li><li id="r-560906" data-claire-element-id="560906"><p id="r-560905" data-claire-element-id="560905">l'utilisation de mots-clés (<code data-claire-semantic="c">struct</code>/<code data-claire-semantic="c">union</code>/<code data-claire-semantic="c">enum</code> pour désigner l'identificateur d'étiquette d'une structure/union/énumération) ;</p></li><li id="r-560908" data-claire-element-id="560908"><p id="r-560907" data-claire-element-id="560907">l'utilisation d'opérateurs (l'opérateur <code data-claire-semantic="c">.</code> ou <code data-claire-semantic="c">-&gt;</code> pour accéder aux membres d'une structure/union) ;</p></li><li id="r-560910" data-claire-element-id="560910"><p id="r-560909" data-claire-element-id="560909">la syntaxe de la déclaration (par exemple les deux points suivant la déclaration d'un identificateur d'étiquette).</p></li></ul><h2 id="r-la-notion-de-masquage" data-claire-element-id="560926">La notion de masquage</h2><p id="r-560913" data-claire-element-id="560913">Nous venons de voir qu'il ne pouvait pas exister deux identificateurs de même nom dans la même portée, <em>quid</em> maintenant de deux identificateurs de même nom ayant des portées différentes ? Autrement dit, que se passe-t-il par exemple dans ce cas ci ?</p><pre id="r-560914" data-claire-element-id="560914"><code data-claire-semantic="c">#include &lt;stdio.h&gt;

int n = 10;

int
main(void)
{
	int n = 20;

	printf(&quot;%d\n&quot;, n);
	return 0;
}</code></pre><p id="r-560915" data-claire-element-id="560915">En fait, dans un tel cas, c'est l'identificateur ayant la portée la plus faible qui sera privilégié. On dit qu'il <strong>masque</strong> celui ou ceux ayant une portée plus élevée6 (en l'occurrence celui ayant une portée au niveau d'un fichier). Je dis « celui ou ceux » car les identificateurs déclarés dans un sous-bloc ont une portée plus faible que ceux déclarés dans le bloc supérieur.</p><pre id="r-560916" data-claire-element-id="560916"><code data-claire-semantic="c">#include &lt;stdio.h&gt;


int n = 10;

int
main(void)
{
	int n = 20;

	if (n == 20) {
		int n = 30;

		printf(&quot;%d\n&quot;, n);
	}

	return 0;
}</code></pre><p id="r-560917" data-claire-element-id="560917">Dans cet exemple, il y a trois identificateurs d'objet portant tous les trois le nom « n » :</p><ul id="r-560924" data-claire-element-id="560924"><li id="r-560919" data-claire-element-id="560919"><p id="r-560918" data-claire-element-id="560918">le premier a une portée au niveau du fichier ;</p></li><li id="r-560921" data-claire-element-id="560921"><p id="r-560920" data-claire-element-id="560920">le second au niveau du bloc de la fonction main ;</p></li><li id="r-560923" data-claire-element-id="560923"><p id="r-560922" data-claire-element-id="560922">et le troisième au niveau du bloc du <code data-claire-semantic="c">if</code>.</p></li></ul><p id="r-560925" data-claire-element-id="560925">L'identificateur ayant une portée au niveau du fichier est donc masqué par celui ayant une portée au niveau du bloc de la fonction main, qui est lui-même masqué par celui ayant une portée au niveau du bloc du <code data-claire-semantic="c">if</code>. Si l'on exécute ce petit programme, il affichera donc 30.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs">Les identificateurs</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/presentation-142">
Présentation
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/portee-espaces-de-noms-et-masquage">
Portée, espaces de noms et masquage
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/liaisons-et-definitions">
Liaisons et définitions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/les-noms">
Les noms
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/presentation-142">
<span class="arrow"></span>
<span class="next">Présentation</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/liaisons-et-definitions">
<span class="next">Liaisons et définitions</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Liaisonsetdfinitions"></a><h2>Liaisons et définitions</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/portee-espaces-de-noms-et-masquage">
<span class="arrow"></span>
<span class="next">Portée, espaces de noms et masquage</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/les-noms">
<span class="next">Les noms</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-560928" data-claire-element-id="560928">Dans le chapitre précédent, nous avons entre autres vu que les identificateurs étaient confinés à une portée et que cette dernière ne pouvait s'étendre au delà d'un fichier. Cependant, si cela s'arrêtait là, il ne serait pas possible d'utiliser des objets ou des fonctions d'autres fichiers. Autrement dit, l'exemple ci-dessous serait incorrect et il serait nécessaire de n'utiliser qu'un seul fichier source, ce qui serait assez peu commode.</p><pre id="r-560929" data-claire-element-id="560929"><code data-claire-semantic="c">int
f(void)
{
	return 1;
}</code></pre><pre id="r-560930" data-claire-element-id="560930"><code data-claire-semantic="c">int f(void);


int
main(void)
{
	f();
	return 0;
}</code></pre><h2 id="r-la-notion-de-liaison" data-claire-element-id="560958">La notion de liaison</h2><h3 id="r-presentation-143" data-claire-element-id="560944">Présentation</h3><p id="r-560931" data-claire-element-id="560931">Heureusement, il existe une solution : la notion de <strong>liaison</strong>. Chaque identificateur peut disposer d'une liaison qui peut être de deux types : externe ou interne7.</p><p id="r-560932" data-claire-element-id="560932">Grâce à cette notion, il est possible de considéré un groupe d'identificateurs comme faisant référence à un même objet ou à une même fonction. En fait, elle permet de préciser que :</p><ul id="r-560937" data-claire-element-id="560937"><li id="r-560934" data-claire-element-id="560934"><p id="r-560933" data-claire-element-id="560933">tous les identificateurs avec liaison externe d'un même programme font référence au même objet ou à la même fonction8 ;</p></li><li id="r-560936" data-claire-element-id="560936"><p id="r-560935" data-claire-element-id="560935">tous les identificateurs avec liaison interne d'un même fichier font référence au même objet ou à la même fonction8.</p></li></ul><p id="r-560938" data-claire-element-id="560938">Ainsi, si je reprends l'exemple donné au début de ce chapitre et que l'on considère que tous les identificateurs de fonction « f » ont une liaison externe ; on peut en déduire qu'en fait, ils font tous référence à la même fonction : celle du fichier autre.c.</p><pre id="r-560939" data-claire-element-id="560939"><code data-claire-semantic="c">int
f(void)
{
	return 1;
}</code></pre><pre id="r-560940" data-claire-element-id="560940"><code data-claire-semantic="c">int f(void);


int
main(void)
{
	f(); /* Retournera 1 */
	return 0;
}</code></pre><p id="r-560941" data-claire-element-id="560941">La même logique peut être appliquée pour une liaison interne, mis à part que le regroupement se limite à un fichier. En conséquence, dans l'exemple ci-dessous, si l'on considère tous les identificateurs de fonction « f » comme ayant une liaison interne, tous ceux situés dans le fichier main.c font référence à la fonction de ce fichier, alors que celui du fichier autre.c fait référence à celle située en son sein.</p><pre id="r-560942" data-claire-element-id="560942"><code data-claire-semantic="c">int
f(void)
{
	return 1;
}</code></pre><pre id="r-560943" data-claire-element-id="560943"><code data-claire-semantic="c">int
f(void)
{
	return 2;
}


int
main(void)
{
	f(); /* Retournera 2 */
	return 0;
}</code></pre><h3 id="r-conditions-d-attribution" data-claire-element-id="560957">Conditions d'attribution</h3><p id="r-560945" data-claire-element-id="560945">Maintenant que vous connaissez la notion de liaison, il reste encore à déterminer dans quelles conditions cette dernière est attribuée à un identificateur. En fait, la présence d'une liaison et son type sont déterminés par la position de la déclaration de l'identificateur ainsi que par l'utilisation des mots-clés <code data-claire-semantic="c">extern</code> et <code data-claire-semantic="c">static</code>. Concrètement, cela se détermine suivant les règles exposées ci-dessous.</p><p id="r-560946" data-claire-element-id="560946">Un identificateur de fonction ou d'objet ayant une portée au niveau d'un fichier a une liaison externe9 / 10, sauf si sa déclaration est précédée du mot-clé <code data-claire-semantic="c">static</code>, auquel cas il a une liaison interne11.</p><pre id="r-560947" data-claire-element-id="560947"><code data-claire-semantic="c">int a;		/* Liaison externe */
static int b;	/* Liaison interne */

void f(void);		/* Liaison externe */
static void g(void);	/* Liaison interne */</code></pre><p id="r-560948" data-claire-element-id="560948">Un identificateur d'objet déclaré à l'intérieur d'un bloc n'a pas de liaison sauf s'il est précédé du mot-clé <code data-claire-semantic="c">extern</code> (voyez la règle suivante)12.</p><pre id="r-560949" data-claire-element-id="560949"><code data-claire-semantic="c">{
	int a; /* Pas de liaison */
}</code></pre><p id="r-560950" data-claire-element-id="560950">Un identificateur d'objet ou de fonction dont la déclaration est précédée du mot-clé <code data-claire-semantic="c">extern</code> a une liaison externe sauf si une déclaration du même identificateur la précède, auquel cas il a la même liaison que ce dernier13.</p><aside id="r-560952" data-claire-element-id="560952" data-claire-semantic="information"><p id="r-560951" data-claire-element-id="560951">Notez que dans le cas où une déclaration d'un identificateur de fonction n'est précédée, ni du mot-clé <code data-claire-semantic="c">static</code>, ni du mot-clé <code data-claire-semantic="c">extern</code>, le mot-clé <code data-claire-semantic="c">extern</code> est implicitement ajouté9.</p></aside><p id="r-560953" data-claire-element-id="560953">Ces règles peuvent paraître quelque peu indigestes, aussi, voici un exemple illustrant chacune de ces dernières.</p><pre id="r-560954" data-claire-element-id="560954"><code data-claire-semantic="c">/*
 * `a' est un identificateur d'objet déclaré en dehors de tout bloc.
 * Il a donc une liaison externe.
 */
int a;

/*
 * `b' est un identificateur d'objet déclaré en dehors de tout bloc.
 * Sa déclaration est précédée du mot-clé `static'.
 * Il a donc une liaison interne.
 */
static int b;

/*
 * `c' est un identificateur d'objet déclaré en dehors de tout bloc.
 * Sa déclaration est précédée du mot-clé `extern'.
 * Aucune déclaration du même identificateur ne le précède.
 * Il a donc une liaison externe.
 */
extern int c;

/*
 * `f' est un identificateur de fonction.
 * Sa déclaration n'est pas précédée du mot-clé `extern' ou `static'.
 * Dès lors, il faut faire comme si elle était précédée du mot-clé `extern'.
 * Aucune déclaration du même identificateur ne le précède.
 * Il a donc une liaison externe.
 */
void f(void);

/*
 * `g' est un identificateur de fonction.
 * Sa déclaration est précédée du mot-clé `static'.
 * Il a donc une liaison interne.
 */
static void g(void);

/*
 * `h' est un identificateur de fonction.
 * Sa déclaration est précédée du mot-clé `extern'.
 * Aucune déclaration du même identificateur ne le précède.
 * Il a donc une liaison externe.
 */
extern void h(void);


int
main(void)
{
	/*
	 * `a' est un identificateur d'objet déclaré à l'intérieur d'un bloc.
	 * Sa déclaration est précédée du mot-clé `extern'.
	 * Il existe déjà une autre déclaration de celui-ci avec liaison externe.
	 * Il a donc une liaison externe.
	 */
	extern int a;

	/*
	 * `b' est un identificateur d'objet déclaré à l'intérieur d'un bloc.
	 * Sa déclaration est précédée du mot-clé `extern'.
	 * Il existe déjà une autre déclaration de celui-ci avec liaison interne.
	 * Il a donc une liaison interne.
	 */
	extern int b;

	/*
	 * `c' est un identificateur d'objet déclaré à l'intérieur d'un bloc.
	 * Sa déclaration n'est pas précédé du mot-clé `extern'.
	 * Il n'a donc pas de liaison.
	 */
	int c;

	/*
	 * `d' est un identificateur d'objet déclaré à l'intérieur d'un bloc.
	 * Sa déclaration est précédée du mot-clé `extern'.
	 * Aucune déclaration du même identificateur ne le précède.
	 * Il a donc une liaison externe.
	 */
	extern int d;


	/*
	 * `g' est un identificateur de fonction.
	 * Sa déclaration n'est pas précédée du mot-clé `extern'.
	 * Dès lors, il faut faire comme si elle était précédée du mot-clé `extern'.
	 * Il existe déjà une autre déclaration de celui-ci avec liaison interne.
	 * Il a donc une liaison interne.
	 */
	void g(void);

	return 0;
}</code></pre><aside id="r-560956" data-claire-element-id="560956" data-claire-semantic="warning"><p id="r-560955" data-claire-element-id="560955">Notez que le mot-clé <code data-claire-semantic="c">static</code> ne peut être utilisé, pour modifier la liaison d'un identificateur, qu'<strong>en dehors de tout bloc</strong> et ce, aussi bien pour les identificateurs d'objet que les identificateurs de fonction14 / 15 !</p></aside><h2 id="r-la-notion-de-definition" data-claire-element-id="560997">La notion de définition</h2><p id="r-560959" data-claire-element-id="560959">Je vous ai dit que la notion de liaison permettait de grouper des identificateurs et de les considérer comme faisant référence au même objet ou à la même fonction. Je vous ai également dit que tous les identificateurs avec liaison externe d'un même programme font référence au même objet ou à la même fonction et que tous les identificateurs avec liaison interne d'un même fichier font référence au même objet ou à la même fonction.</p><p id="r-560960" data-claire-element-id="560960">Cependant, il y a un corollaire qui découle de ces deux règles : il ne peut exister qu'un seul objet ou qu'une seule fonction qui puisse être référencé par le groupe d'identificateurs.</p><p id="r-560961" data-claire-element-id="560961">Au fond, c'est assez logique. Prenez l'exemple ci-dessous, l'identificateur de fonction « f » déclaré dans le bloc de la fonction main a une liaison interne. Cependant, laquelle des deux fonctions désigne-t-il ? La première ? La deuxième ? Les deux ? :-°</p><pre id="r-560962" data-claire-element-id="560962"><code data-claire-semantic="c">static int
f(void)
{
	return 1;
}

static int
f(void)
{
	return 2;
}


int
main(void)
{
	f();
	return 0;
}</code></pre><p id="r-560963" data-claire-element-id="560963">Il est impossible de le dire, il faudrait qu'il n'existe qu'une seule fonction ou, dit plus formellement, qu'il n'y ait qu'une seule <strong>définition</strong> de la fonction f. Qu'est-ce qu'une définition ? C'est ce que nous allons voir tout de suite. :)</p><h3 id="r-les-identificateurs-de-fonction" data-claire-element-id="560967">Les identificateurs de fonction</h3><p id="r-560964" data-claire-element-id="560964">Une définition d'un identificateur de fonction est une déclaration qui comporte le corps de la fonction16. Autrement dit, le code ci-dessous est une définition de l'identificateur de fonction « f », car il comporte le corps de la fonction, alors que le suivant est une déclaration de l'identificateur de fonction « f ».</p><pre id="r-560965" data-claire-element-id="560965"><code data-claire-semantic="c">int
f(void)
{
	return 1;
}</code></pre><pre id="r-560966" data-claire-element-id="560966"><code data-claire-semantic="c">int f(void);</code></pre><h3 id="r-les-identificateurs-d-objet" data-claire-element-id="560978">Les identificateurs d'objet</h3><p id="r-560968" data-claire-element-id="560968">Une définition d'un identificateur d'objet est une déclaration qui alloue l'objet qu'il référence16. Vous voilà bien peu avancé. :p <br/> Heureusement, il y a une règle simple et absolue pour différencier une déclaration et une définition d'un identificateur d'objet : une déclaration d'un identificateur d'objet, en dehors de tout bloc, comportant une initialisation est une définition17. Dans tous les autres cas, il s'agit d'une déclaration.</p><pre id="r-560969" data-claire-element-id="560969"><code data-claire-semantic="c">int a;		/* Déclaration */
static int b;	/* Déclaration */
extern int c;	/* Déclaration */
int d = 10;	/* Définition */</code></pre><p id="r-560970" data-claire-element-id="560970">Cependant, il y a une petite ( :-° ) subtilité : les déclarations d'identificateurs d'objet, en dehors de tout bloc, à l'exception de celles précédées du mot-clé <code data-claire-semantic="c">extern</code>, sont appelées des <strong>définitions potentielles</strong>. Et, dans le cas où un fichier comprend une ou plusieurs définitions potentielles d'un identificateur d'objet mais aucune définition de cet identificateur, une définition est implicitement incluse au début du fichier avec un initialiseur valant zéro18.</p><p id="r-560971" data-claire-element-id="560971">Je vois d'ici vos regards hagards et terrifiés face à cette règle, rassurez vous, nous allons revoir cela en douceur. ;) <br/> Avant toute chose, il est nécessaire que vous fassiez bien la différence entre une déclaration, une définition potentielle et une définition d'un identificateur d'objet. Pour ce faire, voici un petit exemple simple.</p><pre id="r-560972" data-claire-element-id="560972"><code data-claire-semantic="c">/*
 * Cette déclaration ne comporte pas d'initialisation.
 * Elle n'est pas précédée du mot-clé `extern'.
 * Il s'agit donc d'une définition potentielle.
 */
int n;

/*
 * Cette déclaration comporte une initialisation.
 * Il s'agit donc d'une définition.
 */
extern int n = 10;

/*
 * Cette déclaration ne comporte pas d'initialisation.
 * Elle n'est pas précédée du mot-clé `extern'.
 * Il s'agit donc d'une définition potentielle.
 */
static int n;

/*
 * Cette déclaration ne comporte pas d'initialisation.
 * Elle est précédée du mot-clé `extern'.
 * Il s'agit donc d'une déclaration.
 */
extern int n;</code></pre><p id="r-560973" data-claire-element-id="560973">Ensuite, reprenons cette horrible règle pas à pas à l'aide du code ci-dessous.</p><pre id="r-560974" data-claire-element-id="560974"><code data-claire-semantic="c">int n;

int
main(void)
{
	return n;
}</code></pre><p id="r-560975" data-claire-element-id="560975">Comme vous le voyez, nous avons un fichier comprenant une définition potentielle de l'identificateur d'objet « n », mais aucune définition de cet identificateur.</p><p id="r-560976" data-claire-element-id="560976">Ce que dit l'obscure règle que je vous ai présentée auparavant, c'est que dans le cas où un fichier comprend une ou plusieurs définitions potentielles d'un identificateur mais aucune définition de cet identificateur (ce qui est le cas de notre fichier), une définition est implicitement inclue au début de ce fichier avec un initialiseur valant zéro. Autrement dit, appliquée à notre exemple, cela donne ceci :</p><pre id="r-560977" data-claire-element-id="560977"><code data-claire-semantic="c">/* Définition implicite */
int n = 0;
int n;

int
main(void)
{
	return n;
}</code></pre><h3 id="r-formalisation-de-l-interdiction" data-claire-element-id="560996">Formalisation de l'interdiction</h3><p id="r-560979" data-claire-element-id="560979">Maintenant que nous avons vu la notion de définition, il m'est possible de formaliser ce que je vous ai dit au début de la présentation de cette notion : il ne peut exister qu'un seul objet ou qu'une seule fonction qui puisse être référencée par un groupe d'identificateur. Ou, dit de manière plus formelle :</p><ul id="r-560984" data-claire-element-id="560984"><li id="r-560981" data-claire-element-id="560981"><p id="r-560980" data-claire-element-id="560980">il ne peut y avoir qu'une seule définition d'un même identificateur avec liaison externe dans tout le programme19 ;</p></li><li id="r-560983" data-claire-element-id="560983"><p id="r-560982" data-claire-element-id="560982">il ne peut y avoir qu'une seule définition d'un même identificateur avec liaison interne dans un même fichier20.</p></li></ul><aside id="r-560986" data-claire-element-id="560986" data-claire-semantic="information"><p id="r-560985" data-claire-element-id="560985">Certains compilateurs (<code data-claire-semantic="c">gcc</code> pour ne citer que lui) sont par défaut capables de gérer certains cas de définitions multiples. Sachez cependant qu'il s'agit d'une extension non standard. Dans le cas de <code data-claire-semantic="c">gcc</code>, il est possible de désactiver cette extension en utilisant l'option -fno-common.</p></aside><p id="r-560987" data-claire-element-id="560987">Le code ci-dessous est donc incorrect car il comporte plus d'une définition avec liaison interne de l'identificateur « n ».</p><pre id="r-560988" data-claire-element-id="560988"><code data-claire-semantic="c">static int n = 10;
static int n = 20;


int
main(void)
{
	return n;
}</code></pre><p id="r-560989" data-claire-element-id="560989">De même, le code qui suit est faux car il existe plus d'une définition avec liaison externe de l'identificateur « n » dans tout le programme (n'oubliez pas la définition implicite !).</p><pre id="r-560990" data-claire-element-id="560990"><code data-claire-semantic="c">int n = 10;</code></pre><pre id="r-560991" data-claire-element-id="560991"><code data-claire-semantic="c">int n;

int
main(void)
{
	return n;
}</code></pre><p id="r-560992" data-claire-element-id="560992">Notez enfin que si un identificateur apparaît dans un fichier avec à la fois une liaison externe et interne, le résultat est indéterminé21.</p><pre id="r-560993" data-claire-element-id="560993"><code data-claire-semantic="c">int
f(void)
{
	return 1;
}</code></pre><pre id="r-560994" data-claire-element-id="560994"><code data-claire-semantic="c">int f(void);

static int
f(void)
{
	return 2;
}


int
main(void)
{
	f();
	return 0;
}</code></pre><p id="r-560995" data-claire-element-id="560995">Dans cet exemple, l'identificateur « f » du fichier main.c a à la fois une liaison externe et interne. Il est donc impossible de dire à quelle fonction il fait référence.</p><h2 id="r-en-bref-6" data-claire-element-id="561005">En bref</h2><p id="r-560998" data-claire-element-id="560998">Que retenir de ce chapitre si ce n'est qu'il est affreusement théorique et complexe ? :-° <br/> En fait, il est possible d'en déduire une méthode générale afin de partager des variables ou des fonctions entre plusieurs fichiers source.</p><p id="r-560999" data-claire-element-id="560999">Étant donné que les fichiers d'en-têtes sont très souvent inclus dans plusieurs fichiers (pensez à ceux de la bibliothèque standard par exemple), ces derniers ne doivent contenir que des déclarations. En effet, si ce n'est pas le cas, vous allez vous retrouver avec des définitions multiples (explicites ou implicites) et, dès lors, rencontrer des erreurs lors de la compilation. Les fichiers source, quant à eux, recueillent donc les définitions.</p><p id="r-561000" data-claire-element-id="561000">Ainsi, lorsque vous souhaitez utiliser une ou plusieurs variables ou fonctions définies dans un autre fichier, vous incluez le ou les fichiers d'en-tête comprenant leur déclarations dans les fichiers source où vous souhaitez les utiliser. Cette méthode a l'avantage d'éviter d'avoir à réécrire toutes les déclarations dans chaque fichier.</p><p id="r-561001" data-claire-element-id="561001">L'exemple ci-dessous illustre ce qui vient d'être exposé.</p><pre id="r-561002" data-claire-element-id="561002"><code data-claire-semantic="c">#ifndef AUTRE_H
#define AUTRE_H

extern int n;		/* Déclaration */
extern void setn(int);	/* Déclaration */

#endif /* AUTRE_H */</code></pre><pre id="r-561003" data-claire-element-id="561003"><code data-claire-semantic="c">/* Inclusion des déclarations */
#include &quot;autre.h&quot;

/* Définition potentielle */
int n;

/* Définition */
void
setn(int a)
{
	n = a;
}</code></pre><pre id="r-561004" data-claire-element-id="561004"><code data-claire-semantic="c">/* Inclusion des déclarations */
#include &lt;stdio.h&gt;
#include &quot;autre.h&quot;

int
main(void)
{
	printf(&quot;%d\n&quot;, n); /* 0 */
	setn(99);
	printf(&quot;%d\n&quot;, n); /* 99 */
	return 0;
}</code></pre>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs">Les identificateurs</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/presentation-142">
Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/portee-espaces-de-noms-et-masquage">
Portée, espaces de noms et masquage
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/liaisons-et-definitions">
Liaisons et définitions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/les-noms">
Les noms
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/portee-espaces-de-noms-et-masquage">
<span class="arrow"></span>
<span class="next">Portée, espaces de noms et masquage</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/les-noms">
<span class="next">Les noms</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesnoms"></a><h2>Les noms</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/liaisons-et-definitions">
<span class="arrow"></span>
<span class="next">Liaisons et définitions</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-561007" data-claire-element-id="561007">Nous allons à présent terminer notre tour d'horizon des identificateurs avec un sujet plus léger et nettement plus simple (ouf !) : le nom des identificateurs.</p><h3 id="r-caracteres-utilisables" data-claire-element-id="561013">Caractères utilisables</h3><p id="r-561008" data-claire-element-id="561008">Un nom est composé d'une suite de lettres et de chiffres. Oui, mais quelles lettres et quels chiffres ? La liste exhaustive nous est donnée par la norme22.</p><p id="r-561009" data-claire-element-id="561009"><cite>Citation : Caractères utilisables</cite></p><blockquote id="r-561011" data-claire-element-id="561011"><p id="r-561010" data-claire-element-id="561010">a b c d e f g h i j k l m<br/> n o p q r s t u v w x y z<br/> A B C D E F G H I J K L M<br/> N O P Q R S T U V W X Y Z<br/> 0 1 2 3 4 5 6 7 8 9 _</p></blockquote><p id="r-561012" data-claire-element-id="561012">Sachez qu'un nom ne peut pas commencer par un chiffre, il doit obligatoirement débuter par une lettre ou par un <em>underscore</em>23.</p><h3 id="r-noms-reserves-par-le-langage" data-claire-element-id="561017">Noms réservés par le langage</h3><p id="r-561014" data-claire-element-id="561014">Nous savons désormais de quels caractères peuvent être composés nos noms. Cependant, tous les noms ne sont pas utilisables. En effet, certains sont réservés par le langage C lui-même et ne sont donc pas disponibles24.</p><pre id="r-561015" data-claire-element-id="561015"><code data-claire-semantic="c">auto		if		unsigned
break		inline		void
case		int		volatile
char		long		while
const		register	_Alignas
continue	restrict	_Alignof
default		return		_Atomic
do		short		_Bool
double		signed		_Complex
else		sizeof		_Generic
enum		static		_Imaginary
extern		struct		_Noreturn
float		switch		_Static_assert
for		typedef		_Thread_local
goto		union</code></pre><p id="r-561016" data-claire-element-id="561016">Il est à noter que certaines implémentations réservent aussi les mots <code data-claire-semantic="c">asm</code> et <code data-claire-semantic="c">fortran</code>. Il est donc également préférable de les éviter.</p><h3 id="r-noms-reserves-par-la-bibliotheque-standard" data-claire-element-id="561031">Noms réservés par la bibliothèque standard</h3><p id="r-561018" data-claire-element-id="561018">À côté des noms réservés par le langage lui-même, il y a ceux réservés par la bibliothèque standard. En fait, tous les noms de fonctions (par exemple printf) ou de variables (par exemple errno) utilisés par celle-ci sont à éviter, même si vous n'incluez pas l'en-tête les utilisant. Renseignez-vous sur les différents en-têtes pour obtenir les noms qu'ils emploient. ;)</p><p id="r-561019" data-claire-element-id="561019">En plus de cela, la bibliothèque standard réserve certains types de noms dans des portées particulières. Ainsi, sont interdits :</p><ul id="r-561024" data-claire-element-id="561024"><li id="r-561021" data-claire-element-id="561021"><p id="r-561020" data-claire-element-id="561020">les noms commençant par un <em>underscore</em> et une lettre majuscule ou commençant par deux underscore et ce, peu importe leur portée25 ;</p></li><li id="r-561023" data-claire-element-id="561023"><p id="r-561022" data-claire-element-id="561022">les noms commençant par un <em>underscore</em> et ayant une portée au niveau d'un fichier25.</p></li></ul><p id="r-561025" data-claire-element-id="561025">Afin de bien cerner cette interdiction, voici un petit d'exemple.</p><pre id="r-561026" data-claire-element-id="561026"><code data-claire-semantic="c">#define _HELLO		/* Interdit */
#define __HELLO		/* Interdit */
#define __hello		/* Interdit */
#define _hello		/* Interdit car il a une portée au niveau d'un fichier */
	

struct _structure {	/* Interdit pour les même motifs */
	int _membre;	/* Permis */
};


int
main(void)
{
	int _variable;	/* Permis car il n'a pas une portée au niveau d'un fichier */
	int auto;	/* Interdit car c'est un mot réservé par le langage */
	
	return 0;
}</code></pre><p id="r-561027" data-claire-element-id="561027">Remarquez enfin que dans le cas de l'en-tête &lt;errno.h&gt;, les noms de macro commençant par un E et un chiffre ou une lettre majuscule ne doivent pas non plus être employés26, de même pour l'en-tête &lt;signal.h&gt; et les noms de macro commençant par SIG ou SIG_ et une lettre majuscule27.</p><p id="r-561028" data-claire-element-id="561028">Voilà qui termine mon exposé sur les identificateurs. J'espère que vous y voyez désormais plus clair et que vous jonglez avec les portées et les liaisons. ;)</p><h2 id="r-references-9" data-claire-element-id="561030">Références</h2><p id="r-561029" data-claire-element-id="561029"> 1 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.1 : Scopes of identifiers, al. 1, p. 35.<br/> 2 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 3.15 : Terms, definitions, and symbols, al. 1, p. 6.<br/> 3 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.1 : Scopes of identifiers, al. 2, p. 35.<br/> 4 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.1 : Scopes of identifiers, al. 2, p. 35.<br/> 5 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.3 : Name spaces of identifiers, al. 1, p. 37.<br/> 6 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.1 : Scopes of identifiers, al. 4, p. 36.<br/> 7 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.2 : Linkages of identifiers, al. 1, p. 36.<br/> 8 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.2 : Linkages of identifiers, al. 2, p. 36.<br/> 9 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.2 : Linkages of identifiers, al. 5, p. 37.<br/>10 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.2 : Linkages of identifiers, al. 5, p. 37.<br/>11 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.2 : Linkages of identifiers, al. 3, p. 36.<br/>12 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.2 : Linkages of identifiers, al. 6, p. 37.<br/>13 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.2 : Linkages of identifiers, al. 4, p. 37.<br/>14 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.4 : Storage durations of objects, al. 3, p. 38.<br/>15 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.7.1 : Storage-class specifiers, al. 7, p. 110.<br/>16 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.7 : Declarations, al. 5, p. 108.<br/>17 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.9.2 : External object definitions, al. 1, p. 158.<br/>18 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.9.2 : External object definitions, al. 2, p. 158.<br/>19 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.9 : External definitions, al. 5, p. 155.<br/>20 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.9 : External definitions, al. 3, p. 155.<br/>21 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.2.2 : Linkages of identifiers, al. 7, p 37.<br/>22 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.4.2.1 : General, al. 1, p. 59.<br/>23 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.4.2.1 : General, al. 2, p. 59.<br/>24 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 6.4.1 : Keywords, al. 1, p. 58.<br/>25 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 7.1.3 : Reserved identifiers, al. 1, p. 182.<br/>26 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 7.5 : Errors &lt;errno.h&gt;, al. 4, p. 205.<br/>27 ISO/IEC 9899:2011 (doc. <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">N1570</a>) : Programming languages - C - § 7.14 : Signal handling &lt;signal.h&gt;, al. 4, p. 265.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs">Les identificateurs</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/presentation-142">
Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/portee-espaces-de-noms-et-masquage">
Portée, espaces de noms et masquage
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/liaisons-et-definitions">
Liaisons et définitions
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/les-noms">
Les noms
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-identificateurs/liaisons-et-definitions">
<span class="arrow"></span>
<span class="next">Liaisons et définitions</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/les-identificateurs.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 06:12:32 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-identificateurs.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:07:36 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/ableaux-pointeurs-et-allocation-dynamique.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 00:06:13 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/ableaux-pointeurs-et-allocation-dynamique.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:16:20 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Tableaux, pointeurs et allocation dynamique</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Tableaux, pointeurs et allocation dynamique</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Tableauxpointeursetallocationdynamique">Tableaux, pointeurs et allocation dynamique</a><br/><a href="#Lespointeursrappel">Les pointeurs (rappel)</a><br/><a href="#Lestableauxunidimensionnels">Les tableaux unidimensionnels</a><br/><a href="#Lestableauxdetableauxquottableauxplusieursdimensionsquot">Les tableaux de tableaux (&quot;tableaux à plusieurs dimensions&quot;)</a><br/><a href="#Exercices">Exercices</a><br/></div>
<a name="Tableauxpointeursetallocationdynamique"></a><h2>Tableaux, pointeurs et allocation dynamique</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-pointeurs-rappel">
<span class="next">Les pointeurs (rappel)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-515347" data-claire-element-id="515347">Bien que les tableaux et les pointeurs soient souvent confondus, il s'agit de deux choses différentes.</p><p id="r-515348" data-claire-element-id="515348">Nous allons aborder ce sujet dans le but d'utiliser correctement chacun de ces types (pointeur et tableau) et de comprendre la différence entre ces deux notions.<br/> Nous allons également voir certaines notions approfondies dans les manipulations des tableaux (les initialisations, les déclarations, les passages en paramètre pour les fonctions).</p><p id="r-515349" data-claire-element-id="515349">Sans plus tarder attaquons le vif du sujet en vous souhaitant une bonne lecture.</p><aside id="r-515364" data-claire-element-id="515364" data-claire-semantic="information"><p id="r-515350" data-claire-element-id="515350">Conseils pour une bonne lecture :</p><ul id="r-515363" data-claire-element-id="515363"><li id="r-515352" data-claire-element-id="515352"><p id="r-515351" data-claire-element-id="515351">Une bonne concentration.</p></li><li id="r-515354" data-claire-element-id="515354"><p id="r-515353" data-claire-element-id="515353">Un projet &quot;test&quot; ouvert, pour coder au fur et à mesure que vous lisez.</p></li><li id="r-515356" data-claire-element-id="515356"><p id="r-515355" data-claire-element-id="515355">Ne pas passer à l'étape suivante sans comprendre l'étape précédente.</p></li><li id="r-515358" data-claire-element-id="515358"><p id="r-515357" data-claire-element-id="515357">Faites des exercices à chaque fin de partie du tutoriel.</p></li><li id="r-515360" data-claire-element-id="515360"><p id="r-515359" data-claire-element-id="515359">Ne lisez pas le tutoriel en entier d'un seul coup.</p></li><li id="r-515362" data-claire-element-id="515362"><p id="r-515361" data-claire-element-id="515361">Suspendez la lecture si vous vous sentez largués. Et reprenez la lecture plus tard.</p></li></ul></aside>
</div><a name="Lespointeursrappel"></a><h2>Les pointeurs (rappel)</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-unidimensionnels">
<span class="next">Les tableaux unidimensionnels</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-definition-73" data-claire-element-id="515367">Définition</h2><p id="r-515365" data-claire-element-id="515365">A la déclaration d'une variable, un emplacement lui est accordé dans la mémoire. Cet emplacement possède une adresse. Cette adresse peut être stockée dans une variable de type pointeur.</p><p id="r-515366" data-claire-element-id="515366">Pour résumer un pointeur est une variable qui contient l'adresse mémoire d'une autre variable.</p><h2 id="r-declaration-15" data-claire-element-id="515371">Déclaration</h2><p id="r-515368" data-claire-element-id="515368">L'opérateur de déclaration de pointeur est l'astérisque '*', et il est caractérisé par le type de variable sur laquelle il va pointer.<br/> Ainsi pour déclarer un pointeur on doit respecter la syntaxe suivante : <strong>type</strong> *<code data-claire-semantic="c">nom_du_pointeur</code>;</p><p id="r-515369" data-claire-element-id="515369">Si par exemple on souhaite déclarer un pointeur sur une variable de type int, on ferait comme ceci :</p><pre id="r-515370" data-claire-element-id="515370"><code data-claire-semantic="c">int * ptrint;</code></pre><h2 id="r-utilisations-4" data-claire-element-id="515415">Utilisations</h2><p id="r-515372" data-claire-element-id="515372">La règle à retenir est la suivante :</p><ul id="r-515375" data-claire-element-id="515375"><li id="r-515374" data-claire-element-id="515374"><p id="r-515373" data-claire-element-id="515373"><strong><em>Un pointeur doit toujours être initialisé avant utilisation.</em></strong></p></li></ul><h3 id="r-initialisation-9" data-claire-element-id="515395">Initialisation</h3><div id="r-515377" data-claire-element-id="515377" data-claire-semantic="question"><p id="r-515376" data-claire-element-id="515376">Pourquoi il faut toujours initialiser les pointeurs ?</p></div><p id="r-515378" data-claire-element-id="515378">A la déclaration d'une variable quelconque, sa valeur ne peut pas être déterminée. Elle peut valoir &quot;n'importe quoi&quot;. Les pointeurs étant des variables aussi, alors à la déclaration ils valent n'importe quoi :) . Cette valeur se réfère donc à un emplacement mémoire dont on ignore sa signification. Et qui ne nous est pas alloué, donc inutilisable.</p><div id="r-515380" data-claire-element-id="515380" data-claire-semantic="question"><p id="r-515379" data-claire-element-id="515379">Et comment initialiser un pointeur ?</p></div><p id="r-515381" data-claire-element-id="515381">L'initialisation peut avoir trois formes :</p><ul id="r-515393" data-claire-element-id="515393"><li id="r-515385" data-claire-element-id="515385"><p id="r-515382" data-claire-element-id="515382">Avec la valeur <code data-claire-semantic="c">NULL</code> :</p><pre id="r-515383" data-claire-element-id="515383"><code data-claire-semantic="c">int * ptrint = NULL;</code></pre><p id="r-515384" data-claire-element-id="515384">Le pointeur <code data-claire-semantic="c">NULL</code> souvent sous la forme <code data-claire-semantic="c">(void*)0</code>, est une macro déclarée dans <em>stddef.h</em>. Elle est utilisée pour des opérations exclusivement sur le type pointeur (affectation, comparaison...).</p></li><li id="r-515389" data-claire-element-id="515389"><p id="r-515386" data-claire-element-id="515386">Avec l'adresse d'une de nos variables déclarées.</p><pre id="r-515387" data-claire-element-id="515387"><code data-claire-semantic="c">int variable;
int * ptrint = &amp;variable;</code></pre><p id="r-515388" data-claire-element-id="515388">Rappelez-vous de l'opérateur '&amp;', qui permet d'avoir l'adresse mémoire d'un objet. Il s'utilise toujours accompagné du nom de l'objet que l'on souhaite connaitre son adresse mémoire.<br/> Avec cette initialisation, on est sûr que l'espace mémoire que notre pointeur indique, nous est alloué.</p></li><li id="r-515392" data-claire-element-id="515392"><p id="r-515390" data-claire-element-id="515390">En faisant une allocation dynamique (que nous allons voir plus loin dans ce tutoriel).</p><pre id="r-515391" data-claire-element-id="515391"><code data-claire-semantic="c">int * ptrint = malloc(10);</code></pre></li></ul><p id="r-515394" data-claire-element-id="515394">Donc si vous déclarez un pointeur, ayez à l'esprit qu'il faudra l'initialiser tôt ou tard :) avec l'une des trois méthodes présentées ci-dessus, en fonction de ce que vous souhaitez en faire.<br/> Autrement il y a de fortes chances pour que votre programme plante avec l'erreur &quot;<a href="http://fr.wikipedia.org/wiki/Erreur_de_segmentation">SEGFAULT</a>&quot;.</p><h3 id="r-acceder-a-l-adresse-pointee" data-claire-element-id="515399">Accéder à l'adresse pointée</h3><p id="r-515396" data-claire-element-id="515396">L'astérisque '*', vous l'avez reconnue :) . C'est ce même opérateur qui est utilisé pour déclarer une variable de type pointeur et pour accéder à l'emplacement indiqué par notre pointeur.<br/> Dans l'apprentissage de cette partie, les débutants confondent toujours quand est-ce qu'il faut utiliser l'étoile et quand est-ce qu'il ne faut pas l'utiliser.<br/> Gardez à l'esprit que l'étoile, à la déclaration d'une variable de type pointeur, ne signifie pas qu'on accède à l'emplacement qu'il pointe, mais sert juste à dire au compilateur qu'il s'agit d'une déclaration de pointeur.<br/> Mis à part ce cas là, toutes les autres utilisations de l'opérateur '*' suivi du nom d'un pointeur, signifient que c'est de l'emplacement pointé qu'il s'agit.</p><p id="r-515397" data-claire-element-id="515397">Exemple :</p><pre id="r-515398" data-claire-element-id="515398"><code data-claire-semantic="c">int * ptrint;        //Déclaration du pointeur
int variable;        //Déclaration d'une variable

ptrint = &amp;variable;  //Initialisation de notre pointeur

*ptrint = 10;        //On inscrit 10 à l'espace pointé par notre pointeur (en l'occurrence la variable).</code></pre><h3 id="r-argument-de-fonctions-passage-par-valeur" data-claire-element-id="515406">Argument de fonctions : passage par valeur</h3><p id="r-515400" data-claire-element-id="515400">Lors de l'appel d'une fonction, on lui donne des valeurs sous forme de paramètres. Il existe donc le type de passages qu'on appelle par valeur, qui consiste à passer une copie de notre valeur à la fonction. Ainsi la fonction ne manipulera que cette copie de notre valeur, et tous les changements qui y seront apportés, ne seront pas pris en compte ailleurs.</p><p id="r-515401" data-claire-element-id="515401">Exemple :</p><pre id="r-515402" data-claire-element-id="515402"><code data-claire-semantic="c">void ma_fonction(int n)  //Fonction appelée
{
      n = 10;
}

int main (void)                         //Fonction appelante
{
      int variable = 123;

      ma_fonction(variable);
      printf(&quot;La valeur de variable est %d\n&quot;,variable);

      return 0;
}</code></pre><p id="r-515403" data-claire-element-id="515403">Le résultat de ce code sera donc :</p><pre id="r-515404" data-claire-element-id="515404"><code data-claire-semantic="console">La valeur de variable est 123</code></pre><p id="r-515405" data-claire-element-id="515405">Pourtant on a bien modifié la valeur envoyée à la fonction 'ma_fonction'. C'est ce qu'on appelle un passage par valeur :) .</p><h3 id="r-argument-de-fonctions-passage-par-adresse" data-claire-element-id="515412">Argument de fonctions : passage par adresse</h3><p id="r-515407" data-claire-element-id="515407">Ce type de passage donnera un résultat différent de celui présenté précédemment. Il consiste à envoyer l'adresse mémoire de notre variable et non pas sa valeur. Ainsi on a accès à l'emplacement même de cette variable en mémoire. Donc les changements qu'on apportera à cet espace mémoire, seront des changements qu'on aura apportés à notre variable directement. Si je reprends le même exemple, ceci donnerait :</p><pre id="r-515408" data-claire-element-id="515408"><code data-claire-semantic="c">void ma_fonction(int * ptrn)
{
      *ptrn = 10;    //On inscrit la valeur 10 à l'emplacement mémoire indiqué par ptrn
}

int main (void)
{
      int variable = 123;

      ma_fonction( &amp;variable );                            //On appelle la fonction
      printf(&quot;La valeur de variable est %d\n&quot;,variable);

      return 0;
}</code></pre><p id="r-515409" data-claire-element-id="515409">Et le résultat est :</p><pre id="r-515410" data-claire-element-id="515410"><code data-claire-semantic="console">La valeur de variable est 10</code></pre><p id="r-515411" data-claire-element-id="515411">C'est ce qu'on appel un passage par adresse ;) .</p><h3 id="r-argument-de-fonctions-passage-par-reference" data-claire-element-id="515414">Argument de fonctions : passage par référence</h3><p id="r-515413" data-claire-element-id="515413">Le passage par référence tel que nous pouvons le voir dans d'autres langages (C++ par exemple) ne peut pas être réalisé en C; mais il peut être implémenté par utilisation du &quot;passage par adresse&quot;.<br/> Ce passage par adresse est un passage par valeur quelque part, car on transmet une copie de l'adresse de la variable à la fonction. Donc ne soyez pas choqué si on vous dit quelque part qu'il n'y a pas de passage par référence en C.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique">Tableaux, pointeurs et allocation dynamique</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-pointeurs-rappel">
Les pointeurs (rappel)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-unidimensionnels">
Les tableaux unidimensionnels
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-de-tableaux-tableaux-a-plusieurs-dimensions">
Les tableaux de tableaux (&quot;tableaux à plusieurs dimensions&quot;)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/exercices-31">
Exercices
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-unidimensionnels">
<span class="next">Les tableaux unidimensionnels</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lestableauxunidimensionnels"></a><h2>Les tableaux unidimensionnels</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-pointeurs-rappel">
<span class="arrow"></span>
<span class="next">Les pointeurs (rappel)</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-de-tableaux-tableaux-a-plusieurs-dimensions">
<span class="next">Les tableaux de tableaux (&quot;tableaux à plusieurs dimensions&quot;)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-definition-74" data-claire-element-id="515438">Définition</h2><p id="r-515417" data-claire-element-id="515417">&quot;<em>Un tableau est une suite contigüe de données de même type dans la mémoire.</em>&quot;</p><p id="r-515418" data-claire-element-id="515418">Beaucoup de gros mots dans cette phrase n'est-ce pas :) ?</p><p id="r-515419" data-claire-element-id="515419">Si nous les regardons de plus près :</p><p id="r-515420" data-claire-element-id="515420"><strong>Une suite contigüe :</strong></p><p id="r-515421" data-claire-element-id="515421">Une suite contigüe signifie un ensemble d'éléments disposés les uns à la suite des autres sans être intercalés.</p><table id="r-515434" data-claire-element-id="515434"><tbody id="r-515433" data-claire-element-id="515433"><tr id="r-515432" data-claire-element-id="515432"><td id="r-515423" data-claire-element-id="515423"><p id="r-515422" data-claire-element-id="515422">-Donnée1-</p></td><td id="r-515425" data-claire-element-id="515425"><p id="r-515424" data-claire-element-id="515424">-Donnée2-</p></td><td id="r-515427" data-claire-element-id="515427"><p id="r-515426" data-claire-element-id="515426">-Donnée3-</p></td><td id="r-515429" data-claire-element-id="515429"><p id="r-515428" data-claire-element-id="515428">........</p></td><td id="r-515431" data-claire-element-id="515431"><p id="r-515430" data-claire-element-id="515430">-DonnéeN-</p></td></tr></tbody></table><p id="r-515435" data-claire-element-id="515435"><strong>Données de même type :</strong></p><p id="r-515436" data-claire-element-id="515436">Ceci signifie que toutes les données qu'on va retrouver dans notre tableau vont être du même type :) .</p><p id="r-515437" data-claire-element-id="515437">Si nous prenons l'exemple ci-dessus, donnée1, donnée2 jusqu'à la donnéeN vont être exactement du même type.</p><h2 id="r-declaration-syntaxe" data-claire-element-id="515444">Déclaration (syntaxe)</h2><p id="r-515439" data-claire-element-id="515439">La déclaration d'un type tableau en C s'obtient par utilisation des crochets '[' ']', et en précisant le type de données qu'il y aura dedans ainsi que le nombre.</p><p id="r-515440" data-claire-element-id="515440">Le nombre de ces éléments sera appelé la taille de notre tableau, et leur type le type de notre tableau.</p><p id="r-515441" data-claire-element-id="515441">La déclaration sera donc sous la forme : <strong>type</strong><code data-claire-semantic="c">nom_du_tableau </code> [ <strong>taille</strong> ];</p><p id="r-515442" data-claire-element-id="515442">Voici un exemple de déclaration d'un tableau de 10 entiers :</p><pre id="r-515443" data-claire-element-id="515443"><code data-claire-semantic="c">int tableau[10];</code></pre><h2 id="r-utilisation-70" data-claire-element-id="515743">Utilisation</h2><h3 id="r-initialisation-10" data-claire-element-id="515675">Initialisation</h3><p id="r-515445" data-claire-element-id="515445">Il existe certaines expressions <strong>réservées à l'initialisation lors de la déclaration d'un tableau</strong>.</p><aside id="r-515448" data-claire-element-id="515448" data-claire-semantic="error"><pre id="r-515446" data-claire-element-id="515446"><code data-claire-semantic="c">int tableau[3];
tableau = ....;</code></pre><p id="r-515447" data-claire-element-id="515447">Erreur très courante à l'utilisation des chaines de caractères.</p></aside><p id="r-515449" data-claire-element-id="515449">Ces expressions sont :</p><ul id="r-515674" data-claire-element-id="515674"><li id="r-515457" data-claire-element-id="515457"><p id="r-515450" data-claire-element-id="515450">L'utilisation des accolades {} :</p><pre id="r-515451" data-claire-element-id="515451"><code data-claire-semantic="c">int tableau[4] = {15,2,14,23};</code></pre><p id="r-515452" data-claire-element-id="515452">Les cases de ce tableau qu'on vient de déclarer seront donc initialisées respectivement avec les valeurs 15, 2, 14 et 23. Vous remarquerez que le nombre de valeurs correspond à la taille de notre tableau (à savoir 4 éléments). Il est possible de n'initialiser qu'un certain nombre de cases dans ce tableau ainsi :</p><pre id="r-515453" data-claire-element-id="515453"><code data-claire-semantic="c">int tableau[4] = {15,2};</code></pre><p id="r-515454" data-claire-element-id="515454">Ainsi nous aurons initialisé que les deux premières cases. Vous vous demandez peut être ce que deviennent les autres cases :) , elles sont toutes initialisées avec des 0 (zéros).</p><p id="r-515455" data-claire-element-id="515455">En conséquence une initialisation à zéro de la première case uniquement, initialiserait tout notre tableau à zéro :</p><pre id="r-515456" data-claire-element-id="515456"><code data-claire-semantic="c">int tableau[4] = {0};</code></pre></li><li id="r-515660" data-claire-element-id="515660"><p id="r-515458" data-claire-element-id="515458">L'utilisation des accolades {} avec un tableau dont la taille n'est pas spécifiée :</p><pre id="r-515459" data-claire-element-id="515459"><code data-claire-semantic="c">int tableau[] = {15,2,14,23};</code></pre><p id="r-515460" data-claire-element-id="515460">Deux choses très importantes à noter dans ce type de déclarations :<br/> 1_ Le tableau sera alloué pour contenir le nombre d'éléments présents entre les accolades (en l'occurrence 4).<br/> 2_ Le tableau sera initialisé avec ces éléments.</p><p id="r-515461" data-claire-element-id="515461">Par conséquent, il ne faut pas mélanger cette déclaration avec l'initialisation type {0} :</p><aside id="r-515463" data-claire-element-id="515463" data-claire-semantic="error"><pre id="r-515462" data-claire-element-id="515462"><code data-claire-semantic="c">int tableau[] = {0};</code></pre></aside><p id="r-515464" data-claire-element-id="515464">Car cela ne va allouer qu'une seule case. Erreur très courante dans le cas des chaines de caractères.</p><div id="r-515466" data-claire-element-id="515466" data-claire-semantic="question"><p id="r-515465" data-claire-element-id="515465">Que faire pour n'initialiser que certaines cases dans le tableau ?</p></div><p id="r-515467" data-claire-element-id="515467">Seul le standard C99 permet de faire ce genre d'initialisations, contrairement au C90.</p><pre id="r-515468" data-claire-element-id="515468"><code data-claire-semantic="c">int t[10] = {[indice]=5,6};</code></pre><p id="r-515469" data-claire-element-id="515469">indice ici doit être remplacé par une valeur constante indiquant l'indice qu'on souhaite initialiser avec la valeur 5, il est évidemment obligatoire que cet indice soit inférieur à la taille du tableau.</p><p id="r-515470" data-claire-element-id="515470">Pour se familiariser avec ce type d'initialisations prenons quelques exemples :</p><p id="r-515471" data-claire-element-id="515471"><strong>Exemple 1:</strong></p><pre id="r-515472" data-claire-element-id="515472"><code data-claire-semantic="c">int t[10] = {2,3,[4]=5,6,9};</code></pre><p id="r-515473" data-claire-element-id="515473">résultat :</p><table id="r-515496" data-claire-element-id="515496"><tbody id="r-515495" data-claire-element-id="515495"><tr id="r-515494" data-claire-element-id="515494"><td id="r-515475" data-claire-element-id="515475"><p id="r-515474" data-claire-element-id="515474">2</p></td><td id="r-515477" data-claire-element-id="515477"><p id="r-515476" data-claire-element-id="515476">3</p></td><td id="r-515479" data-claire-element-id="515479"><p id="r-515478" data-claire-element-id="515478">0</p></td><td id="r-515481" data-claire-element-id="515481"><p id="r-515480" data-claire-element-id="515480">0</p></td><td id="r-515483" data-claire-element-id="515483"><p id="r-515482" data-claire-element-id="515482">5</p></td><td id="r-515485" data-claire-element-id="515485"><p id="r-515484" data-claire-element-id="515484">6</p></td><td id="r-515487" data-claire-element-id="515487"><p id="r-515486" data-claire-element-id="515486">9</p></td><td id="r-515489" data-claire-element-id="515489"><p id="r-515488" data-claire-element-id="515488">0</p></td><td id="r-515491" data-claire-element-id="515491"><p id="r-515490" data-claire-element-id="515490">0</p></td><td id="r-515493" data-claire-element-id="515493"><p id="r-515492" data-claire-element-id="515492">0</p></td></tr></tbody></table><p id="r-515497" data-claire-element-id="515497"><strong>Exemple 2:</strong></p><pre id="r-515498" data-claire-element-id="515498"><code data-claire-semantic="c">int t[10] = {[4]=5,6,[9]=9};</code></pre><p id="r-515499" data-claire-element-id="515499">résultat :</p><table id="r-515522" data-claire-element-id="515522"><tbody id="r-515521" data-claire-element-id="515521"><tr id="r-515520" data-claire-element-id="515520"><td id="r-515501" data-claire-element-id="515501"><p id="r-515500" data-claire-element-id="515500">0</p></td><td id="r-515503" data-claire-element-id="515503"><p id="r-515502" data-claire-element-id="515502">0</p></td><td id="r-515505" data-claire-element-id="515505"><p id="r-515504" data-claire-element-id="515504">0</p></td><td id="r-515507" data-claire-element-id="515507"><p id="r-515506" data-claire-element-id="515506">0</p></td><td id="r-515509" data-claire-element-id="515509"><p id="r-515508" data-claire-element-id="515508">5</p></td><td id="r-515511" data-claire-element-id="515511"><p id="r-515510" data-claire-element-id="515510">6</p></td><td id="r-515513" data-claire-element-id="515513"><p id="r-515512" data-claire-element-id="515512">0</p></td><td id="r-515515" data-claire-element-id="515515"><p id="r-515514" data-claire-element-id="515514">0</p></td><td id="r-515517" data-claire-element-id="515517"><p id="r-515516" data-claire-element-id="515516">0</p></td><td id="r-515519" data-claire-element-id="515519"><p id="r-515518" data-claire-element-id="515518">9</p></td></tr></tbody></table><p id="r-515523" data-claire-element-id="515523"><strong>Exemple 3:</strong></p><pre id="r-515524" data-claire-element-id="515524"><code data-claire-semantic="c">int t[10] = {2,3,[1]=5,[5]=6,[3]=9};</code></pre><p id="r-515525" data-claire-element-id="515525">résultat :</p><table id="r-515548" data-claire-element-id="515548"><tbody id="r-515547" data-claire-element-id="515547"><tr id="r-515546" data-claire-element-id="515546"><td id="r-515527" data-claire-element-id="515527"><p id="r-515526" data-claire-element-id="515526">2</p></td><td id="r-515529" data-claire-element-id="515529"><p id="r-515528" data-claire-element-id="515528">5</p></td><td id="r-515531" data-claire-element-id="515531"><p id="r-515530" data-claire-element-id="515530">0</p></td><td id="r-515533" data-claire-element-id="515533"><p id="r-515532" data-claire-element-id="515532">9</p></td><td id="r-515535" data-claire-element-id="515535"><p id="r-515534" data-claire-element-id="515534">0</p></td><td id="r-515537" data-claire-element-id="515537"><p id="r-515536" data-claire-element-id="515536">6</p></td><td id="r-515539" data-claire-element-id="515539"><p id="r-515538" data-claire-element-id="515538">0</p></td><td id="r-515541" data-claire-element-id="515541"><p id="r-515540" data-claire-element-id="515540">0</p></td><td id="r-515543" data-claire-element-id="515543"><p id="r-515542" data-claire-element-id="515542">0</p></td><td id="r-515545" data-claire-element-id="515545"><p id="r-515544" data-claire-element-id="515544">0</p></td></tr></tbody></table><p id="r-515549" data-claire-element-id="515549">Ce que je ne vous ai pas encore dit, est que si l'indice spécifié correspond à une case déjà initialisée, alors sa valeur sera écrasée par la nouvelle valeur (par le 5 dans cet exemple dans un premier temps) et toute les autres cases restantes à sa &quot;droite&quot; seront initialisées à 0; le même phénomène est constaté avec [3]=9, la case d'indice 3 sera initialisée à 9 alors que toutes les cases restantes seront mises à 0.<br/> Je vous propose de suivre les étapes de plus près :<br/> Etape 1 : Les deux premières cases sont initialisées à 2 et 3 (les autres ont pour le moment des valeurs indéterminées 'x').</p><table id="r-515572" data-claire-element-id="515572"><tbody id="r-515571" data-claire-element-id="515571"><tr id="r-515570" data-claire-element-id="515570"><td id="r-515551" data-claire-element-id="515551"><p id="r-515550" data-claire-element-id="515550">2</p></td><td id="r-515553" data-claire-element-id="515553"><p id="r-515552" data-claire-element-id="515552">3</p></td><td id="r-515555" data-claire-element-id="515555"><p id="r-515554" data-claire-element-id="515554">x</p></td><td id="r-515557" data-claire-element-id="515557"><p id="r-515556" data-claire-element-id="515556">x</p></td><td id="r-515559" data-claire-element-id="515559"><p id="r-515558" data-claire-element-id="515558">x</p></td><td id="r-515561" data-claire-element-id="515561"><p id="r-515560" data-claire-element-id="515560">x</p></td><td id="r-515563" data-claire-element-id="515563"><p id="r-515562" data-claire-element-id="515562">x</p></td><td id="r-515565" data-claire-element-id="515565"><p id="r-515564" data-claire-element-id="515564">x</p></td><td id="r-515567" data-claire-element-id="515567"><p id="r-515566" data-claire-element-id="515566">x</p></td><td id="r-515569" data-claire-element-id="515569"><p id="r-515568" data-claire-element-id="515568">x</p></td></tr></tbody></table><p id="r-515573" data-claire-element-id="515573">Etape 2 : la case d'indice 1 est initialisée à 5, et les cases restantes à droite sont initialisées à 0 jusqu'au prochain indice ([5]).</p><table id="r-515596" data-claire-element-id="515596"><tbody id="r-515595" data-claire-element-id="515595"><tr id="r-515594" data-claire-element-id="515594"><td id="r-515575" data-claire-element-id="515575"><p id="r-515574" data-claire-element-id="515574">2</p></td><td id="r-515577" data-claire-element-id="515577"><p id="r-515576" data-claire-element-id="515576">5</p></td><td id="r-515579" data-claire-element-id="515579"><p id="r-515578" data-claire-element-id="515578">0</p></td><td id="r-515581" data-claire-element-id="515581"><p id="r-515580" data-claire-element-id="515580">0</p></td><td id="r-515583" data-claire-element-id="515583"><p id="r-515582" data-claire-element-id="515582">0</p></td><td id="r-515585" data-claire-element-id="515585"><p id="r-515584" data-claire-element-id="515584">6</p></td><td id="r-515587" data-claire-element-id="515587"><p id="r-515586" data-claire-element-id="515586">x</p></td><td id="r-515589" data-claire-element-id="515589"><p id="r-515588" data-claire-element-id="515588">x</p></td><td id="r-515591" data-claire-element-id="515591"><p id="r-515590" data-claire-element-id="515590">x</p></td><td id="r-515593" data-claire-element-id="515593"><p id="r-515592" data-claire-element-id="515592">x</p></td></tr></tbody></table><p id="r-515597" data-claire-element-id="515597">Etape 3 : la case d'indice 3 est initialisée à 9, et les cases restantes à droite sont toutes initialisées à 0.</p><table id="r-515620" data-claire-element-id="515620"><tbody id="r-515619" data-claire-element-id="515619"><tr id="r-515618" data-claire-element-id="515618"><td id="r-515599" data-claire-element-id="515599"><p id="r-515598" data-claire-element-id="515598">2</p></td><td id="r-515601" data-claire-element-id="515601"><p id="r-515600" data-claire-element-id="515600">5</p></td><td id="r-515603" data-claire-element-id="515603"><p id="r-515602" data-claire-element-id="515602">0</p></td><td id="r-515605" data-claire-element-id="515605"><p id="r-515604" data-claire-element-id="515604">9</p></td><td id="r-515607" data-claire-element-id="515607"><p id="r-515606" data-claire-element-id="515606">0</p></td><td id="r-515609" data-claire-element-id="515609"><p id="r-515608" data-claire-element-id="515608">6</p></td><td id="r-515611" data-claire-element-id="515611"><p id="r-515610" data-claire-element-id="515610">0</p></td><td id="r-515613" data-claire-element-id="515613"><p id="r-515612" data-claire-element-id="515612">0</p></td><td id="r-515615" data-claire-element-id="515615"><p id="r-515614" data-claire-element-id="515614">0</p></td><td id="r-515617" data-claire-element-id="515617"><p id="r-515616" data-claire-element-id="515616">0</p></td></tr></tbody></table><p id="r-515621" data-claire-element-id="515621"><strong>Exemple 4:</strong></p><pre id="r-515622" data-claire-element-id="515622"><code data-claire-semantic="c">int t[10] = {1,[10]=5,6,[14]=9};</code></pre><p id="r-515623" data-claire-element-id="515623">résultat :<br/> Erreur de compilation, en effet, il est interdit de mettre un indicateur d'indice qui dépasse la taille de notre tableau.</p><p id="r-515624" data-claire-element-id="515624"><strong>Exemple 5:</strong></p><pre id="r-515625" data-claire-element-id="515625"><code data-claire-semantic="c">int t[] = {1,[10]=5,6,[14]=9};</code></pre><p id="r-515626" data-claire-element-id="515626">résultat : Nous avons déclaré un tableau de type &quot;incomplet&quot;; en d'autres mots, un tableau dont la taille n'a pas encore été donnée. Ce tableau prendra donc la taille de l'initialisateur, et dans ce cas de figure, le tableau sera de taille 15 car le plus grand indice est le 14 (les indices seront donc entre 0 et 14 donc une taille de 15 cases).</p><table id="r-515659" data-claire-element-id="515659"><tbody id="r-515658" data-claire-element-id="515658"><tr id="r-515657" data-claire-element-id="515657"><td id="r-515628" data-claire-element-id="515628"><p id="r-515627" data-claire-element-id="515627">1</p></td><td id="r-515630" data-claire-element-id="515630"><p id="r-515629" data-claire-element-id="515629">0</p></td><td id="r-515632" data-claire-element-id="515632"><p id="r-515631" data-claire-element-id="515631">0</p></td><td id="r-515634" data-claire-element-id="515634"><p id="r-515633" data-claire-element-id="515633">0</p></td><td id="r-515636" data-claire-element-id="515636"><p id="r-515635" data-claire-element-id="515635">0</p></td><td id="r-515638" data-claire-element-id="515638"><p id="r-515637" data-claire-element-id="515637">0</p></td><td id="r-515640" data-claire-element-id="515640"><p id="r-515639" data-claire-element-id="515639">0</p></td><td id="r-515642" data-claire-element-id="515642"><p id="r-515641" data-claire-element-id="515641">0</p></td><td id="r-515644" data-claire-element-id="515644"><p id="r-515643" data-claire-element-id="515643">0</p></td><td id="r-515646" data-claire-element-id="515646"><p id="r-515645" data-claire-element-id="515645">0</p></td><td id="r-515648" data-claire-element-id="515648"><p id="r-515647" data-claire-element-id="515647">5</p></td><td id="r-515650" data-claire-element-id="515650"><p id="r-515649" data-claire-element-id="515649">6</p></td><td id="r-515652" data-claire-element-id="515652"><p id="r-515651" data-claire-element-id="515651">0</p></td><td id="r-515654" data-claire-element-id="515654"><p id="r-515653" data-claire-element-id="515653">0</p></td><td id="r-515656" data-claire-element-id="515656"><p id="r-515655" data-claire-element-id="515655">9</p></td></tr></tbody></table></li><li id="r-515673" data-claire-element-id="515673"><p id="r-515661" data-claire-element-id="515661">L'utilisation des doubles-cotes <code data-claire-semantic="c">&quot;&quot; </code> :</p><p id="r-515662" data-claire-element-id="515662">Cette initialisation est réservée aux déclarations de tableaux de type <code data-claire-semantic="c">char </code> appelés aussi chaines de caractères, elle est très identique aux déclarations présentées ci-dessus.</p><pre id="r-515663" data-claire-element-id="515663"><code data-claire-semantic="c">char tableau[4] = &quot;ABC&quot;;</code></pre><p id="r-515664" data-claire-element-id="515664">Ici le tableau sera initialisé avec les valeurs 'A', 'B', 'C' et '\0'.</p><aside id="r-515667" data-claire-element-id="515667" data-claire-semantic="warning"><pre id="r-515665" data-claire-element-id="515665"><code data-claire-semantic="c">char tableau[4] = &quot;ABCD&quot;;</code></pre><p id="r-515666" data-claire-element-id="515666">Ceci va initialiser les 4 premières cases du tableau avec les données 'A', 'B', 'C' et 'D', le '\0' ne sera pas placé en fin de la chaine par défaut de taille. Donc ceci est une source de bogues très courants quand vous essayez de manipuler ce tableau.<br/> Veillez toujours à compter le '\0' en plus des caractères d'initialisation.</p></aside><pre id="r-515668" data-claire-element-id="515668"><code data-claire-semantic="c">char tableau[] = &quot;ABC&quot;;</code></pre><p id="r-515669" data-claire-element-id="515669">Ici le tableau sera alloué pour contenir les données 'A', 'B', 'C' et '\0'. Donc aura une taille de 4 cases.</p><aside id="r-515672" data-claire-element-id="515672" data-claire-semantic="warning"><pre id="r-515670" data-claire-element-id="515670"><code data-claire-semantic="c">char tableau[] = &quot;&quot;;</code></pre><p id="r-515671" data-claire-element-id="515671">Ceci va allouer un tableau d'une seule case, donc prenez en garde lors de vos manipulations de ce tableau.</p></aside></li></ul><h3 id="r-parcourir-un-tableau-6" data-claire-element-id="515687">Parcourir un tableau</h3><p id="r-515676" data-claire-element-id="515676">Le parcours d'un tableau s'effectue par l'utilisation des mêmes crochets '[]' utilisés à la déclaration de notre tableau, et en indiquant le rang de la case à laquelle on souhaite accéder. Par exemple pour écrire le nombre 12 dans la première case on ferait :</p><pre id="r-515677" data-claire-element-id="515677"><code data-claire-semantic="c">tableau[0] = 12;</code></pre><p id="r-515678" data-claire-element-id="515678">Le '0' ici est appelé indice de la première case.</p><aside id="r-515681" data-claire-element-id="515681" data-claire-semantic="warning"><pre id="r-515679" data-claire-element-id="515679"><code data-claire-semantic="c">int tableau[4];

tableau[4] = 15;</code></pre><p id="r-515680" data-claire-element-id="515680">Pour un tableau de 4 cases, les indices commencent à 0 et vont jusqu'à 3 inclus, donc la case d'indice 4 n'existe pas!</p></aside><p id="r-515682" data-claire-element-id="515682">Maintenant qu'on sait que les indices d'un tableau commencent à 0 et vont jusqu'à taille - 1 (taille étant le nombre de cases de notre tableau), on va voir maintenant comment parcourir ce tableau à l'aide d'une boucle.</p><p id="r-515683" data-claire-element-id="515683">Pour ceci, il nous faudrait une variable qui jouera le rôle de l'indice, qu'on déclarera comme ceci :</p><pre id="r-515684" data-claire-element-id="515684"><code data-claire-semantic="c">int i;</code></pre><p id="r-515685" data-claire-element-id="515685">Ensuite, par utilisation d'une boucle, on va parcourir les cases du tableau pour y mettre des zéros :</p><pre id="r-515686" data-claire-element-id="515686"><code data-claire-semantic="c">int i;

for( i=0 ; i &lt; taille ; i++)  //Attention la condition est : i &lt; taille !
{
     tableau[i] = 0;
}</code></pre><h3 id="r-typedef-et-le-type-tableau" data-claire-element-id="515700">'typedef' et le type tableau</h3><p id="r-515688" data-claire-element-id="515688">Comme vous le savez peut être, le mot-clef typedef permet de définir (ou redéfinir) des types. C'est-à-dire, que l'on peut changer l'identificateur d'un objet par utilisation de typedef.</p><p id="r-515689" data-claire-element-id="515689">Je m'explique :) :</p><pre id="r-515690" data-claire-element-id="515690"><code data-claire-semantic="c">typedef int my_int;</code></pre><p id="r-515691" data-claire-element-id="515691">Me permettrait d'utiliser my_int comme étant un type (en l'occurrence <code data-claire-semantic="c">int </code>). C'est très utile pour alléger le code. L'exemple d'application classique sont les structures.</p><p id="r-515692" data-claire-element-id="515692">La syntaxe afin de définir un type tableau à l'aide du mot-clef typedef est :</p><p id="r-515693" data-claire-element-id="515693"><strong>typedef type_du_tableau</strong><code data-claire-semantic="c">nom_du_tableau </code> [ <strong>taille_du_tableau</strong> ];</p><p id="r-515694" data-claire-element-id="515694">Exemple : Si l'on veut définir un type de tableau de 4 entiers, on ferait ainsi :</p><pre id="r-515695" data-claire-element-id="515695"><code data-claire-semantic="c">typedef int tab4 [4];

int main(void){
     tab4 tableauDe4 = {1,2,3,4};

     return 0;
}</code></pre><p id="r-515696" data-claire-element-id="515696">Il est possible que l'on ait besoin de déclarer un type tableau sans taille, on ferait donc ainsi :</p><pre id="r-515697" data-claire-element-id="515697"><code data-claire-semantic="c">typedef int tab [];

int main(void){
     tab tableauDe4 = {1,2,3,4};

     return 0;
}</code></pre><p id="r-515698" data-claire-element-id="515698">Qui est strictement équivalent à faire comme nous l'avons vu dans la partie &quot;initialisation&quot; à savoir :</p><pre id="r-515699" data-claire-element-id="515699"><code data-claire-semantic="c">int tableauDe4[] = {1,2,3,4};</code></pre><h3 id="r-passer-un-tableau-en-argument-a-une-fonction" data-claire-element-id="515720">Passer un tableau en argument à une fonction</h3><p id="r-515701" data-claire-element-id="515701">Il existe quatre façons peu différentes de le faire, et ceci en respect à ce qu'on a vu dans les parties déclaration et initialisation :</p><ul id="r-515719" data-claire-element-id="515719"><li id="r-515708" data-claire-element-id="515708"><p id="r-515702" data-claire-element-id="515702">Utiliser la déclaration d'un tableau :</p><p id="r-515703" data-claire-element-id="515703">Si l'on dispose d'un tableau de taille 'N' qu'on souhaite passer en argument à une de nos fonctions, on ferait donc comme ceci :</p><pre id="r-515704" data-claire-element-id="515704"><code data-claire-semantic="c">void ma_fonction(int tableau[N]);</code></pre><p id="r-515705" data-claire-element-id="515705">Et si l'on ne connait pas à priori la taille de notre tableau (ou que l'on ne souhaite pas utiliser d'indication sur la taille), on peut faire comme ceci :</p><pre id="r-515706" data-claire-element-id="515706"><code data-claire-semantic="c">void ma_fonction(int tableau[]);</code></pre><p id="r-515707" data-claire-element-id="515707"><em><strong>Remarque</strong></em> : <code data-claire-semantic="c">int tableau[N] </code>, <code data-claire-semantic="c">int tableau[] </code>, et <code data-claire-semantic="c">int * tableau </code> sont strictement équivalentes seulement pour les paramètres formels d'une fonction.</p></li><li id="r-515712" data-claire-element-id="515712"><p id="r-515709" data-claire-element-id="515709">Utiliser un pointeur</p><p id="r-515710" data-claire-element-id="515710">On peut utiliser un pointeur pour réceptionner un tableau envoyé en argument, en déclarant l'argument ainsi :</p><pre id="r-515711" data-claire-element-id="515711"><code data-claire-semantic="c">void ma_fonction(int * tableau);</code></pre></li><li id="r-515718" data-claire-element-id="515718"><p id="r-515713" data-claire-element-id="515713">Utiliser un <code data-claire-semantic="c">typedef</code></p><p id="r-515714" data-claire-element-id="515714">Comme on l'a vu, on pourrait utiliser un <code data-claire-semantic="c">typedef </code> pour déclarer un argument de type tableau, on ferait donc ainsi :</p><pre id="r-515715" data-claire-element-id="515715"><code data-claire-semantic="c">typedef int tabN[N];

void ma_fonction(tabN tableau);</code></pre><p id="r-515716" data-claire-element-id="515716">Ou sans utiliser de taille :</p><pre id="r-515717" data-claire-element-id="515717"><code data-claire-semantic="c">typedef int tab[];

void ma_fonction(tab tableau);</code></pre></li></ul><h3 id="r-retourner-un-tableau" data-claire-element-id="515742">Retourner un tableau</h3><p id="r-515721" data-claire-element-id="515721">La syntaxe est la suivante :</p><pre id="r-515722" data-claire-element-id="515722"><code data-claire-semantic="c">int (ma_fonction(void))[4];</code></pre><p id="r-515723" data-claire-element-id="515723">Mais si vous essayez de le faire le compilateur vous rejettera :) . Ce qui est normal, car le langage C ne le permet pas, pour la raison suivante :</p><ul id="r-515734" data-claire-element-id="515734"><li id="r-515725" data-claire-element-id="515725"><p id="r-515724" data-claire-element-id="515724"><strong>Hors cas d'utilisation du mot-clef <code data-claire-semantic="c">static </code></strong>, la déclaration d'un tableau est faite de manière automatique, ce qui fait qu'il a une portée locale. Donc le retourner à une autre fonction, impliquerait l'utilisation d'un espace mémoire déjà détruit.</p></li><aside id="r-515733" data-claire-element-id="515733" data-claire-semantic="error"><pre id="r-515726" data-claire-element-id="515726"><code data-claire-semantic="c">int (ma_fonction(void))[5]{   //Ceci génère une erreur de syntaxe
     int tab[5] = {0};
     return tab;              //Retour du tableau
}</code></pre><p id="r-515727" data-claire-element-id="515727">ou</p><pre id="r-515728" data-claire-element-id="515728"><code data-claire-semantic="c">int  (* fonction(void))[5]{  //ceci est correct syntaxiquement mais aboutirait à un bogue
     int tab[5] = {0};
     return &amp;tab;                           //Retour d'un pointeur sur le tableau
}</code></pre><p id="r-515729" data-claire-element-id="515729">ou</p><pre id="r-515730" data-claire-element-id="515730"><code data-claire-semantic="c">int * fonction(void){  //ceci est correct syntaxiquement mais aboutirait à un bogue
     int tab[5] = {0};
     return tab;                           //Retour d'un pointeur sur le premier élément du tableau
}</code></pre><p id="r-515731" data-claire-element-id="515731">ou</p><pre id="r-515732" data-claire-element-id="515732"><code data-claire-semantic="c">int  * fonction(void){  //ceci est correct syntaxiquement mais aboutirait à un bogue
     int tab[5] = {0};
     return &amp;(tab[0]);                           //Retour d'un pointeur sur le premier élément du tableau
}</code></pre></aside></ul><p id="r-515735" data-claire-element-id="515735">On est donc obligé d'allouer dynamiquement notre tableau et le retourner sous la forme d'un pointeur.</p><p id="r-515736" data-claire-element-id="515736">Ou d'utiliser une structure :) , dans laquelle on mettra un tableau, et le fait de retourner cette structure, ne retournera qu'une copie de cette dernière. Donc cette méthode est correcte, et bien qu'elle soit pratique, mais relève du &quot;bourrin&quot; dans le codage (c'est pourquoi je ne vous encouragerai pas à l'utiliser :p ).</p><p id="r-515737" data-claire-element-id="515737">Exemple :</p><pre id="r-515738" data-claire-element-id="515738"><code data-claire-semantic="c">typedef struct {
     int tableau[5];
}STableauDe5;

STableauDe5 ma_fonction(void){
     STableauDe5 tab = {{0}};
     
     return tab;
}</code></pre><p id="r-515739" data-claire-element-id="515739">Ceci est valable à la seule condition de réceptionner ce retour dans une variable de type STableaDe5 :</p><pre id="r-515740" data-claire-element-id="515740"><code data-claire-semantic="c">int main (void){
     STableauDe5 tab;

     tab = ma_fonction();
     return 0;
}</code></pre><p id="r-515741" data-claire-element-id="515741">Quant à la méthode d'allocation dynamique nous la verrons plus tard.</p><h2 id="r-allocation-dynamique-d-un-tableau-a-une-dimension" data-claire-element-id="515802">Allocation dynamique d'un tableau à une dimension</h2><p id="r-515744" data-claire-element-id="515744">Une allocation dynamique consiste à demander au système d'exploitation de nous allouer un espace d'une taille donnée dans la mémoire (dans le tas).</p><p id="r-515745" data-claire-element-id="515745">Par abus de langage on utilise les termes &quot;allocation dynamique de tableau&quot;. Il est donc important de dissocier une allocation d'une taille en mémoire et le type tableau qu'on a vu précédemment.</p><h3 id="r-la-fonction-malloc" data-claire-element-id="515760">La fonction malloc</h3><p id="r-515746" data-claire-element-id="515746">La fonction malloc est la plus populaire des fonctions d'allocation, j'en rappelle le prototype :</p><pre id="r-515747" data-claire-element-id="515747"><code data-claire-semantic="c">void *malloc (size_t size);</code></pre><ul id="r-515752" data-claire-element-id="515752"><li id="r-515749" data-claire-element-id="515749"><p id="r-515748" data-claire-element-id="515748"><strong>size</strong> : la taille en &quot;byte&quot; (octet par abus de langage) de l'espace mémoire à allouer.</p></li><li id="r-515751" data-claire-element-id="515751"><p id="r-515750" data-claire-element-id="515750"><strong>La valeur retournée</strong> : la fonction malloc retourne un pointeur sur le premier &quot;byte&quot; de l'espace alloué, ou le pointeur <code data-claire-semantic="c">NULL </code> en cas d'échec.</p></li></ul><p id="r-515753" data-claire-element-id="515753">Donc si l'on souhaite allouer un espace de mémoire pour notre dit &quot;tableau&quot;, on utiliserait <code data-claire-semantic="c">malloc </code> comme ceci :</p><pre id="r-515754" data-claire-element-id="515754"><code data-claire-semantic="c">pointeur = malloc(nombreElements * sizeof(*pointeur));</code></pre><p id="r-515755" data-claire-element-id="515755">Ainsi on alloue une taille de : nombreElement x la taille d'un élément (représentée par <code data-claire-semantic="c">sizeof(*pointeur) </code>).</p><aside id="r-515757" data-claire-element-id="515757" data-claire-semantic="warning"><p id="r-515756" data-claire-element-id="515756"><strong>Attention :</strong><br/> Le nombre d'éléments doit représenter le nombre de cases de notre tableau, et donc doit être un <strong>entier positif</strong> (différent de zéro).</p></aside><aside id="r-515759" data-claire-element-id="515759" data-claire-semantic="information"><p id="r-515758" data-claire-element-id="515758"><strong>Règle de bon usage:</strong><br/> Il faut toujours tester le retour de malloc, calloc et realloc. Car en cas d'échec, elles retournent le pointeur <code data-claire-semantic="c">NULL </code>, qui entraîne des &quot;segfaults&quot; à son utilisation (notamment à l'utilisation de l'astérisque '*' sur le pointeur NULL).</p></aside><h3 id="r-la-fonction-calloc-1" data-claire-element-id="515774">La fonction calloc</h3><p id="r-515761" data-claire-element-id="515761">Le prototype de la fonction calloc est :</p><pre id="r-515762" data-claire-element-id="515762"><code data-claire-semantic="c">void *calloc (size_t nmemb, size_t size);</code></pre><ul id="r-515769" data-claire-element-id="515769"><li id="r-515764" data-claire-element-id="515764"><p id="r-515763" data-claire-element-id="515763"><strong>nmemb</strong> : le nombre d'éléments constituant l'espace mémoire à allouer.</p></li><li id="r-515766" data-claire-element-id="515766"><p id="r-515765" data-claire-element-id="515765"><strong>size</strong> : la taille en &quot;byte&quot; de chaque élément constituant l'espace mémoire à allouer.</p></li><li id="r-515768" data-claire-element-id="515768"><p id="r-515767" data-claire-element-id="515767"><strong>La valeur retournée</strong> : la fonction calloc retourne un pointeur sur le premier &quot;byte&quot; de l'espace alloué, ou le pointeur <code data-claire-semantic="c">NULL </code> en cas d'échec.</p></li></ul><p id="r-515770" data-claire-element-id="515770">La différence avec la fonction malloc, est que calloc en plus de l'allocation, elle initialise l'espace alloué avec des 0 (elle met tous les bits à 0).<br/> Il faut noter qu'elle est déconseillée pour allouer des espaces de type <code data-claire-semantic="c">float </code> ou <code data-claire-semantic="c">double </code>.</p><p id="r-515771" data-claire-element-id="515771">Pour allouer dynamiquement un tableau, on procèderait ainsi :</p><pre id="r-515772" data-claire-element-id="515772"><code data-claire-semantic="c">pointeur = calloc(nombreElements , sizeof(*pointeur));</code></pre><p id="r-515773" data-claire-element-id="515773">Ainsi la fonction calloc nous alloue un nombre d'éléments égal à 'nombreElements' du type pointé par 'pointeur'. Cet espace sera initialisé automatiquement par des zéros (0).</p><h3 id="r-la-fonction-realloc-1" data-claire-element-id="515793">La fonction realloc</h3><p id="r-515775" data-claire-element-id="515775">Elle permet de modifier la taille allouée pour un objet, son prototype est :</p><pre id="r-515776" data-claire-element-id="515776"><code data-claire-semantic="c">void *realloc (void *ptr, size_t size);</code></pre><ul id="r-515783" data-claire-element-id="515783"><li id="r-515778" data-claire-element-id="515778"><p id="r-515777" data-claire-element-id="515777"><strong>ptr</strong> : l'ancien espace mémoire alloué, et dont on voudrait modifier la taille. Si ce paramètre est <code data-claire-semantic="c">NULL </code>, alors la fonction se comporte comme malloc.</p></li><li id="r-515780" data-claire-element-id="515780"><p id="r-515779" data-claire-element-id="515779"><strong>size</strong> : la taille en &quot;byte&quot; du nouvel espace à allouer.</p></li><li id="r-515782" data-claire-element-id="515782"><p id="r-515781" data-claire-element-id="515781"><strong>La valeur retournée</strong> : la fonction realloc retourne un pointeur sur le premier &quot;byte&quot; du nouvel espace alloué, ou le pointeur <code data-claire-semantic="c">NULL </code> en cas d'échec.</p></li></ul><p id="r-515784" data-claire-element-id="515784">Si l'on souhaite modifier la taille qu'on a allouée préalablement pour un objet, la fonction realloc s'utilise comme suit :</p><pre id="r-515785" data-claire-element-id="515785"><code data-claire-semantic="c">pointeur = realloc(pointeur, nouvelleTaille);</code></pre><aside id="r-515792" data-claire-element-id="515792" data-claire-semantic="information"><p id="r-515786" data-claire-element-id="515786"><strong>Règles de bon usage:</strong><br/> Une utilisation telle qu'on vient de voir, est risquée. Pourquoi ?<br/> Car en cas d'échec d'allocation, non seulement elle ne détruit pas l'ancien espace alloué, mais aussi elle retourne le pointeur NULL.</p><p id="r-515787" data-claire-element-id="515787">Dans l'expression pointeur = realloc(....), quelque soit le résultat, on aura écrasé l'ancienne valeur de pointeur. Donc on se retrouve dans un cas de mémoire déjà allouée, mais dont on ne connait plus où elle se trouve, ce qui vous rend incapable à la libérer; et c'est ce qu'on appel une <a href="http://fr.wikipedia.org/wiki/Fuite_de_mémoire">fuite mémoire</a> :) .</p><p id="r-515788" data-claire-element-id="515788"><strong>Solution :</strong></p><p id="r-515789" data-claire-element-id="515789">Comme solution simple, on pourrait utiliser une variable intermédiaire, de type pointeur aussi :</p><pre id="r-515790" data-claire-element-id="515790"><code data-claire-semantic="c">ptrintermediaire = realloc( pointeur , nouvelleTaille );

if(ptrintermediaire == NULL){
    free(pointeur);    //Desallocation
    //Ne pas oublier de notifier l'erreur.
}
else{
    pointeur = ptrintermediaire ;
}</code></pre><p id="r-515791" data-claire-element-id="515791">La variable 'ptrintermediaire' doit être du même type que pointeur.<br/> Ainsi nous n'écraserons l'ancienne valeur de pointeur que si la nouvelle allocation s'est bien passée.</p></aside><h3 id="r-retourner-un-espace-alloue-dynamiquement" data-claire-element-id="515801">Retourner un espace alloué dynamiquement</h3><p id="r-515794" data-claire-element-id="515794">Si l'on souhaite effectuer notre allocation dynamique dans une fonction, pour la retourner à la fonction appelante. Il faudrait donc utiliser l'une des fonctions présentées ci-dessus (à savoir malloc, calloc ou realloc). Et de retourner le pointeur sur l'espace alloué.</p><p id="r-515795" data-claire-element-id="515795"><em>Exemple :</em></p><pre id="r-515796" data-claire-element-id="515796"><code data-claire-semantic="c">int * fonctionAllocation(int nombreElements){
      int * ptr = malloc( nombreElements * sizeof(*ptr) );

      return ptr;
}

int main(void){
      int * ptr = fonctionAllocation(10);
      if(ptr == NULL)
           //........
      //.......
      return 0;
}</code></pre><p id="r-515797" data-claire-element-id="515797">Il se peut que l'on souhaite allouer de la mémoire, sans utiliser le retour d'une fonction mais à l'aide d'un passage par référence (vous vous en rappelez ? :) ).</p><p id="r-515798" data-claire-element-id="515798">Exemple :</p><pre id="r-515799" data-claire-element-id="515799"><code data-claire-semantic="c">void fonctionAllocation(int **ptr , int nombreElements){
      *ptr = malloc( nombreElements * sizeof(**ptr) );
}

int main(void){
      int * ptr;
      fonctionAllocation(&amp;ptr , 10);
      if(ptr == NULL)
           //........
      //.......
      return 0;
}</code></pre><p id="r-515800" data-claire-element-id="515800">Vous remarquerez que j'ai utilisé un double pointeur (int **), et oui c'est le piège :p . Avec l'utilisation d'un simple pointeur (int *), on serait entrain de faire un passage par valeur, et donc notre pointeur dans la fonction ne sera qu'une variable locale. Ainsi tous les changements qu'on apportera dessus seront de portée locale également (ne seront pas pris en compte dans la fonction main). D'où le double pointeur.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique">Tableaux, pointeurs et allocation dynamique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-pointeurs-rappel">
Les pointeurs (rappel)
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-unidimensionnels">
Les tableaux unidimensionnels
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-de-tableaux-tableaux-a-plusieurs-dimensions">
Les tableaux de tableaux (&quot;tableaux à plusieurs dimensions&quot;)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/exercices-31">
Exercices
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-pointeurs-rappel">
<span class="arrow"></span>
<span class="next">Les pointeurs (rappel)</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-de-tableaux-tableaux-a-plusieurs-dimensions">
<span class="next">Les tableaux de tableaux (&quot;tableaux à plusieurs dimensions&quot;)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lestableauxdetableauxquottableauxplusieursdimensionsquot"></a><h2>Les tableaux de tableaux (&quot;tableaux à plusieurs dimensions&quot;)</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-unidimensionnels">
<span class="arrow"></span>
<span class="next">Les tableaux unidimensionnels</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/exercices-31">
<span class="next">Exercices</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-declaration-16" data-claire-element-id="515807">Déclaration</h2><p id="r-515804" data-claire-element-id="515804">Un tableau de tableaux (appelé tableau à plusieurs dimensions) se déclare par précision de la taille de chaque &quot;dimension&quot;. Si par exemple je souhaite déclarer un tableau &quot;tridimensionnel&quot; alors je ferais ainsi :</p><pre id="r-515805" data-claire-element-id="515805"><code data-claire-semantic="c">int t[taille1][taille2][taille3];</code></pre><p id="r-515806" data-claire-element-id="515806">'taille1', 'taille2' et 'taille3' sont les tailles de chaque dimension. Autrement dit, 't' est un tableau de taille1 tableaux de taille2 tableaux de taille3<code data-claire-semantic="c">int</code>s.</p><h2 id="r-utilisation-71" data-claire-element-id="516378">Utilisation</h2><h3 id="r-initialisation-11" data-claire-element-id="516372">Initialisation</h3><p id="r-515808" data-claire-element-id="515808">L'initialisation de ce type de tableaux n'est pas très différente de celle d'un tableau à une dimension :</p><p id="r-515809" data-claire-element-id="515809"><em>Exemple 1 :</em></p><pre id="r-515810" data-claire-element-id="515810"><code data-claire-semantic="c">int tableau1[2][3] = {{1,8,9},{0,6,4}};</code></pre><p id="r-515811" data-claire-element-id="515811"><em>Exemple 2 :</em></p><pre id="r-515812" data-claire-element-id="515812"><code data-claire-semantic="c">int tableau1[2][3][2] = {{ {1,8}   , {0,6} , {0,0} },
                         { {31,52} , {4,8} , {11,5}}
                        };</code></pre><p id="r-515813" data-claire-element-id="515813">Ou en ne précisant pas la première dimension :</p><p id="r-515814" data-claire-element-id="515814"><em>Exemple :</em></p><pre id="r-515815" data-claire-element-id="515815"><code data-claire-semantic="c">int tableau1[][3] = {{1,8,9},{0,6,4},{5,3,7},{2,2,2}};</code></pre><p id="r-515816" data-claire-element-id="515816">Ainsi on a créé un tableau de 4x3 (équivalent à <code data-claire-semantic="c">int tableau[4][3]</code>), et initialisé ainsi :</p><table id="r-515846" data-claire-element-id="515846"><tbody id="r-515845" data-claire-element-id="515845"><tr id="r-515823" data-claire-element-id="515823"><td id="r-515818" data-claire-element-id="515818"><p id="r-515817" data-claire-element-id="515817">1</p></td><td id="r-515820" data-claire-element-id="515820"><p id="r-515819" data-claire-element-id="515819">8</p></td><td id="r-515822" data-claire-element-id="515822"><p id="r-515821" data-claire-element-id="515821">9</p></td></tr><tr id="r-515830" data-claire-element-id="515830"><td id="r-515825" data-claire-element-id="515825"><p id="r-515824" data-claire-element-id="515824">0</p></td><td id="r-515827" data-claire-element-id="515827"><p id="r-515826" data-claire-element-id="515826">6</p></td><td id="r-515829" data-claire-element-id="515829"><p id="r-515828" data-claire-element-id="515828">4</p></td></tr><tr id="r-515837" data-claire-element-id="515837"><td id="r-515832" data-claire-element-id="515832"><p id="r-515831" data-claire-element-id="515831">5</p></td><td id="r-515834" data-claire-element-id="515834"><p id="r-515833" data-claire-element-id="515833">3</p></td><td id="r-515836" data-claire-element-id="515836"><p id="r-515835" data-claire-element-id="515835">7</p></td></tr><tr id="r-515844" data-claire-element-id="515844"><td id="r-515839" data-claire-element-id="515839"><p id="r-515838" data-claire-element-id="515838">2</p></td><td id="r-515841" data-claire-element-id="515841"><p id="r-515840" data-claire-element-id="515840">2</p></td><td id="r-515843" data-claire-element-id="515843"><p id="r-515842" data-claire-element-id="515842">2</p></td></tr></tbody></table><p id="r-515847" data-claire-element-id="515847">Ou en n'initialisant que quelques cases du tableau :</p><p id="r-515848" data-claire-element-id="515848"><em>Exemple :</em></p><pre id="r-515849" data-claire-element-id="515849"><code data-claire-semantic="c">int tableau1[][3] = {{1,9},{0,4},{5,3,7},{2,2,2}};</code></pre><p id="r-515850" data-claire-element-id="515850">Les cases restantes de chaque ligne seront donc initialisées à 0.</p><p id="r-515851" data-claire-element-id="515851">Ou pour initialiser toutes les cases à 0 :</p><p id="r-515852" data-claire-element-id="515852"><em>Exemple :</em></p><pre id="r-515853" data-claire-element-id="515853"><code data-claire-semantic="c">int tableau1[][3] = {{0},{0},{0},{0}};</code></pre><aside id="r-515857" data-claire-element-id="515857" data-claire-semantic="warning"><p id="r-515854" data-claire-element-id="515854">Attention :</p><pre id="r-515855" data-claire-element-id="515855"><code data-claire-semantic="c">int tableau1[][3] = {{0}};</code></pre><p id="r-515856" data-claire-element-id="515856">Ceci est équivalent à <code data-claire-semantic="c">int tableau1[1][3]</code> et non pas <code data-claire-semantic="c">int tableau1[4][3]</code> !</p></aside><p id="r-515858" data-claire-element-id="515858">Comme expliqué dans la partie &quot;tableaux unidimensionnels&quot;, on pourrait également initialiser certaines cases de notre tableau; ceci s'applique bien évidemment à des tableaux multidimensionnels. Voici quelques exemples, je vous propose de les faire sous forme d'exercice pour voire si vous avez bien compris.</p><p id="r-515859" data-claire-element-id="515859"><strong>Exemple 1 :</strong></p><pre id="r-515860" data-claire-element-id="515860"><code data-claire-semantic="c">int t[4][5] = {{1,[3]=5,6},
            [2]={[3]1},
               {2,4,[4]=10}};</code></pre><div id="r-515908" data-claire-element-id="515908"><table id="r-515906" data-claire-element-id="515906"><tbody id="r-515905" data-claire-element-id="515905"><tr id="r-515871" data-claire-element-id="515871"><td id="r-515862" data-claire-element-id="515862"><p id="r-515861" data-claire-element-id="515861">1</p></td><td id="r-515864" data-claire-element-id="515864"><p id="r-515863" data-claire-element-id="515863">0</p></td><td id="r-515866" data-claire-element-id="515866"><p id="r-515865" data-claire-element-id="515865">0</p></td><td id="r-515868" data-claire-element-id="515868"><p id="r-515867" data-claire-element-id="515867">5</p></td><td id="r-515870" data-claire-element-id="515870"><p id="r-515869" data-claire-element-id="515869">6</p></td></tr><tr id="r-515882" data-claire-element-id="515882"><td id="r-515873" data-claire-element-id="515873"><p id="r-515872" data-claire-element-id="515872">0</p></td><td id="r-515875" data-claire-element-id="515875"><p id="r-515874" data-claire-element-id="515874">0</p></td><td id="r-515877" data-claire-element-id="515877"><p id="r-515876" data-claire-element-id="515876">0</p></td><td id="r-515879" data-claire-element-id="515879"><p id="r-515878" data-claire-element-id="515878">0</p></td><td id="r-515881" data-claire-element-id="515881"><p id="r-515880" data-claire-element-id="515880">0</p></td></tr><tr id="r-515893" data-claire-element-id="515893"><td id="r-515884" data-claire-element-id="515884"><p id="r-515883" data-claire-element-id="515883">0</p></td><td id="r-515886" data-claire-element-id="515886"><p id="r-515885" data-claire-element-id="515885">0</p></td><td id="r-515888" data-claire-element-id="515888"><p id="r-515887" data-claire-element-id="515887">0</p></td><td id="r-515890" data-claire-element-id="515890"><p id="r-515889" data-claire-element-id="515889">1</p></td><td id="r-515892" data-claire-element-id="515892"><p id="r-515891" data-claire-element-id="515891">0</p></td></tr><tr id="r-515904" data-claire-element-id="515904"><td id="r-515895" data-claire-element-id="515895"><p id="r-515894" data-claire-element-id="515894">2</p></td><td id="r-515897" data-claire-element-id="515897"><p id="r-515896" data-claire-element-id="515896">4</p></td><td id="r-515899" data-claire-element-id="515899"><p id="r-515898" data-claire-element-id="515898">0</p></td><td id="r-515901" data-claire-element-id="515901"><p id="r-515900" data-claire-element-id="515900">0</p></td><td id="r-515903" data-claire-element-id="515903"><p id="r-515902" data-claire-element-id="515902">10</p></td></tr></tbody></table><p id="r-515907" data-claire-element-id="515907">La première ligne a été initialisée suivant la règle que nous avons vu pour un tableau à une dimension (si vous ne vous en rappelez pas vous pouvez relire cette partie.<br/> La deuxième ligne n'a pas été initialisée manuellement car nous avons sauté cette ligne pour aller directement à celle d'indice 2 ([2]={...}).<br/> Naturellement l'initialisateur suivant est utilisé pour initialiser la ligne suivante donc celle d'indice 3.</p></div><p id="r-515909" data-claire-element-id="515909"><strong>Exemple 2 :</strong></p><pre id="r-515910" data-claire-element-id="515910"><code data-claire-semantic="c">int t[4][5] = {[3]={1,[3]=5,6},
               [0]={[3]=1},
                   {2,4,[4]=10}};</code></pre><div id="r-515957" data-claire-element-id="515957"><table id="r-515956" data-claire-element-id="515956"><tbody id="r-515955" data-claire-element-id="515955"><tr id="r-515921" data-claire-element-id="515921"><td id="r-515912" data-claire-element-id="515912"><p id="r-515911" data-claire-element-id="515911">0</p></td><td id="r-515914" data-claire-element-id="515914"><p id="r-515913" data-claire-element-id="515913">0</p></td><td id="r-515916" data-claire-element-id="515916"><p id="r-515915" data-claire-element-id="515915">0</p></td><td id="r-515918" data-claire-element-id="515918"><p id="r-515917" data-claire-element-id="515917">1</p></td><td id="r-515920" data-claire-element-id="515920"><p id="r-515919" data-claire-element-id="515919">0</p></td></tr><tr id="r-515932" data-claire-element-id="515932"><td id="r-515923" data-claire-element-id="515923"><p id="r-515922" data-claire-element-id="515922">2</p></td><td id="r-515925" data-claire-element-id="515925"><p id="r-515924" data-claire-element-id="515924">4</p></td><td id="r-515927" data-claire-element-id="515927"><p id="r-515926" data-claire-element-id="515926">0</p></td><td id="r-515929" data-claire-element-id="515929"><p id="r-515928" data-claire-element-id="515928">0</p></td><td id="r-515931" data-claire-element-id="515931"><p id="r-515930" data-claire-element-id="515930">10</p></td></tr><tr id="r-515943" data-claire-element-id="515943"><td id="r-515934" data-claire-element-id="515934"><p id="r-515933" data-claire-element-id="515933">0</p></td><td id="r-515936" data-claire-element-id="515936"><p id="r-515935" data-claire-element-id="515935">0</p></td><td id="r-515938" data-claire-element-id="515938"><p id="r-515937" data-claire-element-id="515937">0</p></td><td id="r-515940" data-claire-element-id="515940"><p id="r-515939" data-claire-element-id="515939">0</p></td><td id="r-515942" data-claire-element-id="515942"><p id="r-515941" data-claire-element-id="515941">0</p></td></tr><tr id="r-515954" data-claire-element-id="515954"><td id="r-515945" data-claire-element-id="515945"><p id="r-515944" data-claire-element-id="515944">1</p></td><td id="r-515947" data-claire-element-id="515947"><p id="r-515946" data-claire-element-id="515946">0</p></td><td id="r-515949" data-claire-element-id="515949"><p id="r-515948" data-claire-element-id="515948">0</p></td><td id="r-515951" data-claire-element-id="515951"><p id="r-515950" data-claire-element-id="515950">5</p></td><td id="r-515953" data-claire-element-id="515953"><p id="r-515952" data-claire-element-id="515952">6</p></td></tr></tbody></table></div><p id="r-515958" data-claire-element-id="515958"><strong>Exemple 3 :</strong></p><pre id="r-515959" data-claire-element-id="515959"><code data-claire-semantic="c">int t[][5] = { [1]={1,[3]=5,6},
               [2]={7,9,[1]=1,5},
                   {2,4,[4]=10},
                   {0,7,5,3,8,4,7},
                   {0}};</code></pre><p id="r-515960" data-claire-element-id="515960"></p><div id="r-516030" data-claire-element-id="516030"><p id="r-515961" data-claire-element-id="515961">Il se peut que vous ayez un warning vous indiquant que vous avez dépassé la taille pour l'initialisateur {0,7,5,3,8,4,7}.</p><table id="r-516029" data-claire-element-id="516029"><tbody id="r-516028" data-claire-element-id="516028"><tr id="r-515972" data-claire-element-id="515972"><td id="r-515963" data-claire-element-id="515963"><p id="r-515962" data-claire-element-id="515962">0</p></td><td id="r-515965" data-claire-element-id="515965"><p id="r-515964" data-claire-element-id="515964">0</p></td><td id="r-515967" data-claire-element-id="515967"><p id="r-515966" data-claire-element-id="515966">0</p></td><td id="r-515969" data-claire-element-id="515969"><p id="r-515968" data-claire-element-id="515968">0</p></td><td id="r-515971" data-claire-element-id="515971"><p id="r-515970" data-claire-element-id="515970">0</p></td></tr><tr id="r-515983" data-claire-element-id="515983"><td id="r-515974" data-claire-element-id="515974"><p id="r-515973" data-claire-element-id="515973">1</p></td><td id="r-515976" data-claire-element-id="515976"><p id="r-515975" data-claire-element-id="515975">0</p></td><td id="r-515978" data-claire-element-id="515978"><p id="r-515977" data-claire-element-id="515977">0</p></td><td id="r-515980" data-claire-element-id="515980"><p id="r-515979" data-claire-element-id="515979">5</p></td><td id="r-515982" data-claire-element-id="515982"><p id="r-515981" data-claire-element-id="515981">6</p></td></tr><tr id="r-515994" data-claire-element-id="515994"><td id="r-515985" data-claire-element-id="515985"><p id="r-515984" data-claire-element-id="515984">7</p></td><td id="r-515987" data-claire-element-id="515987"><p id="r-515986" data-claire-element-id="515986">1</p></td><td id="r-515989" data-claire-element-id="515989"><p id="r-515988" data-claire-element-id="515988">5</p></td><td id="r-515991" data-claire-element-id="515991"><p id="r-515990" data-claire-element-id="515990">0</p></td><td id="r-515993" data-claire-element-id="515993"><p id="r-515992" data-claire-element-id="515992">0</p></td></tr><tr id="r-516005" data-claire-element-id="516005"><td id="r-515996" data-claire-element-id="515996"><p id="r-515995" data-claire-element-id="515995">2</p></td><td id="r-515998" data-claire-element-id="515998"><p id="r-515997" data-claire-element-id="515997">4</p></td><td id="r-516000" data-claire-element-id="516000"><p id="r-515999" data-claire-element-id="515999">0</p></td><td id="r-516002" data-claire-element-id="516002"><p id="r-516001" data-claire-element-id="516001">0</p></td><td id="r-516004" data-claire-element-id="516004"><p id="r-516003" data-claire-element-id="516003">10</p></td></tr><tr id="r-516016" data-claire-element-id="516016"><td id="r-516007" data-claire-element-id="516007"><p id="r-516006" data-claire-element-id="516006">0</p></td><td id="r-516009" data-claire-element-id="516009"><p id="r-516008" data-claire-element-id="516008">7</p></td><td id="r-516011" data-claire-element-id="516011"><p id="r-516010" data-claire-element-id="516010">5</p></td><td id="r-516013" data-claire-element-id="516013"><p id="r-516012" data-claire-element-id="516012">3</p></td><td id="r-516015" data-claire-element-id="516015"><p id="r-516014" data-claire-element-id="516014">8</p></td></tr><tr id="r-516027" data-claire-element-id="516027"><td id="r-516018" data-claire-element-id="516018"><p id="r-516017" data-claire-element-id="516017">0</p></td><td id="r-516020" data-claire-element-id="516020"><p id="r-516019" data-claire-element-id="516019">0</p></td><td id="r-516022" data-claire-element-id="516022"><p id="r-516021" data-claire-element-id="516021">0</p></td><td id="r-516024" data-claire-element-id="516024"><p id="r-516023" data-claire-element-id="516023">0</p></td><td id="r-516026" data-claire-element-id="516026"><p id="r-516025" data-claire-element-id="516025">0</p></td></tr></tbody></table></div><p id="r-516031" data-claire-element-id="516031"><strong>Exemple 4 :</strong></p><pre id="r-516032" data-claire-element-id="516032"><code data-claire-semantic="c">int t[][5] = {[5]={0}};</code></pre><p id="r-516033" data-claire-element-id="516033"></p><div id="r-516102" data-claire-element-id="516102"><table id="r-516101" data-claire-element-id="516101"><tbody id="r-516100" data-claire-element-id="516100"><tr id="r-516044" data-claire-element-id="516044"><td id="r-516035" data-claire-element-id="516035"><p id="r-516034" data-claire-element-id="516034">0</p></td><td id="r-516037" data-claire-element-id="516037"><p id="r-516036" data-claire-element-id="516036">0</p></td><td id="r-516039" data-claire-element-id="516039"><p id="r-516038" data-claire-element-id="516038">0</p></td><td id="r-516041" data-claire-element-id="516041"><p id="r-516040" data-claire-element-id="516040">0</p></td><td id="r-516043" data-claire-element-id="516043"><p id="r-516042" data-claire-element-id="516042">0</p></td></tr><tr id="r-516055" data-claire-element-id="516055"><td id="r-516046" data-claire-element-id="516046"><p id="r-516045" data-claire-element-id="516045">0</p></td><td id="r-516048" data-claire-element-id="516048"><p id="r-516047" data-claire-element-id="516047">0</p></td><td id="r-516050" data-claire-element-id="516050"><p id="r-516049" data-claire-element-id="516049">0</p></td><td id="r-516052" data-claire-element-id="516052"><p id="r-516051" data-claire-element-id="516051">0</p></td><td id="r-516054" data-claire-element-id="516054"><p id="r-516053" data-claire-element-id="516053">0</p></td></tr><tr id="r-516066" data-claire-element-id="516066"><td id="r-516057" data-claire-element-id="516057"><p id="r-516056" data-claire-element-id="516056">0</p></td><td id="r-516059" data-claire-element-id="516059"><p id="r-516058" data-claire-element-id="516058">0</p></td><td id="r-516061" data-claire-element-id="516061"><p id="r-516060" data-claire-element-id="516060">0</p></td><td id="r-516063" data-claire-element-id="516063"><p id="r-516062" data-claire-element-id="516062">0</p></td><td id="r-516065" data-claire-element-id="516065"><p id="r-516064" data-claire-element-id="516064">0</p></td></tr><tr id="r-516077" data-claire-element-id="516077"><td id="r-516068" data-claire-element-id="516068"><p id="r-516067" data-claire-element-id="516067">0</p></td><td id="r-516070" data-claire-element-id="516070"><p id="r-516069" data-claire-element-id="516069">0</p></td><td id="r-516072" data-claire-element-id="516072"><p id="r-516071" data-claire-element-id="516071">0</p></td><td id="r-516074" data-claire-element-id="516074"><p id="r-516073" data-claire-element-id="516073">0</p></td><td id="r-516076" data-claire-element-id="516076"><p id="r-516075" data-claire-element-id="516075">0</p></td></tr><tr id="r-516088" data-claire-element-id="516088"><td id="r-516079" data-claire-element-id="516079"><p id="r-516078" data-claire-element-id="516078">0</p></td><td id="r-516081" data-claire-element-id="516081"><p id="r-516080" data-claire-element-id="516080">0</p></td><td id="r-516083" data-claire-element-id="516083"><p id="r-516082" data-claire-element-id="516082">0</p></td><td id="r-516085" data-claire-element-id="516085"><p id="r-516084" data-claire-element-id="516084">0</p></td><td id="r-516087" data-claire-element-id="516087"><p id="r-516086" data-claire-element-id="516086">0</p></td></tr><tr id="r-516099" data-claire-element-id="516099"><td id="r-516090" data-claire-element-id="516090"><p id="r-516089" data-claire-element-id="516089">0</p></td><td id="r-516092" data-claire-element-id="516092"><p id="r-516091" data-claire-element-id="516091">0</p></td><td id="r-516094" data-claire-element-id="516094"><p id="r-516093" data-claire-element-id="516093">0</p></td><td id="r-516096" data-claire-element-id="516096"><p id="r-516095" data-claire-element-id="516095">0</p></td><td id="r-516098" data-claire-element-id="516098"><p id="r-516097" data-claire-element-id="516097">0</p></td></tr></tbody></table></div><p id="r-516103" data-claire-element-id="516103"><strong>Exemple 5 :</strong></p><pre id="r-516104" data-claire-element-id="516104"><code data-claire-semantic="c">int t[][5] = {[1]=1,[3]=5,6,2,4,[4]=10,0,7,5,3,8,4,7,[18]=7,9,[23]=13};</code></pre><div id="r-516371" data-claire-element-id="516371"><table id="r-516370" data-claire-element-id="516370"><tbody id="r-516369" data-claire-element-id="516369"><tr id="r-516115" data-claire-element-id="516115"><td id="r-516106" data-claire-element-id="516106"><p id="r-516105" data-claire-element-id="516105">0</p></td><td id="r-516108" data-claire-element-id="516108"><p id="r-516107" data-claire-element-id="516107">0</p></td><td id="r-516110" data-claire-element-id="516110"><p id="r-516109" data-claire-element-id="516109">0</p></td><td id="r-516112" data-claire-element-id="516112"><p id="r-516111" data-claire-element-id="516111">0</p></td><td id="r-516114" data-claire-element-id="516114"><p id="r-516113" data-claire-element-id="516113">0</p></td></tr><tr id="r-516126" data-claire-element-id="516126"><td id="r-516117" data-claire-element-id="516117"><p id="r-516116" data-claire-element-id="516116">1</p></td><td id="r-516119" data-claire-element-id="516119"><p id="r-516118" data-claire-element-id="516118">0</p></td><td id="r-516121" data-claire-element-id="516121"><p id="r-516120" data-claire-element-id="516120">0</p></td><td id="r-516123" data-claire-element-id="516123"><p id="r-516122" data-claire-element-id="516122">0</p></td><td id="r-516125" data-claire-element-id="516125"><p id="r-516124" data-claire-element-id="516124">0</p></td></tr><tr id="r-516137" data-claire-element-id="516137"><td id="r-516128" data-claire-element-id="516128"><p id="r-516127" data-claire-element-id="516127">0</p></td><td id="r-516130" data-claire-element-id="516130"><p id="r-516129" data-claire-element-id="516129">0</p></td><td id="r-516132" data-claire-element-id="516132"><p id="r-516131" data-claire-element-id="516131">0</p></td><td id="r-516134" data-claire-element-id="516134"><p id="r-516133" data-claire-element-id="516133">0</p></td><td id="r-516136" data-claire-element-id="516136"><p id="r-516135" data-claire-element-id="516135">0</p></td></tr><tr id="r-516148" data-claire-element-id="516148"><td id="r-516139" data-claire-element-id="516139"><p id="r-516138" data-claire-element-id="516138">5</p></td><td id="r-516141" data-claire-element-id="516141"><p id="r-516140" data-claire-element-id="516140">6</p></td><td id="r-516143" data-claire-element-id="516143"><p id="r-516142" data-claire-element-id="516142">2</p></td><td id="r-516145" data-claire-element-id="516145"><p id="r-516144" data-claire-element-id="516144">4</p></td><td id="r-516147" data-claire-element-id="516147"><p id="r-516146" data-claire-element-id="516146">0</p></td></tr><tr id="r-516159" data-claire-element-id="516159"><td id="r-516150" data-claire-element-id="516150"><p id="r-516149" data-claire-element-id="516149">10</p></td><td id="r-516152" data-claire-element-id="516152"><p id="r-516151" data-claire-element-id="516151">0</p></td><td id="r-516154" data-claire-element-id="516154"><p id="r-516153" data-claire-element-id="516153">7</p></td><td id="r-516156" data-claire-element-id="516156"><p id="r-516155" data-claire-element-id="516155">5</p></td><td id="r-516158" data-claire-element-id="516158"><p id="r-516157" data-claire-element-id="516157">3</p></td></tr><tr id="r-516170" data-claire-element-id="516170"><td id="r-516161" data-claire-element-id="516161"><p id="r-516160" data-claire-element-id="516160">8</p></td><td id="r-516163" data-claire-element-id="516163"><p id="r-516162" data-claire-element-id="516162">4</p></td><td id="r-516165" data-claire-element-id="516165"><p id="r-516164" data-claire-element-id="516164">7</p></td><td id="r-516167" data-claire-element-id="516167"><p id="r-516166" data-claire-element-id="516166">0</p></td><td id="r-516169" data-claire-element-id="516169"><p id="r-516168" data-claire-element-id="516168">0</p></td></tr><tr id="r-516181" data-claire-element-id="516181"><td id="r-516172" data-claire-element-id="516172"><p id="r-516171" data-claire-element-id="516171">0</p></td><td id="r-516174" data-claire-element-id="516174"><p id="r-516173" data-claire-element-id="516173">0</p></td><td id="r-516176" data-claire-element-id="516176"><p id="r-516175" data-claire-element-id="516175">0</p></td><td id="r-516178" data-claire-element-id="516178"><p id="r-516177" data-claire-element-id="516177">0</p></td><td id="r-516180" data-claire-element-id="516180"><p id="r-516179" data-claire-element-id="516179">0</p></td></tr><tr id="r-516192" data-claire-element-id="516192"><td id="r-516183" data-claire-element-id="516183"><p id="r-516182" data-claire-element-id="516182">0</p></td><td id="r-516185" data-claire-element-id="516185"><p id="r-516184" data-claire-element-id="516184">0</p></td><td id="r-516187" data-claire-element-id="516187"><p id="r-516186" data-claire-element-id="516186">0</p></td><td id="r-516189" data-claire-element-id="516189"><p id="r-516188" data-claire-element-id="516188">0</p></td><td id="r-516191" data-claire-element-id="516191"><p id="r-516190" data-claire-element-id="516190">0</p></td></tr><tr id="r-516203" data-claire-element-id="516203"><td id="r-516194" data-claire-element-id="516194"><p id="r-516193" data-claire-element-id="516193">0</p></td><td id="r-516196" data-claire-element-id="516196"><p id="r-516195" data-claire-element-id="516195">0</p></td><td id="r-516198" data-claire-element-id="516198"><p id="r-516197" data-claire-element-id="516197">0</p></td><td id="r-516200" data-claire-element-id="516200"><p id="r-516199" data-claire-element-id="516199">0</p></td><td id="r-516202" data-claire-element-id="516202"><p id="r-516201" data-claire-element-id="516201">0</p></td></tr><tr id="r-516214" data-claire-element-id="516214"><td id="r-516205" data-claire-element-id="516205"><p id="r-516204" data-claire-element-id="516204">0</p></td><td id="r-516207" data-claire-element-id="516207"><p id="r-516206" data-claire-element-id="516206">0</p></td><td id="r-516209" data-claire-element-id="516209"><p id="r-516208" data-claire-element-id="516208">0</p></td><td id="r-516211" data-claire-element-id="516211"><p id="r-516210" data-claire-element-id="516210">0</p></td><td id="r-516213" data-claire-element-id="516213"><p id="r-516212" data-claire-element-id="516212">0</p></td></tr><tr id="r-516225" data-claire-element-id="516225"><td id="r-516216" data-claire-element-id="516216"><p id="r-516215" data-claire-element-id="516215">0</p></td><td id="r-516218" data-claire-element-id="516218"><p id="r-516217" data-claire-element-id="516217">0</p></td><td id="r-516220" data-claire-element-id="516220"><p id="r-516219" data-claire-element-id="516219">0</p></td><td id="r-516222" data-claire-element-id="516222"><p id="r-516221" data-claire-element-id="516221">0</p></td><td id="r-516224" data-claire-element-id="516224"><p id="r-516223" data-claire-element-id="516223">0</p></td></tr><tr id="r-516236" data-claire-element-id="516236"><td id="r-516227" data-claire-element-id="516227"><p id="r-516226" data-claire-element-id="516226">0</p></td><td id="r-516229" data-claire-element-id="516229"><p id="r-516228" data-claire-element-id="516228">0</p></td><td id="r-516231" data-claire-element-id="516231"><p id="r-516230" data-claire-element-id="516230">0</p></td><td id="r-516233" data-claire-element-id="516233"><p id="r-516232" data-claire-element-id="516232">0</p></td><td id="r-516235" data-claire-element-id="516235"><p id="r-516234" data-claire-element-id="516234">0</p></td></tr><tr id="r-516247" data-claire-element-id="516247"><td id="r-516238" data-claire-element-id="516238"><p id="r-516237" data-claire-element-id="516237">0</p></td><td id="r-516240" data-claire-element-id="516240"><p id="r-516239" data-claire-element-id="516239">0</p></td><td id="r-516242" data-claire-element-id="516242"><p id="r-516241" data-claire-element-id="516241">0</p></td><td id="r-516244" data-claire-element-id="516244"><p id="r-516243" data-claire-element-id="516243">0</p></td><td id="r-516246" data-claire-element-id="516246"><p id="r-516245" data-claire-element-id="516245">0</p></td></tr><tr id="r-516258" data-claire-element-id="516258"><td id="r-516249" data-claire-element-id="516249"><p id="r-516248" data-claire-element-id="516248">0</p></td><td id="r-516251" data-claire-element-id="516251"><p id="r-516250" data-claire-element-id="516250">0</p></td><td id="r-516253" data-claire-element-id="516253"><p id="r-516252" data-claire-element-id="516252">0</p></td><td id="r-516255" data-claire-element-id="516255"><p id="r-516254" data-claire-element-id="516254">0</p></td><td id="r-516257" data-claire-element-id="516257"><p id="r-516256" data-claire-element-id="516256">0</p></td></tr><tr id="r-516269" data-claire-element-id="516269"><td id="r-516260" data-claire-element-id="516260"><p id="r-516259" data-claire-element-id="516259">0</p></td><td id="r-516262" data-claire-element-id="516262"><p id="r-516261" data-claire-element-id="516261">0</p></td><td id="r-516264" data-claire-element-id="516264"><p id="r-516263" data-claire-element-id="516263">0</p></td><td id="r-516266" data-claire-element-id="516266"><p id="r-516265" data-claire-element-id="516265">0</p></td><td id="r-516268" data-claire-element-id="516268"><p id="r-516267" data-claire-element-id="516267">0</p></td></tr><tr id="r-516280" data-claire-element-id="516280"><td id="r-516271" data-claire-element-id="516271"><p id="r-516270" data-claire-element-id="516270">0</p></td><td id="r-516273" data-claire-element-id="516273"><p id="r-516272" data-claire-element-id="516272">0</p></td><td id="r-516275" data-claire-element-id="516275"><p id="r-516274" data-claire-element-id="516274">0</p></td><td id="r-516277" data-claire-element-id="516277"><p id="r-516276" data-claire-element-id="516276">0</p></td><td id="r-516279" data-claire-element-id="516279"><p id="r-516278" data-claire-element-id="516278">0</p></td></tr><tr id="r-516291" data-claire-element-id="516291"><td id="r-516282" data-claire-element-id="516282"><p id="r-516281" data-claire-element-id="516281">0</p></td><td id="r-516284" data-claire-element-id="516284"><p id="r-516283" data-claire-element-id="516283">0</p></td><td id="r-516286" data-claire-element-id="516286"><p id="r-516285" data-claire-element-id="516285">0</p></td><td id="r-516288" data-claire-element-id="516288"><p id="r-516287" data-claire-element-id="516287">0</p></td><td id="r-516290" data-claire-element-id="516290"><p id="r-516289" data-claire-element-id="516289">0</p></td></tr><tr id="r-516302" data-claire-element-id="516302"><td id="r-516293" data-claire-element-id="516293"><p id="r-516292" data-claire-element-id="516292">0</p></td><td id="r-516295" data-claire-element-id="516295"><p id="r-516294" data-claire-element-id="516294">0</p></td><td id="r-516297" data-claire-element-id="516297"><p id="r-516296" data-claire-element-id="516296">0</p></td><td id="r-516299" data-claire-element-id="516299"><p id="r-516298" data-claire-element-id="516298">0</p></td><td id="r-516301" data-claire-element-id="516301"><p id="r-516300" data-claire-element-id="516300">0</p></td></tr><tr id="r-516313" data-claire-element-id="516313"><td id="r-516304" data-claire-element-id="516304"><p id="r-516303" data-claire-element-id="516303">7</p></td><td id="r-516306" data-claire-element-id="516306"><p id="r-516305" data-claire-element-id="516305">9</p></td><td id="r-516308" data-claire-element-id="516308"><p id="r-516307" data-claire-element-id="516307">0</p></td><td id="r-516310" data-claire-element-id="516310"><p id="r-516309" data-claire-element-id="516309">0</p></td><td id="r-516312" data-claire-element-id="516312"><p id="r-516311" data-claire-element-id="516311">0</p></td></tr><tr id="r-516324" data-claire-element-id="516324"><td id="r-516315" data-claire-element-id="516315"><p id="r-516314" data-claire-element-id="516314">0</p></td><td id="r-516317" data-claire-element-id="516317"><p id="r-516316" data-claire-element-id="516316">0</p></td><td id="r-516319" data-claire-element-id="516319"><p id="r-516318" data-claire-element-id="516318">0</p></td><td id="r-516321" data-claire-element-id="516321"><p id="r-516320" data-claire-element-id="516320">0</p></td><td id="r-516323" data-claire-element-id="516323"><p id="r-516322" data-claire-element-id="516322">0</p></td></tr><tr id="r-516335" data-claire-element-id="516335"><td id="r-516326" data-claire-element-id="516326"><p id="r-516325" data-claire-element-id="516325">0</p></td><td id="r-516328" data-claire-element-id="516328"><p id="r-516327" data-claire-element-id="516327">0</p></td><td id="r-516330" data-claire-element-id="516330"><p id="r-516329" data-claire-element-id="516329">0</p></td><td id="r-516332" data-claire-element-id="516332"><p id="r-516331" data-claire-element-id="516331">0</p></td><td id="r-516334" data-claire-element-id="516334"><p id="r-516333" data-claire-element-id="516333">0</p></td></tr><tr id="r-516346" data-claire-element-id="516346"><td id="r-516337" data-claire-element-id="516337"><p id="r-516336" data-claire-element-id="516336">0</p></td><td id="r-516339" data-claire-element-id="516339"><p id="r-516338" data-claire-element-id="516338">0</p></td><td id="r-516341" data-claire-element-id="516341"><p id="r-516340" data-claire-element-id="516340">0</p></td><td id="r-516343" data-claire-element-id="516343"><p id="r-516342" data-claire-element-id="516342">0</p></td><td id="r-516345" data-claire-element-id="516345"><p id="r-516344" data-claire-element-id="516344">0</p></td></tr><tr id="r-516357" data-claire-element-id="516357"><td id="r-516348" data-claire-element-id="516348"><p id="r-516347" data-claire-element-id="516347">0</p></td><td id="r-516350" data-claire-element-id="516350"><p id="r-516349" data-claire-element-id="516349">0</p></td><td id="r-516352" data-claire-element-id="516352"><p id="r-516351" data-claire-element-id="516351">0</p></td><td id="r-516354" data-claire-element-id="516354"><p id="r-516353" data-claire-element-id="516353">0</p></td><td id="r-516356" data-claire-element-id="516356"><p id="r-516355" data-claire-element-id="516355">0</p></td></tr><tr id="r-516368" data-claire-element-id="516368"><td id="r-516359" data-claire-element-id="516359"><p id="r-516358" data-claire-element-id="516358">13</p></td><td id="r-516361" data-claire-element-id="516361"><p id="r-516360" data-claire-element-id="516360">0</p></td><td id="r-516363" data-claire-element-id="516363"><p id="r-516362" data-claire-element-id="516362">0</p></td><td id="r-516365" data-claire-element-id="516365"><p id="r-516364" data-claire-element-id="516364">0</p></td><td id="r-516367" data-claire-element-id="516367"><p id="r-516366" data-claire-element-id="516366">0</p></td></tr></tbody></table></div><h3 id="r-parcours" data-claire-element-id="516377">Parcours</h3><p id="r-516373" data-claire-element-id="516373">Le parcours d'un tableau à plusieurs dimensions s'effectue en précisant l'indice pour chaque dimension.</p><p id="r-516374" data-claire-element-id="516374">Pour un exemple de tableau de trois dimensions, et à l'aide de trois boucles imbriquées, on arriverait à accéder à toutes les cases de notre tableau.</p><p id="r-516375" data-claire-element-id="516375"><em>Exemple :</em></p><pre id="r-516376" data-claire-element-id="516376"><code data-claire-semantic="c">int tableau[taille1][taille2][taille3];
int i,j,k;

for(i=0 ; i &lt; taille1 ; i++){               //Première dimension
      for(j=0 ; j &lt; taille2 ; j++){         //Deuxième dimension
             for(k=0 ; k &lt; taille3 ; k++){  //troisième dimension
                   tableau[i][j][k] = 0;
             }
      }
}</code></pre><h2 id="r-les-pointeurs-sur-tableaux" data-claire-element-id="516397">Les pointeurs sur tableaux</h2><p id="r-516379" data-claire-element-id="516379">Vous pensez peut être au double pointeur (int **) :) , non ce n'est pas de cela qu'il s'agit.</p><p id="r-516380" data-claire-element-id="516380">La déclaration d'un pointeur sur tableau s'effectue en utilisant des parenthèses, l'astérisque '*' et en définissant la taille du tableau sur lequel on souhaite pointer. Notez que les parenthèses sont très importantes car en leur absence, ce sera un tableau de pointeurs qu'on aura déclaré, ce qui n'est pas la même chose.</p><p id="r-516381" data-claire-element-id="516381"><em>Exemple :</em></p><pre id="r-516382" data-claire-element-id="516382"><code data-claire-semantic="c">int (*ptrtableau)[4];</code></pre><p id="r-516383" data-claire-element-id="516383">Dans cet exemple, il s'agit d'une déclaration d'un pointeur sur tableaux de 4 entiers.</p><aside id="r-516387" data-claire-element-id="516387" data-claire-semantic="warning"><p id="r-516384" data-claire-element-id="516384"><strong>L'erreur à ne pas faire :</strong></p><pre id="r-516385" data-claire-element-id="516385"><code data-claire-semantic="c">int * ptrtableau[4];</code></pre><p id="r-516386" data-claire-element-id="516386">Ici il ne s'agit pas d'un pointeur sur tableau de 4, mais un tableau de 4 pointeurs sur int (dont l'explication est dans la partie suivante).</p></aside><h3 id="r-utilite-des-pointeurs-sur-tableaux" data-claire-element-id="516392">Utilité des pointeurs sur tableaux</h3><p id="r-516388" data-claire-element-id="516388">C'est un moyen très pratique pour déclarer un tableau à deux dimensions :) . Sachant qu'une dimension est déjà pré allouée, il ne reste plus qu'à allouer la deuxième dimension.</p><p id="r-516389" data-claire-element-id="516389">Exemple :</p><pre id="r-516390" data-claire-element-id="516390"><code data-claire-semantic="c">int (*tableau)[4];

tableau = malloc(5 * sizeof(*tableau));</code></pre><p id="r-516391" data-claire-element-id="516391">Ainsi on aura déclaré un tableau de 5 tableaux de 4 entiers chacun (équivalent à <code data-claire-semantic="c">int tableau[5][4];</code>).</p><h3 id="r-liberation-de-memoire-allouee" data-claire-element-id="516396">Libération de mémoire allouée</h3><p id="r-516393" data-claire-element-id="516393">Pour libérer la mémoire, on doit utiliser la fonction free toujours, et lui donner en paramètre le pointeur sur l'espace alloué à l'aide de malloc :</p><pre id="r-516394" data-claire-element-id="516394"><code data-claire-semantic="c">int (*tableau)[4];

//----Allocation-----
tableau = malloc(5 * sizeof(*tableau));
if(tableau == NULL){
    //Notifier l'erreur
    exit(EXIT_FAILURE);
}

//----Libération en cas d'allocation réussie-----
free(tableau);</code></pre><p id="r-516395" data-claire-element-id="516395">La deuxième dimension sera libérée automatiquement donc pas besoin de free pour le faire.<br/> Ainsi on remarque que ce type est beaucoup plus rapide d'utilisation (en terme d'allocation/libération de mémoire) du fait qu'il ne nécessite pas de boucles.</p><h2 id="r-les-tableaux-de-pointeurs" data-claire-element-id="516411">Les tableaux de pointeurs</h2><p id="r-516398" data-claire-element-id="516398">Un tableau de pointeurs, est un outil pour ranger un ensemble de pointeurs sur différentes variables.<br/> Il peut également servir pour déclarer un tableau à deux dimensions, en allouant plusieurs espaces et stockant leurs pointeurs dans notre tableau.</p><p id="r-516399" data-claire-element-id="516399"><em>Exemple de déclaration :</em></p><pre id="r-516400" data-claire-element-id="516400"><code data-claire-semantic="c">int * tableauDePtr[5];</code></pre><p id="r-516401" data-claire-element-id="516401"><em>Exemple d'utilisation pour déclarer un tableau à deux dimensions :</em></p><pre id="r-516402" data-claire-element-id="516402"><code data-claire-semantic="c">int * tableauDePtr[5];
int i;

for(i=0 ; i &lt; 5 ; i++){
       tableauDePtr[i] = malloc(4 * sizeof(tableau[0]));
}</code></pre><p id="r-516403" data-claire-element-id="516403">Ainsi on aura créé un tableau de 5 tableaux de 4 entiers chacun (équivalent à <code data-claire-semantic="c">int tableau[5][4];</code>).</p><h3 id="r-liberation-de-memoire-allouee-1" data-claire-element-id="516410">Libération de mémoire allouée</h3><p id="r-516404" data-claire-element-id="516404">La libération de mémoire allouée doit se faire en parcourant le tableau, et en allouant pointeur par pointeur dans ce tableau :</p><pre id="r-516405" data-claire-element-id="516405"><code data-claire-semantic="c">int i;
int * tableauDePtr[5];

//---Allocation-----
for(i=0 ; i &lt; 5 ; i++){
       tableauDePtr[i] = malloc(4 * sizeof(tableau[0]));
       if(tableauDePtr[i] == NULL){    //En cas d'erreur d'allocation
            //N'oubliez pas de notifier l'erreur
            for(i=i-1 ; i &gt;= 0 ; i--)  //Libération de l'espace déjà alloué
                 free(tableauDePtr[i]);

            exit(EXIT_FAILURE);
       }
}

//---Libération en cas d'allocation réussie-----
for(i=0 ; i &lt; 5 ; i++){
       free(tableauDePtr[i]);
}</code></pre><aside id="r-516409" data-claire-element-id="516409" data-claire-semantic="error"><p id="r-516406" data-claire-element-id="516406">L'erreur à ne pas faire :</p><pre id="r-516407" data-claire-element-id="516407"><code data-claire-semantic="c">free(tableauDePtr);</code></pre><p id="r-516408" data-claire-element-id="516408">tableauDePtr est un type automatique, donc sera libéré automatiquement à la fin de la fonction dans laquelle il est déclaré. Faites donc attention à ne pas le confondre avec le type pointeur sur tableaux qu'on a vu précédemment.</p></aside><h2 id="r-allocation-dynamique-3" data-claire-element-id="516508">Allocation dynamique</h2><p id="r-516412" data-claire-element-id="516412">Cette partie je la qualifie étant la plus dure à suivre, donc mettez vos ceintures :) .</p><p id="r-516413" data-claire-element-id="516413">L'allocation dynamique d'un dit &quot;tableau&quot; à plusieurs dimensions, s'effectue en allouant les dimensions une par une. Si je prends l'exemple d'un tableau tridimensionnel, il faudrait un triple pointeur pour y arriver. Donc veillez à avoir le même nombre d'astérisques '*' dans la déclaration de pointeur, que le nombre de dimensions de votre tableau.</p><p id="r-516414" data-claire-element-id="516414">Si je prends un exemple de tableau à 3 dimensions que je souhaite allouer dynamiquement, j'utiliserais un pointeur déclaré ainsi :</p><pre id="r-516415" data-claire-element-id="516415"><code data-claire-semantic="c">int ***ptr;     //3 étoiles pour 3 dimensions</code></pre><p id="r-516416" data-claire-element-id="516416">Et un tableau à deux dimensions nécessiterait un double pointeur :</p><pre id="r-516417" data-claire-element-id="516417"><code data-claire-semantic="c">int **ptr;     //2 étoiles pour 2 dimensions</code></pre><h3 id="r-tableaux-bidimensionnels-1" data-claire-element-id="516458">Tableaux bidimensionnels</h3><p id="r-516418" data-claire-element-id="516418">Ce type de tableaux, est un simple tableau de pointeurs, chacun de ces pointeurs va pointer sur un espace représentant un tableau à une dimension, une petite image est la bienvenue je pense :) :</p><figure id="r-516420" data-claire-element-id="516421"><img id="r-516419" data-claire-element-id="516419" src="medias/uploads.siteduzero.com_files_259001_260000_259256.png" alt="Image utilisateur"/></figure><p id="r-516422" data-claire-element-id="516422">L'allocation doit se faire en respectant la démarche suivante :</p><ul id="r-516433" data-claire-element-id="516433"><li id="r-516426" data-claire-element-id="516427"><img id="r-516427" data-claire-element-id="516426" src="medias/uploads.siteduzero.com_files_259001_260000_259813.png" alt="Image utilisateur"/><p id="r-516423" data-claire-element-id="516423">1- Allocation de la première dimension (ptr) :</p><p id="r-516424" data-claire-element-id="516424">Il s'agit du tableau de pointeurs qui contiendra plusieurs pointeurs qui à leur tour pointent sur des espaces alloués sous forme de tableaux.</p><pre id="r-516425" data-claire-element-id="516425"><code data-claire-semantic="c">int **ptr;

ptr = malloc(taille1 * sizeof(*ptr));       //On alloue 'taille1' pointeurs.
if(ptr == NULL)
      //Ne pas oublier de notifier l'erreur et de quitter le programme.</code></pre></li><li id="r-516431" data-claire-element-id="516432"><img id="r-516432" data-claire-element-id="516431" src="medias/uploads.siteduzero.com_files_259001_260000_259817.png" alt="Image utilisateur"/><p id="r-516428" data-claire-element-id="516428">2- Allocation de la deuxième dimension (*ptr) :</p><p id="r-516429" data-claire-element-id="516429">Il s'agit des différents tableaux appelés &quot;tableaux de valeurs&quot; sur l'image ci-dessus.</p><pre id="r-516430" data-claire-element-id="516430"><code data-claire-semantic="c">int i;

for(i=0 ; i &lt; taille1 ; i++){
     ptr[i] = malloc(taille2 * sizeof(*(ptr[i])));       //On alloue des tableaux de 'taille2' variables.
     if(ptr[i] == NULL){
         //Il faut libérer la mémoire déjà allouée
         //Ne pas oublier de notifier l'erreur et de quitter le programme.
     }
}</code></pre></li></ul><p id="r-516434" data-claire-element-id="516434">Ainsi on obtient le code suivant :</p><pre id="r-516435" data-claire-element-id="516435"><code data-claire-semantic="c">int i , taille1 = 2 , taille2 = 3;
int **ptr;

ptr = malloc(taille1 * sizeof(*ptr));       //On alloue 'taille1' pointeurs.
if(ptr == NULL)
      //Ne pas oublier de notifier l'erreur et de quitter le programme.

for(i=0 ; i &lt; taille1 ; i++){
     ptr[i] = malloc(taille2 * sizeof(**ptr) );       //On alloue des tableaux de 'taille2' variables.
     if(ptr[i] == NULL){                              //En cas d'erreur d'allocation
         //Il faut libérer la mémoire déjà allouée
         //Ne pas oublier de notifier l'erreur et de quitter le programme.
     }
}

//notre tableau ptr[2][3] est maintenant utilisable...</code></pre><p id="r-516436" data-claire-element-id="516436">Quant à la libération de mémoire elle se fait suivant l'ordre inverse à l'allocation :</p><ul id="r-516446" data-claire-element-id="516446"><li id="r-516440" data-claire-element-id="516441"><img id="r-516441" data-claire-element-id="516440" src="medias/uploads.siteduzero.com_files_259001_260000_259819.png" alt="Image utilisateur"/><p id="r-516437" data-claire-element-id="516437">1- Libération de la deuxième dimension (*ptr) :</p><p id="r-516438" data-claire-element-id="516438">En utilisant une boucle, on doit donc libérer les différents tableaux à une dimension qu'on a alloués :</p><pre id="r-516439" data-claire-element-id="516439"><code data-claire-semantic="c">int i;

for(i=0 ; i &lt; taille1 ; i++){
     free(ptr[i]);
}</code></pre></li><li id="r-516444" data-claire-element-id="516445"><img id="r-516445" data-claire-element-id="516444" src="medias/uploads.siteduzero.com_files_259001_260000_259820.png" alt="Image utilisateur"/><p id="r-516442" data-claire-element-id="516442">2- Libération de la première dimension (ptr) :</p><pre id="r-516443" data-claire-element-id="516443"><code data-claire-semantic="c">free(ptr);</code></pre></li></ul><p id="r-516447" data-claire-element-id="516447">On obtient donc le code suivant :</p><pre id="r-516448" data-claire-element-id="516448"><code data-claire-semantic="c">int i;

//Après allocation....

//--------La libération---------
for(i=0 ; i &lt; taille1 ; i++){
     free(ptr[i]);
}

free(ptr);
ptr = NULL;   //Ceci est par mesure de sécurité (ce n'est donc pas obligatoire).
//--------------------------------</code></pre><p id="r-516449" data-claire-element-id="516449">Cette libération n'est utilisable que si l'allocation s'est bien déroulé (sans erreurs), Que faire donc en cas d'erreur d'allocation o_O ?</p><p id="r-516450" data-claire-element-id="516450">Et bien il s'agit des <code data-claire-semantic="c">if( ptr[i] == NULL)</code> que vous avez peut être remarquées dans le code d'allocation :) . On va maintenant essayer de les remplir avec ce qu'il faut.</p><ul id="r-516457" data-claire-element-id="516457"><li id="r-516453" data-claire-element-id="516453"><p id="r-516451" data-claire-element-id="516451">1- Première dimension :</p><pre id="r-516452" data-claire-element-id="516452"><code data-claire-semantic="c">int **ptr;

ptr = malloc(taille1 * sizeof(*ptr));       //On alloue 'taille1' pointeurs.
if(ptr == NULL)
      //Pas de libération nécessaire à ce niveau, il suffirait donc de notifier l'erreur et de fermer le programme (par utilisation de exit(-1) par exemple).</code></pre></li><li id="r-516456" data-claire-element-id="516456"><p id="r-516454" data-claire-element-id="516454">2- Deuxième dimension :</p><pre id="r-516455" data-claire-element-id="516455"><code data-claire-semantic="c">int i;

for(i=0 ; i &lt; taille1 ; i++){
     ptr[i] = malloc(taille2 * sizeof(*(ptr[i])));       //On alloue des tableaux de 'taille2' variables.
     if(ptr[i] == NULL){
         for(i = i-1 ; i &gt;= 0 ; i--)    //On parcourt la boucle dans l'ordre inverse pour libérer ce qui a déjà été alloué
              free(ptr[i]);
         free(ptr);                     //On libère la première dimension.

         //Ne pas oublier de notifier l'erreur et de quitter le programme (en utilisant exit(-2) par exemple).
     }
}</code></pre></li></ul><h3 id="r-tableaux-tridimensionnels" data-claire-element-id="516507">Tableaux tridimensionnels</h3><p id="r-516459" data-claire-element-id="516459">Passant maintenant à un tableau à 3 dimensions :) . Il s'agit d'un tableau de pointeurs sur pointeurs, chacun d'eux va pointer sur un pointeur qui lui pointe sur un tableau :) bref, trop de pointeurs et de blabla, une image serait donc plus explicite :</p><figure id="r-516461" data-claire-element-id="516462"><img id="r-516460" data-claire-element-id="516460" src="medias/uploads.siteduzero.com_files_259001_260000_259255.jpg" alt="Image utilisateur"/></figure><p id="r-516463" data-claire-element-id="516463">L'allocation dynamique de ce tableau, sera divisée en 3 étapes qui doivent correspondre à l'ordre suivant :</p><ul id="r-516476" data-claire-element-id="516476"><li id="r-516466" data-claire-element-id="516467"><img id="r-516467" data-claire-element-id="516466" src="medias/uploads.siteduzero.com_files_259001_260000_259829.jpg" alt="Image utilisateur"/><p id="r-516464" data-claire-element-id="516464">1- Allocation de la première dimension, représentée par ptr : Par analogie aux tableaux automatiques, ce sera celle qui se trouve entre crochets ([]) à gauche.</p><pre id="r-516465" data-claire-element-id="516465"><code data-claire-semantic="c">int ***ptr;

ptr = malloc(taille1 * sizeof(*ptr));</code></pre></li><li id="r-516470" data-claire-element-id="516471"><img id="r-516471" data-claire-element-id="516470" src="medias/uploads.siteduzero.com_files_259001_260000_259833.jpg" alt="Image utilisateur"/><p id="r-516468" data-claire-element-id="516468">2- allocation de la deuxième dimension, représentée par *ptr : Par analogie aux tableaux automatiques, ce sera celle qui se trouve entre crochets ([]) au milieu.</p><pre id="r-516469" data-claire-element-id="516469"><code data-claire-semantic="c">for(i=0 ; i &lt; taille1 ; i++){
     ptr[i] = malloc(taille2 * sizeof(**ptr));
}</code></pre></li><li id="r-516474" data-claire-element-id="516475"><img id="r-516475" data-claire-element-id="516474" src="medias/uploads.siteduzero.com_files_259001_260000_259835.jpg" alt="Image utilisateur"/><p id="r-516472" data-claire-element-id="516472">3- allocation de la troisième dimension, représentée par **ptr : Par analogie aux tableaux automatiques, ce sera celle qui se trouve entre crochets ([]) à droite.</p><pre id="r-516473" data-claire-element-id="516473"><code data-claire-semantic="c">for(i=0 ; i &lt; taille1 ; i++){
     for(j=0 ; j &lt; taille2 ; j++){
           ptr[i][j] = malloc(taille3 * sizeof(***ptr));
     }
}</code></pre></li></ul><p id="r-516477" data-claire-element-id="516477">Nous nous retrouvons donc avec le code suivant :</p><pre id="r-516478" data-claire-element-id="516478"><code data-claire-semantic="c">int ***ptr;
int i,j;

ptr = malloc(taille1 * sizeof(*ptr));
if(ptr == NULL)          //Pas de libération de mémoire à ce niveau
     return -1;          //Exemple de code d'erreur

for(i=0 ; i &lt; taille1 ; i++){
     ptr[i] = malloc(taille2 * sizeof(**ptr));
     if( ptr[i] == NULL) //Pensez à libérer la mémoire déjà allouée et fermer le programme.
          return -1;     //Exemple de code d'erreur
}
for(i=0 ; i &lt; taille1 ; i++){
     for(j=0 ; j &lt; taille2 ; j++){
           ptr[i][j] = malloc(taille3 * sizeof(***ptr));
           if(ptr[i][j] == NULL)   //Pensez à libérer correctement la mémoire déjà allouée
                return -1;           //Exemple de code d'erreur
     }
}</code></pre><p id="r-516479" data-claire-element-id="516479">Pour un tableau de dimensions supérieurs, il faut procéder de la même manière, en allouant les dimensions une à une, et en respectant l'ordre des allocations.</p><p id="r-516480" data-claire-element-id="516480">Pour la libération de mémoire déjà allouée, il faut que cela soit fait dans l'ordre inverse à celui de l'allocation. Pour le même exemple présenté ci-dessus on procèderait ainsi :</p><ul id="r-516490" data-claire-element-id="516490"><li id="r-516483" data-claire-element-id="516483"><p id="r-516481" data-claire-element-id="516481">1- Libération de l'espace **ptr.</p><pre id="r-516482" data-claire-element-id="516482"><code data-claire-semantic="c">for(i=0 ; i &lt; tailleDejaAllouee1 ; i++){
     for(j=0 ; j &lt; tailleDejaAllouee2 ; j++){
           free(ptr[i][j]);
     }
}</code></pre></li><li id="r-516486" data-claire-element-id="516486"><p id="r-516484" data-claire-element-id="516484">2- Libération de l'espace *ptr.</p><pre id="r-516485" data-claire-element-id="516485"><code data-claire-semantic="c">for(i=0 ; i &lt; tailleDejaAllouee1 ; i++){
     free(ptr[i]);
}</code></pre></li><li id="r-516489" data-claire-element-id="516489"><p id="r-516487" data-claire-element-id="516487">3- Libération de l'espace ptr.</p><pre id="r-516488" data-claire-element-id="516488"><code data-claire-semantic="c">free(ptr);</code></pre></li></ul><p id="r-516491" data-claire-element-id="516491">Le code de libération est donc comme ceci :</p><pre id="r-516492" data-claire-element-id="516492"><code data-claire-semantic="c">for(i=0 ; i &lt; tailleDejaAllouee1 ; i++){
     for(j=0 ; j &lt; tailleDejaAllouee2 ; j++){
           free(ptr[i][j]);
     }
     free(ptr[i]);
}
free(ptr);</code></pre><aside id="r-516494" data-claire-element-id="516494" data-claire-semantic="warning"><p id="r-516493" data-claire-element-id="516493">Attention :<br/> Cette méthode de libération n'est valable que si l'allocation s'est <strong>bien déroulée</strong>.</p></aside><p id="r-516495" data-claire-element-id="516495">Voici un code montrant la méthode de libération de mémoire si l'allocation échoue avant d'allouer le tableau entièrement :</p><p id="r-516496" data-claire-element-id="516496"></p><div id="r-516498" data-claire-element-id="516498"><pre id="r-516497" data-claire-element-id="516497"><code data-claire-semantic="c">#include &lt;stdlib.h&gt;

void * my_free(int***,int,int);

void * my_free(int ***ptr,int tailleDejaAllouee1,int tailleDejaAllouee2){
    int i,j;

    for(i=0 ; i &lt; tailleDejaAllouee1 ; i++){
         for(j=0 ; j &lt; tailleDejaAllouee2 ; j++){
               free(ptr[i][j]);
         }
         free(ptr[i]);
    }
    free(ptr);

    return NULL;
}

int main(void)
{
    /*---------------------------------------------------*/
    int taille1 = 2, taille2 = 2, taille3 = 2;
    int ***ptr;
    int i,j;

    /*-----------------Allocation------------------------*/
    ptr = malloc(taille1 * sizeof(*ptr));
    if(ptr == NULL)
         return -1;

    for(i=0 ; i &lt; taille1 ; i++){
         ptr[i] = malloc(taille2 * sizeof(**ptr));

         if( ptr[i] == NULL){         //Erreur d'allocation

              for(--i ; i&gt;=0 ; i--)   //On libère l'espace déjà alloué
                  free(ptr[i]);

              free(ptr);

              return -1;              //Fin du programme
         }
    }

    for(i=0 ; i &lt; taille1 ; i++){
         for(j=0 ; j &lt; taille2 ; j++){
               ptr[i][j] = malloc(taille3 * sizeof(***ptr));

               if(ptr[i][j] == NULL){         //Erreur d'allocation

                   for(--j ; j &gt;= 0 ; j--)    //On libère l'espace déjà alloué
                        free(ptr[i][j]);

                   free(ptr[i]);

                   my_free(ptr , i , taille2);

                   for(--i ; i &gt;= 0 ; i--)
                        free(ptr[i]);

                   return -2;                 //Fin du programme
               }
         }
    }

    /*---------------Libération--------------------------*/
    ptr = my_free(ptr,taille1,taille2);       //On libère la mémoire et on met la valeur de ptr à NULL
    /*---------------------------------------------------*/

    return 0;
}</code></pre></div><aside id="r-516504" data-claire-element-id="516504" data-claire-semantic="warning"><p id="r-516499" data-claire-element-id="516499">Attention :</p><p id="r-516500" data-claire-element-id="516500">On pourrait optimiser nos boucles d'allocation comme ceci :</p><div id="r-516502" data-claire-element-id="516502"><pre id="r-516501" data-claire-element-id="516501"><code data-claire-semantic="c">int ***ptr;
int i,j;

ptr = malloc(taille1 * sizeof(*ptr));
if(ptr == NULL)          //Pas de libération de mémoire à ce niveau
     return -1;          //Exemple de code d'erreur

for(i=0 ; i &lt; taille1 ; i++){
     ptr[i] = malloc(taille2 * sizeof(**ptr));
     if( ptr[i] == NULL) //Pensez à libérer la mémoire déjà allouée et fermer le programme.
          return -1;     //Exemple de code d'erreur

     for(j=0 ; j &lt; taille2 ; j++){
           ptr[i][j] = malloc(taille3 * sizeof(***ptr));
           if(ptr[i][j] == NULL)   //Pensez à libérer correctement la mémoire déjà allouée
                return -1;           //Exemple de code d'erreur
     }
}</code></pre></div><p id="r-516503" data-claire-element-id="516503">Cependant le problème se posera dans la libération de mémoire déjà allouée qui sera beaucoup plus compliquée :) . Si vous n'êtes pas convaincu de la complexité que cela peut engendrer, essayer de le faire, et faîtes vous corrigé par une personne confirmée.</p></aside><aside id="r-516506" data-claire-element-id="516506" data-claire-semantic="information"><p id="r-516505" data-claire-element-id="516505">La méthode que je viens d'expliquer pour un tableau à trois dimensions, est valable pour un tableau à plus de dimensions, il suffirait de suivre la même logique à savoir allouer dimension par dimension en respectant l'ordre. Une fois à l'aise avec les allocations, vous pouvez bien entendu optimiser vos boucles d'allocations :) .</p></aside><h2 id="r-fonctions-mettre-un-tableau-en-argument" data-claire-element-id="516611">Fonctions : mettre un tableau en argument</h2><p id="r-516509" data-claire-element-id="516509">Si vous pensez à utiliser le double pointeur (int **), non il ne s'agit pas de cela :) .</p><aside id="r-516512" data-claire-element-id="516512" data-claire-semantic="error"><p id="r-516510" data-claire-element-id="516510">L'erreur à ne pas faire :</p><pre id="r-516511" data-claire-element-id="516511"><code data-claire-semantic="c">void ma_fonction(int ** tableau2D){
      //....
      tableau2D[i][j] = 10;
}

int main(void){
      int tableau2D[10][5];

      ma_fonction(tableau2D);
      return 0;
}</code></pre></aside><p id="r-516513" data-claire-element-id="516513">Si le tableau est alloué automatiquement, il ne faut pas l'envoyer à une fonction attendant un pointeur sur pointeur (cf : code ci-dessus).<br/> Les méthodes correctes correspondent globalement aux différentes déclarations d'un tableau telles que nous l'avons vu plus haut :) .</p><h3 id="r-methode-classique-1" data-claire-element-id="516524">Méthode classique</h3><p id="r-516514" data-claire-element-id="516514">Lors de la déclaration des arguments d'une fonction, le type tableau à plusieurs dimensions est désigné par des crochets [], avec ou sans taille.</p><pre id="r-516515" data-claire-element-id="516515"><code data-claire-semantic="c">void ma_fonction(int tableau[taille1][taille2][taille3]){
      //Corps de la fonction...
}</code></pre><aside id="r-516519" data-claire-element-id="516519" data-claire-semantic="information"><p id="r-516516" data-claire-element-id="516516">Important :<br/> Une remarque importante à noter est qu'il faut <strong>au plus</strong> une dimension avec une taille non spécifiée.<br/> Une déclaration de tableau en argument d'une fonction comme ceci :</p><pre id="r-516517" data-claire-element-id="516517"><code data-claire-semantic="c">void ma_fonction(int tableau[][][taille3]){
      //Corps de la fonction...
}</code></pre><p id="r-516518" data-claire-element-id="516518"><strong>est incorrecte</strong> !</p></aside><p id="r-516520" data-claire-element-id="516520"><em>Exemple de déclaration correcte :</em></p><pre id="r-516521" data-claire-element-id="516521"><code data-claire-semantic="c">void ma_fonction(int tableau[][taille2][taille3]){
      //Corps de la fonction...
}</code></pre><p id="r-516522" data-claire-element-id="516522">Et l'appel sera par simple envoi du nom du tableau, c'est valable pour les deux cas, à savoir avec ou sans précision de la taille de la première dimension :</p><pre id="r-516523" data-claire-element-id="516523"><code data-claire-semantic="c">int tableau[taille1][taille2][taille3];  //La déclaration du tableau

ma_fonction(tableau);   //L'appel à la fonction avec passage d'un tableau en argument.</code></pre><h3 id="r-utiliser-un-pointeur-sur-tableau" data-claire-element-id="516541">Utiliser un pointeur sur tableau</h3><p id="r-516525" data-claire-element-id="516525"><em>Exemple :</em></p><pre id="r-516526" data-claire-element-id="516526"><code data-claire-semantic="c">int fonction(int (*matrice)[3]){
        //......
        matrice[0][2] = 15;
}</code></pre><p id="r-516527" data-claire-element-id="516527">Dans cet exemple matrice est un pointeur sur tableau de 3 <code data-claire-semantic="c">int</code>.<br/> Il permettra de réceptionner la matrice envoyée sous forme de pointeur sur le premier élément (en l'occurrence, pointeur sur tableau de trois entiers) lors de la l'appel à cette fonction.<br/><em>Exemple :</em></p><div id="r-516529" data-claire-element-id="516529"><pre id="r-516528" data-claire-element-id="516528"><code data-claire-semantic="c">int fonction(int (*matrice)[3]){
        //......
        matrice[0][2] = 15;
}
int main(void){
        int matrice[4][3];  //Notez que la taille 3 correspond à celle spécifiée dans la déclaration de la fonction!

        fonction(matrice);
        return 0;
}</code></pre></div><p id="r-516530" data-claire-element-id="516530">Jusqu'ici, vous avez peut être remarqué que si l'on souhaite parcourir la matrice passée en argument, on serait obligé d'avoir une information sur la taille de la matrice. Vous pensez peut être à utiliser l'opérateur <code data-claire-semantic="c">sizeof</code> ? Alors je vous mets de suite en garde, cela ne fonctionnera pas (du moins pour la première dimension).</p><aside id="r-516536" data-claire-element-id="516536" data-claire-semantic="error"><pre id="r-516531" data-claire-element-id="516531"><code data-claire-semantic="c">void fonction(int tab[][3]){
        sizeof tab;
}</code></pre><p id="r-516532" data-claire-element-id="516532">Qui est équivalent à :</p><pre id="r-516533" data-claire-element-id="516533"><code data-claire-semantic="c">void fonction(int tab[5][3]){
        sizeof tab;
}</code></pre><p id="r-516534" data-claire-element-id="516534">Qui est équivalent à :</p><pre id="r-516535" data-claire-element-id="516535"><code data-claire-semantic="c">void fonction(int (*tab)[3]){
        sizeof tab;
}</code></pre></aside><p id="r-516537" data-claire-element-id="516537">Contrairement à ce qu'on pourrait s'attendre à voir, dans ces trois cas le résultat de l'opérateur <code data-claire-semantic="c">sizeof</code> ne donnera pas la taille des tableaux déclarés en paramètre, mais celle d'un pointeur (souvent 4 octets). Ce qui démontre (en quelque sorte) que le passage d'un paramètre formel de type 'tableau' n'est pas faisable à partir des déclarations ci-dessus.<br/> Dans le cas général, on préfère passer la taille de notre matrice (ou au moins la taille des dites &quot;lignes&quot;) en paramètre à la fonction.</p><div id="r-516539" data-claire-element-id="516539"><pre id="r-516538" data-claire-element-id="516538"><code data-claire-semantic="c">void fonction1(int matrice[][3], size_t Nlignes){
        sizeof matrice[0] * Nlignes;   //Ceci permet de récupérer la taille de toute la matrice.
        sizeof *matrice * Nlignes;     //équivalente à celle ci-dessus
}
void fonction2(int matrice[10][3], size_t Nlignes){ //La taille 10 ici sera ignorée, donc est inutile. Contrairement à la taille 3 qu'il faudra respecter!
        sizeof matrice[0] * Nlignes;   //Ceci permet de récupérer la taille de toute la matrice.
        sizeof *matrice * Nlignes;     //équivalente à celle ci-dessus
}
void fonction3(int (*matrice)[3], size_t Nlignes){
        sizeof matrice[0] * Nlignes;   //Ceci permet de récupérer la taille de toute la matrice.
        sizeof *matrice * Nlignes;     //équivalente à celle ci-dessus
}
int main (void){
        int matrice[4][3];
        fonction1(matrice,4);
        fonction2(matrice,4);
        fonction3(matrice,4);
}</code></pre></div><p id="r-516540" data-claire-element-id="516540">Ainsi nous disposerons de toutes les informations nécessaires pour parcourir notre matrice à l'aide d'une boucle.</p><h3 id="r-utilisation-d-un-double-pointeur-int-ptr" data-claire-element-id="516606">Utilisation d'un double pointeur <code data-claire-semantic="c">int **ptr</code></h3><p id="r-516542" data-claire-element-id="516542">Oui je vous ai mentit :p en vous disant qu'il n'est pas possible de réceptionner une matrice statique à partir d'un double pointeur. Mais cela n'est tout de même pas si simple à manier, et demanderait un peu de bricolage pour y parvenir, vous pouvez en juger vous même.</p><p id="r-516543" data-claire-element-id="516543">La méthode consisterait à réceptionner l'adresse envoyée lors de l'appel de la fonction, qui représente l'adresse mémoire du premier élément de la première dimension de la matrice. Et à l'aide d'un tableau intermédiaire de pointeurs, ainsi que de la mise en équation des adresses mémoire de toutes les cases de la matrice, on arriverait à manier correctement une matrice 2D.<br/> Je vous propose d'analyser ce code :</p><pre id="r-516544" data-claire-element-id="516544"><code data-claire-semantic="c">int fonction(int **mat)
{
        int i, j, *index[3];   //Index est le tableau de pointeurs qu'on utilisera sous forme de mémoire tampon.

        for (i = 0 ; i &lt; 3 ; i++)  //On initialise notre tableau intermédiaire 'index'
                index[i] = (int *)mat + 3 * i; 

        for(i = 0 ; i &lt; 3 ; i++)
        {
                printf(&quot;\n&quot;);
                for(j = 0 ; j &lt; 3 ; j++)
                {
	                printf(&quot;%d&quot;, index[i][j]);
                }
        }
        printf(&quot;\n&quot;);

        return 0;
}</code></pre><p id="r-516545" data-claire-element-id="516545">Pour bien comprendre le pourquoi du comment, je vous fais un petit rappel (qui ne sera pas qu'un simple rappel pour certains).</p><p id="r-516546" data-claire-element-id="516546">Imaginons que l'on veuille mettre en équation les adresses des cases constituant une matrice, afin de pouvoir les indexer en utilisant uniquement comme données l'adresse du premier élément dans cette matrice ainsi que sa taille (lignes et colonnes).<br/> Avant d'attaquer les explications, je tiens à vous informer/rappeler que le langage C garantie qu'un tableau à deux dimensions sera placé en mémoire selon la disposition <a href="http://en.wikipedia.org/wiki/Row-major_order">Row-major order</a>.</p><div id="r-516548" data-claire-element-id="516548" data-claire-semantic="question"><p id="r-516547" data-claire-element-id="516547">En quoi cela nous intéresse ?</p></div><p id="r-516549" data-claire-element-id="516549">Cela signifie que seulement à partir de l'adresse du premier élément, et en connaissant la taille d'une matrice, on arriverait à connaître l'adresse de chacune de ses cases.</p><p id="r-516550" data-claire-element-id="516550">Exemple :</p><table id="r-516573" data-claire-element-id="516573"><tbody id="r-516572" data-claire-element-id="516572"><tr id="r-516557" data-claire-element-id="516557"><td id="r-516552" data-claire-element-id="516552"><p id="r-516551" data-claire-element-id="516551">1</p></td><td id="r-516554" data-claire-element-id="516554"><p id="r-516553" data-claire-element-id="516553">2</p></td><td id="r-516556" data-claire-element-id="516556"><p id="r-516555" data-claire-element-id="516555">3</p></td></tr><tr id="r-516564" data-claire-element-id="516564"><td id="r-516559" data-claire-element-id="516559"><p id="r-516558" data-claire-element-id="516558">4</p></td><td id="r-516561" data-claire-element-id="516561"><p id="r-516560" data-claire-element-id="516560">5</p></td><td id="r-516563" data-claire-element-id="516563"><p id="r-516562" data-claire-element-id="516562">6</p></td></tr><tr id="r-516571" data-claire-element-id="516571"><td id="r-516566" data-claire-element-id="516566"><p id="r-516565" data-claire-element-id="516565">7</p></td><td id="r-516568" data-claire-element-id="516568"><p id="r-516567" data-claire-element-id="516567">8</p></td><td id="r-516570" data-claire-element-id="516570"><p id="r-516569" data-claire-element-id="516569">8</p></td></tr></tbody></table><p id="r-516574" data-claire-element-id="516574">Cette matrice est ramenée dans la mémoire à la forme :</p><table id="r-516595" data-claire-element-id="516595"><tbody id="r-516594" data-claire-element-id="516594"><tr id="r-516593" data-claire-element-id="516593"><td id="r-516576" data-claire-element-id="516576"><p id="r-516575" data-claire-element-id="516575">1</p></td><td id="r-516578" data-claire-element-id="516578"><p id="r-516577" data-claire-element-id="516577">2</p></td><td id="r-516580" data-claire-element-id="516580"><p id="r-516579" data-claire-element-id="516579">3</p></td><td id="r-516582" data-claire-element-id="516582"><p id="r-516581" data-claire-element-id="516581">4</p></td><td id="r-516584" data-claire-element-id="516584"><p id="r-516583" data-claire-element-id="516583">5</p></td><td id="r-516586" data-claire-element-id="516586"><p id="r-516585" data-claire-element-id="516585">6</p></td><td id="r-516588" data-claire-element-id="516588"><p id="r-516587" data-claire-element-id="516587">7</p></td><td id="r-516590" data-claire-element-id="516590"><p id="r-516589" data-claire-element-id="516589">8</p></td><td id="r-516592" data-claire-element-id="516592"><p id="r-516591" data-claire-element-id="516591">8</p></td></tr></tbody></table><p id="r-516596" data-claire-element-id="516596">(disposition Row-major order).</p><p id="r-516597" data-claire-element-id="516597">Pour la suite de l'explication, nous allons prendre trois variables de type pointeurs avec les noms adresse_1, adresse_2 et adresse_3, qui sont respectivement les adresses en mémoire des nombres 1, 4 et 7.<br/> Nous allons dans un premier temps récupérer l'adresse de la première case (celle contenant le chiffre 1), puis nous allons nous décaler de trois cases (trois étant le nombre de colonnes de la matrice) pour obtenir les adresses des élément 4 et 7;</p><pre id="r-516598" data-claire-element-id="516598"><code data-claire-semantic="c">int matrice[3][3] = {{1,2,3},{4,5,6},{7,8,9}}; //La matrice
int **adresse_matrice = (int**)matrice;  //Ceci est pour simuler un passage d'une matrice à une fonction
int *adresse_1, *adresse_2, *adresse_3;

adresse_1 = (int*)adresse_matrice;
adresse_2 = (int*)adresse_matrice + 3;
adresse_3 = (int*)adresse_matrice + 6;</code></pre><p id="r-516599" data-claire-element-id="516599">Ensuite nous allons regrouper maintenant nos pointeurs adresse_1/2/3 dans un tableau :</p><pre id="r-516600" data-claire-element-id="516600"><code data-claire-semantic="c">int matrice[3][3] = {{1,2,3},{4,5,6},{7,8,9}}; //La matrice
int **adresse_matrice = (int**)matrice;  //Ceci est pour simuler un passage d'une matrice à une fonction
int *adresse[3];                  //Les pointeurs intermédiaires

adresse[0] = (int*)adresse_matrice + (0*3);
adresse[1] = (int*)adresse_matrice + (1*3);
adresse[2] = (int*)adresse_matrice + (2*3);</code></pre><p id="r-516601" data-claire-element-id="516601">D'où le code de la fonction présenté précédemment.</p><div id="r-516603" data-claire-element-id="516603"><pre id="r-516602" data-claire-element-id="516602"><code data-claire-semantic="c">int fonction(int **mat)
{
        int i, j, *index[3];   //Index est le tableau de pointeurs qu'on utilisera sous forme de mémoire tampon.

        for (i = 0 ; i &lt; 3 ; i++)  //On initialise notre tableau intermédiaire 'index'
                index[i] = (int *)mat + 3 * i; 

        for(i = 0 ; i &lt; 3 ; i++)
        {
                printf(&quot;\n&quot;);
                for(j = 0 ; j &lt; 3 ; j++)
                {
	                printf(&quot;%d&quot;, index[i][j]);
                }
        }
        printf(&quot;\n&quot;);

        return 0;
}</code></pre></div><p id="r-516604" data-claire-element-id="516604"><em><strong>En conclusion</strong></em></p><p id="r-516605" data-claire-element-id="516605">Cette méthode n'est pas utilisée dans la pratique, de part son caractère complexe et bricolé, sans oublier qu'elle fait appel à un tableau intermédiaire, et peut poser des problèmes du fait qu'on fait des affectations aux pointeurs avec types différents.<br/> Je ne vous conseillerai donc pas de l'utiliser dans le cas général; je tenais simplement à vous la présenter à titre informatif, ça nous a aussi permis de voir la nature d'une tableau multidimensionnel en mémoire.</p><h3 id="r-utilisation-d-un-typedef-1" data-claire-element-id="516610">Utilisation d'un typedef</h3><p id="r-516607" data-claire-element-id="516607">L'utilisation du typedef n'est qu'un raccourci, pour alléger les déclarations de tableaux.</p><p id="r-516608" data-claire-element-id="516608"><em>Exemple :</em></p><pre id="r-516609" data-claire-element-id="516609"><code data-claire-semantic="c">typedef int tableau3x3x3[3][3][3];

void ma_fonction1(tableau3x3x3 tab){   //Déclaration d'un argument de type tableau tridimensionnel de 3x3x3
      //Corps de la fonction...
      printf(&quot;%zu\n&quot;,sizeof(tab[0][0]));//Pour un test
}

int main(void)
{
    tableau3x3x3 tableau;    //Déclaration du tableau 3D

    ma_fonction1(tableau);   //Appel de la fonction en lui passant notre tableau en paramètre
    return 0;
}</code></pre><h2 id="r-fonctions-retourner-un-tableau" data-claire-element-id="516620">Fonctions : retourner un tableau</h2><p id="r-516612" data-claire-element-id="516612">Comme nous l'avons vu dans la partie des tableaux unidimensionnels, il est interdit de renvoyer un tableau automatique (alloué statiquement) :</p><aside id="r-516614" data-claire-element-id="516614" data-claire-semantic="error"><pre id="r-516613" data-claire-element-id="516613"><code data-claire-semantic="c">int (ma_fonction(void))[2][3][4]{
     int tableau[2][3][4];

     return tableau;
}</code></pre></aside><p id="r-516615" data-claire-element-id="516615">Il est donc impératif de procéder à une allocation dynamique, puis de retourner le pointeur sur l'espace alloué dynamiquement (tel que nous l'avons vu avant dans la partie d'allocation dynamique ;) ).</p><p id="r-516616" data-claire-element-id="516616"><em>Exemple :</em></p><p id="r-516617" data-claire-element-id="516617"></p><div id="r-516619" data-claire-element-id="516619"><pre id="r-516618" data-claire-element-id="516618"><code data-claire-semantic="c">int *** fonction_allocation(int taille1, int taille2, int taille3){
     int ***ptr;
     int i,j;

     ptr = malloc(taille1 * sizeof(*ptr));
     if(ptr == NULL)          //Pas de libération de mémoire à ce niveau
          return -1;          //Exemple de code d'erreur

     for(i=0 ; i &lt; taille1 ; i++){
          ptr[i] = malloc(taille2 * sizeof(**ptr));
          if( ptr[i] == NULL) //Pensez à libérer la mémoire déjà allouée et fermer le programme.
               return -1;     //Exemple de code d'erreur
     }
     for(i=0 ; i &lt; taille1 ; i++){
          for(j=0 ; j &lt; taille2 ; j++){
                ptr[i][j] = malloc(taille3 * sizeof(***ptr));
                if(ptr[i][j] == NULL)     //Pensez à libérer correctement la mémoire déjà allouée
                     return -1;           //Exemple de code d'erreur
          }
     }
     return ptr;                          //retour du pointeur sur l'espace alloué
}

int main(void){
     int taille1 = 2, taille2 = 2, taille3 = 2;
     int *** ptr = fonction_allocation(taille1,taille2,taille3);
     //.....
     ptr = my_free(ptr,taille1,taille2);   //Cette fonction est décrite dans la partie allocation dynamique
     return 0;
}</code></pre></div>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique">Tableaux, pointeurs et allocation dynamique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-pointeurs-rappel">
Les pointeurs (rappel)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-unidimensionnels">
Les tableaux unidimensionnels
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-de-tableaux-tableaux-a-plusieurs-dimensions">
Les tableaux de tableaux (&quot;tableaux à plusieurs dimensions&quot;)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/exercices-31">
Exercices
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-unidimensionnels">
<span class="arrow"></span>
<span class="next">Les tableaux unidimensionnels</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/exercices-31">
<span class="next">Exercices</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Exercices"></a><h2>Exercices</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-de-tableaux-tableaux-a-plusieurs-dimensions">
<span class="arrow"></span>
<span class="next">Les tableaux de tableaux (&quot;tableaux à plusieurs dimensions&quot;)</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-pointeurs" data-claire-element-id="516666">Pointeurs</h2><h3 id="r-exercice-1-21" data-claire-element-id="516635">Exercice 1</h3><ul id="r-516634" data-claire-element-id="516634"><li id="r-516623" data-claire-element-id="516623"><p id="r-516622" data-claire-element-id="516622">1. Déclarer un pointeur sur int et l'initialiser par le pointeur NULL.</p></li><li id="r-516625" data-claire-element-id="516625"><p id="r-516624" data-claire-element-id="516624">2. Déclarer un pointeur sur pointeur sur int.</p></li><li id="r-516627" data-claire-element-id="516627"><p id="r-516626" data-claire-element-id="516626">3. Déclarer une variable de type int.</p></li><li id="r-516629" data-claire-element-id="516629"><p id="r-516628" data-claire-element-id="516628">4. Initialiser le pointeur sur int par l'adresse de cette variable.</p></li><li id="r-516631" data-claire-element-id="516631"><p id="r-516630" data-claire-element-id="516630">5. Initialiser le pointeur sur pointeur sur int par l'adresse du pointeur sur int.</p></li><li id="r-516633" data-claire-element-id="516633"><p id="r-516632" data-claire-element-id="516632">6. Allouer dynamiquement un espace de mémoire suffisant pour contenir une variable de type int, et stocker son adresse dans le pointeur sur int.</p></li></ul><h3 id="r-solution-80" data-claire-element-id="516638">Solution</h3><div id="r-516637" data-claire-element-id="516637"><pre id="r-516636" data-claire-element-id="516636"><code data-claire-semantic="c">//Q1 :
int * pointeur = NULL;
//Q2 :
int ** pointeurSurPointeur;
//Q3 :
int variable;
//Q4 :
pointeur = &amp;variable;
//Q5 :
pointeurSurPointeur = &amp;pointeur;
//Q6 :
pointeur = malloc(sizeof(int));
//Ou
pointeur = malloc(sizeof( *pointeur ));</code></pre></div><h3 id="r-exercice-2-21" data-claire-element-id="516655">Exercice 2</h3><ul id="r-516651" data-claire-element-id="516651"><li id="r-516640" data-claire-element-id="516640"><p id="r-516639" data-claire-element-id="516639">1. Déclarer deux pointeurs sur <code data-claire-semantic="c">float </code>.</p></li><li id="r-516642" data-claire-element-id="516642"><p id="r-516641" data-claire-element-id="516641">2. Déclarer deux variables de type <code data-claire-semantic="c">float </code>.</p></li><li id="r-516644" data-claire-element-id="516644"><p id="r-516643" data-claire-element-id="516643">3. Initialiser chacun des pointeurs avec les adresses des deux variables <code data-claire-semantic="c">float </code>.</p></li><li id="r-516646" data-claire-element-id="516646"><p id="r-516645" data-claire-element-id="516645">4. Affecter la valeur 12.5 à la première variable en utilisant son pointeur.</p></li><li id="r-516648" data-claire-element-id="516648"><p id="r-516647" data-claire-element-id="516647">5. Affecter la valeur 5.76 à la deuxième variable en utilisant son pointeur.</p></li><li id="r-516650" data-claire-element-id="516650"><p id="r-516649" data-claire-element-id="516649">6. Échanger le contenu des deux variables en utilisant leurs pointeurs.</p></li></ul><p id="r-516652" data-claire-element-id="516652"></p><div id="r-516654" data-claire-element-id="516654"><pre id="r-516653" data-claire-element-id="516653"><code data-claire-semantic="c">//Q1 :
float * ptr1 , * ptr2 ;
//Q2 :
float variable1 , variable2 ;
//Q3 :
ptr1 = &amp;variable1;
ptr2 = &amp;variable2;
//Q4 :
*ptr1 = 12.5;
//Q5 :
*ptr2 = 5.76;
//Q6 :
float variableIntermediaire;

variableIntermediaire = * ptr1;
*ptr1 = *ptr2;
*ptr2 = variableIntermediaire;</code></pre></div><h3 id="r-exercice-3-probleme" data-claire-element-id="516659">Exercice 3 (problème)</h3><ul id="r-516658" data-claire-element-id="516658"><li id="r-516657" data-claire-element-id="516657"><p id="r-516656" data-claire-element-id="516656">Écrire une procédure &quot;permute&quot; qui permet de permuter les valeurs de deux variables entières et écrire un programme dans lequel on saisira deux nombres entiers avant de faire appel a cette procédure et d'afficher le contenue de ces variable afin de vérifier la permutation.</p></li></ul><h3 id="r-exercice-4-probleme" data-claire-element-id="516665">Exercice 4 (problème)</h3><p id="r-516660" data-claire-element-id="516660"><strong>Pointeurs et références</strong><em>(exercice wikipedia)</em>.</p><ul id="r-516663" data-claire-element-id="516663"><li id="r-516662" data-claire-element-id="516662"><p id="r-516661" data-claire-element-id="516661">Donner et expliquer le résultat de l'exécution du programme suivant :</p></li></ul><pre id="r-516664" data-claire-element-id="516664"><code data-claire-semantic="c">#include &lt;stdio.h&gt;
#define taille_max 5
 
void parcours(int *tab)
{
     int *q=tab;
     do
     {
         printf(&quot;%d:%d\n&quot;, q-tab, *q-*tab);
     }
     while (++q-tab &lt; taille_max);
}
 
void bizarre(int **copie, int *source)
{
     *copie=source;
}
 
int main(void)
{
     int chose[taille_max] = {1,3,2,4,5}, *truc;
     printf(&quot;chose : \n&quot;);

     parcours(chose);

     bizarre(&amp;truc, chose);

     printf(&quot;truc : \n&quot;);

     parcours(truc);
 
     return 0;
}</code></pre><h2 id="r-tableaux-unidimensionnels" data-claire-element-id="516713">Tableaux unidimensionnels</h2><h3 id="r-exercice-1-22" data-claire-element-id="516670">Exercice 1</h3><ul id="r-516669" data-claire-element-id="516669"><li id="r-516668" data-claire-element-id="516668"><p id="r-516667" data-claire-element-id="516667">Déclarer de façon automatique un tableau à 15 variables de type <code data-claire-semantic="c">double </code>. Et initialiser ce tableau avec des zéros.</p></li></ul><h3 id="r-solution-81" data-claire-element-id="516673">Solution</h3><div id="r-516672" data-claire-element-id="516672"><pre id="r-516671" data-claire-element-id="516671"><code data-claire-semantic="c">double tab[15];
int i;

for(i=0 ; i&lt; 15 ; i++)
    tab[i] = 0;</code></pre></div><h3 id="r-exercice-2-probleme" data-claire-element-id="516677">Exercice 2 (problème)</h3><ul id="r-516676" data-claire-element-id="516676"><li id="r-516675" data-claire-element-id="516675"><p id="r-516674" data-claire-element-id="516674">Utiliser l'allocation dynamique pour créer un tableau de 15 variables de type <code data-claire-semantic="c">float </code>. Initialiser ce tableau avec des zéros, puis libérer la mémoire allouée si l'allocation a été effectuée avec succès.</p></li></ul><h3 id="r-exercice-3-probleme-1" data-claire-element-id="516685">Exercice 3 (problème)</h3><ul id="r-516684" data-claire-element-id="516684"><li id="r-516679" data-claire-element-id="516679"><p id="r-516678" data-claire-element-id="516678">Déclarer un double pointeur sur <code data-claire-semantic="c">float </code>, puis utiliser une fonction pour effectuer l'allocation dynamique d'un tableau de 15 variables de type <code data-claire-semantic="c">float </code> (de deux façon, par utilisation du retour de la fonction, puis par un passage par référence).</p></li><li id="r-516681" data-claire-element-id="516681"><p id="r-516680" data-claire-element-id="516680">Utiliser une fonction pour initialiser ce tableau avec des zéros si l'allocation a été effectuée avec succès.</p></li><li id="r-516683" data-claire-element-id="516683"><p id="r-516682" data-claire-element-id="516682">Puis libérer la mémoire allouée toujours si l'allocation a été effectuée avec succès.</p></li></ul><h3 id="r-exercice-4-probleme-1" data-claire-element-id="516698">Exercice 4 (problème)</h3><ul id="r-516692" data-claire-element-id="516692"><li id="r-516687" data-claire-element-id="516687"><p id="r-516686" data-claire-element-id="516686">Ecrire de deux façons différentes, un programme qui vérifie sans utiliser une fonction de &lt;string&gt;, si une chaîne CH introduite au clavier est un palindrome:</p></li><li id="r-516689" data-claire-element-id="516689"><p id="r-516688" data-claire-element-id="516688">a) en utilisant uniquement le formalisme tableau</p></li><li id="r-516691" data-claire-element-id="516691"><p id="r-516690" data-claire-element-id="516690">b) en utilisant des pointeurs au lieu des indices numériques</p></li></ul><p id="r-516693" data-claire-element-id="516693"><strong>Rappel</strong> : Un palindrome est un mot qui reste le même qu'on le lise de gauche à droite ou de droite à gauche.</p><p id="r-516694" data-claire-element-id="516694"><em>Exemples</em> :</p><p id="r-516695" data-claire-element-id="516695"><strong>PIERRE</strong> : n'est pas un palindrome</p><p id="r-516696" data-claire-element-id="516696"><strong>OTTO</strong> : est un palindrome</p><p id="r-516697" data-claire-element-id="516697"><strong>23432</strong> : est un palindrome</p><h3 id="r-exercice-5-probleme" data-claire-element-id="516702">Exercice 5 (problème)</h3><ul id="r-516701" data-claire-element-id="516701"><li id="r-516700" data-claire-element-id="516700"><p id="r-516699" data-claire-element-id="516699">Écrire un programme qui lit deux tableaux A et B et leurs dimensions N et M au clavier et qui ajoute les éléments de B à la fin de A. Utiliser le formalisme pointeur à chaque fois que cela est possible.</p></li></ul><h3 id="r-exercice-6-probleme" data-claire-element-id="516712">Exercice 6 (problème)</h3><ul id="r-516711" data-claire-element-id="516711"><li id="r-516704" data-claire-element-id="516704"><p id="r-516703" data-claire-element-id="516703">Écrire un programme qui demande à l'utilisateur de saisir la dimension N d'un tableau T du type <code data-claire-semantic="c">int </code> (dimension maximale: 50), remplit le tableau par des valeurs entrées au clavier et affiche le tableau.</p></li><li id="r-516706" data-claire-element-id="516706"><p id="r-516705" data-claire-element-id="516705">Calculer et afficher ensuite la somme des éléments du tableau.</p></li><li id="r-516708" data-claire-element-id="516708"><p id="r-516707" data-claire-element-id="516707">Copiez ensuite toutes les composantes strictement positives dans un deuxième tableau TPOS et toutes les valeurs strictement négatives dans un troisième tableau TNEG.</p></li><li id="r-516710" data-claire-element-id="516710"><p id="r-516709" data-claire-element-id="516709">Afficher les tableaux TPOS et TNEG.</p></li></ul><h2 id="r-tableaux-multidimensionnels" data-claire-element-id="516735">Tableaux multidimensionnels</h2><h3 id="r-exercice-1-probleme" data-claire-element-id="516717">Exercice 1 (problème)</h3><ul id="r-516716" data-claire-element-id="516716"><li id="r-516715" data-claire-element-id="516715"><p id="r-516714" data-claire-element-id="516714">Écrire un programme qui lit les dimensions L et C d'un tableau T à deux dimensions du type int (dimensions maximales: 50 lignes et 50 colonnes). Remplir le tableau par des valeurs entrées au clavier et afficher le tableau ainsi que la somme de chaque ligne et de chaque colonne en n'utilisant qu'une variable d'aide pour la somme.</p></li></ul><h3 id="r-exercice-2-probleme-1" data-claire-element-id="516734">Exercice 2 (problème)</h3><ul id="r-516722" data-claire-element-id="516722"><li id="r-516719" data-claire-element-id="516719"><p id="r-516718" data-claire-element-id="516718">Écrire un programme qui lit un texte (sur plusieurs lignes) saisi par l'utilisateur (chaque ligne peut avoir un nombre maximal de 100 caractères). La fin de la saisie sera validée par l'entrée d'une ligne vide.</p></li><li id="r-516721" data-claire-element-id="516721"><p id="r-516720" data-claire-element-id="516720">Écrire une fonction qui demande à l'utilisateur de saisir un mot, elle recherchera ce mot dans le texte saisi (que nous lui passerons sous forme d'argument) et retourne le numéro de la ligne du premier mot trouvé dans le texte.</p></li></ul><p id="r-516723" data-claire-element-id="516723">En conclusion nous allons donc retenir les choses suivantes :</p><ul id="r-516730" data-claire-element-id="516730"><li id="r-516725" data-claire-element-id="516725"><p id="r-516724" data-claire-element-id="516724">Un pointeur n'est pas un tableau.</p></li><li id="r-516727" data-claire-element-id="516727"><p id="r-516726" data-claire-element-id="516726">Un tableau n'est pas un pointeur.</p></li><li id="r-516729" data-claire-element-id="516729"><p id="r-516728" data-claire-element-id="516728">Un pointeur doit toujours être initialisé, soit par une allocation dynamique soit en pointant sur une variable.</p></li></ul><p id="r-516731" data-claire-element-id="516731">Ayez également en esprit que les codes les plus simples sont souvent les plus robustes et fiables. Ne cherchez pas automatiquement la solution compliquée, appliquez ce que vous avez appris dans ce cours qui en fin de compte a été rédigé dans un but de vous montrer comment utiliser correctement chaque technique (d'allocation, libération, traitement d'erreur, initialisation...). Définissez vos contraintes de portabilité et de conformité à l'une des normes dés la rédaction de votre cahier des charges, et avancez dans le développement de vos programmes en respectant cette contrainte.</p><p id="r-516732" data-claire-element-id="516732">Ainsi vous amoindrirez le risque de bogue, et vous obtiendrez un programme fiable en gestion d'erreurs en ce qui concerne tableaux et pointeurs :) .</p><p id="r-516733" data-claire-element-id="516733">Merci pour votre attention, et n'hésitez pas à me faire part de vos remarques.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique">Tableaux, pointeurs et allocation dynamique</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-pointeurs-rappel">
Les pointeurs (rappel)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-unidimensionnels">
Les tableaux unidimensionnels
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-de-tableaux-tableaux-a-plusieurs-dimensions">
Les tableaux de tableaux (&quot;tableaux à plusieurs dimensions&quot;)
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/exercices-31">
Exercices
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tableaux-pointeurs-et-allocation-dynamique/les-tableaux-de-tableaux-tableaux-a-plusieurs-dimensions">
<span class="arrow"></span>
<span class="next">Les tableaux de tableaux (&quot;tableaux à plusieurs dimensions&quot;)</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/ableaux-pointeurs-et-allocation-dynamique.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 00:06:16 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/ableaux-pointeurs-et-allocation-dynamique.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:16:22 GMT -->
</html>
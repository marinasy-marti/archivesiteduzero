<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/les-listes-doublement-chainees-en-langage-c.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 06:36:00 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-listes-doublement-chainees-en-langage-c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:10:22 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Les listes doublement chainées en langage C</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Les listes doublement chainées en langage C</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#LeslistesdoublementchainesenlangageC">Les listes doublement chainées en langage C</a><br/><a href="#Premireapproche">Première approche</a><br/><a href="#Reprsentationd039unelisteenlangageC">Représentation d&#039;une liste en langage C</a><br/><a href="#Manipulationd039unelistedoublementchaine1_2">Manipulation d&#039;une liste doublement chainée (1/2)</a><br/><a href="#Manipulationd039unelistedoublementchaine2_2">Manipulation d&#039;une liste doublement chainée (2/2)</a><br/><a href="#Pratiquerunmaitremot">Pratiquer: un maitre mot</a><br/></div>
<a name="LeslistesdoublementchainesenlangageC"></a><h2>Les listes doublement chainées en langage C</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/premiere-approche-6">
<span class="next">Première approche</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-520253" data-claire-element-id="520253"><strong>Bonjour à tous les lecteurs.</strong></p><p id="r-520254" data-claire-element-id="520254">Dans <strong><a href="http://www.siteduzero.com/tuto-3-9440-1-les-listes-chainees.html">son tutoriel</a></strong>, <strong><a href="http://www.siteduzero.com/membres-294-11449.html">lexou</a></strong> présente un nouveau type de structure de données: les listes chainées. En lisant son tutoriel, vous êtes alors capables de vous fabriquer votre propre petit module vous permettant de manipuler vos listes chainées. Seulement, son tutoriel ne fait uniquement objet des listes <strong>simplement</strong> chainées. lexou vous parle alors dans sa conclusion des listes <strong>doublement</strong> chainées.</p><p id="r-520255" data-claire-element-id="520255">Dans la continuité du tutoriel de lexou, je vous propose d'apprendre à manier les listes dites <strong>doublement</strong> chainées. A la fin de ce tutoriel, vous devriez être capables de mettre en place votre propre module de manipulation des listes doublement chainées. Il est aussi à noter qu'à la fin de ce tutoriel, nous aurons l'occasion d'étudier un cas d'utilisation de nos listes doublement chainées.</p><p id="r-520256" data-claire-element-id="520256">Afin de suivre et de comprendre pleinement les notions évoquées par ce tutoriel, je vous recommande la lecture du tutoriel de lexou ci-dessus. Il est aussi bien entendu évident qu'une lecture du tutoriel de M@teo jusqu'aux pointeurs et l'allocation dynamique est obligatoire.</p><p id="r-520257" data-claire-element-id="520257">Vous voilà avertis. Commençons sans plus attendre.</p>
</div><a name="Premireapproche"></a><h2>Première approche</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/representation-d-une-liste-en-langage-c">
<span class="next">Représentation d&#039;une liste en langage C</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-520258" data-claire-element-id="520258">Avant de commencer à programmer quoi que ce soit, nous nous devons de voir la <em>théorie</em> concernant les listes doublements chainées. Tout d'abord, faisons quelques rappels.</p><p id="r-520259" data-claire-element-id="520259">Les listes chainées se présentent comme une alternative aux tableaux pour le stockage de certaines données. En effet, dans certaines situations, l'usage des tableaux peut se révéler inefficace.</p><div id="r-520261" data-claire-element-id="520261" data-claire-semantic="question"><p id="r-520260" data-claire-element-id="520260">Pourquoi les tableaux ne suffisent t-ils pas ?</p></div><p id="r-520262" data-claire-element-id="520262">Vous devriez savoir que lorsque vous créez un tableau, vous connaissez sa taille à l'avance, que ce soit avec l'utilisation ou non de malloc. Ainsi, vous vous retrouvez limités par la taille de votre tableau. Il est cependant possible à tout moment d'agrandir un tableau, mais ceci n'est pas la meilleur solution envisageable. Pour pallier à cette limitation, nous allons donc utiliser des <strong>listes chainées</strong>. Alors que les éléments d'un tableau sont <strong>contigües</strong> en mémoire, les éléments d'une liste chainées sont quant à eux tous reliés via une série de pointeurs.<br/> Ainsi, lorsque chaque élément d'une liste chainée pointe vers l'élément suivant, nous parlons de liste <strong>simplement</strong> chainée. Lorsque chaque élément d'une liste pointe à la fois vers l'élément suivant et précédent, nous parlons alors de liste <strong>doublement</strong> chainée. Retenez donc qu'une liste chainée nous permet de stoquer un nombre inconnu d'éléments.</p><p id="r-520263" data-claire-element-id="520263">Voici une représentation schématique des listes doublement chainées:</p><figure id="r-520265" data-claire-element-id="520266"><img id="r-520264" data-claire-element-id="520264" src="medias/uploads.siteduzero.com_files_99001_100000_99463.png" alt="Image utilisateur"/></figure><p id="r-520267" data-claire-element-id="520267">Vous pouvez donc voir sur ce schéma que chaque élément d'une liste doublement chainée contient :</p><ul id="r-520274" data-claire-element-id="520274"><li id="r-520269" data-claire-element-id="520269"><p id="r-520268" data-claire-element-id="520268">Une donnée (ici un simple entier)</p></li><li id="r-520271" data-claire-element-id="520271"><p id="r-520270" data-claire-element-id="520270">Un pointeur vers l'élément suivant (NULL si l'élément suivant n'existe pas)</p></li><li id="r-520273" data-claire-element-id="520273"><p id="r-520272" data-claire-element-id="520272">Un pointeur vers l'élément précédent (NULL si l'élément précédent n'existe pas)</p></li></ul><p id="r-520275" data-claire-element-id="520275">Passons maintenant à la représentation de ces listes en langage C.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c">Les listes doublement chainées en langage C</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/premiere-approche-6">
Première approche
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/representation-d-une-liste-en-langage-c">
Représentation d&#039;une liste en langage C
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-1-2">
Manipulation d&#039;une liste doublement chainée (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-2-2">
Manipulation d&#039;une liste doublement chainée (2/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/pratiquer-un-maitre-mot">
Pratiquer: un maitre mot
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/representation-d-une-liste-en-langage-c">
<span class="next">Représentation d&#039;une liste en langage C</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Reprsentationd039unelisteenlangageC"></a><h2>Représentation d&#039;une liste en langage C</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/premiere-approche-6">
<span class="arrow"></span>
<span class="next">Première approche</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-1-2">
<span class="next">Manipulation d&#039;une liste doublement chainée (1/2)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-520277" data-claire-element-id="520277">Qu'allons nous utiliser pour nous représenter ces listes en langage C. La réponse est toute simple. Nous allons tout simplement utiliser une structure. En effet, en langage C, les structures sont très pratiques pour créer de nouveaux types de données. Pour être plus précis, nous allons utiliser exactement <strong>deux structures</strong>. Voici la première :</p><pre id="r-520278" data-claire-element-id="520278"><code data-claire-semantic="c">struct node
{
    int data;
    struct node *p_next;
    struct node *p_prev;
};</code></pre><p id="r-520279" data-claire-element-id="520279">Cette première structure va nous permettre de représenter un 'node' (élément) de notre liste chaînée. Nous pouvons alors voir que chaque élément de notre liste contiendra un élément de type <strong>int</strong>. D'autre part :</p><ul id="r-520284" data-claire-element-id="520284"><li id="r-520281" data-claire-element-id="520281"><p id="r-520280" data-claire-element-id="520280">p_next pointera vers l'élément suivant (ou NULL s'il s'agit du dernier élément de la liste)</p></li><li id="r-520283" data-claire-element-id="520283"><p id="r-520282" data-claire-element-id="520282">p_prev pointera vers l'élément précédent (ou NULL s'il s'agit du premier élément)</p></li></ul><p id="r-520285" data-claire-element-id="520285">Les liens entre les différents éléments de notre liste chaînée sont donc assurés par nos deux pointeurs p_next et p_prev.</p><aside id="r-520287" data-claire-element-id="520287" data-claire-semantic="information"><p id="r-520286" data-claire-element-id="520286">Afin de bien visualiser nos pointeurs, nous utiliserons le préfixe p_ pour toutes nos variables pointeurs.</p></aside><p id="r-520288" data-claire-element-id="520288">Pour représenter notre liste chaînée à proprement parler, nous utiliserons une deuxième liste que voici :</p><pre id="r-520289" data-claire-element-id="520289"><code data-claire-semantic="c">typedef struct dlist
{
    size_t length;
    struct node *p_tail;
    struct node *p_head;
} Dlist;</code></pre><div id="r-520291" data-claire-element-id="520291" data-claire-semantic="question"><p id="r-520290" data-claire-element-id="520290">Attends attends, c'est quoi ça size_t ? Et ça veut dire quoi p_tail et p_head ?</p></div><p id="r-520292" data-claire-element-id="520292">Tout d'abord, nous utilisons une variable nommée length contenant la taille de notre liste chaînée (length = taille en anglais). Grâce à cette variable, nous aurons accès au nombre d'éléments de notre liste chaînée. Cependant, cette variable peut paraître un peu particulière puisqu'elle est de type <strong>size_t</strong>. Ce fameux size_t correspond à un entier <strong>non signé</strong> c'est à dire un entier positif (ça tombe bien car notre liste chaînée ne pourra pas contenir -1 élément). Ce type est de ce fait communément utilisé pour tout ce qui concerne les tailles (taille d'un tableau, ...). <br/> Enfin, éclaircissons ce fameux p_tail et p_head, à quoi vont-ils bien nous servir ? Ceci est tout simple. p_head va pointer vers le premier élément de notre liste alors que p_tail va pointer vers le dernier élément. Ainsi, nous garderons de manière permanente un pointeur vers le début et la fin de la liste.</p><div id="r-520294" data-claire-element-id="520294" data-claire-semantic="question"><p id="r-520293" data-claire-element-id="520293">Ok, mais à quoi ça va nous servir ?</p></div><p id="r-520295" data-claire-element-id="520295">Et bien cela va tout simplement servir à faciliter les différentes opérations que nous effectuerons sur nos listes. En effet, pour exemple, lorsque nous souhaiterons ajouter un élément en fin de liste, nous n'aurons pas besoin de parcourir la liste dans sa totalité pour ajouter l'élément en fin car nous disposerons directement d'une référence vers la fin de liste ;) .<br/> Enfin, afin de faciliter l'écriture, nous créons un <strong>alias</strong> de notre structure grâce à l'opérateur <strong>typedef</strong>. Nous appelons cet alias Dlist pour <strong>D</strong>ouble <strong>L</strong>ist. Pour utiliser une liste dans nos programmes nous utiliserons alors :</p><pre id="r-520296" data-claire-element-id="520296"><code data-claire-semantic="c">Dlist *list = NULL; /* Déclaration d'une liste vide */</code></pre><p id="r-520297" data-claire-element-id="520297">Voilà, vous savez maintenant comment est définie une liste doublement chaînée en langage C. Voyons maintenant comment la manipuler.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c">Les listes doublement chainées en langage C</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/premiere-approche-6">
Première approche
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/representation-d-une-liste-en-langage-c">
Représentation d&#039;une liste en langage C
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-1-2">
Manipulation d&#039;une liste doublement chainée (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-2-2">
Manipulation d&#039;une liste doublement chainée (2/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/pratiquer-un-maitre-mot">
Pratiquer: un maitre mot
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/premiere-approche-6">
<span class="arrow"></span>
<span class="next">Première approche</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-1-2">
<span class="next">Manipulation d&#039;une liste doublement chainée (1/2)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Manipulationd039unelistedoublementchaine1_2"></a><h2>Manipulation d&#039;une liste doublement chainée (1/2)</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/representation-d-une-liste-en-langage-c">
<span class="arrow"></span>
<span class="next">Représentation d&#039;une liste en langage C</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-2-2">
<span class="next">Manipulation d&#039;une liste doublement chainée (2/2)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-520299" data-claire-element-id="520299">Nous savons désormais comment déclarer une liste doublement chaînée en langage C. Nous allons maintenant créer des fonctions nous permettant de réaliser plusieurs opérations sur ces fameuses listes.</p><aside id="r-520301" data-claire-element-id="520301" data-claire-semantic="information"><p id="r-520300" data-claire-element-id="520300">Avant de regarder le code, je vous conseille de réaliser ces fonctions par vous-même, vous progresserez plus vite ;) .</p></aside><p id="r-520302" data-claire-element-id="520302">Commençons alors par notre première fonction.</p><h2 id="r-allouer-une-nouvelle-liste" data-claire-element-id="520315">Allouer une nouvelle liste</h2><p id="r-520303" data-claire-element-id="520303">Avant de pouvoir commencer à utiliser notre liste chaînée, nous allons créer une fonction nous permettant d'allouer de l'espace mémoire pour notre liste chaînée. La fonction retournera la liste chaînée nouvellement créée. Voici cette fameuse fonction</p><pre id="r-520304" data-claire-element-id="520304"><code data-claire-semantic="c">Dlist *dlist_new(void)
{
    Dlist *p_new = malloc(sizeof *p_new);
    if (p_new != NULL)
    {
        p_new-&gt;length = 0;
        p_new-&gt;p_head = NULL;
        p_new-&gt;p_tail = NULL;
    }
    return p_new;
}</code></pre><aside id="r-520306" data-claire-element-id="520306" data-claire-semantic="information"><p id="r-520305" data-claire-element-id="520305">Pour respecter une certaine convention, toutes nos fonctions seront de la forme dlist_.</p></aside><p id="r-520307" data-claire-element-id="520307">Comment fonctionne cette fonction ? Je pense que vous l'aurez deviné sans trop de problèmes. Tout d'abord, nous créons une variable p_new qui sera notre nouvelle liste. Nous utilisons alors malloc pour réserver de l'espace mémoire pour cette liste.</p><aside id="r-520313" data-claire-element-id="520313" data-claire-semantic="information"><p id="r-520308" data-claire-element-id="520308">La syntaxe suivante:</p><pre id="r-520309" data-claire-element-id="520309"><code data-claire-semantic="c">int *p_data = malloc(sizeof *p_data);</code></pre><p id="r-520310" data-claire-element-id="520310">Est identique à:</p><pre id="r-520311" data-claire-element-id="520311"><code data-claire-semantic="c">int *p_data = malloc(sizeof(int));</code></pre><p id="r-520312" data-claire-element-id="520312">De cette manière, si l'on modifie notre type, on n'aura pas besoin de le modifier dans notre malloc ;) .</p></aside><p id="r-520314" data-claire-element-id="520314">Ensuite et de manière générale, il est nécessaire de vérifier si notre malloc n'a pas échoué. En effet, si celui-ci renvoie NULL, et que nous essayons d'accéder aux éléments de notre structure Dlist, c'est le drame :D .<br/> Enfin, nous mettons nos pointeurs p_head ainsi que p_tail à NULL (vu que notre liste est vide), puis nous initialisons la taille de notre liste à 0 et nous retournons notre nouvelle liste.</p><h2 id="r-ajouter-un-element-2" data-claire-element-id="520348">Ajouter un élément</h2><p id="r-520316" data-claire-element-id="520316">Après avoir alloué une nouvelle liste chaînée, voyons maintenant comment ajouter un élément dans celle-ci.</p><h3 id="r-ajout-en-fin-de-liste" data-claire-element-id="520342">Ajout en fin de liste</h3><p id="r-520317" data-claire-element-id="520317">Grâce à la forme de notre structure, l'ajout en fin de liste va être simplifié. En effet, rappelez-vous, nous gardons toujours un pointeur vers la fin de notre liste, nous n'avons donc nul besoin de parcourir la liste en entier afin d'arriver au dernier élément, nous l'avons déjà. Voici comment va se passer l'ajout en fin de liste:</p><figure id="r-520319" data-claire-element-id="520320"><img id="r-520318" data-claire-element-id="520318" src="medias/uploads.siteduzero.com_files_99001_100000_99520.png" alt="Image utilisateur"/></figure><p id="r-520321" data-claire-element-id="520321">A partir de ce schéma, essayons d'en déduire un algorithme. Tout d'abord, nous devons vérifier si notre liste n'est pas NULL. Si elle ne l'est pas, nous allons créer un nouvel élément (nouveau node). Une fois celui-ci créé, nous devons stoquer notre donnée dans le champ donnée (data) de notre structure puis faire pointer p_next vers NULL car ce sera le dernier élément de notre liste. A partir de là, deux possibilités s'offrent à nous :</p><ul id="r-520338" data-claire-element-id="520338"><li id="r-520328" data-claire-element-id="520328"><p id="r-520322" data-claire-element-id="520322">S'il n'existe pas de dernier élément (donc la liste est vide) Alors</p><ul id="r-520327" data-claire-element-id="520327"><li id="r-520324" data-claire-element-id="520324"><p id="r-520323" data-claire-element-id="520323">Nous faisons pointer p_prev vers NULL</p></li><li id="r-520326" data-claire-element-id="520326"><p id="r-520325" data-claire-element-id="520325">Nous faisons pointer la tête et la fin de liste vers notre nouvel élément</p></li></ul></li><li id="r-520337" data-claire-element-id="520337"><p id="r-520329" data-claire-element-id="520329">Sinon</p><ul id="r-520336" data-claire-element-id="520336"><li id="r-520331" data-claire-element-id="520331"><p id="r-520330" data-claire-element-id="520330">Nous rattachons le dernier élément de notre liste à notre nouvel élément (début du chaînage)</p></li><li id="r-520333" data-claire-element-id="520333"><p id="r-520332" data-claire-element-id="520332">Nous faisons pointer p_prev vers le dernier élément de notre liste</p></li><li id="r-520335" data-claire-element-id="520335"><p id="r-520334" data-claire-element-id="520334">Nous faisons pointer notre fin de liste vers notre nouvel élément (fin du chaînage)</p></li></ul></li></ul><p id="r-520339" data-claire-element-id="520339">Enfin, nous incrémentons notre champ length de notre liste puis nous retournons la liste. Tout ceci constitue alors l'algorithme d'ajout en fin de liste. Essayez tout d'abord de le coder par vous même, cela sera bénéfique pour vous et vous aidera à comprendre le concept. Si vous bloquez, munissez vous d'une feuille et d'une crayon et essayez de représenter toutes les étapes sur votre feuille. Ensuite, réessayez de coder l'algorithme.<br/> Voici l'implémentation :</p><pre id="r-520340" data-claire-element-id="520340"><code data-claire-semantic="c">Dlist *dlist_append(Dlist *p_list, int data)
{
    if (p_list != NULL) /* On vérifie si notre liste a été allouée */
    {
        struct node *p_new = malloc(sizeof *p_new); /* Création d'un nouveau node */
        if (p_new != NULL) /* On vérifie si le malloc n'a pas échoué */
        {
            p_new-&gt;data = data; /* On 'enregistre' notre donnée */
            p_new-&gt;p_next = NULL; /* On fait pointer p_next vers NULL */
            if (p_list-&gt;p_tail == NULL) /* Cas où notre liste est vide (pointeur vers fin de liste à  NULL) */
            {
                p_new-&gt;p_prev = NULL; /* On fait pointer p_prev vers NULL */
                p_list-&gt;p_head = p_new; /* On fait pointer la tête de liste vers le nouvel élément */
                p_list-&gt;p_tail = p_new; /* On fait pointer la fin de liste vers le nouvel élément */
            }
            else /* Cas où des éléments sont déjà présents dans notre liste */
            {
                p_list-&gt;p_tail-&gt;p_next = p_new; /* On relie le dernier élément de la liste vers notre nouvel élément (début du chaînage) */
                p_new-&gt;p_prev = p_list-&gt;p_tail; /* On fait pointer p_prev vers le dernier élément de la liste */
                p_list-&gt;p_tail = p_new; /* On fait pointer la fin de liste vers notre nouvel élément (fin du chaînage: 3 étapes) */
            }
            p_list-&gt;length++; /* Incrémentation de la taille de la liste */
        }
    }
    return p_list; /* on retourne notre nouvelle liste */
}</code></pre><p id="r-520341" data-claire-element-id="520341">Le code ci-dessus est entièrement commenté, il ne sera donc pas nécessaire d'ajouter de commentaires. N'hésitez pas à relire ce morceau de code. Si vous avez des difficultés à le comprendre, jouez le rôle du compilateur et imaginez vous le déroulement de chaque instruction ;) .</p><h3 id="r-ajout-en-debut-de-liste" data-claire-element-id="520347">Ajout en début de liste</h3><p id="r-520343" data-claire-element-id="520343">Pour ajouter un élément en début de liste, nous allons utiliser exactement le même procédé que pour l'ajout en fin de liste. Et oui, grâce à nos pointeurs en début et en fin de liste, nous pouvons nous permettre de reprendre nos implémentations. Si vous avez bien compris comment se passait l'ajout en fin de liste, vous n'aurez aucun de mal à réaliser l'ajout en début de liste. Là aussi, essayez d'abord par vous même de programmer cet algorithme.</p><p id="r-520344" data-claire-element-id="520344">Voici la fonction finale :</p><pre id="r-520345" data-claire-element-id="520345"><code data-claire-semantic="c">Dlist *dlist_prepend(Dlist *p_list, int data)
{
    if (p_list != NULL)
    {
        struct node *p_new = malloc(sizeof *p_new);
        if (p_new != NULL)
        {
            p_new-&gt;data = data;
            p_new-&gt;p_prev = NULL;
            if (p_list-&gt;p_tail == NULL)
            {
                p_new-&gt;p_next = NULL;
                p_list-&gt;p_head = p_new;
                p_list-&gt;p_tail = p_new;
            }
            else
            {
                p_list-&gt;p_head-&gt;p_prev = p_new;
                p_new-&gt;p_next = p_list-&gt;p_head;
                p_list-&gt;p_head = p_new;
            }
            p_list-&gt;length++;
       }
    }
    return p_list;
}</code></pre><p id="r-520346" data-claire-element-id="520346">Il y a comme des ressemblances entre les deux fonctions vous ne trouvez pas :D .</p><h2 id="r-inserer-un-element-1" data-claire-element-id="520373">Insérer un élément</h2><p id="r-520349" data-claire-element-id="520349">Nous disposons désormais de fonctions permettant d'ajouter un élément en début ainsi qu'en fin de liste. Mais si l'on désire ajouter un élément nimporte où dans notre liste ? Et bien nous allons justement créer une fonction pour ceci. Comment allons-nous procéder ? Posons-nous et réfléchissons cinq minutes. Tout d'abord, nous aurons besoin de parcourir notre liste. Nous aurons aussi besoin d'un compteur (que l'on nommera) i afin de nous arrêter à la position où nous souhaitons insérer notre nouvel élément. Jusqu'ici, rien de bien sorcier. Il nous faut alors réfléchir des différents cas de figure qui peuvent intervenir lorsque nous aurons trouvé notre position:</p><ul id="r-520356" data-claire-element-id="520356"><li id="r-520351" data-claire-element-id="520351"><p id="r-520350" data-claire-element-id="520350">Soit nous sommes en fin de liste</p></li><li id="r-520353" data-claire-element-id="520353"><p id="r-520352" data-claire-element-id="520352">Soit nous sommes en début de liste</p></li><li id="r-520355" data-claire-element-id="520355"><p id="r-520354" data-claire-element-id="520354">Soit nous sommes en milieu de liste</p></li></ul><p id="r-520357" data-claire-element-id="520357">Cependant, les deux premiers cas sont très faciles à traîter. Enfin, nous disposons de fonctions permettant d'ajouter un élément en début et en fin de liste, il nous suffit donc de les réaliser. Le plus gros de notre travail sera alors de gérer le cas où nous nous trouvons en milieu de liste. Voici un petit schéma permettant de mieux cerner la situation:</p><figure id="r-520359" data-claire-element-id="520360"><img id="r-520358" data-claire-element-id="520358" src="medias/uploads.siteduzero.com_files_99001_100000_99684.png" alt="Image utilisateur"/></figure><p id="r-520361" data-claire-element-id="520361">Le chaînage va être légèrement plus compliqué. En effet, nous devrons tout d'abord relier nos éléments suivant et précédent à notre nouvel élément puis, inversement, nous devrons relier notre nouvel élément aux éléments suivant et précédent. Le chaînage va alors se dérouler en 4 étapes. A noter qu'il sera nécessaire d'avoir préalablement créé un nouvel élément sans quoi le chaînage ne pourra pas avoir lieu. <br/> Pour parcourir notre liste, nous récupérerons le pointeur vers notre début de liste dans un pointeur temporaire. C'est ce pointeur temporaire qui nous servira à parcourir notre liste. Schématiquement, notre liste sera parcourue de gauche à droite. Notre compteur sera bien évidemment incrémenté lors du parcours de chaque maillon de la liste.</p><p id="r-520362" data-claire-element-id="520362">Voici ce que cela donne:</p><pre id="r-520363" data-claire-element-id="520363"><code data-claire-semantic="c">Dlist *dlist_insert(Dlist *p_list, int data, int position)
{
    if (p_list != NULL)
    {
        struct node *p_temp = p_list-&gt;p_head;
        int i = 1;
        while (p_temp != NULL &amp;&amp; i &lt;= position)
        {
            if (position == i)
            {
                if (p_temp-&gt;p_next == NULL)
                {
                    p_list = dlist_append(p_list, data);
                }
                else if (p_temp-&gt;p_prev == NULL)
                {
                    p_list = dlist_prepend(p_list, data);
                }
                else
                {
                    struct node *p_new = malloc(sizeof *p_new);;
                    if (p_new != NULL)
                    {
                        p_new-&gt;data = data;
                        p_temp-&gt;p_next-&gt;p_prev = p_new;
                        p_temp-&gt;p_prev-&gt;p_next = p_new;
                        p_new-&gt;p_prev = p_temp-&gt;p_prev;
                        p_new-&gt;p_next = p_temp;
                        p_list-&gt;length++;
                    }
                }
            }
            else
            {
                p_temp = p_temp-&gt;p_next;
            }
            i++;
        }
    }
    return p_list;
}</code></pre><p id="r-520364" data-claire-element-id="520364">Si vous avez compris les codes précédemment établis, je ne pense pas que vous aurez des difficultés à comprendre celui-ci. Cependant, voici quelques explications supplémentaires: pour notre parcours de liste, nous utilisons un pointeur nommé <strong>p_temp</strong>. Au tout début, celui-ci pointe vers le premier élément de notre liste (<strong>p_list-&gt;p_head</strong>). Pour parcourir notre liste, nous utilisons une structure de type while. Tant que nous n'avons pas atteint la fin de liste (p_temp != NULL) <strong>et</strong> tant que nous ne sommes pas à la position où nous voulons insérer notre élément (position &lt;= i), nous bouclons. Dès lors que nous avons atteint notre position (position == i), nous devons alors effectuer nos trois tests :</p><ul id="r-520371" data-claire-element-id="520371"><li id="r-520366" data-claire-element-id="520366"><p id="r-520365" data-claire-element-id="520365">Si nous sommes en fin de liste (p_temp-&gt;p_next == NULL), nous utilisons notre fonction dlist_append</p></li><li id="r-520368" data-claire-element-id="520368"><p id="r-520367" data-claire-element-id="520367">Sinon, si nous sommes en début de liste (p_temp-&gt;p_prev == NULL), nous utilisons notre fonction dlist_prepend</p></li><li id="r-520370" data-claire-element-id="520370"><p id="r-520369" data-claire-element-id="520369">Sinon, nous devons créer un nouvel élément et réaliser notre chaînage sans oublier de stoquer la donnée dans notre champ data</p></li></ul><p id="r-520372" data-claire-element-id="520372">Logiquement, grâce au schéma précédent et aux explications fournies, vous ne devriez pas avoir de mal à comprendre le chaînage.<br/> Enfin, si nous n'avons pas encore atteint notre position, nous passons à l'élément suivant (p_temp = p_temp-&gt;p_next).</p><h2 id="r-liberer-une-liste" data-claire-element-id="520377">Libérer une liste</h2><p id="r-520374" data-claire-element-id="520374">Après avoir utilisé notre liste, nous nous devons de <strong>libérer</strong> tous nos éléments alloués par nos fonctions sous peine d'obtenir ce que l'on nomme des <strong>fuites de mémoire</strong> (<em>leak memory</em>). Pour accomplir ceci, rien de plus facile. Regardons le code:</p><pre id="r-520375" data-claire-element-id="520375"><code data-claire-semantic="c">void dlist_delete(Dlist **p_list)
{
    if (*p_list != NULL)
    {
        struct node *p_temp = (*p_list)-&gt;p_head;
        while (p_temp != NULL)
        {
            struct node *p_del = p_temp;
            p_temp = p_temp-&gt;p_next;
            free(p_del);
        }
        free(*p_list), *p_list = NULL;
    }
}</code></pre><p id="r-520376" data-claire-element-id="520376">Dans ce code, nous pouvons remarquer qu'une petite chose change par rapport à nos codes précédents. Dans cette fonction, nous utilisons un <strong>double pointeur</strong>. En effet, notre fonction delete doit directement effectuer les modifications sur notre liste. Autrement dit, celle-ci doit faire des modifications sur un objet de type Dlist *. C'est pour cela que nous ne devons pas disposer d'un pointeur simple, mais bel et bien d'un pointeur double.<br/> En premier lieu, nous vérifions si la liste que nous avons récupérée n'est pas NULL. Si celle-ci venait à être NULL et que nous essayions de la manipuler, nous aboutirions à un beau plantage. Nous parcourons ensuite chaque élément de la liste comme dans notre fonction précédente (à noter la présence de parenthèses afin de résoudre la priorité de l'opérateur -&gt; sur l'opérateur *). Seulement, nous prenons garde de sauvegarder l'élément courant dans un pointeur p_del (qui sera comme vous l'aurez compris l'élément que nous supprimerons). En effet, si nous n'utilisons pas de pointeur intermédiaire, lorsque nous supprimerons notre premier élément, p_temp-&gt;p_next n'existera plus puisque notre élément aura été supprimé, nous aurons donc un beau plantage. C'est pour cela que nous sauvegardons d'abord notre élément courant, puis nous passons à l'élément suivant et enfin nous supprimons notre élément courant (p_del). Quand tous les éléments sont supprimés, nous terminons par supprimer notre liste puis nous la remettons à NULL.</p><h2 id="r-exercice-50" data-claire-element-id="520388">Exercice</h2><p id="r-520378" data-claire-element-id="520378">Passons maintenant à un petit exercice afin de mettre en œuvre vos connaissances. Ecrivez une fonction dlist_display prenant en paramètre une liste et affichant tous les éléments de la liste séparés par des '&gt;'. Lorsque la fin de liste sera atteinte, NULL sera affiché. Exemple :</p><pre id="r-520379" data-claire-element-id="520379"><code data-claire-semantic="console">4 &gt; 8 &gt; 15 &gt; 16 &gt; 23 &gt; 42 &gt; NULL</code></pre><p id="r-520380" data-claire-element-id="520380">Correction:</p><p id="r-520381" data-claire-element-id="520381"></p><div id="r-520384" data-claire-element-id="520384"><div id="r-520383" data-claire-element-id="520383"><pre id="r-520382" data-claire-element-id="520382"><code data-claire-semantic="c">void dlist_display(Dlist *p_list)
{
    if (p_list != NULL)
    {
        struct node *p_temp = p_list-&gt;p_head;
        while (p_temp != NULL)
        {
            printf(&quot;%d -&gt; &quot;, p_temp-&gt;data);
            fflush(stdout);
            p_temp = p_temp-&gt;p_next;
        }
    }
    printf(&quot;NULL\n&quot;);
}</code></pre></div></div><p id="r-520385" data-claire-element-id="520385">Comme vous pouvez le voir, ceci n'a rien de sorcier. Il suffit tout simplement de parcourir la liste entièrement puis d'afficher les éléments un à un. Lorsque la boucle est terminée, nous terminons par afficher &quot;NULL&quot;.</p><aside id="r-520387" data-claire-element-id="520387" data-claire-semantic="information"><p id="r-520386" data-claire-element-id="520386">Notre premier printf n'étant pas terminé par un ' ', nous nous devons de <strong>forcer</strong> l'affichage des caractères par l'utilisation de fflush(stdout).<br/><a href="http://mapage.noos.fr/emdel/notes.htm#fflush_stdout">informations supplémentaires</a> sur le sujet.</p></aside>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c">Les listes doublement chainées en langage C</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/premiere-approche-6">
Première approche
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/representation-d-une-liste-en-langage-c">
Représentation d&#039;une liste en langage C
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-1-2">
Manipulation d&#039;une liste doublement chainée (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-2-2">
Manipulation d&#039;une liste doublement chainée (2/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/pratiquer-un-maitre-mot">
Pratiquer: un maitre mot
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/representation-d-une-liste-en-langage-c">
<span class="arrow"></span>
<span class="next">Représentation d&#039;une liste en langage C</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-2-2">
<span class="next">Manipulation d&#039;une liste doublement chainée (2/2)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Manipulationd039unelistedoublementchaine2_2"></a><h2>Manipulation d&#039;une liste doublement chainée (2/2)</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-1-2">
<span class="arrow"></span>
<span class="next">Manipulation d&#039;une liste doublement chainée (1/2)</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/pratiquer-un-maitre-mot">
<span class="next">Pratiquer: un maitre mot</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-520390" data-claire-element-id="520390">Dans la partie précédente, nous avons réalisé quelques fonctions basiques de manipulation de listes chainées. Nous bénéficions désormais de fonctions d'allocation, ajout, insertion ainsi que de libération de liste. Nous allons alors compléter notre petite bibliothèque en créant des fonctions supplémentaires. Nous allons tout d'abord nous occuper de fonctions de suppression.</p><h2 id="r-supprimer-un-element-d-une-liste" data-claire-element-id="520417">Supprimer un élément d'une liste</h2><h3 id="r-supprimer-un-element-selon-sa-valeur" data-claire-element-id="520408">Supprimer un élément selon sa valeur</h3><p id="r-520391" data-claire-element-id="520391">Nous allons tout d'abord voir la manière de supprimer un élément en fonction de sa valeur. A nouveau, voici un schéma pour vous aider à mieux visualiser le procédé:</p><figure id="r-520393" data-claire-element-id="520394"><img id="r-520392" data-claire-element-id="520392" src="medias/uploads.siteduzero.com_files_99001_100000_99994.png" alt="Image utilisateur"/></figure><p id="r-520395" data-claire-element-id="520395">Ici, nous décidons de supprimer l'élément portant la valeur 15. Comment allons-nous nous y prendre ? Tout d'abord, comme vous pourrez l'imaginer, il va nous falloir parcourir notre liste à la rechercher de notre élément à supprimer. Dès que l'on aura trouver la valeur correspondante, trois possibilités s'offreront à nous:</p><ul id="r-520402" data-claire-element-id="520402"><li id="r-520397" data-claire-element-id="520397"><p id="r-520396" data-claire-element-id="520396">l'élément se trouve en fin de liste</p></li><li id="r-520399" data-claire-element-id="520399"><p id="r-520398" data-claire-element-id="520398">l'élément se trouve en début de liste</p></li><li id="r-520401" data-claire-element-id="520401"><p id="r-520400" data-claire-element-id="520400">l'élément se trouve en milieu de liste</p></li></ul><p id="r-520403" data-claire-element-id="520403">Si l'élément se trouve en fin de liste, Alors il faudra faire pointer notre p_tail vers l'avant dernier élément et faire pointer le pointeur vers l'élément suivant de l'avant dernier élément vers NULL.<br/> Sinon, si l'élément se trouve en début de liste, Alors il faudra faire pointer notre p_head vers le second élément et faire pointer le pointeur vers l'élément précédent du second élément vers NULL.<br/> Sinon, il faudra relier l'élément précédent à l'élément que l'on veut supprimer vers l'élément suivant à l'élément que l'on veut supprimer et il faudra aussi relier l'élément suivant à l'élément su l'on veut supprimer vers l'élément précédent à l'élément que l'on veut supprimer.<br/> Une fois ceci fait, il ne nous restera plus qu'à supprimer notre élément trouver et à décrémenter la taille de notre liste. <br/> Tout ceci constitue notre algorithme. A sa lecture, celui-ci peut sembler rebutant mais lors de la réalisation en langage C, il vous deviendra beaucoup plus clair ;) .<br/> Avec ces explications, vous devriez être capable de réaliser le code tout seul.</p><aside id="r-520405" data-claire-element-id="520405" data-claire-semantic="information"><p id="r-520404" data-claire-element-id="520404">Notre fonction ne supprimera que le premier élément trouvé.</p></aside><pre id="r-520406" data-claire-element-id="520406"><code data-claire-semantic="c">Dlist *dlist_remove(Dlist *p_list, int data)
{
    if (p_list != NULL)
    {
        struct node *p_temp = p_list-&gt;p_head;
        int found = 0;
        while (p_temp != NULL &amp;&amp; !found)
        {
            if (p_temp-&gt;data == data)
            {
                if (p_temp-&gt;p_next == NULL)
                {
                    p_list-&gt;p_tail = p_temp-&gt;p_prev;
                    p_list-&gt;p_tail-&gt;p_next = NULL;
                }
                else if (p_temp-&gt;p_prev == NULL)
                {
                    p_list-&gt;p_head = p_temp-&gt;p_next;
                    p_list-&gt;p_head-&gt;p_prev = NULL;
                }
                else
                {
                    p_temp-&gt;p_next-&gt;p_prev = p_temp-&gt;p_prev;
                    p_temp-&gt;p_prev-&gt;p_next = p_temp-&gt;p_next;
                }
                free(p_temp);
                p_list-&gt;length--;
                found = 1;
            }
            else
            {
                p_temp = p_temp-&gt;p_next;
            }
        }
    }
    return p_list;
}</code></pre><p id="r-520407" data-claire-element-id="520407">Vous voyez donc que traduit en langage C, l'algorithme devient plus intuitif ;) . A noter cependant que nous utilisons une variable supplémentaire nommée found pour nous arrêter au premier élément trouvé. Lorsque l'élément est trouvé, cette variable change d'état et prend la valeur 1, marquant ainsi l'arrêt de la boucle de parcours.</p><h3 id="r-supprimer-un-ensemble-d-elements-suivant-une-meme-valeur" data-claire-element-id="520411">Supprimer un ensemble d'éléments suivant une même valeur</h3><p id="r-520409" data-claire-element-id="520409">L'algorithme précédent ne nous permettait de supprimer uniquement le premier élément trouvé. Nous allons maintenant écrire un code supprimant toutes les valeurs trouvées dans la liste. Et devinez quoi ? Et bien comme vous pouvez vous en douter, il s'agit exactement du même code que précédemment, mis à part le fait qu'ici nous n'utilisons plus de variable found, mais nous parcourons notre liste dans sa totalité.</p><pre id="r-520410" data-claire-element-id="520410"><code data-claire-semantic="c">Dlist *dlist_remove_all(Dlist *p_list, int data)
{
    if (p_list != NULL)
    {
        struct node *p_temp = p_list-&gt;p_head;
        while (p_temp != NULL)
        {
            if (p_temp-&gt;data == data)
            {
                struct node *p_del = p_temp;
                p_temp = p_temp-&gt;p_next;
                if (p_del-&gt;p_next == NULL)
                {
                    p_list-&gt;p_tail = p_del-&gt;p_prev;
                    p_list-&gt;p_tail-&gt;p_next = NULL;
                }
                else if (p_del-&gt;p_prev == NULL)
                {
                    p_list-&gt;p_head = p_del-&gt;p_next;
                    p_list-&gt;p_head-&gt;p_prev = NULL;
                }
                else
                {
                    p_del-&gt;p_next-&gt;p_prev = p_del-&gt;p_prev;
                    p_del-&gt;p_prev-&gt;p_next = p_del-&gt;p_next;
                }
                free(p_del);
                p_list-&gt;length--;
            }
            else
            {
                p_temp = p_temp-&gt;p_next;
            }
        }
    }
    return p_list;
}</code></pre><h3 id="r-supprimer-un-element-selon-sa-position" data-claire-element-id="520416">Supprimer un élément selon sa position</h3><p id="r-520412" data-claire-element-id="520412">Passons maintenant à la dernière fonction de suppression. Nous allons créer une fonction permettant de supprimer le n-ème élément d'une liste doublement chaînée. Comment procéder ? Et bien il s'agit exactement du même procédé utilisé précédemment, mis à part le fait que nous aurons besoin d'une variable supplémentaire nous permettant de stoquer la position à laquelle nous nous trouvons. Et comme par hasard, nous allons nommer cette variable i :D . Au vu de ce que nous avons réalisé précédemment, vous devriez parvenir à écrire ce bout de code par vous même. Essayez et persévérez ;) .</p><p id="r-520413" data-claire-element-id="520413">Voici la dite fonction:</p><pre id="r-520414" data-claire-element-id="520414"><code data-claire-semantic="c">Dlist *dlist_remove_id(Dlist *p_list, int position)
{
    if (p_list != NULL)
    {
        struct node *p_temp = p_list-&gt;p_head;
        int i = 1;
        while (p_temp != NULL &amp;&amp; i &lt;= position)
        {
            if (position == i)
            {
                if (p_temp-&gt;p_next == NULL)
                {
                    p_list-&gt;p_tail = p_temp-&gt;p_prev;
                    p_list-&gt;p_tail-&gt;p_next = NULL;
                }
                else if (p_temp-&gt;p_prev == NULL)
                {
                    p_list-&gt;p_head = p_temp-&gt;p_next;
                    p_list-&gt;p_head-&gt;p_prev = NULL;
                }
                else
                {
                    p_temp-&gt;p_next-&gt;p_prev = p_temp-&gt;p_prev;
                    p_temp-&gt;p_prev-&gt;p_next = p_temp-&gt;p_next;
                }
                free(p_temp);
                p_list-&gt;length--;
            }
            else
            {
                p_temp = p_temp-&gt;p_next;
            }
            i++;
        }
    }
    return p_list;
}</code></pre><p id="r-520415" data-claire-element-id="520415">Comme vous le voyez, tant que nous n'avons pas atteint la fin de liste, et tant que nous ne sommes pas à la bonne position, nous bouclons et nous incrémentons notre variable i. Lorsque nous avons trouvé la bonne place (position == i), nous supprimons alors notre élément courant en suivant exactement la même méthode que précédemment.</p><h2 id="r-avoir-la-taille-d-une-liste-chainee" data-claire-element-id="520426">Avoir la taille d'une liste chaînée</h2><p id="r-520418" data-claire-element-id="520418">Voyons maintenant comment obtenir la taille de notre liste chaînée. Rien de plus facile, allez-vous me dire, nous disposons déjà d'un champ length dans notre structure, nous allons donc l'utiliser. La réponse est évidente, néanmoins, il faudra au préalable vérifier si notre liste n'est pas nulle. En effet, si tel est le cas et que nous essayons d'accéder au champ length, alors nous aboutirons à une belle erreur de Segmentation. Prenez donc garde à vérifier la validité de la liste.</p><p id="r-520419" data-claire-element-id="520419">Voici la fonction</p><pre id="r-520420" data-claire-element-id="520420"><code data-claire-semantic="c">size_t dlist_length(Dlist *p_list)
{
    size_t ret = 0;
    if (p_list != NULL)
    {
        ret = p_list-&gt;length;
    }
    return ret;
}</code></pre><p id="r-520421" data-claire-element-id="520421">Je ne pense pas que ce code nécessite une explication supplémentaire, vous devriez aisément le comprendre ;) (nous utilisons juste une variable ret de type size_t pour retourner le résultat. Par défaut, nous renvoyons 0 si la liste n'existe pas).</p><aside id="r-520425" data-claire-element-id="520425" data-claire-semantic="information"><p id="r-520422" data-claire-element-id="520422">Maintenant que nous bénéficions d'une fonction permettant d'effacer un élément selon sa position ainsi que d'une fonction permettant de retourner la taille de notre liste, nous pouvons aisément construire deux autres fonctions dont le rôle sera de supprimer le premier ainsi que le dernier élément de la liste. Pour cela, j'ai choisi d'employer les macros:</p><pre id="r-520423" data-claire-element-id="520423"><code data-claire-semantic="c">#define dlist_remove_first(list) dlist_remove_id(list, 1)
#define dlist_remove_last(list) dlist_remove_id(list, dlist_length(list))</code></pre><p id="r-520424" data-claire-element-id="520424">Ainsi, l'appel à dlist_remove_first et dlist_remove_last sera en fait remplacé directement dans le code par un appel à dlist_remove_id. Pratique, n'est-ce pas :p ?</p></aside><h2 id="r-rechercher-un-element" data-claire-element-id="520438">Rechercher un élément</h2><h3 id="r-recherche-un-element-selon-sa-valeur" data-claire-element-id="520430">Recherche un élément selon sa valeur</h3><p id="r-520427" data-claire-element-id="520427">Pour compléter notre petite bibliothèque, il se peut que nous ayons besoin d'une fonction de recherche. Cette fonction de recherche sera un tout petit peu particulière. En effet, celle-ci ne renverra pas l'élément qu'elle aura trouvé mais une liste contenant l'élément qu'elle aura trouvé. Ceci facilitera de ce fait notre gestion. Comment faire ? Vous vous souvenez de la fonction de suppression ? Et bien nous allons utiliser le même style. Nous allons parcourir notre liste tant que nous n'aurons pas trouvé notre élément (variable found). Si nous trouvons notre élément, nous utilisons alors les fonctions déjà à notre disposition (dlist_new et dlist_append) pour créer notre liste qui sera retourné.</p><pre id="r-520428" data-claire-element-id="520428"><code data-claire-semantic="c">Dlist *dlist_find(Dlist *p_list, int data)
{
    Dlist *ret = NULL;
    if (p_list != NULL)
    {
        struct node *p_temp = p_list-&gt;p_head;
        int found = 0;
        while (p_temp != NULL &amp;&amp; !found)
        {
            if (p_temp-&gt;data == data)
            {
                ret = dlist_new();
                ret = dlist_append(ret, data);
                found = 1;
            }
            else
            {
                p_temp = p_temp-&gt;p_next;
            }
        }
    }
    return ret;
}</code></pre><p id="r-520429" data-claire-element-id="520429">Désormais, cette fonction doit vous paraître anodine ;) . Si jamais nous ne trouvons aucun élément correspondant à une valeur donnée, nous retournons alors une liste nulle.</p><h3 id="r-recherche-un-ensemble-d-elements-selon-une-meme-valeur" data-claire-element-id="520437">Recherche un ensemble d'éléments selon une même valeur</h3><p id="r-520431" data-claire-element-id="520431">Pour compléter notre fonction de recherche, nous allons maintenant créer une fonction qui non pas s'arrête au premier élément trouvé, mais qui retourne tous les éléments trouvés. Et devinez quoi ? Et bien oui, il s'agit exactement du même code que précédemment, mais cette fois ci, sans l'utilisation de la variable found. Ainsi, toute la liste est parcourue:</p><pre id="r-520432" data-claire-element-id="520432"><code data-claire-semantic="c">Dlist *dlist_find_all(Dlist *p_list, int data)
{
    Dlist *ret = NULL;
    if (p_list != NULL)
    {
        struct node *p_temp = p_list-&gt;p_head;
        while (p_temp != NULL)
        {
            if (p_temp-&gt;data == data)
            {
                if (ret == NULL)
                {
                    ret = dlist_new();
                }
                ret = dlist_append(ret, data);
            }
            p_temp = p_temp-&gt;p_next;
        }
    }
    return ret;
}</code></pre><p id="r-520433" data-claire-element-id="520433">Bon, je vous l'accorde, il y a quand même une toute petite différence avec l'autre code. En effet, nous ne pouvons pas créer notre liste de retour à chaque fois que nous trouvons un élément. Il faut alors la créer dès lorsque l'on aura trouvé notre élément. Ensuite, nous nous contenterons d'ajouter tous les autres éléments trouvés, d'où l'intêrèt du</p><pre id="r-520434" data-claire-element-id="520434"><code data-claire-semantic="c">if (ret == NULL)</code></pre><p id="r-520435" data-claire-element-id="520435">Voilà, dûr hein :D .</p><p id="r-520436" data-claire-element-id="520436">Et bien voilà, nous en avons maintenant terminé avec nos fonctions de manipulation de listes chaînées. Passons maintenant à un petit exercice pour vérifier vos acquis.</p><h2 id="r-exercice-51" data-claire-element-id="520446">Exercice</h2><p id="r-520439" data-claire-element-id="520439">Le but de cet exercice est de créer une fonction dlist_reverse permettant &quot;d'inverser&quot; une liste chaînée. Tous les éléments doivent alors être inversés un par un (le premier doit se retrouver dernier, le deuxième avant-dernier, ...). De plus, notre structure de liste nous donne une flexibilité incroyable car nous pouvons de choisir de partir soit en début de liste, soit en fin. Mais j'en ai déjà trop dit, à vous de jouer.</p><p id="r-520440" data-claire-element-id="520440">Correction:</p><p id="r-520441" data-claire-element-id="520441"></p><div id="r-520444" data-claire-element-id="520444"><div id="r-520443" data-claire-element-id="520443"><pre id="r-520442" data-claire-element-id="520442"><code data-claire-semantic="c">Dlist *dlist_reverse(Dlist *p_list)
{
    Dlist *ret = NULL;
    if (p_list != NULL)
    {
        struct node *p_temp = p_list-&gt;p_tail;
        ret = dlist_new();
        while (p_temp != NULL)
        {
            ret = dlist_append(ret, p_temp-&gt;data);
            p_temp = p_temp-&gt;p_prev;
        }
    }
    return ret;
}</code></pre></div></div><p id="r-520445" data-claire-element-id="520445">Comme vous le voyez, j'ai choisi de partir en fin de liste puis d'ajouter en début de liste. Mais l'inverse est aussi tout à fait envisageable ;) .</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c">Les listes doublement chainées en langage C</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/premiere-approche-6">
Première approche
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/representation-d-une-liste-en-langage-c">
Représentation d&#039;une liste en langage C
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-1-2">
Manipulation d&#039;une liste doublement chainée (1/2)
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-2-2">
Manipulation d&#039;une liste doublement chainée (2/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/pratiquer-un-maitre-mot">
Pratiquer: un maitre mot
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-1-2">
<span class="arrow"></span>
<span class="next">Manipulation d&#039;une liste doublement chainée (1/2)</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/pratiquer-un-maitre-mot">
<span class="next">Pratiquer: un maitre mot</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Pratiquerunmaitremot"></a><h2>Pratiquer: un maitre mot</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-2-2">
<span class="arrow"></span>
<span class="next">Manipulation d&#039;une liste doublement chainée (2/2)</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-520448" data-claire-element-id="520448">La pratique est tout aussi importante si ce n'est plus que l'aspect théorique d'un concept. La pratique permet alors de s'exercer sur un concept récemment abordé et d'apprendre à résoudre par soi-même un problème grâce à ce nouveau concept.</p><p id="r-520449" data-claire-element-id="520449">C'est pourquoi j'ai choisi de créer un second tutoriel sur le sujet qui vous présentera un aspect pratique des listes chaînées. Ce tutoriel est basé sur un petit TP fabriqué de toute pièce par moi-même. Vous serez alors guidés vers une résolution d'un problème donné. Si vous ne parvenez pas à le résoudre, une correction avec des explications vous sera présentée.</p><p id="r-520450" data-claire-element-id="520450">Ce tutoriel est accessible à <a href="http://www.siteduzero.com/tutoriel-3-66266-1-les-listes-doublement-chainees-de-la-theorie-a-la-pratique.html">cette adresse</a>.</p><p id="r-520451" data-claire-element-id="520451">Bon courage.</p><p id="r-520452" data-claire-element-id="520452">Et bien voilà, ce tutoriel est désormais terminé. Comme vous avez pu le constater, les listes chainées sont parfois très utiles, notamment lorsque l'on travaille sur des données dont nous ne connaissons le nombre à l'avance. Si cela vous intéresse, vous pouvez alors regarder la <a href="http://library.gnome.org/devel/glib/stable/glib-Doubly-Linked-Lists.html">documentation</a> dédiée aux listes doublement chainées implémentées par la Glib, une bibliothèque Gnome ;) .</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c">Les listes doublement chainées en langage C</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/premiere-approche-6">
Première approche
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/representation-d-une-liste-en-langage-c">
Représentation d&#039;une liste en langage C
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-1-2">
Manipulation d&#039;une liste doublement chainée (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-2-2">
Manipulation d&#039;une liste doublement chainée (2/2)
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/pratiquer-un-maitre-mot">
Pratiquer: un maitre mot
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-doublement-chainees-en-langage-c/manipulation-d-une-liste-doublement-chainee-2-2">
<span class="arrow"></span>
<span class="next">Manipulation d&#039;une liste doublement chainée (2/2)</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/les-listes-doublement-chainees-en-langage-c.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 06:36:04 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-listes-doublement-chainees-en-langage-c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:10:23 GMT -->
</html>
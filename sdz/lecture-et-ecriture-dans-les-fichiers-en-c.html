<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/lecture-et-ecriture-dans-les-fichiers-en-c.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 00:00:52 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/lecture-et-ecriture-dans-les-fichiers-en-c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:15:24 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Lecture et écriture dans les fichiers en C++</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Lecture et écriture dans les fichiers en C++</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#LectureetcrituredanslesfichiersenC">Lecture et écriture dans les fichiers en C++</a><br/><a href="#Ouvertureetfermetured039unfichier">Ouverture et fermeture d&#039;un fichier</a><br/><a href="#Lireetcriredansunfichiertexte">Lire et écrire dans un fichier texte</a><br/><a href="#Placementdanslefichier">Placement dans le fichier</a><br/><a href="#Quelquesfonctionsbienutiles">Quelques fonctions bien utiles</a><br/></div>
<a name="LectureetcrituredanslesfichiersenC"></a><h2>Lecture et écriture dans les fichiers en C++</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/ouverture-et-fermeture-d-un-fichier">
<span class="next">Ouverture et fermeture d&#039;un fichier</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-461289" data-claire-element-id="461289">Bonjour à tous !</p><p id="r-461290" data-claire-element-id="461290">En naviguant sur divers sites, je me suis rendu compte que dans beaucoup de tutoriels et de cours censés être sur le C++, quand le chapitre sur les fichiers arrivait, la méthode donnée était en C et non en C++.<br/> De plus, leurs auteurs n'indiquent même pas que c'est du C !!</p><p id="r-461291" data-claire-element-id="461291">Ce n'est quand même pas si compliqué que cela, et je vais vous le prouver ! ;)</p><p id="r-461292" data-claire-element-id="461292">Dans ce tutoriel, je vais vous montrer comment agir sur deux types de fichiers en C++. Dans son big-tuto, M@teo21 le montre en C mais pas (encore) en C++. :D</p><p id="r-461293" data-claire-element-id="461293">En fait, c'est la traduction en C++ du chapitre 7 de la partie 2 du tuto de M@teo21, mais j'ai quand même rajouté des choses ^^ .</p><aside id="r-461295" data-claire-element-id="461295" data-claire-semantic="warning"><p id="r-461294" data-claire-element-id="461294">Évidemment, il faut avoir les bases en C/C++. Le tuto de M@teo21 doit donc être lu ! Il est disponible <a href="http://www.siteduzero.com/tuto-3-8-0-apprenez-a-programmer-en-c-c.html">ici</a>.</p></aside>
</div><a name="Ouvertureetfermetured039unfichier"></a><h2>Ouverture et fermeture d&#039;un fichier</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/lire-et-ecrire-dans-un-fichier-texte">
<span class="next">Lire et écrire dans un fichier texte</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-461296" data-claire-element-id="461296">Afin d'ouvrir des fichiers, que ce soit en lecture ou en écriture, il faut utiliser la classe ifstream (<strong>I</strong>nput <strong>F</strong>ile <strong>stream</strong> ;) ) pour la lecture et ofstream (<strong>O</strong>utput <strong>F</strong>ile <strong>stream</strong>) pour l'écriture. Ces deux classes sont des dérivées de std::ios_base qui, comme son nom l'indique, est la classe de base pour les flux.</p><p id="r-461297" data-claire-element-id="461297">Pour pouvoir les utiliser, il faut inclure l'entête fstream.</p><p id="r-461298" data-claire-element-id="461298">Le début du code est donc :</p><pre id="r-461299" data-claire-element-id="461299"><code data-claire-semantic="cpp">#include &lt;fstream&gt;
 
using namespace std;</code></pre><h2 id="r-ouverture-en-lecture-ifstream" data-claire-element-id="461334">Ouverture en lecture : ifstream</h2><p id="r-461300" data-claire-element-id="461300">Maintenant, il faut ouvrir le fichier.<br/> Pour ce faire, il faut un flux agissant sur le fichier.</p><aside id="r-461302" data-claire-element-id="461302" data-claire-semantic="warning"><p id="r-461301" data-claire-element-id="461301">Pour chaque fichier, il faut un flux différent !</p></aside><p id="r-461303" data-claire-element-id="461303">Pour créer un flux, il nous faut un constructeur d'initialisation. Pour la lecture, il est de la forme ifstream flux;. Une fois le flux créé, il faut ouvrir le fichier.</p><p id="r-461304" data-claire-element-id="461304">Pour l'ouvrir, on a deux possibilités :</p><ul id="r-461309" data-claire-element-id="461309"><li id="r-461306" data-claire-element-id="461306"><p id="r-461305" data-claire-element-id="461305">on utilise la fonction membre open qui prend deux paramètres : le premier est le nom du fichier à ouvrir, et le deuxième est le mode d'ouverture. Ça ressemble donc à flux.open(&quot;fichier.extension&quot;, mode_Ouverture); ;</p></li><li id="r-461308" data-claire-element-id="461308"><p id="r-461307" data-claire-element-id="461307">on ne passe pas par la fonction membre open, on indique directement le fichier et le mode d'ouverture en même temps que la déclaration du constructeur d'initialisation. Ça ressemble donc à ifstream flux(&quot;fichier.extension&quot;, mode_Ouverture);.</p></li></ul><aside id="r-461311" data-claire-element-id="461311" data-claire-semantic="information"><p id="r-461310" data-claire-element-id="461310">Dans la suite du tuto, je n'utiliserai <strong>pas</strong> la fonction open.</p></aside><p id="r-461312" data-claire-element-id="461312">Pour indiquer l'emplacement du fichier, on a plusieurs solutions :</p><ul id="r-461319" data-claire-element-id="461319"><li id="r-461314" data-claire-element-id="461314"><p id="r-461313" data-claire-element-id="461313">le chemin absolu (= chemin complet, qui part de la racine du disque) qui est de la forme : <br/> &quot;C:/Documents and Settings/login/Bureau/fichier.txt&quot; ;</p></li><li id="r-461316" data-claire-element-id="461316"><p id="r-461315" data-claire-element-id="461315">le chemin relatif (à partir de là où se trouve l'exécutable). Par exemple, <br/> &quot;sousDossier/fichier.txt&quot; si le fichier se trouve dans un sous-dossier du dossier de l'exécutable ;</p></li><li id="r-461318" data-claire-element-id="461318"><p id="r-461317" data-claire-element-id="461317">si le fichier est dans le même répertoire que l'exécutable, il y a juste à indiquer le nom du fichier.</p></li></ul><div id="r-461321" data-claire-element-id="461321" data-claire-semantic="question"><p id="r-461320" data-claire-element-id="461320">Moi, je suis sous Linux, je fais comment ?</p></div><p id="r-461322" data-claire-element-id="461322">Sous Linux, c'est : &quot;/home/login/fichier.txt&quot; qui est le chemin absolu. Le fonctionnement du chemin relatif est le même que pour Windows.</p><p id="r-461323" data-claire-element-id="461323">Les modes d'ouverture proviennent tous de la classe ios_base, ce qui explique que l'on fasse précéder leur nom du préfixe ios_base:: ou ios:: tout court. Comme on veut ouvrir en lecture, c'est ios::in (pour <em>input</em>).</p><p id="r-461324" data-claire-element-id="461324">Une fois le fichier ouvert, il faut vérifier que l'ouverture a bien fonctionné. Pour cela, il suffit de faire if(flux).</p><p id="r-461325" data-claire-element-id="461325">Une fois les opérations sur le fichier effectuées, il faut le fermer avec la fonction membre close() comme ceci : flux.close();.</p><p id="r-461326" data-claire-element-id="461326">Voici le code pour ouvrir et fermer le fichier <em>test.txt</em> qui se trouve dans le même répertoire que mon programme :</p><pre id="r-461327" data-claire-element-id="461327"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
 
using namespace std;
 
int main()
{
        ifstream fichier(&quot;test.txt&quot;, ios::in);  // on ouvre le fichier en lecture
 
        if(fichier)  // si l'ouverture a réussi
        {       
            // instructions
                fichier.close();  // on ferme le fichier
        }
        else  // sinon
                cerr &lt;&lt; &quot;Impossible d'ouvrir le fichier !&quot; &lt;&lt; endl;
 
        return 0;
}</code></pre><aside id="r-461333" data-claire-element-id="461333" data-claire-semantic="information"><ul id="r-461332" data-claire-element-id="461332"><li id="r-461329" data-claire-element-id="461329"><p id="r-461328" data-claire-element-id="461328">Quand on ouvre un fichier en lecture, le mode d'ouverture ios::in est facultatif. En effet, il est par défaut.</p></li><li id="r-461331" data-claire-element-id="461331"><p id="r-461330" data-claire-element-id="461330">cerr est la sortie standard des erreurs. On peut aussi utiliser cout sans aucun problème.</p></li></ul></aside><h2 id="r-ouverture-en-ecriture-ofstream" data-claire-element-id="461353">Ouverture en écriture : ofstream</h2><p id="r-461335" data-claire-element-id="461335">Pour ouvrir le fichier en écriture, il faut également un flux agissant le fichier. Pour l'ouverture, on peut utiliser soit la fonction open soit par la déclaration directe, qui, comme vous le savez, prennent deux paramètres : le nom du fichier ainsi que le mode d'ouverture.</p><p id="r-461336" data-claire-element-id="461336">Pour l'écriture, il y a différents modes d'ouverture, et si on ne fait pas attention, on peut perdre tout ce qu'il y a dans le fichier si celui-ci n'est pas vide.</p><p id="r-461337" data-claire-element-id="461337">Les modes d'ouverture sont :</p><ul id="r-461346" data-claire-element-id="461346"><li id="r-461339" data-claire-element-id="461339"><p id="r-461338" data-claire-element-id="461338">ios::out (pour <em>output</em>) : spécifie qu'on ouvre le fichier en écriture. Obligatoire - mais par défaut - quand on utilise un objet ofstream ;</p></li><li id="r-461341" data-claire-element-id="461341"><p id="r-461340" data-claire-element-id="461340">ios::app (pour <em>append</em> = ajouter à la suite) : lorsqu'on ouvre le fichier en écriture, on se trouve à la fin pour écrire des données à la suite du fichier (sans effacer le contenu, s'il y en a un). Avec ce mode d'ouverture, à chaque écriture, on est placé à la fin du fichier, même si on se déplace dans celui-ci avant (on verra comment se déplacer un peu plus tard ;) );</p></li><li id="r-461343" data-claire-element-id="461343"><p id="r-461342" data-claire-element-id="461342">ios::trunc (pour <em>truncate</em> = tronquer) : lorsqu'on ouvre le fichier en écriture, spécifie qu'il doit être effacé s'il existe déjà, pour laisser un fichier vide ;</p></li><li id="r-461345" data-claire-element-id="461345"><p id="r-461344" data-claire-element-id="461344">ios::ate (pour <em>at end</em>) : ouvre le fichier en écriture et positionne le curseur à la fin de celui-ci. La différence avec ios::app est que si on se repositionne dans le fichier, l'écriture ne se fera pas forcément à la fin du fichier, contrairement à ios::app.</p></li></ul><p id="r-461347" data-claire-element-id="461347">Pour ces modes d'ouverture, si le fichier n'existe pas ou s'il n'est pas trouvé, il sera créé.</p><aside id="r-461349" data-claire-element-id="461349" data-claire-semantic="warning"><p id="r-461348" data-claire-element-id="461348">Il faut toujours indiquer un des trois modificateurs ios::trunc ou ios::app ou encore ios::ate, en plus de ios::out, pour spécifier la procédure à suivre au cas où le fichier existerait déjà.</p></aside><p id="r-461350" data-claire-element-id="461350">Pour spécifier plusieurs modes d'ouverture, on utilise l'opérateur &quot;ou&quot; : | (prononcé <em>pipe</em> en anglais). Sur un clavier, c'est la combinaison de touches Alt Gr et 6.</p><p id="r-461351" data-claire-element-id="461351">Voici le code qui ouvre en écriture le fichier <em>test.txt</em>, qui efface le contenu du fichier s'il n'est pas vide et qui le referme :</p><pre id="r-461352" data-claire-element-id="461352"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
 
using namespace std;
 
int main()
{
        ofstream fichier(&quot;test.txt&quot;, ios::out | ios::trunc);  //déclaration du flux et ouverture du fichier
        
        if(fichier)  // si l'ouverture a réussi
        {
            // instructions
                fichier.close();  // on referme le fichier
        }
        else  // sinon
                cerr &lt;&lt; &quot;Erreur à l'ouverture !&quot; &lt;&lt; endl;
 
        return 0;
}</code></pre><h2 id="r-ouverture-en-lecture-et-en-ecriture-fstream" data-claire-element-id="461374">Ouverture en lecture ET en écriture : fstream</h2><p id="r-461354" data-claire-element-id="461354">En utilisant fstream, on ouvre en lecture et en écriture un fichier. Le fonctionnement est le même que pour ifstream ou ofstream.</p><p id="r-461355" data-claire-element-id="461355">Le prototype pour utiliser cette méthode d'ouverture est : <br/>fstream flux(&quot;fichier.extention&quot;, ios::in | ios::out | [ios::trunc | ios::ate]);.</p><div id="r-461357" data-claire-element-id="461357" data-claire-semantic="question"><p id="r-461356" data-claire-element-id="461356">Pourquoi les crochets ?</p></div><p id="r-461358" data-claire-element-id="461358">C'est pour indiquer qu'il faut utiliser un des deux, en fonction de ce qu'on veut faire.</p><aside id="r-461366" data-claire-element-id="461366" data-claire-semantic="warning"><ul id="r-461365" data-claire-element-id="461365"><li id="r-461360" data-claire-element-id="461360"><p id="r-461359" data-claire-element-id="461359">C'est l'unique moyen pour ouvrir le fichier en lecture-écriture !</p></li><li id="r-461362" data-claire-element-id="461362"><p id="r-461361" data-claire-element-id="461361">Il ne faut pas mettre les crochets une fois la méthode d'ouverture choisie (ios::app, ios::trunc ou ios::ate) !</p></li><li id="r-461364" data-claire-element-id="461364"><p id="r-461363" data-claire-element-id="461363">Vous avez avez peut-être remarqué qu'il n'y a pas la possibilité de mettre ios::app. En effet, il ne peut être utilisé que si on fait des écritures ; or, l'ouverture avec fstream permet la lecture ET l'écriture.</p></li></ul></aside><p id="r-461367" data-claire-element-id="461367">Avec ce mode d'ouverture, le fichier <strong>DOIT</strong> exister ! Le ios::in | ios::out est obligatoire pour bien spécifier que l'on ouvre le fichier en lecture ET en écriture. Comme le fichier est ouvert en écriture et qu'il existe déjà, il faut rajouter soit ios::ate pour ne pas effacer le contenu, soit ios::trunc pour l'effacer.</p><aside id="r-461369" data-claire-element-id="461369" data-claire-semantic="information"><p id="r-461368" data-claire-element-id="461368">Et maintenant, une chose bien utile !</p></aside><p id="r-461370" data-claire-element-id="461370">Si vous avez votre nom de fichier stocké dans une chaîne de caractères, et vous voulez que fichier.extension prenne cette valeur, comment faites-vous ?<br/> Si vous essayez de mettre à la place du nom de fichier le nom de votre chaîne, ça ne marche pas !<br/> Pour le faire fonctionner, il faut rajouter .c_str() après le nom de la chaîne. Ce c_str() est une fonction membre de la librairie string qui va renvoyer un pointeur vers un tableau de caractères (comme en langage C ;) ).<br/> Voici un exemple :</p><pre id="r-461371" data-claire-element-id="461371"><code data-claire-semantic="cpp">#include &lt;fstream&gt;
#include &lt;string&gt;
using namespace std;
 
int main()
{
     string mon_fichier = &quot;test.txt&quot;;  // je stocke dans la chaîne mon_fichier le nom du fichier à ouvrir
     ifstream fichier(mon_fichier.c_str(), ios::in);
     if(fichier)  // si l'ouverture a réussi
     {
          // instructions
            fichier.close();  // je referme le fichier
     }
     else  // sinon
            cerr &lt;&lt; &quot;Erreur à l'ouverture !&quot; &lt;&lt; endl;
 
     return 0;
}</code></pre><p id="r-461372" data-claire-element-id="461372">Ce code ouvre en lecture le fichier <em>test.txt</em>.</p><p id="r-461373" data-claire-element-id="461373">Voilà, vous savez ouvrir un fichier texte avec différents modes, tester l'ouverture et fermer le fichier.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c">Lecture et écriture dans les fichiers en C++</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/ouverture-et-fermeture-d-un-fichier">
Ouverture et fermeture d&#039;un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/lire-et-ecrire-dans-un-fichier-texte">
Lire et écrire dans un fichier texte
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/placement-dans-le-fichier">
Placement dans le fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/quelques-fonctions-bien-utiles">
Quelques fonctions bien utiles
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/lire-et-ecrire-dans-un-fichier-texte">
<span class="next">Lire et écrire dans un fichier texte</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lireetcriredansunfichiertexte"></a><h2>Lire et écrire dans un fichier texte</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/ouverture-et-fermeture-d-un-fichier">
<span class="arrow"></span>
<span class="next">Ouverture et fermeture d&#039;un fichier</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/placement-dans-le-fichier">
<span class="next">Placement dans le fichier</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-lire-le-contenu-d-un-fichier" data-claire-element-id="461421">Lire le contenu d'un fichier</h2><p id="r-461376" data-claire-element-id="461376">Alors, pour lire un fichier, il y a différentes méthodes qu'il faut employer en fonction de ce que l'on veut faire.<br/> Les voilà :</p><ul id="r-461383" data-claire-element-id="461383"><li id="r-461378" data-claire-element-id="461378"><p id="r-461377" data-claire-element-id="461377">getline(flux, chaineDeCaractères) : pour lire une ligne complète ;</p></li><li id="r-461380" data-claire-element-id="461380"><p id="r-461379" data-claire-element-id="461379">flux.get(caractère) : pour lire un caractère ;</p></li><li id="r-461382" data-claire-element-id="461382"><p id="r-461381" data-claire-element-id="461381">flux &gt;&gt; variable : pour récupérer à partir du fichier jusqu'à un délimiteur (espace, saut à la ligne, ...).</p></li></ul><aside id="r-461385" data-claire-element-id="461385" data-claire-semantic="warning"><p id="r-461384" data-claire-element-id="461384">Il faut ouvrir le fichier en lecture ou en lecture-écriture, mais pas en écriture seule avec ofstream !</p></aside><h3 id="r-commencons-par-getline" data-claire-element-id="461395">Commençons par getline</h3><p id="r-461386" data-claire-element-id="461386">Avec cette fonction, on peut lire et afficher à l'écran une ligne du fichier ou bien le fichier en entier en utilisant une boucle.</p><p id="r-461387" data-claire-element-id="461387">Cette fonction prend deux paramètres : le flux que l'on crée avec ifstream ou <em>fstream</em>. Le deuxième paramètre est la &quot;cible&quot; dans laquelle vous allez stocker le contenu lu dans le fichier. En général, c'est une chaîne de caractères (string ;) ). Il faut donc inclure l'entête #include &lt;string&gt;.</p><p id="r-461388" data-claire-element-id="461388">Voici le code qui ouvre le fichier <em>test.txt</em> en lecture, affiche la première ligne et referme le fichier :</p><pre id="r-461389" data-claire-element-id="461389"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
 
using namespace std;
 
int main()
{
        ifstream fichier(&quot;test.txt&quot;, ios::in);  // on ouvre en lecture
 
        if(fichier)  // si l'ouverture a fonctionné
        {
                string contenu;  // déclaration d'une chaîne qui contiendra la ligne lue
                getline(fichier, contenu);  // on met dans &quot;contenu&quot; la ligne
                cout &lt;&lt; contenu;  // on affiche la ligne
 
                fichier.close();
        }
        else
                cerr &lt;&lt; &quot;Impossible d'ouvrir le fichier !&quot; &lt;&lt; endl;
 
        return 0;
}</code></pre><p id="r-461390" data-claire-element-id="461390">Pour lire et afficher le fichier en entier, il faut le lire ligne par ligne et afficher à chaque fois la ligne lue.<br/> On utilisera donc une boucle dont le contenu se répètera tant qu'il y a une ligne à lire. S'il n'y a plus de ligne, on sort de la boucle.</p><p id="r-461391" data-claire-element-id="461391">Dans le code précédent, il faut changer ce qu'il y a dans le if comme ceci :</p><pre id="r-461392" data-claire-element-id="461392"><code data-claire-semantic="cpp">if(fichier)
{
        string ligne;
        while(getline(fichier, ligne))  // tant que l'on peut mettre la ligne dans &quot;contenu&quot;
        {
                cout &lt;&lt; ligne &lt;&lt; endl;  // on l'affiche
        }
}</code></pre><p id="r-461393" data-claire-element-id="461393">Il existe encore une surcharge de cette fonction qui prend en troisième paramètre un caractère de fin. getline va alors lire le fichier jusqu'à trouver ce caractère de fin. Par défaut, ce caractère est égal au retour à la ligne (' '), c'est pour cela qu'on peut lire ligne par ligne sans spécifier ce troisième paramètre. Celui-ci est facultatif.</p><p id="r-461394" data-claire-element-id="461394">Bien, on en a fini avec getline.</p><h3 id="r-continuons-avec-get" data-claire-element-id="461407">Continuons avec get</h3><aside id="r-461397" data-claire-element-id="461397" data-claire-semantic="warning"><p id="r-461396" data-claire-element-id="461396">Tout comme getline, cette fonction ne marche que si on a utilisé ifstream ou fstream comme flux. Ça ne fonctionne pas avec ofstream.</p></aside><p id="r-461398" data-claire-element-id="461398">Cette fonction est utilisée pour lire un caractère, et un seul. Bien sûr, il est également possible d'afficher le texte en entier en utilisant une boucle.</p><aside id="r-461400" data-claire-element-id="461400" data-claire-semantic="warning"><p id="r-461399" data-claire-element-id="461399">En informatique, les espaces, retours à la ligne, retours chariot, ... sont considérés comme des caractères !</p></aside><p id="r-461401" data-claire-element-id="461401">La syntaxe de cette fonction est : flux.get(caractère);. Ceci lit un caractère du fichier et le stocke dans caractere qui est de type char.</p><p id="r-461402" data-claire-element-id="461402">Le code suivant ouvre un fichier en lecture, lit un caractère, l'affiche, et referme le fichier :</p><pre id="r-461403" data-claire-element-id="461403"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
 
using namespace std;
 
int main()
{
        ifstream fichier(&quot;test.txt&quot;, ios::in);  // on ouvre
        
        if(fichier)
        {
                char caractere;  // notre variable où sera stocké le caractère
                fichier.get(caractere);  // on lit un caractère et on le stocke dans caractere
                cout &lt;&lt; caractere;  // on l'affiche
 
                fichier.close();
        }
        else
                cerr &lt;&lt; &quot;Impossible d'ouvrir le fichier !&quot; &lt;&lt; endl;
 
        return 0;
}</code></pre><aside id="r-461405" data-claire-element-id="461405" data-claire-semantic="information"><p id="r-461404" data-claire-element-id="461404">Pour lire le fichier en entier avec cette méthode, la boucle est la même que celle pour getline.</p></aside><p id="r-461406" data-claire-element-id="461406">On en a fini avec get.</p><h3 id="r-terminons-avec" data-claire-element-id="461420">Terminons avec &gt;&gt;</h3><p id="r-461408" data-claire-element-id="461408">Ce symbole ne devrait pas vous être inconnu : il est aussi utilisé pour cin. Le fonctionnement avec les fichiers est exactement le même. Cet opérateur lit dans le fichier jusqu'à ce qu'il trouve un délimiteur qui peut être un espace ou un retour à la ligne.</p><p id="r-461409" data-claire-element-id="461409">Après avoir lu le premier élément, si on réutilise cet opérateur, c'est l'élément suivant qui est lu jusqu'au prochain délimiteur.</p><p id="r-461410" data-claire-element-id="461410">Exemple : dans mon fichier <em>test.txt</em> il y a :</p><figure id="r-461412" data-claire-element-id="461413"><img id="r-461411" data-claire-element-id="461411" src="medias/uploads.siteduzero.com_files_85001_86000_85076.png" alt="Image utilisateur"/></figure><p id="r-461414" data-claire-element-id="461414">Comme vous le voyez, il y a deux entiers et deux chaînes de caractères. Si je veux récupérer chaque élément, il faut que je déclare deux int et deux string.</p><p id="r-461415" data-claire-element-id="461415">Voici le code qui stocke les différents éléments du fichier dans quatre variables différentes :</p><pre id="r-461416" data-claire-element-id="461416"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
 
using namespace std;
 
int main()
{
        ifstream fichier(&quot;test.txt&quot;, ios::in);
 
        if(fichier)
        {
                int entier1, entier2;
                string chaine1, chaine2;
 
                fichier &gt;&gt; entier1 &gt;&gt; entier2 &gt;&gt; chaine1 &gt;&gt; chaine2;  /*on lit jusqu'à l'espace et on stocke ce qui est lu dans la variable indiquée */
 
                fichier.close();
        }
        else
                cerr &lt;&lt; &quot;Impossible d'ouvrir le fichier !&quot; &lt;&lt; endl;
 
        return 0;
}</code></pre><p id="r-461417" data-claire-element-id="461417">Maintenant, entier1 vaut 12, entier2 vaut 345, chaine1 contient test et chaine2 contient SDZ.</p><p id="r-461418" data-claire-element-id="461418">Et on en a fini avec &gt;&gt; !</p><p id="r-461419" data-claire-element-id="461419">Bien, maintenant vous savez lire dans un fichier ! :D <br/> Alors passons à l'écriture !</p><h2 id="r-ecrire-dans-un-fichier-2" data-claire-element-id="461443">Écrire dans un fichier</h2><p id="r-461422" data-claire-element-id="461422">Pour l'écriture, nous allons voir deux méthodes, mais la première est largement plus utilisée :</p><ul id="r-461427" data-claire-element-id="461427"><li id="r-461424" data-claire-element-id="461424"><p id="r-461423" data-claire-element-id="461423">flux &lt;&lt;<em>élémentQuelconque</em> : écrit dans le fichier un élément quelconque (string, int, ...) ;</p></li><li id="r-461426" data-claire-element-id="461426"><p id="r-461425" data-claire-element-id="461425">flux.put(<em>caractère</em>) : écrit un seul caractère dans le fichier.</p></li></ul><h3 id="r-tout-d-abord" data-claire-element-id="461437">Tout d'abord &lt;&lt;</h3><p id="r-461428" data-claire-element-id="461428">Ce symbole non plus ne devrait pas vous être inconnu : il est utilisé pour cout. Son fonctionnement pour les fichiers est exactement le même que pour l'affichage sur la sortie standard (l'écran ;) ). Cet opérateur permet d'écrire dans le fichier soit un caractère, soit une chaîne de caractères, soit des entiers, ...</p><p id="r-461429" data-claire-element-id="461429">Pour utiliser cet opérateur, la syntaxe est la suivante : flux &lt;&lt; élément1 &lt;&lt; élément2 &lt;&lt; ...<br/> Comme vous le voyez, ce n'est pas très différent de cout ! :D</p><p id="r-461430" data-claire-element-id="461430">Voici un exemple de code qui écrit des données dans le fichier test.txt qui est effacé s'il n'est pas vide :</p><pre id="r-461431" data-claire-element-id="461431"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
 
using namespace std;
 
int main()
{
        ofstream fichier(&quot;test.txt&quot;, ios::out | ios::trunc);  // ouverture en écriture avec effacement du fichier ouvert
 
        if(fichier)
        {
                string nom = &quot;Xav57&quot;;
                int age = 19;
                fichier &lt;&lt; &quot;Date de naissance : &quot; &lt;&lt; 24 &lt;&lt; '/' &lt;&lt; 3 &lt;&lt; '/' &lt;&lt; 1988 &lt;&lt; endl;
                fichier &lt;&lt; &quot;Bonjour, &quot; &lt;&lt; nom &lt;&lt; &quot;. Vous avez &quot; &lt;&lt; age &lt;&lt; &quot; ans.&quot;;
 
                fichier.close();
        }
        else
                cerr &lt;&lt; &quot;Impossible d'ouvrir le fichier !&quot; &lt;&lt; endl;
 
        return 0;
}</code></pre><p id="r-461432" data-claire-element-id="461432">Comme vous le voyez, j'ai écrit des chaînes de caractères, des caractères, des entiers, un retour à la ligne, des éléments sans type et ce, sans faire aucune distinction. Je l'ai aussi fait en deux fois.</p><p id="r-461433" data-claire-element-id="461433">Voici le résultat :</p><figure id="r-461435" data-claire-element-id="461436"><img id="r-461434" data-claire-element-id="461434" src="medias/uploads.siteduzero.com_files_85001_86000_85075.png" alt="Image utilisateur"/></figure><h3 id="r-passons-a-put" data-claire-element-id="461442">Passons à put</h3><p id="r-461438" data-claire-element-id="461438">Comme je l'ai déjà dit, put est moins utilisé car &lt;&lt; fait la même chose.<br/> La syntaxe est : flux.put(char). <br/> Cette fonction ne peut écrire qu'un caractère à la fois. C'est l'équivalent de get pour la lecture.</p><p id="r-461439" data-claire-element-id="461439">Voici juste la partie du code qui écrit un caractère :</p><pre id="r-461440" data-claire-element-id="461440"><code data-claire-semantic="cpp">if(fichier)
{
        char car = 'S';
        fichier.put(car);
 
        // équivalent à &quot;fichier.put('S')&quot; ou encore &quot;fichier &lt;&lt; car&quot; ou bien &quot;fichier &lt;&lt; 'S'&quot;
}</code></pre><p id="r-461441" data-claire-element-id="461441">Voilà, vous savez presque tout. Il ne reste plus qu'à voir le placement et le déplacement dans un fichier.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c">Lecture et écriture dans les fichiers en C++</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/ouverture-et-fermeture-d-un-fichier">
Ouverture et fermeture d&#039;un fichier
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/lire-et-ecrire-dans-un-fichier-texte">
Lire et écrire dans un fichier texte
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/placement-dans-le-fichier">
Placement dans le fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/quelques-fonctions-bien-utiles">
Quelques fonctions bien utiles
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/ouverture-et-fermeture-d-un-fichier">
<span class="arrow"></span>
<span class="next">Ouverture et fermeture d&#039;un fichier</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/placement-dans-le-fichier">
<span class="next">Placement dans le fichier</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Placementdanslefichier"></a><h2>Placement dans le fichier</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/lire-et-ecrire-dans-un-fichier-texte">
<span class="arrow"></span>
<span class="next">Lire et écrire dans un fichier texte</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/quelques-fonctions-bien-utiles">
<span class="next">Quelques fonctions bien utiles</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-461445" data-claire-element-id="461445">Tout comme en C, il existe une notion de curseur pour le placement dans le fichier. Maintenant, pour bien pouvoir utiliser ces fonctions, il faut bien connaître le fichier. Comme l'a dit M@teo21 :</p><p id="r-461446" data-claire-element-id="461446"><cite>Citation : M@teo21</cite></p><blockquote id="r-461450" data-claire-element-id="461450"><div id="r-461448" data-claire-element-id="461448" data-claire-semantic="question"><p id="r-461447" data-claire-element-id="461447">Mais comment je sais à quelle position je dois aller lire et écrire dans le fichier ?</p></div><p id="r-461449" data-claire-element-id="461449">Alors ça, c'est vous qui gérez. ;) <br/> Si c'est un fichier que vous avez vous-mêmes écrit, vous savez comment il est construit. Vous savez donc où aller chercher vos informations (par exemple les meilleurs scores sont en position 0, les noms des derniers joueurs sont en position 50, etc.).</p></blockquote><h2 id="r-savoir-ou-on-est" data-claire-element-id="461458">Savoir où on est</h2><p id="r-461451" data-claire-element-id="461451">Pour connaître la position courante, ça dépend de la manière dont il a été ouvert.</p><h3 id="r-s-il-est-ouvert-avec-ifstream" data-claire-element-id="461453">S'il est ouvert avec <strong>ifstream</strong></h3><p id="r-461452" data-claire-element-id="461452">Il y a la méthode tellg().</p><h3 id="r-s-il-est-ouvert-avec-ofstream" data-claire-element-id="461457">S'il est ouvert avec <strong>ofstream</strong></h3><p id="r-461454" data-claire-element-id="461454">La méthode porte presque le même nom, il n'y a qu'une seule lettre qui change. C'est la méthode tellp().</p><p id="r-461455" data-claire-element-id="461455">Ces deux méthodes renvoient la position courante dans le fichier (le numéro de l'octet courant depuis le début du fichier).</p><p id="r-461456" data-claire-element-id="461456">La syntaxe en C++ de tellg ou de tellp est : flux.tell[g | p]().</p><h2 id="r-se-deplacer-3" data-claire-element-id="461476">Se déplacer</h2><p id="r-461459" data-claire-element-id="461459">Pour se placer à une position précise dans le fichier, ça dépend, tout comme pour connaître sa position, du mode d'ouverture.</p><h3 id="r-s-il-est-ouvert-avec-ifstream-1" data-claire-element-id="461469">S'il est ouvert avec <strong>ifstream</strong></h3><p id="r-461460" data-claire-element-id="461460">Il y a la méthode seekg. Elle prend deux arguments : le premier est le numéro de l'octet où se placer, et le second l'endroit du fichier à partir duquel se situe ce numéro. Cette seconde valeur peut être égale à :</p><ul id="r-461467" data-claire-element-id="461467"><li id="r-461462" data-claire-element-id="461462"><p id="r-461461" data-claire-element-id="461461">ios::beg (octet indiqué depuis le début du fichier) ;</p></li><li id="r-461464" data-claire-element-id="461464"><p id="r-461463" data-claire-element-id="461463">ios::cur (octet indiqué depuis la position courante dans le fichier) ;</p></li><li id="r-461466" data-claire-element-id="461466"><p id="r-461465" data-claire-element-id="461465">ios::end (octet indiqué depuis la fin du fichier).</p></li></ul><p id="r-461468" data-claire-element-id="461468">Par défaut, ce second argument est égal à ios::beg.</p><h3 id="r-s-il-est-ouvert-avec-ofstream-1" data-claire-element-id="461475">S'il est ouvert avec <strong>ofstream</strong></h3><p id="r-461470" data-claire-element-id="461470">Ici encore, la méthode porte presque le même nom. Il s'agit de la méthode seekp, et son fonctionnement est identique à celui de seekg.</p><p id="r-461471" data-claire-element-id="461471">En C++, ça donne : <br/>fichier.seek[g | p](10, ios::beg). <br/> Ce code va à l'octet 10 depuis le début du fichier.</p><div id="r-461473" data-claire-element-id="461473" data-claire-semantic="question"><p id="r-461472" data-claire-element-id="461472">Si on est au dixième octet, est-on au dixième caractère ?</p></div><p id="r-461474" data-claire-element-id="461474">Pas forcément. Cela dépend du codage utilisé (ASCII, UTF, ...). De plus, les caractères spéciaux comme le retour à la ligne sont souvent codés sur 2 octets. Mais pas d'inquiétude : dans la prochaine partie, je vous montrerai une astuce pour aller à la n-ième ligne ou au n-ième caractère.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c">Lecture et écriture dans les fichiers en C++</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/ouverture-et-fermeture-d-un-fichier">
Ouverture et fermeture d&#039;un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/lire-et-ecrire-dans-un-fichier-texte">
Lire et écrire dans un fichier texte
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/placement-dans-le-fichier">
Placement dans le fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/quelques-fonctions-bien-utiles">
Quelques fonctions bien utiles
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/lire-et-ecrire-dans-un-fichier-texte">
<span class="arrow"></span>
<span class="next">Lire et écrire dans un fichier texte</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/quelques-fonctions-bien-utiles">
<span class="next">Quelques fonctions bien utiles</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Quelquesfonctionsbienutiles"></a><h2>Quelques fonctions bien utiles</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/placement-dans-le-fichier">
<span class="arrow"></span>
<span class="next">Placement dans le fichier</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-461478" data-claire-element-id="461478">Pour terminer ce tuto, je vais vous présenter quelques fonctions membres de fstream.<br/> Les fonctions que j'ai choisies sont (je trouve) les plus pratiques et les plus utilisées.</p><p id="r-461479" data-claire-element-id="461479">Voici les prototypes de ces fonctions :</p><ul id="r-461488" data-claire-element-id="461488"><li id="r-461481" data-claire-element-id="461481"><p id="r-461480" data-claire-element-id="461480">flux.eof() pour savoir si le &quot;curseur virtuel&quot; (comme dit M@teo21) a atteint la fin du fichier ;</p></li><li id="r-461483" data-claire-element-id="461483"><p id="r-461482" data-claire-element-id="461482">flux.ignore(nbCaractere, caractereDeFin) pour ignorer nbCaractere lu <strong>OU</strong> ignorer tout jusqu'à ce que caractereDeFin est rencontré ;</p></li><li id="r-461485" data-claire-element-id="461485"><p id="r-461484" data-claire-element-id="461484">flux.clear() pour remettre les flags d'état à leur état d'origine ;</p></li><li id="r-461487" data-claire-element-id="461487"><p id="r-461486" data-claire-element-id="461486">flux.fail() pour tester si l'ouverture du flux s'est bien déroulée. Très utile pour vérifier qu'un fichier existe ;) .</p></li></ul><div id="r-461490" data-claire-element-id="461490" data-claire-semantic="question"><p id="r-461489" data-claire-element-id="461489">Un flag ? Jamais entendu...</p></div><p id="r-461491" data-claire-element-id="461491">Un flag (drapeau en français) est un bit qui peut prendre 2 valeurs : 0 ou 1. Pour fstream, il existe 4 flags : goodbit, eofbit, failbit et badbit. Nous ne verrons que eofbit et failbit dans ce tuto.</p><h2 id="r-les-fonctions-membres-1" data-claire-element-id="461516">Les fonctions membres</h2><p id="r-461492" data-claire-element-id="461492">Voyons ces fonctions dans l'ordre.</p><h3 id="r-tout-d-abord-flux-eof" data-claire-element-id="461495">Tout d'abord<strong> flux.eof()</strong></h3><p id="r-461493" data-claire-element-id="461493">Cette fonction renvoie un booléen qui vérifie l'état de eofbit qui vaut true si la fin du fichier a été atteinte et false sinon.</p><p id="r-461494" data-claire-element-id="461494">Ce eofbit peut passer à true soit parce qu'il n'y a plus de données à lire, soit parce qu'on ne peut plus en écrire.</p><h3 id="r-continuons-par-flux-ignore-nbcaractere-caracteredefin" data-claire-element-id="461509">Continuons par<strong> flux.ignore(nbCaractere, caractereDeFin)</strong></h3><p id="r-461496" data-claire-element-id="461496">Cette fonction demande deux paramètres : le nombre de caractères à ignorer et un caractère de fin.<br/> Elle ignore donc les nbCaractere jusqu'à trouver le caractereDeFin.<br/> Cette fonction est souvent utilisée pour compter les lignes dans un fichier.</p><aside id="r-461502" data-claire-element-id="461502" data-claire-semantic="warning"><ul id="r-461501" data-claire-element-id="461501"><li id="r-461498" data-claire-element-id="461498"><p id="r-461497" data-claire-element-id="461497">Pour l'utiliser pour compter les lignes, il faut connaître le nombre de caractères dans une ligne !</p></li><li id="r-461500" data-claire-element-id="461500"><p id="r-461499" data-claire-element-id="461499">Le fichier doit être ouvert en lecture !</p></li></ul></aside><p id="r-461503" data-claire-element-id="461503">Si on ne connait pas le nombre de caractères dans les lignes, il y a une petite astuce. Pour utiliser cette astuce, il faut inclure :</p><pre id="r-461504" data-claire-element-id="461504"><code data-claire-semantic="cpp">#include &lt;limits&gt;
using namespace std;</code></pre><p id="r-461505" data-claire-element-id="461505">Ensuite, à la place du nbCaractere, on met numeric_limits&lt;int&gt;::max().<br/> Cette méthode va renvoyer la valeur maximale que peut prendre un int. Pour la connaître, on peut faire un cout dessus.<br/> Cette façon de faire fonctionne, car je ne pense pas que quelqu'un va mettre autant de caractères sur une seule ligne (sur ma machine, la valeur de numeric_limits&lt;int&gt;::max() est 2147483647).</p><p id="r-461506" data-claire-element-id="461506">La syntaxe de cette fonction devient alors : flux.ignore(numeric_limits&lt;int&gt;::max(), ' ').</p><aside id="r-461508" data-claire-element-id="461508" data-claire-semantic="information"><p id="r-461507" data-claire-element-id="461507">Le caractère ' ' est le retour à la ligne.</p></aside><h3 id="r-voyons-maintenant" data-claire-element-id="461513">Voyons maintenant</h3><p id="r-461510" data-claire-element-id="461510"><strong>flux.clear()</strong></p><p id="r-461511" data-claire-element-id="461511">La fonction membre clear remet à leur état d'origine les 4 flags de fstream.</p><p id="r-461512" data-claire-element-id="461512">C'est très utilisé quand on a atteint la fin du fichier (donc eofbit est passé à true) et si on veut se replacer au début du fichier. Si on n'utilise pas cette fonction, le flag eofbit reste à true, on ne peut donc pas revenir au début.</p><h3 id="r-terminons-avec-flux-fail" data-claire-element-id="461515">Terminons avec<strong> flux.fail()</strong></h3><p id="r-461514" data-claire-element-id="461514">Cette fonction membre réalise le test des bits failbit et badbit. Si le résultat est false, cela veut dire que le flux a bien été créé et ouvert. Cela nous rassure donc quant à l'existence du fichier.</p><h2 id="r-un-dernier-exemple-utilisant-ces-fonctions-membres" data-claire-element-id="461531">Un dernier exemple utilisant ces fonctions membres</h2><p id="r-461517" data-claire-element-id="461517">Dans le dernier exemple du tuto, je vais utiliser les 3 fonctions membres que l'on vient de voir en faisant diverses opérations. Avec cet exemple, vous devriez tout comprendre ! :D</p><p id="r-461518" data-claire-element-id="461518">Voici le contenu du fichier <em>test.txt</em> avec lequel je vais travailler :</p><figure id="r-461520" data-claire-element-id="461521"><img id="r-461519" data-claire-element-id="461519" src="medias/uploads.siteduzero.com_files_85001_86000_85074.png" alt="Image utilisateur"/></figure><pre id="r-461522" data-claire-element-id="461522"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;limits&gt;  // pour utiliser numeric_limits&lt;int&gt;::max()
 
using namespace std;
 
int main()
{
        string toto = &quot;toto.txt&quot;;
        ifstream fichier_toto(toto.c_str(), ios::in);
        
        if(fichier_toto.fail())
                cout &lt;&lt; &quot;Le fichier &quot; &lt;&lt; toto &lt;&lt; &quot; n'existe pas !&quot; &lt;&lt; endl;
 
        ifstream fichier(&quot;test.txt&quot;, ios::in);
 
        if(!fichier.fail())
        {
                cout &lt;&lt; &quot;Le fichier existe bien et est correctement ouvert !&quot; &lt;&lt; endl;
                cout &lt;&lt; &quot;A l'ouverture du fichier, le curseur de trouve a l'octet &quot; &lt;&lt; fichier.tellg() &lt;&lt; &quot;.&quot; &lt;&lt; endl &lt;&lt; endl;
                cout &lt;&lt; &quot;Le fichier contient : &quot; &lt;&lt; endl &lt;&lt; endl;
 
                string ligne;
                while(getline(fichier, ligne))
                        cout &lt;&lt; ligne &lt;&lt; endl;
 
                cout &lt;&lt; endl &lt;&lt; &quot;Une fois tout le fichier lu, le \&quot;eofbit\&quot; est passe a &quot; &lt;&lt; boolalpha &lt;&lt; fichier.eof() &lt;&lt; &quot;.&quot; &lt;&lt; endl;
/* boolalpha sert à afficher en toutes lettres un booléen */
                
                cout &lt;&lt; endl &lt;&lt; &quot;Pour revenir au debut du fichier, on peut tenter un \&quot;fichier.seekg(0, ios::beg\&quot;. Est-ce que ca a fonctionne ?&quot; &lt;&lt; endl;
                
                fichier.seekg(0, ios::beg);
 
                cout &lt;&lt; endl &lt;&lt; &quot;On se trouve au &quot; &lt;&lt; fichier.tellg() &lt;&lt; &quot;ieme octet.&quot; &lt;&lt; endl;
 
                if((int)fichier.tellg() != 0)
                {
                        cout &lt;&lt; &quot;Oh non, ca n'a pas fonctionne ! Je vais tenter de faire un \&quot;fichier.clear()\&quot;.&quot; &lt;&lt; endl;
                        fichier.clear();
                        fichier.seekg(0, ios::beg);
                        cout &lt;&lt; endl &lt;&lt; &quot;On se trouve au &quot; &lt;&lt; fichier.tellg() &lt;&lt; &quot;ieme octet.&quot; &lt;&lt; endl;
                }
 
                int nbLignes = 0;
                while(fichier.ignore(numeric_limits&lt;int&gt;::max(), '\n'))
                        nbLignes++;
 
                cout &lt;&lt; &quot;Le fichier contient &quot; &lt;&lt; nbLignes &lt;&lt; &quot; lignes.&quot; &lt;&lt; endl;
 
                cout &lt;&lt; &quot;Comme on a parcouru a nouveau le fichier, le \&quot;eofbit\&quot; est passe a &quot; &lt;&lt; boolalpha &lt;&lt; fichier.eof() &lt;&lt; &quot;.&quot; &lt;&lt; endl;
 
                fichier.close();        
        }
        else
                cerr &lt;&lt; &quot;Impossible d'ouvrir le fichier !&quot; &lt;&lt; endl;
 
        return 0;
}</code></pre><p id="r-461523" data-claire-element-id="461523">Bien, vous êtes arrivés au terme de ce long tutoriel. BRAVO ! :D</p><p id="r-461524" data-claire-element-id="461524">Si vous voulez manipuler <em>autrement</em> les fichiers mais également les dossiers, je vous conseille de regarder au niveau de la bibliothèque <a href="http://www.boost.org/">Boost</a>, qui est portable, et plus particulièrement <a href="http://www.boost.org/libs/filesystem/doc/index.htm">Boost.FileSystem</a>.</p><p id="r-461525" data-claire-element-id="461525">Mais bon, ce n'était pas si dur que ça. Si vous avez lu la partie sur les fichiers en C dans le tuto de M@teo21, vous pouvez comparer. Personnellement, je trouve que c'est plus simple de le faire en C++, mais là, chacun ses choix !</p><p id="r-461526" data-claire-element-id="461526">Si une chose ne vous semble pas claire, ou si vous voulez voir apparaître une autre fonction membre de fstream qui vous semble importante et utile, contactez-moi !</p><p id="r-461527" data-claire-element-id="461527">Sur ce, je vous dit :</p><p id="r-461528" data-claire-element-id="461528"><cite>Citation : Xavinou</cite></p><blockquote id="r-461530" data-claire-element-id="461530"><p id="r-461529" data-claire-element-id="461529">Au revoir et à bientôt ! :D</p></blockquote>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c">Lecture et écriture dans les fichiers en C++</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/ouverture-et-fermeture-d-un-fichier">
Ouverture et fermeture d&#039;un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/lire-et-ecrire-dans-un-fichier-texte">
Lire et écrire dans un fichier texte
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/placement-dans-le-fichier">
Placement dans le fichier
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/quelques-fonctions-bien-utiles">
Quelques fonctions bien utiles
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/lecture-et-ecriture-dans-les-fichiers-en-c/placement-dans-le-fichier">
<span class="arrow"></span>
<span class="next">Placement dans le fichier</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/lecture-et-ecriture-dans-les-fichiers-en-c.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 00:00:54 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/lecture-et-ecriture-dans-les-fichiers-en-c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:15:25 GMT -->
</html>
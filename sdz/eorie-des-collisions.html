<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/eorie-des-collisions.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Oct 2013 23:49:46 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/eorie-des-collisions.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:12:06 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Théorie des collisions</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/theorie-des-collisions.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Théorie des collisions</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Thoriedescollisions">Théorie des collisions</a><br/><a href="#Formessimples">Formes simples</a><br/><a href="#PointdansAABB">Point dans AABB</a><br/><a href="#CollisionAABB">Collision AABB</a><br/><a href="#Cercles">Cercles</a><br/><a href="#Formespluscomplexes">Formes plus complexes</a><br/><a href="#Pointdanspolygone">Point dans polygone</a><br/><a href="#Segmentcercle">Segment cercle</a><br/><a href="#SegmentSegment">Segment Segment</a><br/><a href="#Cercles-AABB">Cercles-AABB</a><br/><a href="#Collisionsaupixelprs">Collisions au pixel près</a><br/><a href="#Utilisationdemasques">Utilisation de masques</a><br/><a href="#Pixelperfect">Pixel perfect</a><br/><a href="#Dcor">Décor</a><br/><a href="#Sol">Sol</a><br/><a href="#Tilesdroits">Tiles droits</a><br/><a href="#Tilesisomtriques">Tiles isométriques</a><br/><a href="#Partitionnement">Partitionnement</a><br/><a href="#Problmatique">Problématique</a><br/><a href="#Lagrille">La grille</a><br/><a href="#Lequadtree">Le quadtree</a><br/><a href="#LeBSP2D">Le BSP 2D</a><br/><a href="#Spritesenrichis">Sprites enrichis</a><br/><a href="#Pointchaudetpointd039action">Point chaud et point d&#039;action</a><br/><a href="#SousAABB">Sous AABB</a><br/><a href="#Collisionsspcifiques">Collisions spécifiques</a><br/><a href="#Pong">Pong</a><br/><a href="#Coursevuedudessus">Course vue du dessus</a><br/><a href="#Labyrinthe">Labyrinthe</a><br/><a href="#Formessimples">Formes simples</a><br/><a href="#AABB3D">AABB 3D</a><br/><a href="#Sphres">Sphères</a><br/><a href="#Sol">Sol</a><br/><a href="#Heightmap">Heightmap</a><br/></div>
<a name="Thoriedescollisions"></a><h2>Théorie des collisions</h2><div class="content" role="article">
<p id="r-474906" data-claire-element-id="474906">Vous programmez un jeu vidéo, et vous vous intéressez aux collisions d'objets.</p><p id="r-474907" data-claire-element-id="474907">Est-ce-que mon personnage touche un ennemi ? Est-ce-qu'il touche le sol ? Est-ce-que mon curseur de souris, un viseur, touche un ennemi ? Tout ceci, ce sont des tests de collision. Les collisions sont un aspect fondamental de tout jeu d'action ou d'animation en général.</p><p id="r-474908" data-claire-element-id="474908">Nous considèrerons une ou plusieurs fonctions <strong>Collision</strong> qui prendront en paramètre 2 objets, ou un objet et un monde fait de sols et de murs. Et ces fonctions renverront simplement un booléen, ayant donc pour valeur <strong>oui ou non</strong>, selon si ça touche ou non.</p><p id="r-474909" data-claire-element-id="474909">Toute la gestion des collisions s'appuiera sur ces fonctions. <br/> Selon votre jeu, selon vos besoins, les fonctions de collisions seront différentes, mais renverront toujours &quot;oui&quot; ou &quot;non&quot;.</p><p id="r-474910" data-claire-element-id="474910">Comment implémenter ces fonctions de collision en fonction de vos besoins ? C'est la raison d'être de ce tutoriel, qui vous présentera plusieurs méthodes.</p><p id="r-474911" data-claire-element-id="474911">Les quelques fonctions d'exemple qui illustreront les différents cas seront codées en C, cependant facilement transcodables en d'autres langages.</p>
</div>
<div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1358423835269-0" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1358423835269-0');
        });
    }
    </script>
</div><a name="Formessimples"></a><h2>Formes simples</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
<span class="next">Point dans AABB</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-474913" data-claire-element-id="474913">Nous allons commencer ici par les algorithmes de collision les plus élémentaires.</p>
</div><a name="PointdansAABB"></a><h2>Point dans AABB</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">
<span class="arrow"></span>
<span class="next">Formes simples</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
<span class="next">Collision AABB</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-point-dans-aabb" data-claire-element-id="474958">Point dans AABB</h4><h5 id="r-definitions-8" data-claire-element-id="474929">Définitions</h5><p id="r-474914" data-claire-element-id="474914">Tout d'abord définissons <strong>AABB</strong> : Axis Aligned Bounding Box. Il s'agit d'un rectangle aligné avec les axes, c'est à dire que ses cotés sont parallèles aux axes des x et des y de votre repère (de votre écran pour les cas standard)</p><figure id="r-474916" data-claire-element-id="474917"><img id="r-474915" data-claire-element-id="474915" src="medias/uploads.siteduzero.com_files_234001_235000_234917.png" alt="Image utilisateur"/></figure><p id="r-474918" data-claire-element-id="474918">A la différence d'une <strong>OBB</strong> : Oriented Bounding Box, qui est un rectangle qui peut être orienté : ses cotés ne sont pas obligatoirement parallèles aux axes de votre repère.</p><p id="r-474919" data-claire-element-id="474919">Une AABB peut être définie par 4 paramètres : la position x,y de son coin supérieur gauche (en 2D, l'axe Y va vers le bas). Ainsi que de sa largeur w (comme width) et sa hauteur (h comme height)</p><figure id="r-474921" data-claire-element-id="474922"><img id="r-474920" data-claire-element-id="474920" src="medias/uploads.siteduzero.com_files_234001_235000_234916.png" alt="Image utilisateur"/></figure><figure id="r-474924" data-claire-element-id="474925"><img id="r-474923" data-claire-element-id="474923" src="medias/uploads.siteduzero.com_files_234001_235000_234918.png" alt="Image utilisateur"/></figure><p id="r-474926" data-claire-element-id="474926">Cela donne, en C, la structure suivante :</p><pre id="r-474927" data-claire-element-id="474927"><code data-claire-semantic="c">struct AABB
{
  int x;
  int y;
  int w;
  int h;
};</code></pre><p id="r-474928" data-claire-element-id="474928">Notez, pour les utilisateurs de SDL, que cette structure est exactement SDL_Rect (à un type près), et que donc SDL_Rect est parfaite pour décrire une AABB.</p><h5 id="r-applications-4" data-claire-element-id="474939">Applications</h5><p id="r-474930" data-claire-element-id="474930">Ce type de collision cherche donc à savoir si un point (de coordonnées x,y) est dans une AABB ou non.<br/> Dans quel cas avons nous besoin de ce type de collision ? <br/> Par exemple pour un jeu de tir comme Opération Wolf, ou la sélection d'un menu de ce bon vieux Warcraft premier du nom :</p><figure id="r-474932" data-claire-element-id="474933"><img id="r-474931" data-claire-element-id="474931" src="medias/uploads.siteduzero.com_files_234001_235000_234920.jpg" alt="Image utilisateur"/></figure><figure id="r-474935" data-claire-element-id="474936"><img id="r-474934" data-claire-element-id="474934" src="medias/uploads.siteduzero.com_files_234001_235000_234921.png" alt="Image utilisateur"/></figure><p id="r-474937" data-claire-element-id="474937">Dans la première image, j'ai encadré les cibles en vert. Ce sont les AABB qui les portent. Bien que cette collision ne soit pas parfaite (vous pouvez descendre l'ennemi en tirant juste au dessus de son épaule), elle est très utilisée et rapide. <br/> (Certains vont me dire qu'Opération Wolf affine ses collisions... ça se peut, mais considérons que non).<br/> L'idée de ce jeu est simple : on déplace le curseur à la souris (pointeur rouge) et quand on clique, on regarde s'il est dans une AABB ou non, tout simplement.</p><p id="r-474938" data-claire-element-id="474938">Pour la deuxième image, chaque option du menu est un rectangle, une AABB. On va aller cliquer sur une option ou une autre avec la souris. C'est la même collision.</p><h5 id="r-calcul-de-collision" data-claire-element-id="474957">Calcul de collision</h5><p id="r-474940" data-claire-element-id="474940">La fonction de collision aura cette signature :</p><pre id="r-474941" data-claire-element-id="474941"><code data-claire-semantic="c">bool Collision(int curseur_x,int curseur_y,AABB box)</code></pre><p id="r-474942" data-claire-element-id="474942">Notes :</p><ul id="r-474948" data-claire-element-id="474948"><li id="r-474945" data-claire-element-id="474945"><p id="r-474943" data-claire-element-id="474943">Je renvoie un bool même si celui ci n'est pas défini en C, vous adapterez si besoin. Ce choix a été fait pour donner davantage de sémantique au code. Vous pouvez définir en C le type et les deux constantes suivantes :</p><pre id="r-474944" data-claire-element-id="474944"><code data-claire-semantic="c">typedef int bool;
#define true 1
#define false 0</code></pre></li><li id="r-474947" data-claire-element-id="474947"><p id="r-474946" data-claire-element-id="474946">Idéalement, en C, il est préférable de passer un pointeur vers une structure plutôt que la structure entière, cependant, ce tuto voulant rester théorique, je n'alourdirai pas le code par des pointeurs.</p></li></ul><p id="r-474949" data-claire-element-id="474949">Le calcul est très simple : il y a collision si et seulement si le point est à l'intérieur de la box.<br/> Le point supérieur gauche est : (box.x;box.y)<br/> Le point inférieur droit est : (box.x+box.w-1;box.y+box.h-1)</p><p id="r-474950" data-claire-element-id="474950">Pourquoi -1 ? Parce que nous commençons à 0. Si nous ajoutons juste box.w à box.x, nous tombons sur le premier point hors de la box. Cependant, on peut se passer du -1 si on considère que le point testé sera strictement inférieur à ce premier point après la box.</p><p id="r-474951" data-claire-element-id="474951">Du coup, la fonction de collision est triviale :</p><pre id="r-474952" data-claire-element-id="474952"><code data-claire-semantic="c">bool Collision(int curseur_x,int curseur_y,AABB box)
{
   if (curseur_x &gt;= box.x 
    &amp;&amp; curseur_x &lt; box.x + box.w
    &amp;&amp; curseur_y &gt;= box.y 
    &amp;&amp; curseur_y &lt; box.y + box.h)
       return true;
   else
       return false;
}</code></pre><p id="r-474953" data-claire-element-id="474953">Note : Il m'a été reproché de faire un if avec return true ou false, au lieu de mettre directement la condition dans le return, comme le permet le langage C. Ce choix a été fait pour des raisons de clarté, de sémantique, et de compréhension car tous les langages ne permettent pas de factoriser de la sorte. Si vous trouvez ça horrible, vous pouvez bien sûr adapter.</p><p id="r-474954" data-claire-element-id="474954">Je pense que la fonction parle d'elle même. Voici donc notre première fonction de collision !</p><aside id="r-474956" data-claire-element-id="474956" data-claire-semantic="information"><p id="r-474955" data-claire-element-id="474955">Les librairies graphiques 2D utilisent souvent des nombres entiers (int, short...) pour les coordonnées. On parle de coordonnées discrètes. On dit qu'on est dans le plan N^2. Si vous faites de la 2D avec OpenGL, avec glOrtho, vous utilisez des float pour les coordonnées. On parle de coordonnées réelles, on est dans le plan R^2. Cet algorithme marche aussi bien dans N^2 que dans R^2 (il suffit d'adapter les coordonnées en float).</p></aside>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">
<span class="arrow"></span>
<span class="next">Formes simples</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
<span class="next">Collision AABB</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="CollisionAABB"></a><h2>Collision AABB</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
<span class="arrow"></span>
<span class="next">Point dans AABB</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
<span class="next">Cercles</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-collision-aabb" data-claire-element-id="475014">Collision AABB</h4><p id="r-474959" data-claire-element-id="474959">Voici un autre test de collision.<br/> Cette fois ci, nous allons voir comment tester la collision entre 2 AABB.</p><h5 id="r-applications-5" data-claire-element-id="474969">Applications</h5><p id="r-474960" data-claire-element-id="474960">Cette fonction est extrêmement utilisée dans énormément de jeux.</p><figure id="r-474962" data-claire-element-id="474963"><img id="r-474961" data-claire-element-id="474961" src="medias/uploads.siteduzero.com_files_234001_235000_234924.jpg" alt="Image utilisateur"/></figure><figure id="r-474965" data-claire-element-id="474966"><img id="r-474964" data-claire-element-id="474964" src="medias/uploads.siteduzero.com_files_234001_235000_234925.gif" alt="Image utilisateur"/></figure><p id="r-474967" data-claire-element-id="474967">Nous voyons à gauche ce cher Mario. Il a sa boite englobante (en vert), et la tortue aussi. Comment voir s'il la touche ? Et bien en testant une collision entre 2 Bounding box.<br/> Pareil, à droite, Gradius est un shoot'em up à l'ancienne. Chaque vaisseau, chaque missile, a sa bounding box. Il faut tester les collisions entre notre vaisseau et tous les vaisseaux et missiles ennemis (ce qui nous fait perdre), et également la collision entre nos missiles et les vaisseaux ennemis (pour les détruire).</p><p id="r-474968" data-claire-element-id="474968">Il y a beaucoup de collisions à tester, cela doit donc être rapide de préférence.</p><h5 id="r-calcul-de-collision-1" data-claire-element-id="475013">Calcul de collision</h5><p id="r-474970" data-claire-element-id="474970">La signature de notre fonction sera la suivante :</p><pre id="r-474971" data-claire-element-id="474971"><code data-claire-semantic="c">bool Collision(AABB box1,AABB box2)</code></pre><p id="r-474972" data-claire-element-id="474972">L'idée est la suivante. Regardons le petit schéma ci dessous :</p><figure id="r-474974" data-claire-element-id="474975"><img id="r-474973" data-claire-element-id="474973" src="medias/uploads.siteduzero.com_files_234001_235000_234926.png" alt="Image utilisateur"/></figure><p id="r-474976" data-claire-element-id="474976">Le rectangle rouge est box1. J'ai dessiné des traits, rouge, bleu, jaune et vert, en prolongeant les cotés à l'infini. Pour savoir si un autre rectangle touche le rectangle rouge, raisonnons à l'envers : essayons de savoir quand il ne touche pas.<br/> Un rectangle box2 ne touche pas si :</p><ul id="r-474985" data-claire-element-id="474985"><li id="r-474978" data-claire-element-id="474978"><p id="r-474977" data-claire-element-id="474977">il est complètement à gauche de la ligne jaune ;</p></li><li id="r-474980" data-claire-element-id="474980"><p id="r-474979" data-claire-element-id="474979">il est complètement à droite de la ligne verte ;</p></li><li id="r-474982" data-claire-element-id="474982"><p id="r-474981" data-claire-element-id="474981">il est complètement en haut de la ligne bleue ;</p></li><li id="r-474984" data-claire-element-id="474984"><p id="r-474983" data-claire-element-id="474983">il est complètement en bas de la ligne rouge.</p></li></ul><p id="r-474986" data-claire-element-id="474986">Voyons avec le dessin ci-dessous les exemples :</p><ul id="r-474993" data-claire-element-id="474993"><li id="r-474988" data-claire-element-id="474988"><p id="r-474987" data-claire-element-id="474987">Le rectangle bleu est non seulement complètement à gauche de la ligne jaune, mais aussi complètement en bas de la ligne rouge : il ne touche pas.</p></li><li id="r-474990" data-claire-element-id="474990"><p id="r-474989" data-claire-element-id="474989">Le rectangle vert est complètement au dessus de la ligne bleue : il ne touche pas.</p></li><li id="r-474992" data-claire-element-id="474992"><p id="r-474991" data-claire-element-id="474991">Le rectangle jaune n'est ni complètement en haut, ni à gauche, ni à droite, ni en bas :il touche.</p></li></ul><p id="r-474994" data-claire-element-id="474994">Voici la règle énoncée :</p><aside id="r-474996" data-claire-element-id="474996" data-claire-semantic="information"><p id="r-474995" data-claire-element-id="474995">Si la box2 est complètement à gauche, ou complètement en haut, ou complètement à droite, ou complètement en bas, alors elle ne touche pas. Sinon, elle touche.</p></aside><p id="r-474997" data-claire-element-id="474997">Pour savoir si la box2 est à droite du trait vert (donc trop à droite), on regarde simplement si sa coordonnée x (son minimum en x) est plus grande que le maximum en x de box1 (le maximum en x étant box1.x + box1.w -1<br/> Donc on obtient le test suivant :</p><p id="r-474998" data-claire-element-id="474998">box2.x &gt; box1.x + box1.w -1</p><p id="r-474999" data-claire-element-id="474999">Ce qui équivaut à :</p><p id="r-475000" data-claire-element-id="475000">box2.x &gt;= box1.x + box1.w</p><p id="r-475001" data-claire-element-id="475001">Pour les 4 autres directions, le calcul est similaire.</p><p id="r-475002" data-claire-element-id="475002">La fonction suivante en découle :</p><pre id="r-475003" data-claire-element-id="475003"><code data-claire-semantic="c">bool Collision(AABB box1,AABB box2)
{
   if((box2.x &gt;= box1.x + box1.w)      // trop à droite
	|| (box2.x + box2.w &lt;= box1.x) // trop à gauche
	|| (box2.y &gt;= box1.y + box1.h) // trop en bas
	|| (box2.y + box2.h &lt;= box1.y))  // trop en haut
          return false; 
   else
          return true; 
}</code></pre><p id="r-475004" data-claire-element-id="475004">La rapidité de cette collision est assurée. En très peu de calcul, on a notre résultat, ce qui permet de pouvoir faire beaucoup de tests dans le jeu sans ralentissements. <br/> Cette collision peut paraître grossière, mais elle est souvent largement suffisante pour beaucoup de cas. D'autres collisions plus fines, mais aussi plus coûteuses en temps de calcul, utiliseront cette collision auparavant, afin d'éliminer facilement les cas ou les objets ne se touchent clairement pas.</p><aside id="r-475012" data-claire-element-id="475012" data-claire-semantic="information"><ul id="r-475011" data-claire-element-id="475011"><li id="r-475006" data-claire-element-id="475006"><p id="r-475005" data-claire-element-id="475005">Notez qu'on se moque de savoir quelle est la box1 et quelle est la box2. Si la box1 touche la box2, alors la box2 touche aussi la box1.</p></li><li id="r-475008" data-claire-element-id="475008"><p id="r-475007" data-claire-element-id="475007">Ça fonctionne avec des boîtes de taille différentes, aucune restriction sur ce point.</p></li><li id="r-475010" data-claire-element-id="475010"><p id="r-475009" data-claire-element-id="475009">Cet algorithme marche aussi bien dans N^2 que dans R^2.</p></li></ul></aside>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
<span class="arrow"></span>
<span class="next">Point dans AABB</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
<span class="next">Cercles</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Cercles"></a><h2>Cercles</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
<span class="arrow"></span>
<span class="next">Collision AABB</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">
<span class="next">Formes plus complexes</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-cercles" data-claire-element-id="475062">Cercles</h4><p id="r-475015" data-claire-element-id="475015">Les cercles sont également fort intéressants pour les collisions. On peut très rapidement tester si un point est dans un cercle, ou si deux cercles se touchent, ce qui peut être fort utile.</p><h5 id="r-definitions-9" data-claire-element-id="475022">Définitions</h5><p id="r-475016" data-claire-element-id="475016">Un cercle, c'est un centre x,y et un rayon.</p><figure id="r-475018" data-claire-element-id="475019"><img id="r-475017" data-claire-element-id="475017" src="medias/uploads.siteduzero.com_files_235001_236000_235091.png" alt="Image utilisateur"/></figure><p id="r-475020" data-claire-element-id="475020">Nous pouvons immédiatement définir une structure de cercle :</p><pre id="r-475021" data-claire-element-id="475021"><code data-claire-semantic="c">struct Cercle
{
   int x,y;
   int rayon;
};</code></pre><h5 id="r-applications-6" data-claire-element-id="475030">Applications</h5><p id="r-475023" data-claire-element-id="475023">Imaginons que vous vouliez cliquer dans une zone de cercle (crever des ballons par exemple), ou alors que vous fassiez un jeu de billard ou un jeu du genre Puzzle Bubble (même si je ne suis pas sur que Puzzle Bubble utilise rigoureusement cette collision), alors cette collision vous sera fort utile.</p><figure id="r-475025" data-claire-element-id="475026"><img id="r-475024" data-claire-element-id="475024" src="medias/uploads.siteduzero.com_files_235001_236000_235097.png" alt="Image utilisateur"/></figure><figure id="r-475028" data-claire-element-id="475029"><img id="r-475027" data-claire-element-id="475027" src="medias/uploads.siteduzero.com_files_235001_236000_235098.gif" alt="Image utilisateur"/></figure><h5 id="r-calcul-de-collision-2" data-claire-element-id="475061">Calcul de collision</h5><h6 id="r-point-dans-un-cercle" data-claire-element-id="475044">Point dans un cercle</h6><p id="r-475031" data-claire-element-id="475031">Tout d'abord, voyons le cas d'un point dans un cercle.<br/> La signature de notre fonction sera la suivante :</p><pre id="r-475032" data-claire-element-id="475032"><code data-claire-semantic="c">bool Collision(int x,int y,Cercle C)</code></pre><p id="r-475033" data-claire-element-id="475033">Vous souhaitez savoir si le point x,y est dans le cercle ou non.<br/> C'est très simple, il suffit de calculer la distance du point x,y au centre du cercle. Si cette distance est supérieure au rayon, alors vous êtes dehors, sinon, vous êtes dedans.</p><p id="r-475034" data-claire-element-id="475034">Pour le calcul de distance, pensez a Pythagore. Le calcul de la <a href="http://fr.wikipedia.org/wiki/Distance_(mathématiques)">distance Euclidienne</a> dans un plan se calcul simplement :</p><p id="r-475035" data-claire-element-id="475035">d = sqrt((x-C.x)^2 + (y-C.y)^2)</p><p id="r-475036" data-claire-element-id="475036">Le seul inconvénient de cette méthode, c'est qu'il y a une racine carrée. C'est une opération assez coûteuse, même si maintenant, les machines sont suffisamment puissantes pour ne pas trop s'en rendre compte. Si on peut l'éviter, alors on l'évite.</p><p id="r-475037" data-claire-element-id="475037">Et dans notre cas, on peut. En effet, on souhaite savoir si d&gt;C.r ou pas. Or, d et C.r étant positifs, on peut dire que :<br/>d&gt;C.r &lt;=&gt; d^2&gt;C.r^2</p><p id="r-475038" data-claire-element-id="475038">Du coup, la racine carré disparaît :<br/>d^2 = (x-C.x)^2 + (y-C.y)^2</p><p id="r-475039" data-claire-element-id="475039">La fonction de collision est donc très simple :</p><pre id="r-475040" data-claire-element-id="475040"><code data-claire-semantic="c">bool Collision(int x,int y,Cercle C)
{
   int d2 = (x-C.x)*(x-C.x) + (y-C.y)*(y-C.y);
   if (d2&gt;C.rayon*C.rayon)
      return false;
   else
      return true;
}</code></pre><aside id="r-475042" data-claire-element-id="475042" data-claire-semantic="warning"><p id="r-475041" data-claire-element-id="475041">Note : en C, la &quot;puissance 2&quot; n'existe pas. Je multiplie donc (x-C.x)*(x-C.x), ce qui en soit est un vilain copier/coller, et un calcul fait deux fois. On pourrait éviter ça avec des variables intermédiaires, mais y gagnerait-on en vitesse ? Pas sûr. Une chose par contre est sure, n'utilisez pas la fonction pow() en C pour faire des carrés, jamais. C'est sortir l'artillerie lourde, et perdre du temps, pour une simple mise au carré.</p></aside><p id="r-475043" data-claire-element-id="475043">Note : Une idée pour optimiser davantage est de stocker directement le rayon au carré dans la structure du cercle. Si le rayon reste contant, on gagnera en optimisation en évitant à chaque fois de recalculer C.rayon*C.rayon.</p><h6 id="r-collision-de-2-cercles" data-claire-element-id="475060">Collision de 2 cercles</h6><p id="r-475045" data-claire-element-id="475045">Nous souhaitons maintenant savoir si 2 cercles se touchent. Pour un jeu de billard par exemple, c'est fort utile.</p><p id="r-475046" data-claire-element-id="475046">La signature de notre fonction sera celle ci :</p><pre id="r-475047" data-claire-element-id="475047"><code data-claire-semantic="c">bool Collision(Cercle C1,Cercle C2)</code></pre><p id="r-475048" data-claire-element-id="475048">Comment savoir si deux cercles se touchent ? En réalité, c'est très simple : nous mesurons la distance entre leurs deux centres, et il suffit de voir si cette distance est supérieure ou inférieure à la somme des rayons.</p><p id="r-475049" data-claire-element-id="475049">La distance entre les rayons sera bien sûr un calcul similaire à ce qu'on a vu au dessus :<br/>d = sqrt((C1.x-C2.x)^2 + (C1.y-C2.y)^2)</p><p id="r-475050" data-claire-element-id="475050">L'astuce pour éliminer les carrés est la même. Nous obtenons donc la fonction suivante :</p><pre id="r-475051" data-claire-element-id="475051"><code data-claire-semantic="c">bool Collision(Cercle C1,Cercle C2)
{
   int d2 = (C1.x-C2.x)*(C1.x-C2.x) + (C1.y-C2.y)*(C1.y-C2.y);
   if (d2 &gt; (C1.rayon + C2.rayon)*(C1.rayon + C2.rayon))
      return false;
   else
      return true;
}</code></pre><aside id="r-475057" data-claire-element-id="475057" data-claire-semantic="information"><ul id="r-475056" data-claire-element-id="475056"><li id="r-475053" data-claire-element-id="475053"><p id="r-475052" data-claire-element-id="475052">Cela fonctionne même avec des cercles de rayons différents. Une bille et une boule de pétanque par exemple.</p></li><li id="r-475055" data-claire-element-id="475055"><p id="r-475054" data-claire-element-id="475054">Cet algorithme marche aussi bien dans N^2 que dans R^2.</p></li></ul></aside><p id="r-475058" data-claire-element-id="475058">Note : Si le rayon des cercles est constant, alors (C1.rayon + C2.rayon)*(C1.rayon + C2.rayon) est contant aussi. On pourrait donc, si besoin, stocker cette valeur quelque part pour optimiser le calcul au lieu de le refaire à chaque fois. Merci à Sylvior pour cette remarque.</p><p id="r-475059" data-claire-element-id="475059">Tous ces algorithmes sont très rapides et utiles pour beaucoup de problèmes.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
<span class="arrow"></span>
<span class="next">Collision AABB</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">
<span class="next">Formes plus complexes</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Formespluscomplexes"></a><h2>Formes plus complexes</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
<span class="arrow"></span>
<span class="next">Cercles</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
<span class="next">Point dans polygone</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-475064" data-claire-element-id="475064">Nous parlerons ici de collisions avec des objets plus complexes. <br/> Vous aurez besoin de connaissances mathématiques avancées pour comprendre tous les concepts.<br/> Si ce n'est pas le cas, vous pouvez néanmoins utiliser les fonctions proposées telles quelles.</p>
</div><a name="Pointdanspolygone"></a><h2>Point dans polygone</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">
<span class="arrow"></span>
<span class="next">Formes plus complexes</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
<span class="next">Segment cercle</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-point-dans-polygone" data-claire-element-id="475194">Point dans polygone</h4><p id="r-475065" data-claire-element-id="475065">Jusqu'à présent, nous avons vu les AABB et les cercles. Comment tester si un point est dans une OBB (Oriented Bounding Box), dans un triangle, un hexagone, et plus généralement dans un polygone ?</p><h5 id="r-definitions-10" data-claire-element-id="475088">Définitions</h5><h6 id="r-polygone-convexe" data-claire-element-id="475081">Polygone convexe</h6><p id="r-475066" data-claire-element-id="475066">Sans reprendre la définition exacte d'un polygone (que vous trouverez en lien à la fin de ce paragraphe), nous allons définir ce qu'est un polygone convexe.<br/> Pour cela, nous allons d'abord présenter les polygones non-convexes :</p><figure id="r-475068" data-claire-element-id="475069"><img id="r-475067" data-claire-element-id="475067" src="medias/uploads.siteduzero.com_files_235001_236000_235713.png" alt="Image utilisateur"/></figure><p id="r-475070" data-claire-element-id="475070">Les polygones sont en rouge. Si on regarde les 3 polygones de gauche, on peut constater qu'à chaque fois, au moins une diagonale est hors du polygone. Les diagonales sont en bleu. Je rappelle que les diagonales d'un polygone sont des segments qui relient 2 sommets quelconques du polygone, mais qui ne sont pas des côtés.</p><p id="r-475071" data-claire-element-id="475071">La quatrième figure est un cas tordu : un polygone croisé, c'est-à-dire qu'il y a intersection entre au moins deux de ses cotés. Nous allons vite oublier ce quatrième cas.</p><aside id="r-475073" data-claire-element-id="475073" data-claire-semantic="information"><p id="r-475072" data-claire-element-id="475072">Un polygone convexe est un polygone non-croisé, dont toutes les diagonales sont à l'intérieur du polygone.</p></aside><figure id="r-475075" data-claire-element-id="475076"><img id="r-475074" data-claire-element-id="475074" src="medias/uploads.siteduzero.com_files_235001_236000_235712.png" alt="Image utilisateur"/></figure><p id="r-475077" data-claire-element-id="475077">Les polygones ci-dessus sont donc convexes. Ils ne sont pas croisés, et il n'existe pas de diagonales à l'extérieur.</p><p id="r-475078" data-claire-element-id="475078">Pour en savoir plus sur les polygones, et leur classification, consultez <a href="http://fr.wikipedia.org/wiki/Polygone">Wikipedia </a>.</p><aside id="r-475080" data-claire-element-id="475080" data-claire-semantic="information"><p id="r-475079" data-claire-element-id="475079">Un triangle est toujours convexe. Une OBB aussi.</p></aside><h6 id="r-de-non-convexe-a-convexe" data-claire-element-id="475087">De non-convexe à convexe</h6><p id="r-475082" data-claire-element-id="475082">Un polygone non-convexe peut être transformé en un ensemble de polygones convexes. Si on regarde la figure ci-dessus sur les polygones non-convexes, j'ai ajouté des traits verts qui découpent les polygones en plusieurs triangles. Comme chaque triangle est convexe, on transforme ainsi le polygone non-convexe en plusieurs polygones convexes.</p><p id="r-475083" data-claire-element-id="475083">Vérifier si un point est dans ce polygone non-convexe reviendra à vérifier s'il est dans l'un des triangles qui le compose.</p><p id="r-475084" data-claire-element-id="475084">Un algorithme pour transformer le polygone non-convexe en triangles peut être le suivant :<br/> 1 - On parcourt les points du polygone non-convexe. <br/> 2 - Pour un point i, on considère son voisin précédent et son voisin suivant. Si le triangle formé par ces trois points est dans le polygone, alors on ajoute le triangle à la liste, et on considère le polygone non-convexe restant comme étant le même polygone auquel on retire le sommet i (on relie donc i-1 et i+1).<br/> 3 - etc.</p><p id="r-475085" data-claire-element-id="475085">C'est un algorithme glouton, et le polygone restant finit par être un triangle.</p><p id="r-475086" data-claire-element-id="475086">On peut tester l'appartenance du triangle en regardant si l'angle du point i est aigu ou obtus par rapport au sens de parcours.</p><h5 id="r-applications-7" data-claire-element-id="475094">Applications</h5><p id="r-475089" data-claire-element-id="475089">Un jeu comme Risk peut recourir à cette collision. Chaque pays peut être vu comme un polygone (non-convexe), donc par un ensemble de polygones convexes.</p><figure id="r-475091" data-claire-element-id="475092"><img id="r-475090" data-claire-element-id="475090" src="medias/uploads.siteduzero.com_files_235001_236000_235717.jpg" alt="Image utilisateur"/></figure><p id="r-475093" data-claire-element-id="475093">Quand vous choisissez un pays en cliquant dessus, cette collision est appliquée.</p><h5 id="r-calcul-de-collision-premiere-methode" data-claire-element-id="475133">Calcul de collision première méthode</h5><h6 id="r-regardez-a-gauche" data-claire-element-id="475108">Regardez à gauche</h6><p id="r-475095" data-claire-element-id="475095">Pour cette méthode, nous considérons un polygone convexe (s'il n'est pas convexe, regardez ci-dessus comment faire pour le décomposer en plusieurs polygones convexes)..</p><figure id="r-475097" data-claire-element-id="475098"><img id="r-475096" data-claire-element-id="475096" src="medias/uploads.siteduzero.com_files_235001_236000_235719.png" alt="Image utilisateur"/></figure><p id="r-475099" data-claire-element-id="475099">Voici de nouveau mes polygones convexes. Cette fois j'ai rajouté des flèches. En effet, je vais parcourir mes points dans l'ordre, comme si je partais d'un point, et que j'avançais en voiture sur le tour de mon polygone. L'idée est de choisir le bon sens de façon à ce que l'intérieur du polygone soit à gauche.</p><p id="r-475100" data-claire-element-id="475100">Voici l'idée :</p><aside id="r-475102" data-claire-element-id="475102" data-claire-semantic="information"><p id="r-475101" data-claire-element-id="475101">Un point est à l'intérieur du polygone si et seulement si il est &quot;à votre gauche&quot; tout le long de votre parcours.</p></aside><p id="r-475103" data-claire-element-id="475103">Il va donc falloir, pour chaque coté orienté, voir si le point testé est à gauche ou non. S'il est, ne serait ce qu'une fois, à droite, alors le point n'est pas à l'intérieur.</p><figure id="r-475105" data-claire-element-id="475106"><img id="r-475104" data-claire-element-id="475104" src="medias/uploads.siteduzero.com_files_235001_236000_235721.png" alt="Image utilisateur"/></figure><p id="r-475107" data-claire-element-id="475107">Il ne reste plus qu'a savoir si un point est à gauche ou pas. Sur la figure ci-dessus, il y a un segment [AB]. On va de A vers B. Le Point P est il à gauche ?</p><h6 id="r-le-determinant" data-claire-element-id="475132">Le déterminant</h6><p id="r-475109" data-claire-element-id="475109">Mathématiquement, un simple calcul de déterminant suffit.<br/> Nous avons les points A, B, P.<br/> Soit D le vecteur AB :</p><p id="r-475110" data-claire-element-id="475110">\vec{D} = \left( \begin{array}{c}B_x - A_x \\B_y - A_y \\\end{array} ight)</p><p id="r-475111" data-claire-element-id="475111">Soit T le vecteur AP :</p><p id="r-475112" data-claire-element-id="475112">\vec{T} = \left( \begin{array}{c}P_x - A_x \\P_y - A_y \\\end{array} ight)</p><p id="r-475113" data-claire-element-id="475113">Soit d le déterminant de D,T. Le déterminant se calcule simplement ainsi (règle du gamma) :</p><p id="r-475114" data-claire-element-id="475114">d = D_x*T_y - D_y*T_x</p><aside id="r-475122" data-claire-element-id="475122" data-claire-semantic="information"><ul id="r-475121" data-claire-element-id="475121"><li id="r-475116" data-claire-element-id="475116"><p id="r-475115" data-claire-element-id="475115">Si d&gt;0 alors P est à gauche de AB ;</p></li><li id="r-475118" data-claire-element-id="475118"><p id="r-475117" data-claire-element-id="475117">Si d&lt;0 alors P est à droite de AB ;</p></li><li id="r-475120" data-claire-element-id="475120"><p id="r-475119" data-claire-element-id="475119">Si d=0 alors P sur la droite AB.</p></li></ul></aside><p id="r-475123" data-claire-element-id="475123">Pour le code, nous considérons le polygone comme un tableau de points, de taille nbp. Soient les structures suivantes :</p><pre id="r-475124" data-claire-element-id="475124"><code data-claire-semantic="c">struct Point
{
  float x,y;
};

struct Vecteur
{
  float x,y;
};</code></pre><p id="r-475125" data-claire-element-id="475125">Nous obtenons une fonction de collision comme ceci :</p><pre id="r-475126" data-claire-element-id="475126"><code data-claire-semantic="c">bool Collision(Point tab[],int nbp,Point P)
{
  int i;
  for(i=0;i&lt;nbp;i++)
  {
     Point A = tab[i];
     Point B;
     if (i==nbp-1)  // si c'est le dernier point, on relie au premier
         B = tab[0];
     else           // sinon on relie au suivant.
         B = tab[i+1];
     Vecteur D,T;
     D.x = B.x - A.x;
     D.y = B.y - A.y;
     T.x = P.x - A.x;
     T.y = P.y - A.y;
     float d = D.x*T.y - D.y*T.x;
     if (d&lt;0)
        return false;  // un point à droite et on arrête tout.
  }
  return true;  // si on sort du for, c'est qu'aucun point n'est à gauche, donc c'est bon.
}</code></pre><p id="r-475127" data-claire-element-id="475127">A vous de voir si vous voulez qu'un point sur AB soit considéré comme dedans ou dehors, en mettant if (d&lt;0) ou if (d&lt;=0). Cependant, ça reste un cas limite.</p><aside id="r-475129" data-claire-element-id="475129" data-claire-semantic="information"><p id="r-475128" data-claire-element-id="475128">Note : ceci fonctionne dans des repères directs. Dans les librairies 2D, on manipule souvent des repères indirects (vecteur Y vers le bas). Dans ce cas, il faudra faire attention au sens de parcours. Notez que si vous &quot;roulez à l'envers&quot; sur le polygone, il suffira de tester si le point est toujours à droite (et non à gauche).</p></aside><aside id="r-475131" data-claire-element-id="475131" data-claire-semantic="information"><p id="r-475130" data-claire-element-id="475130">Cet algorithme marche aussi bien dans N^2 que dans R^2.</p></aside><h5 id="r-calcul-de-collision-deuxieme-methode" data-claire-element-id="475193">Calcul de collision deuxième méthode</h5><p id="r-475134" data-claire-element-id="475134">La deuxième méthode permet de tester si un point est dans un polygone quelconque. Convexe ou non, cette méthode fonctionne dans tous les cas, même dans les cas de polygones croisés.<br/> Il faudra cependant faire très attention à ce qu'on appellera les &quot;cas limites&quot;.</p><h6 id="r-point-infini" data-claire-element-id="475157">Point infini</h6><p id="r-475135" data-claire-element-id="475135">Pour cet algo, nous allons chercher un point I qui sera en dehors du polygone. <br/> Comment être sûr qu'un point est en dehors ? Il suffit de le prendre très loin.<br/> Par exemple, on peut poser I(100000,0).</p><p id="r-475136" data-claire-element-id="475136">Nous partons du principe que notre polygone est sagement dans notre monde, et, notre monde étant par exemple compris entre -1000 et +1000, nous sommes sûr que le point I(100000,0) est hors du monde, et hors du polygone.</p><figure id="r-475138" data-claire-element-id="475139"><img id="r-475137" data-claire-element-id="475137" src="medias/uploads.siteduzero.com_files_235001_236000_235732.png" alt="Image utilisateur"/></figure><p id="r-475140" data-claire-element-id="475140">Regardons le schéma ci-dessus. Des polygones, et des segments verts dont une extrémité est un des points P, Q, R, S, T, et l'autre extrémité est... loin ! (le point I lointain)</p><p id="r-475141" data-claire-element-id="475141">Voici la règle :</p><aside id="r-475143" data-claire-element-id="475143" data-claire-semantic="information"><p id="r-475142" data-claire-element-id="475142">Comptez les intersections entre le segment vert et les segments du polygone. Si le nombre d'intersections est impair, alors le point est dans le polygone, sinon il est dehors.</p></aside><p id="r-475144" data-claire-element-id="475144">Vérifions tout ça avec les exemples ci-dessus :</p><ul id="r-475155" data-claire-element-id="475155"><li id="r-475146" data-claire-element-id="475146"><p id="r-475145" data-claire-element-id="475145">Pour P, on coupe une fois : 1 est impair, P est à l'intérieur ;</p></li><li id="r-475148" data-claire-element-id="475148"><p id="r-475147" data-claire-element-id="475147">Pour Q, idem ;</p></li><li id="r-475150" data-claire-element-id="475150"><p id="r-475149" data-claire-element-id="475149">Pour R, on coupe deux fois. 2 est pair, on est à l'extérieur ;</p></li><li id="r-475152" data-claire-element-id="475152"><p id="r-475151" data-claire-element-id="475151">Pour S, on coupe 5 fois, impair, on est dedans ;</p></li><li id="r-475154" data-claire-element-id="475154"><p id="r-475153" data-claire-element-id="475153">Pour T, on coupe 4 fois, pair, on est dehors.</p></li></ul><p id="r-475156" data-claire-element-id="475156">Cet algo revient donc à savoir combien de fois on coupe, donc se base sur un algo d'intersection de segments.</p><h6 id="r-intersection-de-segments" data-claire-element-id="475185">Intersection de segments</h6><p id="r-475158" data-claire-element-id="475158">Un segment est inscrit dans une droite. Nous allons donc considérer l'équation paramétrique d'une droite. Ceci est vu, me semble-t-il, à la fin du lycée.</p><p id="r-475159" data-claire-element-id="475159">P(t) = O + t*\vec{D}</p><p id="r-475160" data-claire-element-id="475160">Une droite est définie par un point d'origine O, et un vecteur directeur \vec{D}<br/> En faisant varier t, on obtient tous les points de la droite.</p><p id="r-475161" data-claire-element-id="475161">Si on s'intéresse à un segment [AB], posons astucieusement \vec{D} = \vec{AB} et O = A.</p><p id="r-475162" data-claire-element-id="475162">Nous aurons donc les règles suivantes :</p><ul id="r-475169" data-claire-element-id="475169"><li id="r-475164" data-claire-element-id="475164"><p id="r-475163" data-claire-element-id="475163">Si t=0, alors P(t) = A ;</p></li><li id="r-475166" data-claire-element-id="475166"><p id="r-475165" data-claire-element-id="475165">Si t=1, alors P(t) = B ;</p></li><li id="r-475168" data-claire-element-id="475168"><p id="r-475167" data-claire-element-id="475167">Si t appartient au segment [0..1] alors P(t) appartient au segment [AB], sinon, il n'est pas sur le segment.</p></li></ul><p id="r-475170" data-claire-element-id="475170">Nous cherchons l'intersection de 2 segments [AB] et [IP]. Soit J le point d'intersection. Nous cherchons donc :</p><p id="r-475171" data-claire-element-id="475171">\left \{\begin{array} .J = A + t*\vec{AB} \\J = I + u*\vec{IP} \\\end{array} ight.</p><p id="r-475172" data-claire-element-id="475172">Où t et u seront les paramètres du point J sur chacune des deux droites (AB) et (IP).<br/> Ce qui nous donne :</p><p id="r-475173" data-claire-element-id="475173">A + t*\vec{AB} = I + u*\vec{IP}</p><p id="r-475174" data-claire-element-id="475174">Posons \vec{D} = \vec{AB}<br/> Posons \vec{E} = \vec{IP}</p><p id="r-475175" data-claire-element-id="475175">Nous travaillons dans le plan, donc chaque point et chaque vecteur a une coordonnée x,y.<br/> Ceci nous permet de poser le système suivant :</p><p id="r-475176" data-claire-element-id="475176">\left \{\begin{array}.A_x + t*D_x = I_x + u*E_x \\A_y + t*D_y = I_y + u*E_y\\\end{array} ight.</p><p id="r-475177" data-claire-element-id="475177">Nous résolvons le système pour trouver t et u. Nous obtenons :<br/>t = - \frac{A_x*E_y-I_x*E_y-E_x*A_y+E_x*I_y}{D_x*E_y-D_y*E_x}u = - \frac{-D_x*A_y+D_x*I_y+D_y*A_x-D_y*I_x}{D_x*E_y-D_y*E_x}</p><p id="r-475178" data-claire-element-id="475178">Si le dénominateur (qui est le même pour t et u) s'annule, cela veut dire que les droites (AB) et (IJ) sont parallèles : donc J n'existe pas (ou alors l'intersection est l'ensemble de la droite).</p><p id="r-475179" data-claire-element-id="475179">Sinon, cela veut dire qu'il existe un point J intersection des droites (AB) et (IJ). Mais nous, nous cherchons l'intersection des segments.<br/> Il faut donc regarder si 0&lt;=t&lt;1 et 0&lt;=u&lt;1. Dans ce cas seulement, l'intersection se produit au niveau des segments.</p><aside id="r-475181" data-claire-element-id="475181" data-claire-semantic="information"><p id="r-475180" data-claire-element-id="475180">Nous considèrerons qu'un point est sur le segment si t (ou u) vaut 0, mais pas s'il vaut 1. En effet, au niveau des sommets du polygone, si nous ne voulons considérer qu'un seul point d'intersection, nous dirons qu'il est sur un seul des segments, celui de paramètre 0.</p></aside><p id="r-475182" data-claire-element-id="475182">Nous nous appuierons sur la fonction d'intersection de segments suivante :</p><pre id="r-475183" data-claire-element-id="475183"><code data-claire-semantic="c">int intersectsegment(Point A,Point B,Point I,Point P)
{
   Vecteur D,E;
   D.x = B.x - A.x;
   D.y = B.y - A.y;
   E.x = P.x - I.x;
   E.y = P.y - I.y;
   double denom = D.x*E.y - D.y*E.x;
   if (denom==0)
       return -1;   // erreur, cas limite
   t = - (A.x*E.y-I.x*E.y-E.x*A.y+E.x*I.y) / denom;
   if (t&lt;0 || t&gt;=1)
      return 0;
   u = - (-D.x*A.y+D.x*I.y+D.y*A.x-D.y*I.x) / denom;
   if (u&lt;0 || u&gt;=1)
      return 0;
   return 1;
}</code></pre><p id="r-475184" data-claire-element-id="475184">Vous pouvez constater que je retourne 0 si les segments ne se touchent pas, 1 s'ils se touchent, et -1 dans les cas limites. Nous en aurons besoin pour la suite.</p><h6 id="r-fonction-de-collision" data-claire-element-id="475192">Fonction de collision</h6><p id="r-475186" data-claire-element-id="475186">Nous en arrivons à la fonction de collision. Nous allons prendre un point I au hasard, mais loin. Puis nous allons calculer le nombre d'intersections avec chacun des segments. Si nous avons un nombre impair d'intersection, alors le point sera dedans, sinon dehors.<br/> Nous ajoutons que si on tombe sur un cas limite (une droite parallèle à un des cotés), nous choisirons à nouveau un autre I.</p><pre id="r-475187" data-claire-element-id="475187"><code data-claire-semantic="c">bool Collision(Point tab[],int nbp,Point P)
{
  int i;
  Point I;
  I.x = 10000 + rand()%100;   // 10000 + un nombre aléatoire entre 0 et 99
  I.y = 10000 + rand()%100;
  int nbintersections = 0;
  for(i=0;i&lt;nbp;i++)
  {
     Point A = tab[i];
     Point B;
     if (i==nbp-1)  // si c'est le dernier point, on relie au premier
         B = tab[0];
     else           // sinon on relie au suivant.
         B = tab[i+1];
     int iseg = intersectsegment(A,B,I,P);
     if (iseg == -1)
         return Collision(tab,nbp,P);  // cas limite, on relance la fonction.
     nbintersections+=iseg;
  }
  if (nbintersections%2==1)  // nbintersections est-il impair ?
     return true;
  else
     return false;
}</code></pre><aside id="r-475189" data-claire-element-id="475189" data-claire-semantic="information"><p id="r-475188" data-claire-element-id="475188">Note : la fonction peut être récursive en cas d'échec (cas limite). Elle pourrait donc planter si par malchance tous les rand donnaient chacun un cas limite, ce qui lancerait une récursivité infinie. Ceci est extrêmement improbable. Il faudrait un polygone comportant beaucoup de cotés, et vraiment... vraiment tordu !</p></aside><aside id="r-475191" data-claire-element-id="475191" data-claire-semantic="information"><p id="r-475190" data-claire-element-id="475190">Cet algorithme marche aussi bien dans N^2 que dans R^2.</p></aside>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">
<span class="arrow"></span>
<span class="next">Formes plus complexes</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
<span class="next">Segment cercle</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Segmentcercle"></a><h2>Segment cercle</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
<span class="arrow"></span>
<span class="next">Point dans polygone</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
<span class="next">Segment Segment</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-segment-cercle" data-claire-element-id="475286">Segment cercle</h4><p id="r-475195" data-claire-element-id="475195">Nous allons maintenant voir si un cercle touche un segment ou une droite.<br/> Nous allons faire pas mal de maths ici, si ça vous fait peur, vous pouvez prendre les fonctions finales.</p><h5 id="r-applications-8" data-claire-element-id="475202">Applications</h5><p id="r-475196" data-claire-element-id="475196">Un jeu de flipper par exemple : vous testez les collisions entre la boule et chaque bord, représenté par des segments. Même les flips sont comme des segments pour les collisions.</p><figure id="r-475198" data-claire-element-id="475199"><img id="r-475197" data-claire-element-id="475197" src="medias/uploads.siteduzero.com_files_236001_237000_236196.jpg" alt="Image utilisateur"/></figure><p id="r-475200" data-claire-element-id="475200">Contre exemple : Les casse briques. Les casse briques, c'est une balle qui touche une raquette &quot;horizontale&quot;. Il suffit de regarder, quand le y de la balle est en deçà d'une certaine valeur, si la raquette est en dessous ou non. De même on considerera souvent la balle comme une AABB.</p><p id="r-475201" data-claire-element-id="475201">Ici, je parlerai d'un cas général de collision entre un cercle et un segment quelconque.</p><h5 id="r-calcul-de-collision-3" data-claire-element-id="475285">Calcul de collision</h5><p id="r-475203" data-claire-element-id="475203">Un petit schéma pour commencer.</p><figure id="r-475205" data-claire-element-id="475206"><img id="r-475204" data-claire-element-id="475204" src="medias/uploads.siteduzero.com_files_236001_237000_236199.png" alt="Image utilisateur"/></figure><p id="r-475207" data-claire-element-id="475207">Nous avons le cercle de centre C et de rayon r. Nous avons la droite d'équation paramétrique P(t) = O + t*\vec{u}. <br/> Nous souhaitons avoir la distance CI, avec le point I projection orthogonale de C sur la droite. Nous ne connaissons pas I.</p><p id="r-475208" data-claire-element-id="475208">Je rappelle que si on a 2 points A et B, on peut définir l'équation paramétrique de la droite en posant O = A et \vec{u} = \vec{AB}</p><p id="r-475209" data-claire-element-id="475209">La règle est simmple, et facile à voir en regardant le schéma :</p><aside id="r-475211" data-claire-element-id="475211" data-claire-semantic="information"><p id="r-475210" data-claire-element-id="475210">Le cercle touche la droite si et seulement si la distance CI est plus petite que le rayon du cercle.</p></aside><p id="r-475212" data-claire-element-id="475212">Pour un segment, il y aura une précaution supplémentaire à prendre en compte que nous verrons plus loin.</p><h6 id="r-la-distance-ci" data-claire-element-id="475228">La distance CI</h6><p id="r-475213" data-claire-element-id="475213">Un petit peu de trigo, considérons le triangle ACI rectangle en I. Le point I est inconnu, mais A et C sont connus.<br/> Nous cherchons la distance CI.</p><p id="r-475214" data-claire-element-id="475214">Nous connaissons la distance AC, c'est la norme du vecteur \vec{AC}</p><p id="r-475215" data-claire-element-id="475215">Je rappelle que la norme d'un vecteur v est sa longueur, et qu'elle se calcule ainsi :<br/>||v|| = sqrt{v_x^2 + v_y^2}</p><p id="r-475216" data-claire-element-id="475216">Dans notre triangle ACI, nous pouvons écrire que : sin(a) = \frac{CI}{AC}, donc que <br/>CI = AC * sin(a) (1)<br/> avec a l'angle formé entre les 2 vecteurs \vec{AI} et \vec{AC}</p><p id="r-475217" data-claire-element-id="475217">Ce qui nous embête maintenant, c'est cet angle, qu'il faudrait calculer. Soit on le calcule, soit on le vire. Une astuce est d'invoquer le <a href="http://fr.wikipedia.org/wiki/Produit_vectoriel">produit vectoriel</a> des deux vecteurs. Une des formules du produit vectoriel est la suivante :</p><p id="r-475218" data-claire-element-id="475218">||\vec{u}\wedge\vec{AC}|| = ||\vec{u}||*||\vec{AC}||*sin(a) or ||\vec{AC}|| = AC donc :</p><p id="r-475219" data-claire-element-id="475219">||\vec{u}\wedge\vec{AC}|| = ||\vec{u}||*AC*sin(a) (2)</p><p id="r-475220" data-claire-element-id="475220">En combinant (1) et (2), nous obtenons :</p><p id="r-475221" data-claire-element-id="475221">Nous obtenons donc : CI = \frac{||\vec{u}\wedge\vec{AC}||}{||\vec{u}||} (3)</p><p id="r-475222" data-claire-element-id="475222">Nous nous sommes débarrassé de l'angle. Nous n'avons plus qu'un produit vectoriel et 2 normes à calculer. Un produit vectoriel considère des vecteurs dans l'espace. Cependant, nous sommes dans le plan, donc c'est comme si nous étions dans l'espace, mais que les coordonnées z des vecteurs étaient à 0.<br/> A partir de la, la norme d'un produit vectoriel sera un vecteur \vec{v}dont les composantes x et y seront nulles, et seule sa composante z sera non nulle. Prendre la norme de ce vecteur reviendra à prendre la valeur absolue de cette composante z, comme ceci :</p><p id="r-475223" data-claire-element-id="475223">\vec{v} = \vec{u}\wedge\vec{AC} = \left( \begin{array}{c}u_x \\u_y \\0 \\\end{array} ight)\wedge\left( \begin{array}{c}AC_x \\AC_y \\0 \\\end{array} ight)=\left( \begin{array}{c}0 \\0 \\u_x*AC_y - u_y*AC_x \\\end{array} ight)</p><p id="r-475224" data-claire-element-id="475224">et donc, dans notre cas : <br/>||\vec{u}\wedge\vec{AC}|| = ||\vec{v}|| = |u_x*AC_y - u_y*AC_x|</p><p id="r-475225" data-claire-element-id="475225">Il suffira de diviser cette valeur absolue par la norme de u pour obtenir CI.</p><p id="r-475226" data-claire-element-id="475226">Et il nous suffira donc de savoir si CI est plus grand que le rayon ou non... Voici le code pour tester si le cercle C touche la droite AB :</p><pre id="r-475227" data-claire-element-id="475227"><code data-claire-semantic="c">bool CollisionDroite(Point A,Point B,Cercle C)
{
   Vecteur u;
   u.x = B.x - A.x;
   u.y = B.y - A.y;
   Vecteur AC;
   AC.x = C.x - A.x;
   AC.y = C.y - A.y;
   float numerateur = u.x*AC.y - u.y*AC.x;   // norme du vecteur v
   if (numerateur &lt;0)
      numerateur = -numerateur ;   // valeur absolue ; si c'est négatif, on prend l'opposé.
   float denominateur = sqrt(u.x*u.x + u.y*u.y);  // norme de u
   float CI = numerateur / denominateur;
   if (CI&lt;C.rayon)
      return true;
   else
      return false;
}</code></pre><h6 id="r-restriction-au-segment" data-claire-element-id="475247">Restriction au segment</h6><figure id="r-475230" data-claire-element-id="475231"><img id="r-475229" data-claire-element-id="475229" src="medias/uploads.siteduzero.com_files_236001_237000_236213.png" alt="Image utilisateur"/></figure><aside id="r-475233" data-claire-element-id="475233" data-claire-semantic="information"><p id="r-475232" data-claire-element-id="475232">Tout d'abord, si le cercle ne touche pas la droite (AB), il ne touchera jamais le segment [AB]. Ensuite, si le cercle touche la droite, il touchera le segment si le point d'intersection I est entre A et B (cas 2 ci dessus), mais aussi si A ou B sont dans le cercle (cas 3 contre cas 1 ci-dessus)</p></aside><p id="r-475234" data-claire-element-id="475234">Pour le test d'un point dans un cercle, je vous renvoie au début de ce tutoriel.</p><p id="r-475235" data-claire-element-id="475235">Alors l'idée est de savoir si I est entre A et B.</p><figure id="r-475237" data-claire-element-id="475238"><img id="r-475236" data-claire-element-id="475236" src="medias/uploads.siteduzero.com_files_236001_237000_236226.png" alt="Image utilisateur"/></figure><p id="r-475239" data-claire-element-id="475239">Pour cela, nous allons utiliser le produit scalaire, rapide, et qui a des propriétés bien sympathiques. Regardez le dessin de gauche.<br/> J'ai les points A,B qui me donnent un vecteur \vec{AB}, qui part de A.<br/> Au point A, on imagine une frontière verte, orthogonale au vecteur. Si on appelle P l'un des points (rouge ou bleu), le signe du produit scalaire \vec{AB}.\vec{AP} nous permet de savoir de quel coté de la ligne verte on est. Si le produit scalaire est positif, on est du coté de B, sinon, on est de l'autre coté.</p><aside id="r-475241" data-claire-element-id="475241" data-claire-semantic="information"><p id="r-475240" data-claire-element-id="475240">Cette astuce est fort utile dans les jeux vidéos. Imaginons que vous soyez un héro au point A, que vous regardez en direction du point B. Un monstre arrive (c'est un point P). Comme savoir si le monstre est devant vous ou derrière vous ? \vec{AB}.\vec{AP}... Et ainsi selon que le signe de ce produit scalaire est positif ou non, vous voyez le monstre ou non.</p></aside><p id="r-475242" data-claire-element-id="475242">Maintenant, nous voulons savoir si I est entre A et B. Regardons le dessin de droite ci-dessus. Comme I est le projeté orthogonal de C sur la droite, alors pour savoir si I est entre A et B, il suffit de regarder si C est dans la bande verte ou non. Pour cela, on applique 2 produits scalaires :</p><p id="r-475243" data-claire-element-id="475243">pscal1 = \vec{AB}.\vec{AC}pscal2 = \vec{BA}.\vec{BC}</p><p id="r-475244" data-claire-element-id="475244">Si pscal1&gt;0 ET pscal2&gt;0, alors C est dans la bande verte, et donc I entre A et B.</p><p id="r-475245" data-claire-element-id="475245">Cela nous donne la fonction suivante :</p><pre id="r-475246" data-claire-element-id="475246"><code data-claire-semantic="c">bool CollisionSegment(Point A,Point B,Cercle C)
{
   if (CollisionDroite(A,B,C) == false)
     return false;  // si on ne touche pas la droite, on ne touchera jamais le segment
   Vecteur AB,AC,BC;
   AB.x = B.x - A.x;
   AB.y = B.y - A.y;
   AC.x = C.x - A.x;
   AC.y = C.y - A.y;
   BC.x = C.x - B.x;
   BC.y = C.y - B.y;
   float pscal1 = AB.x*AC.x + AB.y*AC.y;  // produit scalaire
   float pscal2 = (-AB.x)*BC.x + (-AB.y)*BC.y;  // produit scalaire
   if (pscal1&gt;=0 &amp;&amp; pscal2&gt;=0)
      return true;   // I entre A et B, ok.
   // dernière possibilité, A ou B dans le cercle
   if (CollisionPointCercle(A,C))
     return true;
   if (CollisionPointCercle(B,C))
     return true;
   return false;
}</code></pre><h6 id="r-le-point-d-impact" data-claire-element-id="475261">Le point d'impact</h6><p id="r-475248" data-claire-element-id="475248">Actuellement, nous avons une information sur l'entrée en collision ou non. Mais il peut être utile de savoir à quel endroit on touche. On touche au point I bien entendu, mais comment calculer I ?</p><p id="r-475249" data-claire-element-id="475249">Nous avons vu que notre droite a pour équation : P(t) = A + t*\vec{u} (avec \vec{u} = \vec{AB} dans notre cas)<br/> I appartient à la droite, donc il existe t_i tel que :<br/>I = A + t_i*\vec{u} (5)</p><p id="r-475250" data-claire-element-id="475250">Si on regarde le triangle AIC rectangle en I, de nouveau, avec un peu de trigonométrie, on trouve :</p><p id="r-475251" data-claire-element-id="475251">cos(a) = \frac{AI}{AC}, avec a angle au sommet A.<br/>AI = AC*cos(a) (6)</p><p id="r-475252" data-claire-element-id="475252">Ici, il est astucieux de considéder la formule suivante du <a href="http://fr.wikipedia.org/wiki/Produit_scalaire">produit scalaire</a>.</p><p id="r-475253" data-claire-element-id="475253">\vec{u}.\vec{AC} = ||\vec{u}||*||\vec{AC}||*cos(a) (7)<br/> Sachant que ||\vec{AC}|| = AC</p><p id="r-475254" data-claire-element-id="475254">En utilisant (6) et (7), on trouve :<br/>AI = \frac{\vec{u}.\vec{AC}}{||\vec{u}||}</p><p id="r-475255" data-claire-element-id="475255">Si on veut t_i, il faut diviser par la norme de u. Cela donne :<br/>t_i= \frac{\vec{u}.\vec{AC}}{||\vec{u}||^2}</p><p id="r-475256" data-claire-element-id="475256">Cela nous épargnera, au niveau optimisation, de calculer la racine carrée de la norme de u puisqu'on la considère au carré.</p><p id="r-475257" data-claire-element-id="475257">Nous obtenons la formule finale suivante :</p><p id="r-475258" data-claire-element-id="475258">I = A + \frac{\vec{u}.\vec{AC}}{||\vec{u}||^2}*\vec{u}</p><p id="r-475259" data-claire-element-id="475259">Au niveau du code nous avons donc une droite (AB), et un point C à projeter :</p><pre id="r-475260" data-claire-element-id="475260"><code data-claire-semantic="c">Point ProjectionI(Point A,Point B,Point C)
{
  Vecteur u,AC;
  u.x = B.x - A.x; 
  u.y = B.y - A.y; 
  AC.x = C.x - A.x;
  AC.y = C.y - A.y;
  float ti = (u.x*AC.x + u.y*AC.y)/(u.x*u.x + u.y*u.y);
  Point I;
  I.x = A.x + ti*u.x;
  I.y = A.y + ti*u.y;
  return I;
}</code></pre><h6 id="r-la-normale" data-claire-element-id="475268">La normale</h6><p id="r-475262" data-claire-element-id="475262">La normale est le vecteur orthogonal à la tangente qui &quot;regarde&quot; le point C. Avoir la normale au point d'impact permet de calculer un rebond par exemple.<br/> Sur une droite, la normale est constante en tout point.</p><p id="r-475263" data-claire-element-id="475263">On utilise souvent le produit vectoriel pour calculer des normales. Ici, on fera pareil, en utilisant deux produits vectoriels, un pour calculer un vecteur v orthogonal a notre plan \vec{v} = \vec{u}\wedge\vec{AC} , puis on refera un autre produit vectoriel pour trouver notre normale n \vec{n} = \vec{v}\wedge\vec{u}.<br/> L'avantage de cette méthode, c'est que la normale &quot;regardera&quot; toujours C, qu'il soit d'un coté ou de l'autre de la droite.<br/> Cet algo fonctionne aussi dans l'espace, pour trouver le vecteur \vec{IC}.</p><p id="r-475264" data-claire-element-id="475264">Si on appliques les formules des deux produits vectoriels, on trouve simplement, pour la normale :<br/>N_x = -u_y*(u_x*AC_y-u_y*AC_x)N_y = u_x*(u_x*AC_y-u_y*AC_x)</p><p id="r-475265" data-claire-element-id="475265">Il est d'usage qu'une normale soit normalisée... autrement dit que sa norme (sa longueur) soit 1. Il suffit de diviser N par sa norme :<br/>\vec{N}_{normalise} = \frac{\vec{N}}{||\vec{N}||}</p><p id="r-475266" data-claire-element-id="475266">Au niveau du code, cela nous donne la chose suivante :</p><pre id="r-475267" data-claire-element-id="475267"><code data-claire-semantic="c">Vecteur GetNormale(Point A,Point B,Point C)
{
  Vecteur AC,u,N;
  u.x = B.x - A.x;  
  u.y = B.y - A.y;
  AC.x = C.x - A.x;  
  AC.y = C.y - A.y;
  float parenthesis = u.x*AC.y-u.y*AC.x;  // calcul une fois pour les deux
  N.x = -u.y*(parenthesis);
  N.y = u.x*(parenthesis);
  // normalisons
  float norme = sqrt(N.x*N.x + N.y*N.y);
  N.x/=norme;
  N.y/=norme;
  return N;
}</code></pre><h6 id="r-une-utilisation-de-tout-ca-le-rebond" data-claire-element-id="475284">Une utilisation de tout ça : le rebond</h6><p id="r-475269" data-claire-element-id="475269">Voici une utilisation pratique de tout ça : un calcul de rebond. Un jeu de flipper par exemple : votre balle arrive sur un mur en biais, vous voulez calculer le rebond : dans quel sens va-t-elle repartir ?</p><figure id="r-475271" data-claire-element-id="475272"><img id="r-475270" data-claire-element-id="475270" src="medias/uploads.siteduzero.com_files_236001_237000_236242.png" alt="Image utilisateur"/></figure><p id="r-475273" data-claire-element-id="475273">Regardons le dessin ci-dessus. La balle (qu'on ne voit pas) arrive avec une trajectoire suivant le vecteur v rouge (de A vers I)<br/> Après rebond, il faudra qu'elle reparte avec la trajectoire v_2 violet, de I vers B.</p><p id="r-475274" data-claire-element-id="475274">Nous calculons grâce à la fonction de collision si on touche la droite. Ensuite, si on touche, il faut faire rebondir. Pour cela, on aura besoin de la normale (en bleu) au segment (qu'on calculera comme vu au dessus).</p><p id="r-475275" data-claire-element-id="475275">Le vecteur v_2 est tel que la normale soit la <strong>bissectrice </strong> des vecteurs v et v_2 au point I. Sur le dessin, j'ai mis les angles égaux.</p><p id="r-475276" data-claire-element-id="475276">J est le projeté orthogonal de A sur la droite faite par le point I et la normale.<br/> Le vecteur v_3 est le même que le vecteur v_2, en partant de A au lieu de I, mais c'est le même vecteur.<br/> Géométriquement, on peut démontrer que J est le milieu de [IK], et J est aussi le milieu de [AB].</p><p id="r-475277" data-claire-element-id="475277">Le vecteur \vec{N} est normalisé : rappelez vous, les normales sont normalisées.</p><p id="r-475278" data-claire-element-id="475278">La longueur IJ (qu'on pourra aussi appeler d) s'obtient à partir d'un produit scalaire :</p><p id="r-475279" data-claire-element-id="475279">d = IJ = \vec{IA}.\vec{N} = - \vec{AI}.\vec{N} (7)<br/> Je considère IA et non AI pour avoir une longueur positive.</p><p id="r-475280" data-claire-element-id="475280">On veut calculer le vecteur \vec{IB}, donc \vec{AK}<br/> Géométriquement : <br/>\vec{AK} = (K) - (A) = (I + 2*d*\vec{N}) - (I - \vec{AI})<br/> On simplifie : <br/>\vec{AK} = 2*d*\vec{N} + \vec{AI}</p><p id="r-475281" data-claire-element-id="475281">En injectant (7), je trouve :<br/>\vec{AK} = 2*(- \vec{AI}.\vec{N})*\vec{N} + \vec{AI} \\ = \vec{AI} - 2*(\vec{AI}.\vec{N})*\vec{N}</p><p id="r-475282" data-claire-element-id="475282">Enfin, un petit code pour terminer cette grande partie. On donne le vecteur v (= \vec{AI}) incident, et la normale, et on calculera le vecteur de rebond :</p><pre id="r-475283" data-claire-element-id="475283"><code data-claire-semantic="c">Vecteur CalculerVecteurV2(Vecteur v,Vecteur N)
{
  Vecteur v2;
  float pscal = (v.x*N.x +  v.y*N.y);
  v2.x = v.x -2*pscal*N.x;
  v2.y = v.y -2*pscal*N.y;
  return v2;
}</code></pre>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
<span class="arrow"></span>
<span class="next">Point dans polygone</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
<span class="next">Segment Segment</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="SegmentSegment"></a><h2>Segment Segment</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
<span class="arrow"></span>
<span class="next">Segment cercle</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
<span class="next">Cercles-AABB</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-segment-segment" data-claire-element-id="475372">Segment Segment</h4><p id="r-475287" data-claire-element-id="475287">Voici maintenant une collision Segment-Segment.</p><h5 id="r-pourquoi-cette-collision" data-claire-element-id="475296">Pourquoi cette collision ?</h5><p id="r-475288" data-claire-element-id="475288">Nous pouvons penser que ce genre n'est pas trop utilisée, car un personnage est rarement représenté par un segment. Il peut être représenté par un point, par une AABB, un polygone, un cercle... Mais rarement un segment.</p><p id="r-475289" data-claire-element-id="475289">Cependant, en raisonnant comme cela, vous pensez à un état <strong>figé</strong>.</p><p id="r-475290" data-claire-element-id="475290">Maintenant, regardez ce schéma :</p><figure id="r-475292" data-claire-element-id="475293"><img id="r-475291" data-claire-element-id="475291" src="medias/uploads.siteduzero.com_files_239001_240000_239247.png" alt="Image utilisateur"/></figure><p id="r-475294" data-claire-element-id="475294">Votre personnage est le point O. Il y a un mur, représenté par le segment AB. Il veut avancer vers le point P (donc selon le vecteur OP). Se prend-il le mur ?</p><p id="r-475295" data-claire-element-id="475295">Pour le savoir, nous regarderons la collision entre les segments [AB] et [OP].</p><h5 id="r-applications-9" data-claire-element-id="475312">Applications</h5><figure id="r-475298" data-claire-element-id="475299"><img id="r-475297" data-claire-element-id="475297" src="medias/uploads.siteduzero.com_files_239001_240000_239252.jpg" alt="Image utilisateur"/></figure><figure id="r-475301" data-claire-element-id="475302"><img id="r-475300" data-claire-element-id="475300" src="medias/uploads.siteduzero.com_files_239001_240000_239253.gif" alt="Image utilisateur"/></figure><div id="r-475304" data-claire-element-id="475304" data-claire-semantic="question"><p id="r-475303" data-claire-element-id="475303">Quoi ? Un jeu 3D comme Doom dans la rubrique 2D ? o_O</p></div><p id="r-475305" data-claire-element-id="475305">Oh que oui... Le premier Doom, une merveille, un jeu faussement 3D. Un amas de trapèzes qui nous font penser à la 3D, mais un jeu en interne bien 2D...</p><figure id="r-475307" data-claire-element-id="475308"><img id="r-475306" data-claire-element-id="475306" src="medias/uploads.siteduzero.com_files_239001_240000_239255.png" alt="Image utilisateur"/></figure><p id="r-475309" data-claire-element-id="475309">Quel beau monde en 3D n'est ce pas ? Un beau couloir multicolore... Dites merci à votre cerveau de vous faire voir un monde en 3D, parce que moi je n'ai dessiné que des trapèzes... (un rectangle est un trapèze particulier). Des trapèzes dont les bases sont alignées avec l'axe des Y, bien droit. Voila, dans Doom, tous les murs sont des trapèzes. <br/> Mais ça, c'est l'affichage. En réalité, dans Doom, en mémoire, il n'y a qu'une map 2D (comme la 2e image que je présente ici, ces segments rouges et jaunes (mais pas à petits pois, la génération Dorothée comprendra la blague).</p><p id="r-475310" data-claire-element-id="475310">Donc dans Doom, le personnage est un point dans une carte 2D faite de plein plein de segments qui représentent les murs.</p><p id="r-475311" data-claire-element-id="475311">Nous sommes donc tout à fait dans le cas vu plus haut, à savoir que nous sommes un point O, nous voulons avancer vers P. Touchons nous le segment [AB] ?</p><h5 id="r-calcul-de-collision-4" data-claire-element-id="475371">Calcul de collision</h5><p id="r-475313" data-claire-element-id="475313">Nous allons Calculer cette collision en 2 étapes :</p><aside id="r-475315" data-claire-element-id="475315" data-claire-semantic="information"><p id="r-475314" data-claire-element-id="475314">Tout d'abord, il peut y avoir collision seulement si O et P ne sont pas du même coté de la droite (AB).</p></aside><p id="r-475316" data-claire-element-id="475316">En effet, si P et O sont du même coté de la droite (AB), on peut tout de suite dire &quot;il n'y aura pas collision&quot;. On peut donc calculer la collision entre le segment [OP] et la droite (AB)</p><h6 id="r-calcul-de-collision-entre-segment-et-droite" data-claire-element-id="475344">Calcul de collision entre segment et droite</h6><p id="r-475317" data-claire-element-id="475317">Rappelez vous le calcul du déterminant de 2 vecteurs qui me dit si un point est &quot;à gauche&quot; ou &quot;à droite&quot; d'une droite. Si on considère le vecteur AB, et le vecteur AP, le déterminant de d = \det(\vec{AB},\vec{AP}) me dit si mon point P est à gauche ou à droite du mur (en considérant le mur comme &quot;démarrant&quot; au point A et &quot;regardant&quot; le point B.</p><ul id="r-475324" data-claire-element-id="475324"><li id="r-475319" data-claire-element-id="475319"><p id="r-475318" data-claire-element-id="475318">Si (d&gt;0), P est à gauche</p></li><li id="r-475321" data-claire-element-id="475321"><p id="r-475320" data-claire-element-id="475320">si (d&lt;0), P est à droite</p></li><li id="r-475323" data-claire-element-id="475323"><p id="r-475322" data-claire-element-id="475322">si (d==0), P est dans le mur : on va éviter ce cas la.</p></li></ul><p id="r-475325" data-claire-element-id="475325">On va partir du principe que P n'est jamais dans le mur. En effet, dans un jeu comme Doom, on commence hors d'un mur, et quand on évolue, on ne permet pas d'aller &quot;dans&quot; le mur. On permet d'aller proche, mais jamais dedans. Donc on n'est jamais &quot;dans&quot; un mur. Donc d n'est jamais égale à 0.</p><p id="r-475326" data-claire-element-id="475326">Maintenant, on calcule le déterminant d_P = \det(\vec{AB},\vec{AP}) et d_O = \det(\vec{AB},\vec{AO}) pour savoir de quel coté sont P et O.</p><ul id="r-475335" data-claire-element-id="475335"><li id="r-475328" data-claire-element-id="475328"><p id="r-475327" data-claire-element-id="475327">Si d_P&gt;0 et d_O&gt;0 alors ils sont du meme coté</p></li><li id="r-475330" data-claire-element-id="475330"><p id="r-475329" data-claire-element-id="475329">Si d_P&lt;0 et d_O&lt;0 alors ils sont du meme coté</p></li><li id="r-475332" data-claire-element-id="475332"><p id="r-475331" data-claire-element-id="475331">Si d_P&gt;0 et d_O&lt;0 alors ils ne sont pas du même coté</p></li><li id="r-475334" data-claire-element-id="475334"><p id="r-475333" data-claire-element-id="475333">Si d_P&lt;0 et d_O&gt;0 alors ils ne sont pas du même coté</p></li></ul><p id="r-475336" data-claire-element-id="475336">ça nous fait 4 conditions à voir, sauf si on pense aux propriétés de la multiplication, qui vont nous simplifier le travail :</p><ul id="r-475341" data-claire-element-id="475341"><li id="r-475338" data-claire-element-id="475338"><p id="r-475337" data-claire-element-id="475337">Si d_P * d_O &gt;0 alors ils sont du meme coté</p></li><li id="r-475340" data-claire-element-id="475340"><p id="r-475339" data-claire-element-id="475339">Si d_P * d_O &lt;0 alors ils ne sont pas du meme coté</p></li></ul><p id="r-475342" data-claire-element-id="475342">Au niveau du code, cela donne ceci :</p><pre id="r-475343" data-claire-element-id="475343"><code data-claire-semantic="c">bool CollisionDroiteSeg(Point A,Point B,Point O,Point P)
{
  Vecteur AO,AP,AB;
  AB.x = B.x - A.x;
  AB.y = B.y - A.y;
  AP.x = P.x - A.x;
  AP.y = P.y - A.y;
  AO.x = O.x - A.x;
  AO.y = O.y - A.y;
  if ((AB.x*AP.y - AB.y*AP.x)*(AB.x*AO.y - AB.y*AO.x)&lt;0)
     return true;
  else
     return false;
}</code></pre><h6 id="r-calcul-de-collision-entre-segment-et-segment" data-claire-element-id="475348">Calcul de collision entre segment et segment</h6><p id="r-475345" data-claire-element-id="475345">Une idée simple pour calculer la collision entre segment et segment est de se servir deux fois de la formule ci dessus.<br/> Si vous avez 4 points ABOP, que vous voulez calculer la collision entre le segment [AB] et le segment [OP], il suffit de calculer la collision entre la droite (AB) et le segment [OP], puis la collision entre la droite (OP) et le segment [AB]. Si les deux collisions sont valides, alors les segments se touchent.</p><p id="r-475346" data-claire-element-id="475346">Au niveau du code, cela donne :</p><pre id="r-475347" data-claire-element-id="475347"><code data-claire-semantic="c">bool CollisionSegSeg(Point A,Point B,Point O,Point P)
{
  if (CollisionDroiteSeg(A,B,O,P)==false)
     return false;  // inutile d'aller plus loin si le segment [OP] ne touche pas la droite (AB)
  if (CollisionDroiteSeg(O,P,A,B)==false)
     return false;
  return true;
}</code></pre><h6 id="r-calcul-de-collision-entre-segment-et-segment-forme-parametrique" data-claire-element-id="475365">Calcul de collision entre segment et segment, forme paramétrique</h6><p id="r-475349" data-claire-element-id="475349">Cette méthode est plus complexe que la précédente, mais permettra de calculer le point d'intersection.<br/> Grâce au calcul segment/droite, on sait que les points O et P sont de part et d'autre de la droite (AB), mais il y a collision segment/segment seulement si le point d'intersection I est entre A et B. Sinon, le personnage passe à coté du mur : il n'y a pas collision.</p><p id="r-475350" data-claire-element-id="475350">Nous allons donc voir si l'intersection est entre A et B ou non. De cette condition dépendra notre collision.</p><p id="r-475351" data-claire-element-id="475351">Posons la forme paramétrique de la droite (AB) :<br/>I = A + k*\vec{AB}</p><p id="r-475352" data-claire-element-id="475352">Avec cette forme, nous pouvons affirmer que I est entre A et B si et seulement si 0&lt;=k&lt;=1</p><p id="r-475353" data-claire-element-id="475353">Il ne reste plus qu'à trouver k.</p><p id="r-475354" data-claire-element-id="475354">I appartient également à la droite (OP), donc :<br/>I = O + l*\vec{OP}</p><p id="r-475355" data-claire-element-id="475355">Du coup, on peut écrire :</p><p id="r-475356" data-claire-element-id="475356">A + k*\vec{AB} = O + l*\vec{OP}</p><p id="r-475357" data-claire-element-id="475357">Nous sommes dans le plan, nous pouvons décomposer les points et les vecteurs comme suite :</p><p id="r-475358" data-claire-element-id="475358">\left \{\begin{array}. A_x + k*\vec{AB_x} = O_x + l*\vec{OP_x} \\ A_y + k*\vec{AB_y} = O_y + l*\vec{OP_y} \\\end{array} ight.</p><p id="r-475359" data-claire-element-id="475359">Nous avons donc 2 équations, et 2 inconnues (k et l).<br/> Si nous résolvons ce système, nous obtenons :</p><p id="r-475360" data-claire-element-id="475360">k=-{\frac {A_{{x}}{\it OP}_{{y}}-O_{{x}}{\it OP}_{{y}}-{\it OP}_{{x}}A_{{y}}+{\it OP}_{{x}}O_{{y}}}{{\it AB}_{{x}}{\it OP}_{{y}}-{\it AB}_{{y}}{\it OP}_{{x}}}}</p><p id="r-475361" data-claire-element-id="475361">l=-{\frac {-{\it AB}_{{x}}A_{{y}}+{\it AB}_{{x}}O_{{y}}+{\it AB}_{{y}}A_{{x}}-{\it AB}_{{y}}O_{{x}}}{{\it AB}_{{x}}{\it OP}_{{y}}-{\it AB}_{{y}}{\it OP}_{{x}}}}</p><p id="r-475362" data-claire-element-id="475362">Notez que pour notre cas, nous n'avons pas besoin de l. Je le mets quand même car on en aura besoin plus loin si on veut s'approcher au plus près du mur.</p><p id="r-475363" data-claire-element-id="475363">Voici la fonction de Collision Segment-Segment :</p><pre id="r-475364" data-claire-element-id="475364"><code data-claire-semantic="c">bool CollisionSegSeg(Point A,Point B,Point O,Point P)
{
  if (CollisionDroiteSeg(A,B,O,P)==false)
     return false;  // inutile d'aller plus loin si le segment [OP] ne touche pas la droite (AB)
  Vecteur AB,OP;
  AB.x = B.x - A.x;
  AB.y = B.y - A.y;
  OP.x = P.x - O.x;
  OP.y = P.y - O.y;
  float k = -(A.x*OP.y-O.x*OP.y-OP.x*A.y+OP.x*O.y)/(AB.x*OP.y-AB.y*OP.x);
  if (k&lt;0 || k&gt;1)
     return false;
  else
     return true;
}</code></pre><h6 id="r-ne-pas-aller-dans-le-mur" data-claire-element-id="475370">Ne pas aller dans le mur</h6><p id="r-475366" data-claire-element-id="475366">Pour terminer ce chapitre, quelques idées pour éviter de se retrouver dans le mur.<br/> Si vous êtes le point O et que vous allez vers le mur, alors il y aura collision. L'idée est d'avancer quand même &quot;jusqu'au mur&quot;.</p><p id="r-475367" data-claire-element-id="475367">Comme nous allons dans le mur, nous ne déplacerons pas notre joueur selon le vecteur \vec{OP}, qui nous amènerait au dela du mur (au point P).<br/> Nous ne le déplacerons pas non plus selon le vecteur l*\vec{OP}, qui nous amènerait dans le mur exactement (ce que nous voulons absolument éviter, il ne faut jamais être &quot;dans&quot; le mur)<br/> Nous déplacerons le joueur selon le vecteur (l-e)*\vec{OP} ou e est un nombre positif très petit (un &quot;epsilon&quot; dit-on dans le jargon mathématique), par exemple 0.001 <br/> Ainsi, nous nous approcherons au plus près du mur, sans être dedans, ni passer à travers.</p><aside id="r-475369" data-claire-element-id="475369" data-claire-semantic="information"><p id="r-475368" data-claire-element-id="475368">Bien que ce genre d'algorithme pourrait marcher avec des nombres entiers, (dans N²) en faisant attention aux arrondis, il est préférable d'utiliser des coordonnées réelles (dans R²) pour cet algorithme.</p></aside>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
<span class="arrow"></span>
<span class="next">Segment cercle</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
<span class="next">Cercles-AABB</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Cercles-AABB"></a><h2>Cercles-AABB</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
<span class="arrow"></span>
<span class="next">Segment Segment</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">
<span class="next">Collisions au pixel près</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-cercles-aabb" data-claire-element-id="475426">Cercles-AABB</h4><p id="r-475373" data-claire-element-id="475373">Nous cherchons maintenant à déterminer la collision entre un cercle et une AABB.</p><p id="r-475374" data-claire-element-id="475374">Cette collision pourra, dans certains cas tordus, être un peu calculatoire.<br/> C'est pour cela que l'idée sera d'éliminer le plus rapidement possible les cas triviaux. <br/> Comme ces cas seront majoritaires, la collision sera en moyenne très rapide.</p><p id="r-475375" data-claire-element-id="475375">Regardons le schéma suivant :</p><figure id="r-475377" data-claire-element-id="475378"><img id="r-475376" data-claire-element-id="475376" src="medias/uploads.siteduzero.com_files_350001_351000_350472.png" alt="Image utilisateur"/></figure><p id="r-475379" data-claire-element-id="475379">Je souhaite tester la collision entre le cercle vert, et la AABB rouge.</p><p id="r-475380" data-claire-element-id="475380">Première étape, le cercle peut être lui même inscrit dans une AABB, que l'on peut calculer facilement. <br/> Mieux, si votre <em>sprite</em> est une balle, sa surface porteuse sera rectangulaire, et sera directement la AABB violette : vous n'aurez donc même pas à la calculer, il suffira de passer la surface porteuse !</p><h6 id="r-premier-test-1" data-claire-element-id="475389">Premier test</h6><p id="r-475381" data-claire-element-id="475381">Premier test, nous allons tester la collision AABB vs AABB de nos deux AABB rouge et violette. Ce test est rapide, et élimine déjà tous les cas ou les objets sont suffisamment loin. <br/> En effet, s'il n'y a pas collision entre ces deux AABB, inutile d'aller plus loin : il n'y a pas collision.</p><aside id="r-475383" data-claire-element-id="475383" data-claire-semantic="information"><p id="r-475382" data-claire-element-id="475382">Vous éliminez ici d'entrée la grande majorité des cas ! :)</p></aside><p id="r-475384" data-claire-element-id="475384">S'il y a collision AABB, alors nous sommes dans l'un de ces cas :</p><figure id="r-475386" data-claire-element-id="475387"><img id="r-475385" data-claire-element-id="475385" src="medias/uploads.siteduzero.com_files_350001_351000_350474.png" alt="Image utilisateur"/></figure><p id="r-475388" data-claire-element-id="475388">Nous allons continuer à éliminer rapidement les cas triviaux :</p><h6 id="r-deuxieme-test" data-claire-element-id="475391">Deuxième test</h6><p id="r-475390" data-claire-element-id="475390">Nous allons voir si un des sommets de la AABB rouge est dans le cercle, grâce à la collision rapide &quot;Point dans Cercle&quot; vue plus haut.<br/> Nous pourrons alors dire qu'il y a collision dans les cas A et D, et sortir de l'algorithme.</p><h6 id="r-troisieme-test" data-claire-element-id="475394">Troisième test</h6><p id="r-475392" data-claire-element-id="475392">Afin de détecter le cas C, nous allons faire une collision &quot;Point dans AABB&quot; sur le centre du cercle et la AABB rouge. Nous pouvons alors sortir de l'algorithme dans ce cas.</p><p id="r-475393" data-claire-element-id="475393">A partir d'ici, cela devient plus calculatoire : nous sommes soit dans le cas B, soit dans le cas E. La bonne nouvelle, c'est que dans la majorité des cas, nous serons sortis avant.</p><h6 id="r-quatrieme-test" data-claire-element-id="475425">Quatrième test</h6><p id="r-475395" data-claire-element-id="475395">Il faut donc lever l'ambiguïté entre le cas B, et le cas E.<br/> La différence entre ces deux cas, se situe au niveau des segments de la AABB.<br/> Nous allons considérer chacun des 4 segments de la AABB.<br/> Pour chacun de ces segments, nous allons projeter le point centre du cercle sur le segment. Si la projection est sur le segment, alors nous sommes dans le cas E, si elle est hors du segment, alors on est dans le cas B.</p><p id="r-475396" data-claire-element-id="475396">Si on regarde le schéma suivant :</p><figure id="r-475398" data-claire-element-id="475399"><img id="r-475397" data-claire-element-id="475397" src="medias/uploads.siteduzero.com_files_350001_351000_350476.png" alt="Image utilisateur"/></figure><p id="r-475400" data-claire-element-id="475400">Nous avons le segment AB. Nous projetons un point dessus, soit le rouge, soit le vert, soit le bleu. Seul le vert est projeté sur le segment, les deux autres sont hors du segment.<br/> Cela signifie que le point vert est entre les deux droites bleu ciel, droites passant respectivement par A et B et perpendiculaires au segment AB.</p><p id="r-475401" data-claire-element-id="475401">Pour déterminer si le point sera projeté sur le segment ou dehors, c'est assez simple. <br/> Soit C le point à tester. Nous allons considérer les produits scalaires suivants :</p><p id="r-475402" data-claire-element-id="475402">s1 = \vec{AC}.\vec{AB}s2 = \vec{BC}.\vec{AB}</p><p id="r-475403" data-claire-element-id="475403">Le signe de ces produits scalaires va nous donner immédiatement la réponse :</p><ul id="r-475412" data-claire-element-id="475412"><li id="r-475405" data-claire-element-id="475405"><p id="r-475404" data-claire-element-id="475404">Si s1&gt;0 et s2&gt;0, alors nous sommes hors du segment, coté B (point bleu) ;</p></li><li id="r-475407" data-claire-element-id="475407"><p id="r-475406" data-claire-element-id="475406">Si s1&lt;0 et s2&lt;0, alors nous sommes hors du segment, coté A (point rouge) ;</p></li><li id="r-475409" data-claire-element-id="475409"><p id="r-475408" data-claire-element-id="475408">Si s1&gt;0 et s2&lt;0, alors nous sommes dans le segment (point vert) ;</p></li><li id="r-475411" data-claire-element-id="475411"><p id="r-475410" data-claire-element-id="475410">Si s1&lt;0 et s2&gt;0, alors nous avons un grave problème mathématique.... Ce cas n'existe pas !</p></li></ul><p id="r-475413" data-claire-element-id="475413">Évidemment, nous avons aussi les cas limites où s1==0, s2==0.</p><p id="r-475414" data-claire-element-id="475414">Mais pour simplifier, basons-nous sur la règle des signes :</p><ul id="r-475419" data-claire-element-id="475419"><li id="r-475416" data-claire-element-id="475416"><p id="r-475415" data-claire-element-id="475415">si s1*s2&gt;0, on est dehors ;</p></li><li id="r-475418" data-claire-element-id="475418"><p id="r-475417" data-claire-element-id="475417">sinon, on est dedans.</p></li></ul><p id="r-475420" data-claire-element-id="475420">Vous pouvez remplacer &gt;0 par &gt;=0 si vous considérez le segment comme ouvert : ]AB[ au lieu de [AB].</p><p id="r-475421" data-claire-element-id="475421">Après avoir fait ces projections sur les 4 segments de la AABB (en réalité, 2 suffisent car les segments sont parallèles et &quot;en face&quot; 2 à 2) ; si les points calculés sont tous dehors, nous sommes dans le cas B (pas de collision), sinon nous sommes dans le cas E (collision).</p><p id="r-475422" data-claire-element-id="475422">Et pour finir, petit algorithme formel pour illustrer :</p><pre id="r-475423" data-claire-element-id="475423"><code data-claire-semantic="c">bool CollisionCercleAABB(Cercle C1,AABB box1)
{
   AABB boxCercle = GetBoxAutourCercle(C1);  // retourner la bounding box de l'image porteuse, ou calculer la bounding box.
   if (CollisionAABBvsAABB(box1,boxCercle)==0)
      return false;   // premier test
   if (CollisionPointCercle(box1.x,box1.y,C1)==1
    || CollisionPointCercle(box1.x,box1.y+box1.h,C1)==1
    || CollisionPointCercle(box1.x+box1.w,box1.y,C1)==1
    || CollisionPointCercle(box1.x+box1.w,box1.y+box1.h,C1)==1)
      return true;   // deuxieme test
   if (CollisionPointAABB(C1.x,C1.y,box1)==1)
      return true;   // troisieme test
   int projvertical = ProjectionSurSegment(C1.x,C1.y,box1.x,box1.y,box1.x,box1.y+box1.h);
   int projhorizontal = ProjectionSurSegment(C1.x,C1.y,box1.x,box1.y,box1.x+box1.w,box1.y); 
   if (projvertical==1 || projhorizontal==1)
      return true;   // cas E
   return false;  // cas B   
}

int ProjectionSurSegment(int Cx,int Cy,int Ax,int Ay,int Bx,int By)
{
   int ACx = Cx-Ax;
   int ACy = Cy-Ay; 
   int ABx = Bx-Ax;
   int ABy = By-Ay; 
   int BCx = Cx-Bx;
   int BCy = Cy-By; 
   int s1 = (ACx*ABx) + (ACy*ABy);
   int s2 = (BCx*ABx) + (BCy*ABy); 
   if (s1*s2&gt;0)
     return 0;
   return 1;
}</code></pre><p id="r-475424" data-claire-element-id="475424">Nous verrons avec le temps les collisions d'autres objets complexes.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
<span class="arrow"></span>
<span class="next">Segment Segment</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">
<span class="next">Collisions au pixel près</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Collisionsaupixelprs"></a><h2>Collisions au pixel près</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
<span class="arrow"></span>
<span class="next">Cercles-AABB</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
<span class="next">Utilisation de masques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-475428" data-claire-element-id="475428">Nous allons voir maintenant dans ce chapitre comment déterminer une collision au pixel près.</p>
</div><a name="Utilisationdemasques"></a><h2>Utilisation de masques</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">
<span class="arrow"></span>
<span class="next">Collisions au pixel près</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
<span class="next">Pixel perfect</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-utilisation-de-masques" data-claire-element-id="475470">Utilisation de masques</h4><p id="r-475429" data-claire-element-id="475429">L'utilisation des masques va permettre de détecter des collisions sur des zones de forme quelconques.</p><h5 id="r-definition-61" data-claire-element-id="475439">Définition</h5><p id="r-475430" data-claire-element-id="475430">Au sens strict du terme, on appelle &quot;masque&quot; une image faite de 2 couleurs qui représente un objet de façon monochrome.<br/> Ci dessous par exemple, vous voyez ce cher Véga, à gauche, et la même image qui représente le masque de cette image à droite :</p><figure id="r-475432" data-claire-element-id="475433"><img id="r-475431" data-claire-element-id="475431" src="medias/uploads.siteduzero.com_files_245001_246000_245313.gif" alt="Image utilisateur"/></figure><p id="r-475434" data-claire-element-id="475434">Si vous manipulez SDL par exemple, vous connaissez déjà la notion de masque, même sans forcément en connaître le nom, au moins pour le concept d'affichage.<br/> Avec SDL, ou autre librairie graphique 2D, vous définissez une &quot;keycolor&quot;, c'est à dire une couleur qui sera transparente : si vous affichez Véga, vous ne voulez pas que le noir autour s'affiche, donc vous définirez que la keycolor sera la noir, et la carte graphique n'affichera que les pixels du personnage.</p><p id="r-475435" data-claire-element-id="475435">Si vous manipulez des PNG, ou des images 32 bits, le format permet directement de définir de la transparence pour chaque pixel (alpha channel). Il est d'usage de mettre les pixels qui correspondent à Véga en &quot;opaque&quot; et le noir autour en &quot;complètement transparent&quot;.</p><aside id="r-475437" data-claire-element-id="475437" data-claire-semantic="information"><p id="r-475436" data-claire-element-id="475436">D'une façon ou d'une autre, vous saurez rapidement, pour un pixel donné, si il fait partie de Véga, ou du noir autour, soit en comparant la valeur du pixel avec la keycolor, soit en regardant la transparence du pixel.</p></aside><p id="r-475438" data-claire-element-id="475438">Finalement, pour l'affichage, la machine va afficher uniquement la partie &quot;blanche&quot; si on regarde le masque, donc uniquement Véga.</p><h5 id="r-point-sur-une-image" data-claire-element-id="475454">Point sur une image</h5><p id="r-475440" data-claire-element-id="475440">Si maintenant, vous souhaitez cliquer sur l'image, et savoir si vous cliquez bien sur Véga, au pixel près, et non sur le noir autour, vous considérez la collision &quot;Point sur image&quot;.</p><p id="r-475441" data-claire-element-id="475441">L'idée est très simple : vous cliquez sur l'image. Tout d'abord, il faut savoir si vous cliquez dans la AABB de cette image ou pas. En effet, si vous personnage est à l'autre bout de l'écran par rapport à votre pointeur de souris, inutile d'aller vérifier au pixel près si vous touchez, car ce n'est pas le cas.</p><aside id="r-475443" data-claire-element-id="475443" data-claire-semantic="information"><p id="r-475442" data-claire-element-id="475442">En premier lieu, testez si votre point est dans la AABB, grâce l'algo &quot;point dans AABB&quot; vu plus haut. Si ce n'est pas le cas, il n'y a pas collision. Si c'est le cas, alors on testera au pixel près.</p></aside><p id="r-475444" data-claire-element-id="475444">Considérons la fonction &quot;PixelMaskColor(I,x,y)&quot; qui renverra 1 si le pixel du masque de l'image I à la coordonnée x,y est blanc, 0 s'il est noir.</p><p id="r-475445" data-claire-element-id="475445">Cette fonction dépendra de comment vous codez le bord du personnage :</p><ul id="r-475450" data-claire-element-id="475450"><li id="r-475447" data-claire-element-id="475447"><p id="r-475446" data-claire-element-id="475446">Si vous utilisez une keycolor, il faudra lire le pixel, et le comparer à la keycolor. Si ce pixel est de la même couleur, on renvoie 0, sinon on renvoie 1</p></li><li id="r-475449" data-claire-element-id="475449"><p id="r-475448" data-claire-element-id="475448">Si vous utilisez l'alpha channel, vous regarderez la composante alpha du pixel, et renverrez 0 si le pixel est complètement transparent, 1 sinon</p></li></ul><p id="r-475451" data-claire-element-id="475451">Nous pouvons écrire la fonction suivante :</p><pre id="r-475452" data-claire-element-id="475452"><code data-claire-semantic="c">bool CollisionPixelMasque(Image I,AABB box,int curseur_x,int curseur_y)
{
   if (CollisionPixelAABB(box,curseur_x,curseur_y)==false)
      return false;
   int xlocal = curseur_x - box.x;
   int ylocal = curseur_y - box.y;
   if (PixelMaskColor(I,xlocal,ylocal)==1)
      return true;
   else
      return false;
}</code></pre><p id="r-475453" data-claire-element-id="475453">xlocal et ylocal sont les coordonnées locales du pixel à tester dans l'image I. Par exemple, si votre image démarre à la coordonnée 100,100, et que vous cliquez à la coordonnée 110,110, il est clair qu'il faudra tester les pixels de coordonnée 10,10 dans l'image. 10,10 étant les coordonnées locales du pixel à tester dans le repère de l'image.</p><h5 id="r-masques-multicolores" data-claire-element-id="475469">Masques multicolores</h5><p id="r-475455" data-claire-element-id="475455">Nous pourrons considérer des masques multicolores. Cela pourra être fort utile pour les jeux du genre &quot;point &amp; clic&quot;. Si on regarde les images suivantes, de Day Of The Tentacle :</p><figure id="r-475457" data-claire-element-id="475458"><img id="r-475456" data-claire-element-id="475456" src="medias/uploads.siteduzero.com_files_245001_246000_245309.png" alt="Image utilisateur"/></figure><figure id="r-475460" data-claire-element-id="475461"><img id="r-475459" data-claire-element-id="475459" src="medias/uploads.siteduzero.com_files_245001_246000_245310.png" alt="Image utilisateur"/></figure><p id="r-475462" data-claire-element-id="475462">Le personnage évolue dans des décors farfelus. On peut cliquer sur une porte pour qu'il y aille, cliquer sur le sol pour qu'il se déplace, et également cliquer sur les objets.</p><p id="r-475463" data-claire-element-id="475463">Pour déterminer toutes ces zones à partir d'un masque, une idée est de dessiner 2 images par décor : l'image affichée, et aussi une image faite de zones de couleur, comme l'image de droite.<br/> Pour détecter la collision du pointeur de souris, il suffira de lire le pixel du masque à l'endroit ou on a cliqué. Si je clique sur la zone rouge, Bernard ira vers la porte du fond. Si je clique sur la zone bleue, il ira vers la porte de droite.</p><p id="r-475464" data-claire-element-id="475464">Notez que pour mon exemple, j'ai laissé le reste du décor, alors qu'un masque multicolore aura effacé tout décor, simplifiant au maximum le schéma de la pièce.</p><p id="r-475465" data-claire-element-id="475465">Il faudra donc, quand on dessinera la pièce, dessiner en parallèle le masque multicolore. Cela se fait facilement, il suffit de charger une copie de l'image de la pièce dans un logiciel de dessin, puis de barbouiller de couleurs l'image au bon endroit. Personnellement, j'ai fait l'image de droite avec Paint...</p><p id="r-475466" data-claire-element-id="475466">Ce masque créé sera compact sur le disque, car il contiendra peu de couleurs différentes, donc se compressera bien. Il pourra également prendre peu de place en mémoire, car on pourra stocker chaque pixel sur un octet, voir moins. Si vous avez de la mémoire et que ce concept de stockage vous fait peur, vous pourrez simplement garder l'image multicolore en mémoire comme une autre...</p><aside id="r-475468" data-claire-element-id="475468" data-claire-semantic="information"><p id="r-475467" data-claire-element-id="475467">Il est possible que Day Of The Tentacle n'utilise pas cette technique, mais plutôt des polygones autour des portes, et qu'on aie affaire à des cas de points dans polygones, je ne sais pas. Quoiqu'il en soit, certains jeux de ce style doivent utiliser des masques multicolores.</p></aside>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">
<span class="arrow"></span>
<span class="next">Collisions au pixel près</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
<span class="next">Pixel perfect</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Pixelperfect"></a><h2>Pixel perfect</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
<span class="arrow"></span>
<span class="next">Utilisation de masques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">
<span class="next">Décor</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-pixel-perfect" data-claire-element-id="475500">Pixel perfect</h4><p id="r-475471" data-claire-element-id="475471">Le pixel perfect est un algorithme de collision qui va détecter la collision de 2 objets au pixel près.</p><h5 id="r-concept-3" data-claire-element-id="475489">Concept</h5><p id="r-475472" data-claire-element-id="475472">Le concept n'est pas complexe. Supposons que j'ai 2 objets, 2 personnages par exemple (avec leur masque) :</p><figure id="r-475474" data-claire-element-id="475475"><img id="r-475473" data-claire-element-id="475473" src="medias/uploads.siteduzero.com_files_245001_246000_245313.gif" alt="Image utilisateur"/></figure><figure id="r-475477" data-claire-element-id="475478"><img id="r-475476" data-claire-element-id="475476" src="medias/uploads.siteduzero.com_files_245001_246000_245313.gif" alt="Image utilisateur"/></figure><p id="r-475479" data-claire-element-id="475479">Je veux simplement savoir s'ils se touchent, au pixel près, si leurs zones blanches (dans le masque) se touchent ou non.</p><aside id="r-475481" data-claire-element-id="475481" data-claire-semantic="information"><p id="r-475480" data-claire-element-id="475480">Première optimisation obligatoire, tester s'il y a collisions AABB entre les deux. En effet, ce test est rapide, et élimine tout de suite les cas où les deux images à tester sont loin l'une de l'autre.</p></aside><p id="r-475482" data-claire-element-id="475482">Et si les deux boîtes englobantes se touchent, on va voir si il y a collision réelle, donc si ce sont bien les &quot;parties blanches&quot; qui se touchent.</p><p id="r-475483" data-claire-element-id="475483">Pour cela, nous utiliserons un algorithme très lourd : pour chaque pixel de l'image 1, on regarde si ce pixel est &quot;blanc&quot; sur le masque. Si c'est le cas, on regarde le pixel correspondant sur l'image 2. Si ce pixel est également blanc, il y a collision, sinon, on continue à tester les autres pixels. Il n'y aura pas collision si et seulement si on a tout testé, et que aucun des pixels ne touche la zone blanche de l'image 2.</p><h6 id="r-choix-de-l-ordre-des-images" data-claire-element-id="475485">Choix de l'ordre des images</h6><p id="r-475484" data-claire-element-id="475484">Nous avons dit qu'il fallait prendre une image 1, la parcourir et tester ses pixels par rapport à l'image 2. Afin que l'algorithme soit moins lourd, on prendra comme image 1 l'image la plus petite (celle qui contient le moins de pixels)</p><h6 id="r-complexite-8" data-claire-element-id="475488">Complexité</h6><p id="r-475486" data-claire-element-id="475486">La complexité de cet algorithme dépend directement de la taille de l'image que l'on teste. Plus cette image est grande, plus lourd sera l'algorithme. Nous avons une complexité en O(w*h) avec w et h hauteur et largeur de l'image 1.</p><p id="r-475487" data-claire-element-id="475487">C'est assez lourd. Surtout si on doit tester, à chaque frame, plusieurs collisions.</p><h5 id="r-inconvenients-5" data-claire-element-id="475499">Inconvénients</h5><p id="r-475490" data-claire-element-id="475490">Outre les ressources en calcul assez lourdes, cet algorithme présente beaucoup d'inconvénients.</p><p id="r-475491" data-claire-element-id="475491">Prenons nos 2 Véga, mettons les côte à côte. Puis faisons en sauter un verticalement : le pied sera bloqué par la griffe. On pourra &quot;coincer&quot; un bras entre la jambe et la griffe de l'autre Véga.<br/> Cela complique énormément les choses au niveau programmation, et &quot;coincera&quot; nos personnages de façon gênante au niveau gameplay.</p><p id="r-475492" data-claire-element-id="475492">Si on considère un Zelda vu de haut, on se promène près d'un arbre, et notre bouclier pourra se coincer dans une branche, si un pixel &quot;dépasse&quot; ...</p><p id="r-475493" data-claire-element-id="475493">Ensuite, au niveau animations. Notre Véga, quand il marche, bouge ses jambes. En réalité, et c'est bien la le problème, il ne &quot;déplace&quot; par ses jambes comme dans la réalité, mais c'est un nouveau dessin avec les jambes dessinées à une autre position qui apparaît à la place du premier, comme s'il &quot;téléportait&quot; ses jambes à un autre endroit.</p><p id="r-475494" data-claire-element-id="475494">Du coup, imaginons une pierre posée à ses pieds, entre ses jambes : il n'y a pas collision. Le dessin d'après nous dessine son pied pile sur la pierre : il est <strong>dans </strong>la pierre, ce n'est pas logique, pas acceptable. Pour pallier ce problème, que fait on ? On le décale ? Si la Pierre est assez grosse, on le décale d'un coup de 25 pixels, ça fait un sautement vif bien moche.<br/> Et si en le décalant, ça l'amène sur un mur, que fait on ? On le décale ailleurs ? Et si on ne peut pas, il est coincé à cause d'une petite pierre ?</p><p id="r-475495" data-claire-element-id="475495">Le pixel perfect est selon moi une vraie boîte de Pandore, un nid à ennuis.</p><p id="r-475496" data-claire-element-id="475496">Alors pour des sprites qui ne s'animent pas (une balle par exemple), on n'aura pas les problèmes cités ci dessus, mais n'oublions pas la lourdeur du calcul. Est ce bien nécessaire ? Dans un jeu qui bouge à toute vitesse, est ce que l'exactitude de collisions au pixel près est fondamentale ? <br/> Je pense que dans la plupart des cas non.</p><p id="r-475497" data-claire-element-id="475497">Surement qu'il y a des cas ou c'est obligatoire.</p><p id="r-475498" data-claire-element-id="475498">Voici donc quelques algorithmes de collision au pixel près.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
<span class="arrow"></span>
<span class="next">Utilisation de masques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">
<span class="next">Décor</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Dcor"></a><h2>Décor</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
<span class="arrow"></span>
<span class="next">Pixel perfect</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
<span class="next">Sol</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-475502" data-claire-element-id="475502">Jusqu'à présent, nous avons vu les collisions entre objets potentiellement mobiles.<br/> Nous allons ici voir les différentes collisions avec des décors fixes.</p>
</div><a name="Sol"></a><h2>Sol</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">
<span class="arrow"></span>
<span class="next">Décor</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
<span class="next">Tiles droits</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-sol" data-claire-element-id="475540">Sol</h4><p id="r-475503" data-claire-element-id="475503">Nous allons voir maintenant comment tester la collision avec le sol.<br/> Tout d'abord avec un sol plat, puis un sol bien courbe.</p><h5 id="r-applications-10" data-claire-element-id="475511">Applications</h5><figure id="r-475505" data-claire-element-id="475506"><img id="r-475504" data-claire-element-id="475504" src="medias/uploads.siteduzero.com_files_235001_236000_235108.jpg" alt="Image utilisateur"/></figure><figure id="r-475508" data-claire-element-id="475509"><img id="r-475507" data-claire-element-id="475507" src="medias/uploads.siteduzero.com_files_235001_236000_235103.jpg" alt="Image utilisateur"/></figure><p id="r-475510" data-claire-element-id="475510">Nous voyons à gauche Street Fighter 2 ou le sol est plat. Si le personnage saute et retombe sur le sol, il faut qu'il s'arrête. À droite, Rayman évolue dans un monde ou le sol est en pente. En réalité, je pense que Rayman utilise un système de tiles amélioré, mais imaginons que non.</p><h5 id="r-calcul-de-collision-5" data-claire-element-id="475539">Calcul de collision</h5><h6 id="r-sol-plat" data-claire-element-id="475518">Sol plat</h6><p id="r-475512" data-claire-element-id="475512">Le sol plat n'a qu'un seul paramètre : son altitude a. Nous souhaitons savoir si la bounding box de notre personnage passe à travers ou pas.</p><p id="r-475513" data-claire-element-id="475513">La signature de notre fonction sera la suivante :</p><pre id="r-475514" data-claire-element-id="475514"><code data-claire-semantic="c">bool Collision(AABB box,int a)</code></pre><p id="r-475515" data-claire-element-id="475515">Pour savoir si on passe à travers, c'est très simple : si l'ordonnée du point du bas de la bounding box est supérieure à 'a', alors on passe à travers, sinon, non.</p><p id="r-475516" data-claire-element-id="475516">La fonction est donc triviale :</p><pre id="r-475517" data-claire-element-id="475517"><code data-claire-semantic="c">bool Collision(AABB box,int a)
{
   if (box.y + box.h &gt;=a)
      return true;
   else
      return false;
}</code></pre><h6 id="r-sol-courbe" data-claire-element-id="475538">Sol courbe</h6><p id="r-475519" data-claire-element-id="475519">Rappelez vous de vos cours de maths. Une fonction cartésienne f(x) = y a cette forme :</p><figure id="r-475521" data-claire-element-id="475522"><img id="r-475520" data-claire-element-id="475520" src="medias/uploads.siteduzero.com_files_235001_236000_235106.jpg" alt="Image utilisateur"/></figure><figure id="r-475524" data-claire-element-id="475525"><img id="r-475523" data-claire-element-id="475523" src="medias/uploads.siteduzero.com_files_235001_236000_235107.jpg" alt="Image utilisateur"/></figure><p id="r-475526" data-claire-element-id="475526">Voici une belle fonction sinus (à gauche). Pensez vous qu'on puisse marcher dessus ? En réalité, c'est très facile...</p><p id="r-475527" data-claire-element-id="475527">Notre fonction aura cette signature :</p><pre id="r-475528" data-claire-element-id="475528"><code data-claire-semantic="c">bool Collision(AABB box,fonction f)</code></pre><p id="r-475529" data-claire-element-id="475529">f est un pointeur de fonction (c'est pour illustrer le principe, vous pouvez faire sans).</p><p id="r-475530" data-claire-element-id="475530">Pour savoir si le perso touche ou pas la fonction, nous n'allons considérer qu'un seul point x,y : celui en bas au milieu de la AABB (point mauve sur l'image de droite ci-dessus)<br/> Comment savoir si le joueur est en dessus ou en dessous de la courbe ? Il suffit de voir si f(x)&gt;y ou non.</p><p id="r-475531" data-claire-element-id="475531">Cela donne la chose suivante :</p><pre id="r-475532" data-claire-element-id="475532"><code data-claire-semantic="c">bool Collision(AABB box,fonction f)
{
   int x = box.x + box.w/2;  // point milieu bas.
   int y = box.y + box.h; 
   if (f(x)&gt;y)
      return true;
   else
      return false;
}</code></pre><p id="r-475533" data-claire-element-id="475533">Toute la difficulté revient à avoir l'équation du sol. Il faut pouvoir dire, pour un x donné, où est la coordonnée y du sol, un f(x) = y. Souvent, on voudra une courbe qui passe par des points qu'on aura choisis. Les <a href="http://fr.wikipedia.org/wiki/Interpolation_numérique">splines cubiques</a> sont de bonnes candidates. Mais cela sort du cadre de ce tuto.</p><p id="r-475534" data-claire-element-id="475534">Ce chapitre vous montre déjà comment marcher sur une fonction mathématique... Vous penserez à un petit bonhomme qui se déplace sur la fonction que votre prof de maths dessinera au tableau ! :p</p><p id="r-475535" data-claire-element-id="475535">J'ai même une astuce supplémentaire pour vous faire utiliser les dérivées.<br/> Dans certains jeux où il y a des pentes, le personnage peut gravir la pente si elle est douce, et glisse si elle est &quot;trop raide&quot;. Comment savoir cela ? Il suffit de calculer la dérivée f'(x), et de voir sa valeur absolue. Si elle est plus grande qu'un seuil que vous fixerez, vous pourrez dire que c'est trop pentu et jouer en conséquence...</p><p id="r-475536" data-claire-element-id="475536">Le calcul de dérivée, vous n'avez pas à le programmer, vous le pré-calculez sur une feuille. Par exemple, si vous marchez sur la fonction sin(x), vous savez que sa dérivée est cos(x).<br/> Pour les splines cubiques, ce sont des polynômes. Un polynôme se dérive facilement...</p><p id="r-475537" data-claire-element-id="475537">Cette technique de collision n'est pas très utilisée dans les jeux 2D (à ma connaissance), les jeux de plateforme avec pentes préfèreront un concept de tiles améliorés, dont nous parlerons plus bas. Cependant, beaucoup de jeux 3D utilisent ce concept, dans ce qu'on appellera le Heightmap. Nous verrons ça par la suite.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">
<span class="arrow"></span>
<span class="next">Décor</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
<span class="next">Tiles droits</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Tilesdroits"></a><h2>Tiles droits</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
<span class="arrow"></span>
<span class="next">Sol</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
<span class="next">Tiles isométriques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-tiles-droits" data-claire-element-id="475596">Tiles droits</h4><p id="r-475541" data-claire-element-id="475541">Dans beaucoup de jeux 2D, les décors sont définis par des tiles.<br/> Si vous voulez approfondir ce concept, je vous invite à lire mon tutoriel sur le <a href="http://www.siteduzero.com/tutoriel-3-198472-tile-mapping.html">TileMapping</a>.</p><h5 id="r-definition-62" data-claire-element-id="475557">Définition</h5><p id="r-475542" data-claire-element-id="475542">Les jeux exploitant le tilemapping sont reconnaissables par leurs carreaux répétitifs régulièrement placées. Si on regarde l'image ci dessous :</p><figure id="r-475544" data-claire-element-id="475545"><img id="r-475543" data-claire-element-id="475543" src="medias/uploads.siteduzero.com_files_188001_189000_188033.jpg" alt="Image utilisateur"/></figure><p id="r-475546" data-claire-element-id="475546">Nous pouvons constater que les blocs se répètent et s'inscrivent exactement dans une grille de taille régulière. <br/> Stocker le TileMapping en mémoire revient juste à stocker les dessins de quelques blocs, et un tableau de nombres (appelés indices), qui permettent de construire l'image, comme le montre ce schéma :</p><figure id="r-475548" data-claire-element-id="475549"><img id="r-475547" data-claire-element-id="475547" src="medias/uploads.siteduzero.com_files_238001_239000_238936.jpg" alt="Image utilisateur"/></figure><p id="r-475550" data-claire-element-id="475550">A gauche, j'ai 8 petits dessins (numérotés de 0 a 7). Au milieu, j'ai un tableau de nombres. A partir de la, je peux reconstruire l'image de droite. Pour afficher l'image, il suffira d'appliquer l'algorithme formel suivant :</p><pre id="r-475551" data-claire-element-id="475551"><code>// soit T le tableau de nombres, de dimension X,Y
for(i=0;i&lt;X;i++)
{
   for(j=0;j&lt;X;j++)
   {
      typetile = T[i][j];
      px = i*LARGEUR_TILE;
      py = i*HAUTEUR_TILE;
      BlitTile(typetile,px,py);   // blit le tile typetile a la position px,py
   }
}</code></pre><p id="r-475552" data-claire-element-id="475552">La grille étant régulière, LARGEUR_TILE et HAUTEUR_TILE sont constants. Sur le dessin ci dessus, c'est l'écart qu'il y a entre 2 lignes verticales (pour la largeur), et 2 lignes verticales (pour la hauteur)</p><p id="r-475553" data-claire-element-id="475553">Même si parfois, en mémoire, c'est légèrement plus complexe, il y a toujours cette notion de tableau a 2 dimensions qui réfèrent un type de tile. Certains tiles seront des murs, d'autres non.</p><p id="r-475554" data-claire-element-id="475554">Pour ce tuto, je définirai la fonction suivante :</p><pre id="r-475555" data-claire-element-id="475555"><code data-claire-semantic="c">bool TileIsMur(int i,int j);</code></pre><p id="r-475556" data-claire-element-id="475556">qui me dira si le tile a la position i,j est un mur ou non.</p><h5 id="r-applications-11" data-claire-element-id="475569">Applications</h5><p id="r-475558" data-claire-element-id="475558">Les jeux utilisant le tilemapping sont légion.</p><figure id="r-475560" data-claire-element-id="475561"><img id="r-475559" data-claire-element-id="475559" src="medias/uploads.siteduzero.com_files_188001_189000_188036.jpg" alt="Image utilisateur"/></figure><figure id="r-475563" data-claire-element-id="475564"><img id="r-475562" data-claire-element-id="475562" src="medias/uploads.siteduzero.com_files_188001_189000_188027.png" alt="Image utilisateur"/></figure><figure id="r-475566" data-claire-element-id="475567"><img id="r-475565" data-claire-element-id="475565" src="medias/uploads.siteduzero.com_files_188001_189000_188025.png" alt="Image utilisateur"/></figure><p id="r-475568" data-claire-element-id="475568">Zelda, Mario, les jeux de plateforme des consoles 8 bits et 16 bits utilisent du tilemapping.<br/> Même si, dans le 3e exemple (secret of mana), ce n'est pas flagrant, ce sont des tiles.</p><h5 id="r-calcul-de-collision-6" data-claire-element-id="475595">Calcul de collision</h5><h6 id="r-juste-un-point-dans-le-mur" data-claire-element-id="475580">Juste un point dans le mur</h6><p id="r-475570" data-claire-element-id="475570">Comment savoir si un point donné touche un mur ou non ? Cela est extrêmement simple.</p><p id="r-475571" data-claire-element-id="475571">Vous avez un point x,y à tester. Il suffit de savoir au dessus de quelle case de la grille il est. On regardera ensuite si le tile correspondant à cette case est un mur ou non...<br/> Nous partons du principe que la grille commence à la coordonnée 0,0.</p><p id="r-475572" data-claire-element-id="475572">Il suffira, pour avoir les coordonnées i,j du tile concerné, d'une simple division...<br/> i = x/LARGEURTILE<br/> j = y/HAUTEURTILE</p><p id="r-475573" data-claire-element-id="475573">Nous prendrons la partie entière de i et j. <br/> Autrement dit, si la division donne 5.1 ou 5.9, nous prendrons 5.<br/> En C, le fait de diviser 2 int donne une division entière, ce qui donne notre résultat.</p><aside id="r-475575" data-claire-element-id="475575" data-claire-semantic="warning"><p id="r-475574" data-claire-element-id="475574">Il ne s'agit pas d'arrondir mais bien de prendre la partie entière. Si on arrondit 5.9, on trouve 6, si on prend sa partie entière, on a 5. Et on attend 5.</p></aside><p id="r-475576" data-claire-element-id="475576">Cela nous donne immédiatement la code suivant :</p><pre id="r-475577" data-claire-element-id="475577"><code data-claire-semantic="c">bool CollisionTile(int x,int y)
{
   int i = x/LARGEUR_TILE;   
   int j = y/HAUTEUR_TILE;
   return TileIsMur(i,j);
}</code></pre><p id="r-475578" data-claire-element-id="475578">Variante :<br/> Si votre grille ne démarre pas à la coordonnée 0,0 mais à la coordonnée a,b, la variante est extrêmement simple :</p><p id="r-475579" data-claire-element-id="475579">int i = (x-a)/LARGEUR_TILE; <br/> int j = (y-b)/HAUTEUR_TILE;</p><h6 id="r-une-aabb-dans-le-mur" data-claire-element-id="475594">Une AABB dans le mur</h6><p id="r-475581" data-claire-element-id="475581">Votre Mario n'est pas un point mais une AABB, et vous souhaitez savoir s'il touche un mur.<br/> Regardons le dessin ci dessous :</p><figure id="r-475583" data-claire-element-id="475584"><img id="r-475582" data-claire-element-id="475582" src="medias/uploads.siteduzero.com_files_211001_212000_211176.png" alt="Image utilisateur"/></figure><p id="r-475585" data-claire-element-id="475585">Nous voyons la grille, et quelques AABB à tester (en couleurs claires).<br/> Pour savoir si le personnage touche le mur, il suffit de tester tous les tiles que coupent la AABB.</p><div id="r-475587" data-claire-element-id="475587" data-claire-semantic="question"><p id="r-475586" data-claire-element-id="475586">Alors il faut déjà calculer l'intersection entre tous les tiles possibles et notre AABB, ce sera long !</p></div><p id="r-475588" data-claire-element-id="475588">Et bien non, puisque comme la grille est droite, et que la AABB aussi, alors il suffira de considérer i1,j1 comme le point supérieur gauche de la AABB, et i2,j2 comme le coin inférieur droit. Les tiles concernés seront tous ceux dans le rectangle i1,j1 et i2,j2.<br/> Sur le dessin, cela nous donne les tiles remplis de couleur foncées.</p><aside id="r-475590" data-claire-element-id="475590" data-claire-semantic="information"><p id="r-475589" data-claire-element-id="475589">Si un seul de ces tiles à tester est un mur, alors notre perso est dans un mur. Si aucun n'est un mur, alors on n'est pas dans un mur.</p></aside><p id="r-475591" data-claire-element-id="475591">Voici le code :</p><pre id="r-475592" data-claire-element-id="475592"><code data-claire-semantic="c">bool CollisionTiles(AABB box)
{
   i1 = box.x/LARGEUR_TILE;;
   j1 = box.y/HAUTEUR_TILE;
   i2 = (box.x + box.w -1)/LARGEUR_TILE;  
   j2 = (box.y + box.h -1)/HAUTEUR_TILE;
   int i,j;
   for(i=i1;i&lt;=i2;i++)
   {
     for(j=j1;j&lt;=j2;j++)
     {
         if (TileIsMur(i,j))
             return true;
     }
   }
   return false;  // si on n'est pas sorti avant, c'est qu'on ne touche aucun tile.
}</code></pre><p id="r-475593" data-claire-element-id="475593">Pour des exemples appliqués et complets sur le tilemapping, je vous invite à lire mon tuto sur <a href="http://www.siteduzero.com/tutoriel-3-198472-tile-mapping.html">le Tilemapping</a></p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
<span class="arrow"></span>
<span class="next">Sol</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
<span class="next">Tiles isométriques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Tilesisomtriques"></a><h2>Tiles isométriques</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
<span class="arrow"></span>
<span class="next">Tiles droits</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">
<span class="next">Partitionnement</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-tiles-isometriques" data-claire-element-id="475682">Tiles isométriques</h4><h5 id="r-definition-63" data-claire-element-id="475602">Définition</h5><p id="r-475597" data-claire-element-id="475597">On parle de tile isométrique quand, au lieu d'être un rectangle, le tile est incliné comme ci dessous :</p><figure id="r-475599" data-claire-element-id="475600"><img id="r-475598" data-claire-element-id="475598" src="medias/uploads.siteduzero.com_files_238001_239000_238955.png" alt="Image utilisateur"/></figure><p id="r-475601" data-claire-element-id="475601">Cela permet de simuler un effet 3D, et est très utilisé dans les jeux 2D qui veulent donner une sorte de profondeur.</p><h5 id="r-applications-12" data-claire-element-id="475611">Applications</h5><p id="r-475603" data-claire-element-id="475603">Les jeux suivants utilisent des tiles isométriques.</p><figure id="r-475605" data-claire-element-id="475606"><img id="r-475604" data-claire-element-id="475604" src="medias/uploads.siteduzero.com_files_238001_239000_238969.gif" alt="Image utilisateur"/></figure><figure id="r-475608" data-claire-element-id="475609"><img id="r-475607" data-claire-element-id="475607" src="medias/uploads.siteduzero.com_files_238001_239000_238968.jpg" alt="Image utilisateur"/></figure><p id="r-475610" data-claire-element-id="475610">On voit bien le sol &quot;penché&quot;, qui nous donne un effet de profondeur. <br/> De plus, pour donner une sorte d'altitude, des objets sont blittés par dessus, comme les barrières dans Diablo (image du haut) ce qui nous donne une réelle impression de 3D, alors que ce n'est que de la 2D.</p><h5 id="r-calcul-de-collision-7" data-claire-element-id="475681">Calcul de collision</h5><h6 id="r-point-dans-un-tile-isometrique" data-claire-element-id="475674">Point dans un tile isométrique</h6><p id="r-475612" data-claire-element-id="475612">Imaginons que vous ayez un point x,y (sur l'écran), et vous avez envie de savoir sur quel tile isométrique il est. (par exemple, vous voulez cliquer dessus).<br/> Revoyons notre image :</p><figure id="r-475614" data-claire-element-id="475615"><img id="r-475613" data-claire-element-id="475613" src="medias/uploads.siteduzero.com_files_238001_239000_238955.png" alt="Image utilisateur"/></figure><p id="r-475616" data-claire-element-id="475616">Ma grille isométrique commence au point O de coordonnée Ox,Oy.<br/> Je définis le repère du monde de tile par 2 vecteurs X et Y, sont les vecteurs \vec{X} = \vec{OB} et \vec{Y} = \vec{OA}</p><aside id="r-475618" data-claire-element-id="475618" data-claire-semantic="warning"><p id="r-475617" data-claire-element-id="475617">Il vous suffit de 3 points : O,A,B pour définir votre grille. Nous définissons ainsi le repère de la grille isométrique</p></aside><p id="r-475619" data-claire-element-id="475619">Si on considère O comme le point d'ancrage du tile de coordonnée (0,0), pour avoir le point d'ancrage P du tile de coordonnée (i,j), il suffit de faire :</p><p id="r-475620" data-claire-element-id="475620">P = O + i*\vec{X} + j*\vec{Y}</p><p id="r-475621" data-claire-element-id="475621">Si on pose Q de coordonnée (i,j), on a alors, de façon matricielle :</p><p id="r-475622" data-claire-element-id="475622">P = M*Q</p><p id="r-475623" data-claire-element-id="475623">Avec M la matrice du repère O,X,Y :</p><p id="r-475624" data-claire-element-id="475624">M = \begin{pmatrix}X_x&amp;Y_x&amp;O_x \\X_y&amp;Y_y&amp;O_y \\0&amp;0&amp;01\end{pmatrix}</p><p id="r-475625" data-claire-element-id="475625">Ce qui nous donne :</p><p id="r-475626" data-claire-element-id="475626">\begin{pmatrix}P_x \\P_y \\1\end{pmatrix} = \begin{pmatrix}X_x&amp;Y_x&amp;O_x \\X_y&amp;Y_y&amp;O_y \\0&amp;0&amp;1\end{pmatrix}\begin{pmatrix}i \\j \\1\end{pmatrix}</p><p id="r-475627" data-claire-element-id="475627">Ceci est l'éciture matricielle de : P = M*Q</p><p id="r-475628" data-claire-element-id="475628">Grâce à cela, pour un i,j donné, nous pouvons calculer le point correspondant dans le repère de l'écran.</p><aside id="r-475630" data-claire-element-id="475630" data-claire-semantic="information"><p id="r-475629" data-claire-element-id="475629">Oui, mais nous voulons l'inverse : nous avons le point dans le repère de l'écran, et nous voulons savoir sur quel tile il est, autrement dit quelle est sa coordonnée dans le repère de la grille... Autrement dit, nous avons P, nous voulons connaître Q.</p></aside><p id="r-475631" data-claire-element-id="475631">Si P = M*Q alors Si Q = M^{-1}*P</p><p id="r-475632" data-claire-element-id="475632">M^{-1} est l'inverse de la matrice M</p><p id="r-475633" data-claire-element-id="475633">Si vous ne connaissez pas les matrices en maths, sachez juste que c'est un outil puissant pour changer de repère. Votre écran est un repère, la grille en est un autre. Vous avez un point dans un repère, vous voulez savoir quelle est sa coordonnée dans l'autre ? Utilisez des matrices.</p><p id="r-475634" data-claire-element-id="475634">Voici donc les étapes que nous devons effectuer :</p><ul id="r-475649" data-claire-element-id="475649"><li id="r-475636" data-claire-element-id="475636"><p id="r-475635" data-claire-element-id="475635">Nous avons A,B,C, et x,y dans l'écran</p></li><li id="r-475638" data-claire-element-id="475638"><p id="r-475637" data-claire-element-id="475637">Nous devons calculer \vec{X} et \vec{Y}</p></li><li id="r-475640" data-claire-element-id="475640"><p id="r-475639" data-claire-element-id="475639">Nous devons calculer P</p></li><li id="r-475642" data-claire-element-id="475642"><p id="r-475641" data-claire-element-id="475641">Nous devons construire M</p></li><li id="r-475644" data-claire-element-id="475644"><p id="r-475643" data-claire-element-id="475643">Nous devons calculer M^{-1}</p></li><li id="r-475646" data-claire-element-id="475646"><p id="r-475645" data-claire-element-id="475645">Nous devons multiplier cette dernière par P</p></li><li id="r-475648" data-claire-element-id="475648"><p id="r-475647" data-claire-element-id="475647">Nous Récupérons Q, nous faisons une division entière comme pour les tiles droits ci dessus, et nous pourrons dire que le clic x,y touche le tile i,j</p></li></ul><p id="r-475650" data-claire-element-id="475650">Calculer \vec{X} et \vec{Y} :</p><p id="r-475651" data-claire-element-id="475651">Si on regarde le dessin ci dessus, c'est simple :</p><p id="r-475652" data-claire-element-id="475652">\vec{X} = B - O = \begin{pmatrix}X_x \\X_y \\0\end{pmatrix}\vec{Y} = A - O = \begin{pmatrix}Y_x \\Y_y \\0\end{pmatrix}<br/> Ce sont des vecteurs, on pose 0 comme dernière coordonnée.</p><p id="r-475653" data-claire-element-id="475653">O est le point origine de la grille. On peut l'écrire ainsi :<br/>O = \begin{pmatrix}O_x \\O_y \\1\end{pmatrix}<br/> O est un point, on pose 1 comme dernière coordonnée.</p><p id="r-475654" data-claire-element-id="475654">Calculer P :</p><p id="r-475655" data-claire-element-id="475655">P, c'est point que j'ai en entrée. <br/>P = \begin{pmatrix}x \\y \\1\end{pmatrix}<br/> P est un point, on pose 1 comme dernière coordonnée.</p><p id="r-475656" data-claire-element-id="475656">Nous cherchons : <br/>Q = \begin{pmatrix}i \\j \\1\end{pmatrix}<br/> Q est un point, on pose 1 comme dernière coordonnée.</p><p id="r-475657" data-claire-element-id="475657">calculer M</p><p id="r-475658" data-claire-element-id="475658">La matrice d'un repère en 2D est une matrice 3 lignes et 3 colonnes. La construire est simple, ayant la repère O,\vec{X},\vec{Y}, la matrice est simplement (\vec{X},\vec{Y},O)</p><p id="r-475659" data-claire-element-id="475659">Si on prend l'expression des points et vecteurs ci dessus, on trouve bien :</p><p id="r-475660" data-claire-element-id="475660">M = \begin{pmatrix}X_x&amp;Y_x&amp;O_x \\X_y&amp;Y_y&amp;O_y \\0&amp;0&amp;01\end{pmatrix}</p><p id="r-475661" data-claire-element-id="475661">calculer M^{-1}</p><p id="r-475662" data-claire-element-id="475662">M^{-1} est l'inverse de la matrice M. Je vous renvoie a vos cours de maths. Nous trouvons :<br/>M^{-1} =</p><figure id="r-475664" data-claire-element-id="475665"><img id="r-475663" data-claire-element-id="475663" src="medias/uploads.siteduzero.com_files_238001_239000_238987.png" alt="Image utilisateur"/></figure><p id="r-475666" data-claire-element-id="475666">Multiplication par P</p><p id="r-475667" data-claire-element-id="475667">Enfin, pour avoir Q, et donc i et j, il faut multiplier M^{-1} par P, ce qui nous donne :</p><p id="r-475668" data-claire-element-id="475668">i = {\frac {Y_{{y}}*x-Y_{{x}}*y+Y_{{x}}O_{{y}}-O_{{x}}Y_{{y}}}{X_{{x}}Y_{{y}}-X_{{y}}Y_{{x}}}}</p><p id="r-475669" data-claire-element-id="475669">j = -{\frac {X_{{y}}*x-X_{{x}}*y+X_{{x}}O_{{y}}-O_{{x}}X_{{y}}}{X_{{x}}Y_{{y}}-X_{{y}}Y_{{x}}}}</p><p id="r-475670" data-claire-element-id="475670">Au niveau du code, cela nous donne :</p><pre id="r-475671" data-claire-element-id="475671"><code data-claire-semantic="c">bool CollisionIso(Point O,Point A,Point B,float x,float y)
{
  Vecteur X,Y;
  X.x = B.x - O.x;
  X.y = B.y - O.y;
  Y.x = A.x - O.x;
  Y.y = A.y - O.y;
  float denom = X.x*Y.y-X.y*Y.x;  
// coordonnées réelles de x,y dans repère de la grille.
  float fi = (Y.y*x - Y.x*y + Y.x*O.y-O.x*Y.y)/denom;  // i et j non tronqués.
  float fj = -(X.y*x - X.x*y + X*x*O.y-O.x*X.y)/denom;
// prendre la partie entière pour savoir sur quel tile on est.
  int i = (int)fi;
  int j = (int)fj;  // vous pouvez modifier la fonction pour renvoyer i et j.
// est ce que ce tile est un mur ?
  return TileIsMur(i,j);
}</code></pre><aside id="r-475673" data-claire-element-id="475673" data-claire-semantic="information"><p id="r-475672" data-claire-element-id="475672">Ce calcul marchera dans dans les cas quelconques. Dans le dessin ci dessus, l'axe X est bien horizontal, ce qui nous permettrait de simplifier quelques calculs. Mais qui peut le plus peut le moins dit on !</p></aside><h6 id="r-rectangle-dans-tile-iso" data-claire-element-id="475680">Rectangle dans tile iso.</h6><p id="r-475675" data-claire-element-id="475675">Je suis sûr que vous me voyez déjà venir avec de gros calculs, mais il n'en est rien ici.</p><p id="r-475676" data-claire-element-id="475676">L'astuce, quand on fait un jeu isométrique, c'est de garder en mémoire les mêmes données que si c'était droit. En effet, Si on regarde un jeu isométrique, on peut l'imaginer comme un jeu &quot;droit&quot;.<br/> Tout calcul de collision entre objets marchera de la même manière.</p><p id="r-475677" data-claire-element-id="475677">Et c'est <strong>seulement au moment de l'affichage</strong> que vous dessinerez vos tiles en biais.<br/> Et c'est également seulement quand vous cliquez sur un tile que vous calculerez le point dans le repère de la grille comme vu au chapitre précédent.<br/> Mais en mémoire, tout se passe dans le repère de la grille.</p><p id="r-475678" data-claire-element-id="475678">Donc toute collision entre objets, tout objet avec les murs, se passe comme dans un monde de tiles droits.</p><p id="r-475679" data-claire-element-id="475679">D'autres types de collisions viendront enrichir prochainement ce paragraphe.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
<span class="arrow"></span>
<span class="next">Tiles droits</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">
<span class="next">Partitionnement</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Partitionnement"></a><h2>Partitionnement</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
<span class="arrow"></span>
<span class="next">Tiles isométriques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
<span class="next">Problématique</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-475684" data-claire-element-id="475684">Nous allons voir ici quelques algorithmes qui permettent, non pas de tester directement des collisions, mais d'optimiser les calculs de façon à faire beaucoup moins de tests, et donc aller beaucoup plus vite.</p>
</div><a name="Problmatique"></a><h2>Problématique</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">
<span class="arrow"></span>
<span class="next">Partitionnement</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
<span class="next">La grille</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-problematique-2" data-claire-element-id="475695">Problématique</h4><p id="r-475685" data-claire-element-id="475685">Avant de poursuivre, je vous laisse lire le chapitre précédent sur la collision Segment-Segment, et l'exemple de Doom que j'ai pris.</p><p id="r-475686" data-claire-element-id="475686">La carte d'un petit stage de Doom donne ceci :</p><figure id="r-475688" data-claire-element-id="475689"><img id="r-475687" data-claire-element-id="475687" src="medias/uploads.siteduzero.com_files_239001_240000_239294.png" alt="Image utilisateur"/></figure><p id="r-475690" data-claire-element-id="475690">Les murs sont des segments en noir, les &quot;marches&quot; sont en gris ou en orange.</p><p id="r-475691" data-claire-element-id="475691">Quand nous nous déplaçons dans cette map, nous testons des collisions Segment-Segment, comme nous avons vu dans le chapitre du même nom.</p><p id="r-475692" data-claire-element-id="475692">Mais si on veut être sur de ne pas passer à travers un mur, il faut tous les tester ! Et à chaque mouvement ! <br/> Même si le test est rapide, tester 100, 1000, 10 000 ou même 100 000 murs, car un stage peut être grand, ce sera beaucoup trop violent.</p><p id="r-475693" data-claire-element-id="475693">Il va donc falloir tester les murs &quot;autour&quot; du joueur, et pas les autres. En effet, si je suis complètement à droite du stage, tester tous les murs à gauche est stupide.</p><p id="r-475694" data-claire-element-id="475694">Mais comment va-t-on faire pour cela ? Nous allons voir plusieurs méthodes.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">
<span class="arrow"></span>
<span class="next">Partitionnement</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
<span class="next">La grille</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lagrille"></a><h2>La grille</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
<span class="arrow"></span>
<span class="next">Problématique</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
<span class="next">Le quadtree</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-la-grille-6" data-claire-element-id="475750">La grille</h4><p id="r-475696" data-claire-element-id="475696">L'idée la plus simple est de définir une grille :</p><h5 id="r-boite-englobante" data-claire-element-id="475703">Boîte englobante</h5><p id="r-475697" data-claire-element-id="475697">Tout d'abord, un stage, aussi grand soit il, est inscrit dans une boîte englobante, une AABB.<br/> Pour la calculer, c'est simple, il suffit de parcourir tous les segments, et de relever les x et y, et de garder le minimum et le maximum.</p><p id="r-475698" data-claire-element-id="475698">Ceci est calculatoire, mais sera fait qu'une seule fois (au chargement de la map) voir, encore mieux, sera carrément fourni avec la map si on a calculé cela au moment ou on l'a créée, et qu'on a enregistré le résultat avec.</p><p id="r-475699" data-claire-element-id="475699">Voici donc la map avec sa boîte englobante :</p><figure id="r-475701" data-claire-element-id="475702"><img id="r-475700" data-claire-element-id="475700" src="medias/uploads.siteduzero.com_files_239001_240000_239300.png" alt="Image utilisateur"/></figure><h5 id="r-decoupage" data-claire-element-id="475739">Découpage</h5><p id="r-475704" data-claire-element-id="475704">L'idée de la grille va être très simple : nous découpons la boîte englobante en petits carrés égaux en taille. Cela nous donne ceci :</p><figure id="r-475706" data-claire-element-id="475707"><img id="r-475705" data-claire-element-id="475705" src="medias/uploads.siteduzero.com_files_239001_240000_239303.png" alt="Image utilisateur"/></figure><p id="r-475708" data-claire-element-id="475708">Dans cet exemple, j'ai découpé en 36 morceaux (6*6).<br/> Et dans chaque morceau, je vais stocker la liste de mes segments.</p><p id="r-475709" data-claire-element-id="475709">Il y aura donc 36 listes (ou tableaux) de segments, répartis dans un tableau 2D de &quot;petit carré&quot;</p><p id="r-475710" data-claire-element-id="475710">En mémoire, on pourra avoir ceci :</p><pre id="r-475711" data-claire-element-id="475711"><code data-claire-semantic="c">struct Segment // un segment, c'est 2 points
{
  Point A,B;
};

struct Carre  // un carre contient une liste (ou tableau) de segments
{
  Segment* tableau;
  int nbsegs;
};

struct Grille  // tableau a 2 dimensions 
{
  Carre** c;   // en autre langage que le C, on pourra écrire Carre[nbx][nby] c;
  int nbx,nby;
  float largeurcarre,hauteurcarre;
  AABB bbox;   // bounding box globale, de tout le stage
};</code></pre><p id="r-475712" data-claire-element-id="475712">Pour créer la grille, le concept est le suivant : nous avons notre stage au départ avec un grand tableau de segments (tous les segments du stage)<br/> On les prend un par un, et on les range dans le bon carré, en fonction de leur position.</p><p id="r-475713" data-claire-element-id="475713">Notez que tout ceci se fait également une fois pour toutes</p><ul id="r-475718" data-claire-element-id="475718"><li id="r-475715" data-claire-element-id="475715"><p id="r-475714" data-claire-element-id="475714">soit pendant le chargement de la carte</p></li><li id="r-475717" data-claire-element-id="475717"><p id="r-475716" data-claire-element-id="475716">soit ces données sont enregistrées avec la carte, et on été calculées lors de la création de la map</p></li></ul><p id="r-475719" data-claire-element-id="475719">Dans les deux cas, une fois dans la boucle du jeu, nous n'aurons plus à faire ces calculs, donc le jeu sera rapide.</p><h6 id="r-calcul-de-la-largeur-et-hauteur-d-un-carre" data-claire-element-id="475722">Calcul de la largeur et hauteur d'un carré.</h6><p id="r-475720" data-claire-element-id="475720">Etant donné la bounding box AABB du stage, et le nombre de carrés en X et en Y que l'on souhaite, une simple division permet de calculer la largueur et la hauteur d'un carré :</p><p id="r-475721" data-claire-element-id="475721">Grille.largeurcarre = bbox.w/nbx;<br/> Grille.hauteurcarre= bbox.h/nby;</p><h6 id="r-dans-quel-carre-est-mon-point-p" data-claire-element-id="475727">Dans quel carré est mon point P.</h6><p id="r-475723" data-claire-element-id="475723">Vous avez un point P, vous voulez savoir dans quel carré il est. Un peu comme le tilemapping, c'est une histoire de mise à l'échelle. Notez que, contrairement à un tilemapping bien fait, l'origine de la grille n'est pas (0,0) mais bien le point min de la bounding box (bbox.x;bbox.y).</p><p id="r-475724" data-claire-element-id="475724">Donc pour un point P (Px,Py) donné, nous avons :</p><p id="r-475725" data-claire-element-id="475725">i = (Px-bbox.x)/largeurcarre;<br/> j = (Py-bbox.y)/hauteurcarre;</p><p id="r-475726" data-claire-element-id="475726">Il faut prendre la partie entière de i et j pour savoir dans quel carré est le point P.</p><h6 id="r-segment-inscrit" data-claire-element-id="475730">Segment inscrit</h6><p id="r-475728" data-claire-element-id="475728">Nous disions donc, pour préparer nos 36 listes, nous prenons les segments un par un. un segment, c'est 2 points A et B.<br/> Nous calculons rapidement dans quel carré sont A et B grâce au calcul ci dessus.</p><p id="r-475729" data-claire-element-id="475729">Si les 2 poins sont dans le même carré, c'est formidable, le segment est inscrit dans le carré, nous l'ajoutons à la liste du carré correspondant. <br/> Dans le cas contraire, il y a chevauchement du segment au dessus de plusieurs carrés.</p><h6 id="r-chevauchement-1" data-claire-element-id="475738">Chevauchement</h6><p id="r-475731" data-claire-element-id="475731">En effet, si les 2 points du segment ne sont pas dans le même carré, cela pose problème.<br/> Pour éviter ce problème, nous allons découper le segment en plusieurs segments.<br/> Pour cela, nous calculons l'intersection entre le segment et les bords des carrés concernés, et nous mettons 2 ou plusieurs petits segments ainsi formés dans chacun des carrés correspondants.</p><figure id="r-475733" data-claire-element-id="475734"><img id="r-475732" data-claire-element-id="475732" src="medias/uploads.siteduzero.com_files_239001_240000_239315.png" alt="Image utilisateur"/></figure><p id="r-475735" data-claire-element-id="475735">Sur ce dessin, a gauche j'ai un segment coupé une fois : je coupe et je mets donc le segment vert dans la liste du carré de gauche, et le segment rouge dans la liste du carré de droite.<br/> A droite, le segment coupe 3 carrés. Je coupe et je mets donc les segment vert, rouge, et gris dans les listes des carrés correspondants.</p><aside id="r-475737" data-claire-element-id="475737" data-claire-semantic="information"><p id="r-475736" data-claire-element-id="475736">A la fin de cette étape la, chaque carré contient sa propre liste de murs. La construction de la grille est terminée.</p></aside><h5 id="r-calcul-de-collision-8" data-claire-element-id="475744">Calcul de collision</h5><p id="r-475740" data-claire-element-id="475740">Maintenant que notre grille est prête, comment tester si notre personnage de Doom touche un mur ?<br/> Et bien l'idée est la suivante :</p><p id="r-475741" data-claire-element-id="475741">Nous avons vu que le déplacement d'un personnage de doom est un segment. Il va falloir déterminer dans combien de carrés ce segment va passer. <br/> Et pour chacun de ces carrés de passage, on va tester la collision avec la liste de ses murs.</p><p id="r-475742" data-claire-element-id="475742">Il sera ainsi inutile de tester la collision avec les carrés ou on ne passe pas : ils sont suffisamment loin pour qu'on ne les touche pas.</p><p id="r-475743" data-claire-element-id="475743">C'est ainsi qu'on restreint très fortement le nombre de tests, en ne testant que les murs autour de notre trajectoire.</p><h5 id="r-inconvenients-6" data-claire-element-id="475749">Inconvénients</h5><p id="r-475745" data-claire-element-id="475745">Cette méthode présente quelques inconvénients.<br/> Il faut déterminer le nombre de carrés que l'on veut, donc fixer nbx et nby au départ.</p><p id="r-475746" data-claire-element-id="475746">Si on fixe des valeurs petites, alors les carrés seront grands, et pourront donc contenir des listes de segments à tester assez grandes. Si par exemple, dans un carré, on a 1000 murs à tester, parce qu'on a une pièce petite avec beaucoup d'obstacles, ça fait beaucoup de tests.</p><p id="r-475747" data-claire-element-id="475747">Si on fixe des valeurs grandes, et ainsi on se retrouve avec une grille assez fine, alors on fait exploser le nombre de carrés à stocker... avec leurs listes ! ça consommera donc énormément de mémoire.</p><p id="r-475748" data-claire-element-id="475748">Si la carte se compose d'une petite maison avec beaucoup de murs, et à coté d'un très grand terrain : on aura plein de carrés avec une liste vide pour le terrain, mais qui couteront quand même de la mémoire.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
<span class="arrow"></span>
<span class="next">Problématique</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
<span class="next">Le quadtree</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lequadtree"></a><h2>Le quadtree</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
<span class="arrow"></span>
<span class="next">La grille</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
<span class="next">Le BSP 2D</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-le-quadtree" data-claire-element-id="475797">Le quadtree</h4><p id="r-475751" data-claire-element-id="475751">Le quatree est un autre système de partitionnement qui présente des avantages par rapport à la grille.</p><h5 id="r-presentation-125" data-claire-element-id="475768">Présentation</h5><p id="r-475752" data-claire-element-id="475752">Avant tout, le terme Quadtree veut dire &quot;Arbre à 4 fils&quot;. Cette partie nécessite de connaître la notion d'arbres en informatique.</p><p id="r-475753" data-claire-element-id="475753">Reprenons notre terrain, avec sa boîte englobante AABB, comme vu dans le chapitre au dessus.<br/> Maintenant, observons le dessin ci dessous :</p><figure id="r-475755" data-claire-element-id="475756"><img id="r-475754" data-claire-element-id="475754" src="medias/uploads.siteduzero.com_files_239001_240000_239334.png" alt="Image utilisateur"/></figure><p id="r-475757" data-claire-element-id="475757">Il est composé de 3 cartes. Regardons à gauche :<br/> J'ai coupé en 4 parts égales la carte (les traits bleus), en coupant au milieu de la boîte englobante globale. J'appelle les nouvelles zones ainsi créées 1,2,3,4</p><p id="r-475758" data-claire-element-id="475758">En mémoire (si on regarde en dessous), j'ai un arbre, a 4 fils. La racine, c'est &quot;le monde entier&quot;, chacun des fils est une des 4 zones ainsi crées.<br/> Pour le moment, c'est exactement si j'avais fait une grille avec nbx = 2 et nby = 2, sauf que je range ça dans un arbre.</p><p id="r-475759" data-claire-element-id="475759">Je dis, arbitrairement, que le 1er fils est le carré en haut à gauche, le 2e celui en haut à droite, le 3e celui en bas à gauche, le 4e celui en bas à droite. Je mets l'ordre que je veux, mais il faudra s'y tenir.</p><p id="r-475760" data-claire-element-id="475760">Maintenant, regardons le dessin du milieu. Je n'ai pas touché à mes zones 1,3,4, mais pour la zone 2, je l'ai encore découpée en 4, en coupant de nouveau la zone au milieu. Me voila avec 4 nouvelles zones que j'ai appelé 21,22,23,24. Ces zones sont des filles de la zone 2 (puisque c'est la zone 2 que j'ai découpé)</p><p id="r-475761" data-claire-element-id="475761">Je suppose que vous commencez à comprendre le concept. Le 3e dessin redivise à nouveau la zone 23 en 4 nouvelles zones, en coupant la zone mère en son milieu.</p><p id="r-475762" data-claire-element-id="475762">Et je peux continuer comme cela autant que je veux...</p><p id="r-475763" data-claire-element-id="475763">Et à la fin, comme dans l'algorithme de la grille, je vais ranger un tableau de murs dans chaque feuille de mon arbre, donc dans les zones terminales.</p><p id="r-475764" data-claire-element-id="475764">En mémoire, cela se présente ainsi :</p><pre id="r-475765" data-claire-element-id="475765"><code data-claire-semantic="c">struct QuadTree
{
  AABB bbox;  // bounding box du noeud
  QuadTree* fils[4];  // 4 fils.
  Segment* tableau;
  int nbsegs;

};</code></pre><p id="r-475766" data-claire-element-id="475766">L'arbre est un noeud, la racine contient le bounding box du monde, chaque fils contient une bounding box 4 fois plus petite (2 fois en x, 2 fois en y) que son père.<br/> Quand on arrive sur une feuille, les 4 pointeurs vers les Quadtree fils seront à NULL.<br/> Ces pointeurs seront soit tous nuls, soit tous non nuls. <br/> Du coup, pour vérifier qu'un noeud est une feuille, il suffira de regarder le premier fils, et voir s'il est nul ou non.</p><p id="r-475767" data-claire-element-id="475767">Mais uniquement les feuilles du quadtree pourront contenir des segments, pas les noeuds intermédiaires. (il existe des variantes de quadtrees qui pourraient permettre ça, mais on n'en parlera pas ici)</p><h5 id="r-decoupage-1" data-claire-element-id="475791">Découpage</h5><p id="r-475769" data-claire-element-id="475769">Comment découper un Quadtree ? Jusqu'où continuer à découper, à l'infini ?</p><p id="r-475770" data-claire-element-id="475770">L'idée est de définir une variable NBMAX qui sera le nombre maximal de segments qu'on veut dans une liste. par exemple, je dis que chaque zone ne contiendra pas plus de 10 segments à tester.</p><p id="r-475771" data-claire-element-id="475771">Donc au début, je construis la racine du quadree. Je mets tous mes segments dedans (dans le liste du noeud). Disons 1000 segments.</p><p id="r-475772" data-claire-element-id="475772">Est ce qu'il y a plus de segments que NBMAX ? Oui, évidemment. Alors je découpe : je crée 4 fils, et je vais distribuer les segments dans chacune des 4 listes des 4 fils.</p><p id="r-475773" data-claire-element-id="475773">je considère une extrémité de segment, disons un point P. Comme savoir dans quelle zone il devra aller ?<br/> Il suffit de prendre la bounding box du père, et de prendre son point milieu I.</p><ul id="r-475782" data-claire-element-id="475782"><li id="r-475775" data-claire-element-id="475775"><p id="r-475774" data-claire-element-id="475774">Si Px&lt;Ix et Py&lt;Iy alors on ira dans le fils 1</p></li><li id="r-475777" data-claire-element-id="475777"><p id="r-475776" data-claire-element-id="475776">Si Px&gt;Ix et Py&lt;Iy alors on ira dans le fils 2</p></li><li id="r-475779" data-claire-element-id="475779"><p id="r-475778" data-claire-element-id="475778">Si Px&lt;Ix et Py&gt;Iy alors on ira dans le fils 3</p></li><li id="r-475781" data-claire-element-id="475781"><p id="r-475780" data-claire-element-id="475780">Si Px&gt;Ix et Py&gt;Iy alors on ira dans le fils 4</p></li></ul><p id="r-475783" data-claire-element-id="475783">Je vide ainsi la liste du père, pour répartir tous les segments dans les 4 fils.</p><p id="r-475784" data-claire-element-id="475784">Si mon découpage coupe en deux quelques segments, je crée des segments plus petits, comme pour la grille.<br/> J'aurais donc potentiellement plus de 1000 segments à distribuer.</p><p id="r-475785" data-claire-element-id="475785">Au vu de la carte, disons que j'en distribue 150 au fils 1, 200 au fils 300 au fils 3 et 400 au fils 4.<br/> (j'en ai injecté 1050 a cause des chevauchements).</p><p id="r-475786" data-claire-element-id="475786">Je continue récusivement sur chaque zone. Chaque zone a plus de NBMAX éléments dans sa liste, donc je les découpe toutes à nouveau...<br/> Arrivé au 3e niveau, je constate que la zone 1_1 n'a pas de segments, et que la zone 1_2 en a 5 : j'arrête donc de subdiviser ces zones. Mais pour le reste je continue...</p><aside id="r-475788" data-claire-element-id="475788" data-claire-semantic="information"><p id="r-475787" data-claire-element-id="475787">Je me retrouve donc avec un bel arbre, qui, pour chaque noeud, a 4 fils, et au bout, ses feuilles n'ont pas plus de NBMAX éléments.</p></aside><p id="r-475789" data-claire-element-id="475789">note : dans certains cas extrêmes, on pourra arrêter les découpages quoiqu'il arrive, même s'il y a trop de segments dans la liste, si on arrive au dela d'une profondeur maximale fixée...</p><p id="r-475790" data-claire-element-id="475790">La construction d'un Quadtree se fait au chargement d'une map, ou bien est enregistré avec la map directement. Tous ces calculs sont déjà faits et ne sont plus à refaire quand le jeu tourne.</p><h5 id="r-calcul-de-collision-9" data-claire-element-id="475793">Calcul de Collision</h5><p id="r-475792" data-claire-element-id="475792">Le calcul de collision depuis un quadtree revient uniquement à déterminer les feuilles ou passe notre trajectoire. On a un segment qui représente notre trajectoire, on le fait descendre dans le quadtree comme on faisait descendre les murs, on se retrouve avec le segment dans une feuille (ou plusieurs s'il a été découpé)<br/> Il suffira de tester les collisions avec les listes de segments murs des feuilles considérées...</p><h5 id="r-inconvenients-7" data-claire-element-id="475796">Inconvénients</h5><p id="r-475794" data-claire-element-id="475794">L'inconvénient du quadtree est son potentiel déséquilibre. En effet, si notre carte contient des zones denses, et d'autres vides, l'arbre va être déséquilibré.</p><p id="r-475795" data-claire-element-id="475795">Prenons un cas extrême : une map est un grand terrain avec une petite cabane dans un coin, mais une cabane avec beaucoup de murs.<br/> Le quadtree associé aura 4 fils, 3 avec quasiment aucun mur, et il faudra descendre fort profond pour trouver la cabane, qui, étant petite, sera dans une zone petite, donc profonde dans l'arbre. Le reste de l'arbre sera presque vide.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
<span class="arrow"></span>
<span class="next">La grille</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
<span class="next">Le BSP 2D</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="LeBSP2D"></a><h2>Le BSP 2D</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
<span class="arrow"></span>
<span class="next">Le quadtree</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">
<span class="next">Sprites enrichis</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-le-bsp-2d" data-claire-element-id="475837">Le BSP 2D</h4><p id="r-475798" data-claire-element-id="475798">Le BSP 2D est une très bonne réponse à ces inconvénients.</p><h5 id="r-presentation-126" data-claire-element-id="475811">Présentation</h5><p id="r-475799" data-claire-element-id="475799">BSP signifie &quot;Binary Space Partitionning&quot;, autrement dit : &quot;on coupe l'espace en deux&quot;.<br/> Le BSP se base sur des arbres binaires : donc des arbres à 2 fils.</p><p id="r-475800" data-claire-element-id="475800">Regardons le schéma ci dessous :</p><figure id="r-475802" data-claire-element-id="475803"><img id="r-475801" data-claire-element-id="475801" src="medias/uploads.siteduzero.com_files_239001_240000_239344.png" alt="Image utilisateur"/></figure><p id="r-475804" data-claire-element-id="475804">Nous retrouvons, à gauche, notre carte. Je l'ai d'abord coupée en deux par un grand trait vert. D'un coté du trait vert, j'obtiens donc une zone, que je coupe de nouveau avec un trait violet, et j'arrête le découpage de ce coté la.</p><p id="r-475805" data-claire-element-id="475805">Regardez à droite l'arbre : la racine est verte, comme le premier trait vert que j'ai tracé, puis, d'un coté de l'arbre, j'ai mis un noeud violet pour symboliser le découpage de cette moitié en deux. Puis j'ai mis les feuilles en dessous de la zone violette.</p><p id="r-475806" data-claire-element-id="475806">Si on regarde l'autre coté du trait vert, la ou il y a le trait bleu, on voit que je coupe la zone restante en deux, puis une des sous zones est recoupée en deux par le trait jaune. Si vous regardez l'arbre à droite, j'ai mis un carré bleu sous le carré vert, et un carré jaune sous le trait bleu.</p><p id="r-475807" data-claire-element-id="475807">Voici comment est codée ceci en C :</p><pre id="r-475808" data-claire-element-id="475808"><code data-claire-semantic="c">struct Axe
{
  Point A,B;
};

struct BSP2D
{
  Axe decoupe;
  BSP2D* fils[2];
  Segment* tableau;
  int nbsegs;
}</code></pre><p id="r-475809" data-claire-element-id="475809">A l'instar du quadtree, seulement les feuilles contiendront la liste des segments correspondant à leur zone.<br/> Les noeuds intermédiaires, eux, contiendront une droite de coupe (celle que j'ai mis en vert, bleu, jaune, violet sur le dessin)</p><p id="r-475810" data-claire-element-id="475810">L'idée du BSP tree est couper en deux une zone pour en faire 2 zones. Cette coupe n'est pas alignée avec les axes X ou Y comme la grille ou le Quadtree, elle est quelconque.</p><h5 id="r-comment-choisir-les-axes-de-coupe" data-claire-element-id="475818">Comment choisir les axes de coupe ?</h5><p id="r-475812" data-claire-element-id="475812">Si le découpage est quelconque, ça ne veut pas dire qu'il est fait au hasard. <br/> En effet, les axes de découpage sont astucieusement placés.</p><aside id="r-475814" data-claire-element-id="475814" data-claire-semantic="information"><p id="r-475813" data-claire-element-id="475813">Le but est d'avoir a peu près le même nombre de segments d'un coté ou de l'autre, pour faire un arbre équilibré.</p></aside><p id="r-475815" data-claire-element-id="475815">L'inconvénient du quadtree disparaît avec le BSP. Un arbre BSP est un arbre équilibré, même dans les cas ou notre monde comporte beaucoup de murs à un endroit, et peu ailleurs, contrairement au quadtree.</p><p id="r-475816" data-claire-element-id="475816">Cependant, construire un bel arbre BSP est quelque chose de long. En effet, étant donné une soupe de segments, il faut trouver la droite qui coupera le tout intelligemment en faisant un bon équilibre entre les deux zones ainsi coupées.</p><p id="r-475817" data-claire-element-id="475817">Les algorithmes employés pour ça sont complexes, lourds et calculatoires.<br/> C'est pour cela que le calcul d'un arbre BSP est quasiment toujours enregistré avec la carte du monde. C'est l'éditeur de carte qui va construire le BSP, et le sauvegarder.<br/> Le joueur, quand il va lancer son jeu et charger sa carte, chargera le BSP tout fait avec.</p><h5 id="r-calcul-des-collisions" data-claire-element-id="475836">Calcul des collisions</h5><p id="r-475819" data-claire-element-id="475819">Tout comme le quadtree, calculer les collisions dans un BSP revient à trouver, pour notre segment de déplacement, dans quelle(s) zone(s) il passe, et de tester ensuite les listes de segments des zones concernées.</p><p id="r-475820" data-claire-element-id="475820">Il faut donc, pour un point donné, descendre dans l'abre BSP et se laisser guider vers la bonne feuille.</p><h6 id="r-choisir-la-bonne-zone" data-claire-element-id="475835">Choisir la bonne zone</h6><p id="r-475821" data-claire-element-id="475821">Si vous êtes sur un noeud, avec un point P, et que vous voulez savoir si votre point P est dans la zone du fils gauche, ou du fils droit, il vous suffit de faire un petit calcul.</p><p id="r-475822" data-claire-element-id="475822">Chaque axe est une droite orientée de A vers B.<br/> Si on considère un point P, est il à gauche de cette droite (on ira dans le fils gauche), ou à droite ? (on ira dans le fils droit)</p><p id="r-475823" data-claire-element-id="475823">Si vous avez bien lu le chapitre sur les collisions segment-segment, un simple calcul de déterminant faire l'affaire.</p><p id="r-475824" data-claire-element-id="475824">d = \det(\vec{AB},\vec{AP}) = AB_x*AP_y-AB_y*AP_x</p><ul id="r-475831" data-claire-element-id="475831"><li id="r-475826" data-claire-element-id="475826"><p id="r-475825" data-claire-element-id="475825">Si d&gt;0, alors P est à gauche</p></li><li id="r-475828" data-claire-element-id="475828"><p id="r-475827" data-claire-element-id="475827">Si d&lt;0 alors P est à droite</p></li><li id="r-475830" data-claire-element-id="475830"><p id="r-475829" data-claire-element-id="475829">Si d==0, on est sur un cas limite, on pourra ranger à gauche ou à droite, au choix, mais il est préférable de se tenir à son choix</p></li></ul><aside id="r-475833" data-claire-element-id="475833" data-claire-semantic="information"><p id="r-475832" data-claire-element-id="475832">Le jeu vidéo Doom utilisait un BSP 2D.</p></aside><p id="r-475834" data-claire-element-id="475834">Tous ces algorithmes ont leur équivalent en 3D. Je les présenterai donc dans la rubrique 3D.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
<span class="arrow"></span>
<span class="next">Le quadtree</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">
<span class="next">Sprites enrichis</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Spritesenrichis"></a><h2>Sprites enrichis</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
<span class="arrow"></span>
<span class="next">Le BSP 2D</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
<span class="next">Point chaud et point d&#039;action</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-475839" data-claire-element-id="475839">Jusqu'à présent, nous avons considéré les sprites (petits objets animés) comme une simple image, ou un simple ensemble d'images. Cependant, rien n'interdit, en se faisant son propre éditeur de sprite, de pouvoir rajouter des informations directement dans les images pour aider au calcul de collision, ou même à l'affichage.</p><p id="r-475840" data-claire-element-id="475840">Ce sera donc le graphiste qui rajoutera des informations qui nous seront fort utiles.</p><p id="r-475841" data-claire-element-id="475841">Voyons ici quelques concepts d'informations qu'on pourrait rajouter aux images.</p>
</div><a name="Pointchaudetpointd039action"></a><h2>Point chaud et point d&#039;action</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">
<span class="arrow"></span>
<span class="next">Sprites enrichis</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
<span class="next">Sous AABB</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-point-chaud-et-point-d-action" data-claire-element-id="475887">Point chaud et point d'action</h4><p id="r-475842" data-claire-element-id="475842">Ici, nous allons parler du point chaud et du point d'action. Ce sont des concepts qui simplifient bien la vie dans certains cas.<br/> Le vieux logiciel de création <a href="http://en.wikipedia.org/wiki/Klik">Klick &amp; Play</a> utilisait ces concepts.</p><h5 id="r-le-point-chaud" data-claire-element-id="475872">Le point chaud</h5><p id="r-475843" data-claire-element-id="475843">Le point chaud ne concerne pas directement les collisions, mais il peut être utile d'en parler.</p><p id="r-475844" data-claire-element-id="475844">Regardons ensemble l'image suivante :</p><figure id="r-475846" data-claire-element-id="475847"><img id="r-475845" data-claire-element-id="475845" src="medias/uploads.siteduzero.com_files_248001_249000_248142.png" alt="Image utilisateur"/></figure><p id="r-475848" data-claire-element-id="475848">Vous avez reconnu ce cher Dhalsim, fakir combattant assez élastique dirons nous. Quand il donne un coup, il a une très grande portée ! Nous voyons ici deux images, l'une où Dhalsim ne donne pas de coup, et une où il donne un coup de pied bien tendu.<br/> En bleu, j'ai dessiné les boîtes englobantes, elles ne sont pas de la même largeur. Cela va poser problème.</p><h6 id="r-probleme-4" data-claire-element-id="475854">Problème</h6><p id="r-475849" data-claire-element-id="475849">Imaginons que vous vouliez faire une animation de Dhalsim qui donne un coup de pied. Vous avez ces deux images, ci-dessus, et vous voulez faire l'animation.</p><p id="r-475850" data-claire-element-id="475850">Vous blittez donc tour à tour chaque image, un blit colle l'image à la position x,y de telle sorte que le coin supérieur gauche de l'image blittée soit à la coordonnée (x,y).</p><p id="r-475851" data-claire-element-id="475851">Conséquence immédiate : vous aurez un Dhalsim qui va vivement partir à droite quand il donnera un coup de pied, parce que dans une image, sa tête est à coté du coin supérieur gauche, et dans l'autre, elle est loin. L'animation va être complètement ratée.</p><p id="r-475852" data-claire-element-id="475852">La seule solution est de blitter la première image à une position (x,y), et de blitter la seconde à une position (x2,y) avec x2 &lt; x, et de bien calculer x2 de façon à ce que le corps de Dhalsim reste au même endroit.</p><p id="r-475853" data-claire-element-id="475853">C'est extrêmement contraignant, surtout s'il faut faire ça avec chaque image.<br/> Et pourtant, si on veut une belle animation, il <strong>faut </strong>calculer un x2 correct.</p><h6 id="r-insertion-du-point-chaud" data-claire-element-id="475863">Insertion du point chaud</h6><p id="r-475855" data-claire-element-id="475855">Pour palier ce problème, nous allons dire au graphiste que nous souhaitons des informations supplémentaires, et qu'il nous les donnera graphiquement.<br/> Regardez les points rouges que j'ai mis au pied de Dhalsim dans chaque cas. Imaginez maintenant qu'on ait une fonction de blit qui affiche le personnage non pas en considérant que l'ancrage est en haut à gauche, mais qu'il est au niveau de ce point rouge. <br/> Autrement dit, le point rouge est à la coordonnée (x,y) du blit, et Dhalsim se dessine autour.</p><p id="r-475856" data-claire-element-id="475856">Le problème est donc résolu : l'animation sera convenable.</p><aside id="r-475858" data-claire-element-id="475858" data-claire-semantic="information"><p id="r-475857" data-claire-element-id="475857">Ce point rouge, c'est le point chaud. Il faudra définir un point chaud pour chaque image pour notre cas.</p></aside><p id="r-475859" data-claire-element-id="475859">A vous de programmer un éditeur qui permet au graphiste de définir un point chaud pour chaque image à blitter. <br/> Vous savez, il y a deux possibilités de gérer les sprites : soit un sprite par surface, soit une planche de sprite sur la même surface et un blit partiel. <br/> Dans le premier cas, chaque surface devra avoir un point chaud. Dans le deuxième, il y aura autant de points chauds que d'images dans la planche.</p><p id="r-475860" data-claire-element-id="475860">Un point chaud, c'est juste une coordonnée (x,y) locale à l'image. Dans la première image, on aura par exemple le point chaud qui a comme coordonnée (45,100), et dans la deuxième, il a comme coordonnée (167,100).</p><p id="r-475861" data-claire-element-id="475861">Ces coordonnées ne seront pas entrées à la main par le graphiste, mais en un clic : le graphiste a son image sur l'écran, il clique sur l'option &quot;mettre point chaud&quot; puis il clique sur son image entre les pieds de Dhalsim, et l'éditeur stocke la coordonnée de souris relative à l'image, tout simplement. Cela reste donc visuel. C'est la machine qui fait les calculs.</p><p id="r-475862" data-claire-element-id="475862">Notez qu'un point chaud à la coordonnée (0,0) est un point chaud en haut à gauche, donc ça nous ramène au cas du blit normal !</p><h6 id="r-blit-sur-le-point-chaud" data-claire-element-id="475871">Blit sur le point chaud</h6><p id="r-475864" data-claire-element-id="475864">Les librairies graphiques ne gèrent pas les points chauds. Elles fournissent une fonction &quot;Blit&quot; (SDL_BlitSurface par exemple) qui va blitter de tel sorte que le point (x,y) passé soit le coin supérieur gauche de l'image.</p><p id="r-475865" data-claire-element-id="475865">Pour créer une fonction &quot;BlitAuPointChaud&quot;, il suffit de faire deux soustractions.<br/> Soit une fonction :</p><pre id="r-475866" data-claire-element-id="475866"><code data-claire-semantic="c">void Blit(Image Source,Image Destination,int x,int y);</code></pre><p id="r-475867" data-claire-element-id="475867">La fonction BlitAuPointChaud s'implémente ainsi :</p><pre id="r-475868" data-claire-element-id="475868"><code data-claire-semantic="c">void BlitAuPointChaud(Image Source,Image Destination,int x,int y,int xpointchaud,ypointchaud)
{
   Blit(Source,Destination,x-xpointchaud,y-ypointchaud);
}</code></pre><p id="r-475869" data-claire-element-id="475869">Pour les utilisateurs de SDL, nous aurons :</p><pre id="r-475870" data-claire-element-id="475870"><code data-claire-semantic="c">void BlitAuPointChaud(SDL_Surface* Source,SDL_Surface* Destination,int x,int y)
{
   SDL_Rect R;
   R.x = x - xpointchaud;
   R.y = y - ypointchaud;
   SDL_BlitSurface(source,NULL,destination,&amp;R);
}</code></pre><h5 id="r-le-point-d-action" data-claire-element-id="475886">Le point d'action</h5><p id="r-475873" data-claire-element-id="475873">Le point d'action est un autre point que le graphiste peut mettre pour nous aider. Regardons le dessin suivant :</p><figure id="r-475875" data-claire-element-id="475876"><img id="r-475874" data-claire-element-id="475874" src="medias/uploads.siteduzero.com_files_248001_249000_248153.png" alt="Image utilisateur"/></figure><p id="r-475877" data-claire-element-id="475877">On peut voir ici plusieurs images de Ken donnant un coup. Regardez, j'ai placé à chaque fois un point violet à l'endroit du potentiel point d'impact.</p><p id="r-475878" data-claire-element-id="475878">L'idée est simple : c'est encore le graphiste qui va définir le &quot;point d'action&quot; pour chaque image ou le personnage donne un coup.<br/> Et en tant que programmeur, je vais dire &quot;si le personnage donne un coup, alors je regarde si le point d'action touche l'adversaire. Si c'est le cas, il se prend le coup, et seulement dans ce cas là&quot;.</p><p id="r-475879" data-claire-element-id="475879">Vous voyez, si Ken donne un coup de poing, seul le poing est dangereux. Si l'adversaire est derrière contre sa jambe, il n'a pas à se prendre le coup.</p><p id="r-475880" data-claire-element-id="475880">L'idée du point d'action permettra de tester une collision avec un simple algorithme du &quot;Point dans AABB&quot;, vu tout au début de ce tutoriel !<br/> Le graphiste rajoute la une information extrêmement enrichissante et qui simplifie la vie au programmeur.</p><p id="r-475881" data-claire-element-id="475881">Le point d'action est également une coordonnée (x,y) relative à l'image.<br/> Si on veut savoir où se trouve le point d'impact sur l'écran, il suffit de faire l'opération suivante :</p><p id="r-475882" data-claire-element-id="475882">xpointimpact = (xpositionperso - xpointchaud) + xpointactionypointimpact = (ypositionperso - ypointchaud) + ypointaction</p><p id="r-475883" data-claire-element-id="475883">On testera ensuite le point (xpointimpact,ypointimpact) dans l'algorithme &quot;point dans AABB&quot;.</p><p id="r-475884" data-claire-element-id="475884">La difficulté de cette collision ne vient donc pas des fonctions utilisées, qui sont simples, mais de la conception d'un éditeur permettant de définir un point chaud et un point d'action pour chaque image.</p><p id="r-475885" data-claire-element-id="475885">Évidemment, le point d'action n'a de sens que si un coup est porté, et pas si le personnage est en attente. Alors on peut mettre un point d'action bidon, ou pas de point d'action du tout pour les autres images, et le considérer uniquement si le personnage est dans un statut offensif. À vous de définir tout ça selon vos besoins.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">
<span class="arrow"></span>
<span class="next">Sprites enrichis</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
<span class="next">Sous AABB</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="SousAABB"></a><h2>Sous AABB</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
<span class="arrow"></span>
<span class="next">Point chaud et point d&#039;action</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">
<span class="next">Collisions spécifiques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-sous-aabb" data-claire-element-id="475911">Sous AABB</h4><p id="r-475888" data-claire-element-id="475888">La notion de sous AABB (ou Sub AABB, qu'on notera <strong>SAABB</strong>) va permettre des collisions plus fines, et pas tellement plus calculatoires. Cependant, tout comme les points chauds et points d'action, les informations de SAABB devront être fournies avec les sprites au programmeur, grâce à un éditeur créé pour l'occasion.</p><h5 id="r-definition-64" data-claire-element-id="475901">Définition</h5><p id="r-475889" data-claire-element-id="475889">Regardons ensemble l'image suivante :</p><figure id="r-475891" data-claire-element-id="475892"><img id="r-475890" data-claire-element-id="475890" src="medias/uploads.siteduzero.com_files_248001_249000_248160.png" alt="Image utilisateur"/></figure><p id="r-475893" data-claire-element-id="475893">Nous voyons Ken dans plusieurs positions. Cependant, vous pouvez constater que j'ai rajouté des AABB autour de lui, dans chaque image. Ce sont les SAABB. J'en ai rajouté seulement quelques unes, mais qui permettent d'approximer la forme correctement.</p><h6 id="r-collision" data-claire-element-id="475896">Collision</h6><p id="r-475894" data-claire-element-id="475894">Nous avons vu qu'un algorithme de collision dans ce cas là peut être simplement un algorithme de &quot;Point dans AABB&quot;. Si nous considérons la AABB globale de l'image cible, vous restez trop approximatif dans notre cas : vous pouvez frapper l'air au dessus de l'épaule de Ken...</p><p id="r-475895" data-claire-element-id="475895">Pour un algorithme plus fin, on appellera plusieurs fois l'algorithme &quot;Point dans AABB&quot; dans chacune des SAABB. Si le point testé touche une seule SAABB, alors il y a collision.</p><h6 id="r-premiere-optimisation" data-claire-element-id="475898">Première optimisation</h6><p id="r-475897" data-claire-element-id="475897">Si on veut tester la collision d'un point dans le personnage, avant de tester chaque SAABB, on testera d'abord la AABB entière, celle de l'image.<br/> Si on ne touche pas cette AABB, inutile d'aller plus loin : il n'y a pas collision.<br/> Sinon, on teste chacune des SAABB.</p><h6 id="r-deuxieme-optimisation" data-claire-element-id="475900">Deuxième optimisation</h6><p id="r-475899" data-claire-element-id="475899">Nous pouvons considérer les SAABB en hiérarchie. Par exemple, vous voyez la première image, il y a plusieurs SAABB bleues côte à côte. Soit on les teste une par une, soit on teste d'abord la AABB de l'ensemble des boîtes bleues. Si on ne touche pas cette dernière, inutile de tester chacune des SAABB internes...</p><h5 id="r-davantage-de-semantique" data-claire-element-id="475910">Davantage de sémantique</h5><p id="r-475902" data-claire-element-id="475902">Vous savez, dans Street Fighter 2 ou autres jeux de combat, un personnage souffrira différemment si il prend un coup dans la tête, dans le corps, ou dans les jambes.</p><p id="r-475903" data-claire-element-id="475903">Regardez le dessin ci-dessus : j'ai fait exprès de dessiner en bleu les boîtes correspondant aux jambes, en jaune celle de la tête, en vert celle du torse, en violet celle des bras.<br/> Si le graphiste respecte bien un tel codage de SAABB, alors on pourra détecter, lors d'une collision, dans quelle couleur de SAABB tape le point d'action de l'autre joueur.</p><aside id="r-475905" data-claire-element-id="475905" data-claire-semantic="information"><p id="r-475904" data-claire-element-id="475904">Cela nous permettra de savoir immédiatement si on a tapé dans la tête, dans le torse, les pieds...</p></aside><p id="r-475906" data-claire-element-id="475906">C'est ce qu'on appelle rajouter de la sémantique directement au niveau des sprites.</p><p id="r-475907" data-claire-element-id="475907">Au lieu d'avoir une suite d'image sans données, on aura une banque de sprite, qui contiendra des images, mais aussi plein d'informations pour chaque image, informations qui auront été rentrées graphiquement à la souris avec un éditeur, et qui faciliteront énormément le travail des programmeurs.</p><p id="r-475908" data-claire-element-id="475908">Cette partie nécessite donc un travail en amont au niveau de la création des sprites pour être utilisable.<br/> N'oubliez pas que les boîtes de jeux se programment souvent leurs propres éditeurs, leurs propres outils, en fonction de leurs besoins.</p><p id="r-475909" data-claire-element-id="475909">L'idée est de donner graphiquement le maximum de sémantique au niveau des images elles mêmes, pour simplifier la tâche du programmeur par la suite.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
<span class="arrow"></span>
<span class="next">Point chaud et point d&#039;action</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">
<span class="next">Collisions spécifiques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Collisionsspcifiques"></a><h2>Collisions spécifiques</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
<span class="arrow"></span>
<span class="next">Sous AABB</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
<span class="next">Pong</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-475913" data-claire-element-id="475913">Après ce bouquet d'algorithmes de collisions, il peut être intéressant de voir quelques collisions spécifiques.<br/> En effet, chaque type de jeu peut profiter de ses spécificités pour proposer quelques algorithmes de collision qui lui seront propres, et plus rapides dans leur cas.</p><p id="r-475914" data-claire-element-id="475914">Je ne vous propose pas de vérités absolues, mais simplement des idées astucieuses pour gagner du temps. Si vous avez d'autres pistes pour améliorer ce que je propose, n'hésitez pas à m'envoyer un message ! ;)</p>
</div><a name="Pong"></a><h2>Pong</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">
<span class="arrow"></span>
<span class="next">Collisions spécifiques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
<span class="next">Course vue du dessus</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-pong" data-claire-element-id="475949">Pong</h4><p id="r-475915" data-claire-element-id="475915">Notre premier exemple : <strong>Pong</strong>, un des plus vieux jeu vidéo.</p><h5 id="r-presentation-127" data-claire-element-id="475921">Présentation</h5><p id="r-475916" data-claire-element-id="475916">On ne présente plus Pong : 2 raquettes, et une balle. La balle rebondit sur les murs, et si on ne la rattrape pas, on perd le point.</p><figure id="r-475918" data-claire-element-id="475919"><img id="r-475917" data-claire-element-id="475917" src="medias/uploads.siteduzero.com_files_245001_246000_245948.png" alt="Image utilisateur"/></figure><p id="r-475920" data-claire-element-id="475920">L'algorithme de collisions testera donc la collision avec chacune des raquettes. La balle est carrée, les raquettes sont rectangles, comme dans le Pong original.<br/> Notez que si la balle est ronde, on peut considérer sa zone de collision comme un carré.</p><h5 id="r-premiere-idee" data-claire-element-id="475925">Première idée</h5><p id="r-475922" data-claire-element-id="475922">Notre première approche sera donc de détecter <a href="http://www.siteduzero.com/tutoriel-3-254500-formes-simples.html#ss_part_2">les collisions AABB</a>, vues au début de ce chapitre, entre la balle et chacune des raquettes.</p><p id="r-475923" data-claire-element-id="475923">Cela serait rapide avec nos machines actuelles. A chaque itération de notre boucle principale, 2 tests de collision à faire. Le <em>if </em>qu'il y a dans la fonction de collision effectue cependant plusieurs tests, même s'ils sont rapides.</p><p id="r-475924" data-claire-element-id="475924">Nous pouvons aller encore plus vite, et faire moins de calcul, ce qui n'était pas du luxe pour les premières machines qui ont fait tourner Pong.</p><h5 id="r-test-specifique" data-claire-element-id="475948">Test spécifique</h5><p id="r-475926" data-claire-element-id="475926">Regardons l'image ci dessus. J'ai rajouté 2 traits verticaux rouges.<br/> L'idée est simple, si la balle traverse un de ces traits rouge, alors on doit tester si on touche la raquette concernée ou non. Soit la balle rebondit, soit on perd un point.</p><p id="r-475927" data-claire-element-id="475927">Dans Pong, les raquettes se déplacent verticalement, mais pas latéralement. De ce fait, la position de ces hypothétiques traits rouges <strong>sera constante</strong>.</p><p id="r-475928" data-claire-element-id="475928">Si on regarde à gauche, le trait rouge touche la raquette, si on regarde à droite, ce n'est pas le cas, pourquoi ? Eh bien parce que la position de la balle est définie par son coin supérieur gauche. De ce fait, si le coin supérieur gauche touche le trait rouge de droite, alors la balle touche la raquette, l'espace entre le trait et la raquette étant la largeur de la balle. Cela nous évitera de calculer sans cesse le point de droite de la balle.</p><p id="r-475929" data-claire-element-id="475929">De ce fait, dans notre boucle principale, au lieu d'appeler 2 fois une fonction de collision à plusieurs tests, nous allons faire uniquement 2 tests :</p><pre id="r-475930" data-claire-element-id="475930"><code data-claire-semantic="c">if (balle.x&lt;X_TRAIT_ROUGE_GAUCHE)
{
  TestCollisionY(balle,raquette1);
  ...
}
if (balle.x&gt;X_TRAIT_ROUGE_DROITE)
{
  TestCollisionY(balle,raquette2);
  ...
}</code></pre><p id="r-475931" data-claire-element-id="475931">Dans la majorité des cas, quand la balle transite au milieu, on ne rentrera pas dans ces if.<br/> Que faire maintenant si on rentre dans le if ?</p><p id="r-475932" data-claire-element-id="475932">Il suffira de tester la position y de la balle, par rapport à celle de la raquette.</p><p id="r-475933" data-claire-element-id="475933">La balle touchera la raquette si :</p><ul id="r-475938" data-claire-element-id="475938"><li id="r-475935" data-claire-element-id="475935"><p id="r-475934" data-claire-element-id="475934">balle.y + balle.h &gt; raquette.y</p></li><li id="r-475937" data-claire-element-id="475937"><p id="r-475936" data-claire-element-id="475936">balle.y &lt; raquette.y + raquette.w</p></li></ul><p id="r-475939" data-claire-element-id="475939">Sinon, elle ne touche pas, et on perd le point.</p><p id="r-475940" data-claire-element-id="475940">Cela peut s'écrire aussi :</p><ul id="r-475945" data-claire-element-id="475945"><li id="r-475942" data-claire-element-id="475942"><p id="r-475941" data-claire-element-id="475941">balle.y &gt; raquette.y - balle.h</p></li><li id="r-475944" data-claire-element-id="475944"><p id="r-475943" data-claire-element-id="475943">balle.y &lt; raquette.y + raquette.w</p></li></ul><p id="r-475946" data-claire-element-id="475946">Si on regarde de nouveau le dessin ci-dessus, on voit le trait jaune qui correspond à la position &quot;raquette.y - balle.h&quot;.</p><p id="r-475947" data-claire-element-id="475947">Cet algorithme sera un petit peu plus rapide que les collisions AABB, et il est plus intuitif, même si sur nos machines actuelles, cela n'a plus aucune importance pour un Pong. :)</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">
<span class="arrow"></span>
<span class="next">Collisions spécifiques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
<span class="next">Course vue du dessus</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Coursevuedudessus"></a><h2>Course vue du dessus</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
<span class="arrow"></span>
<span class="next">Pong</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
<span class="next">Labyrinthe</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-course-vue-du-dessus" data-claire-element-id="475994">Course vue du dessus</h4><p id="r-475950" data-claire-element-id="475950">Voici maintenant une astuce pour les collisions dans un jeu de course vu du dessus sur des pistes courbes. C'est <a href="http://www.siteduzero.com/forum-83-538238-p1-gestion-des-collision.html#r5172614">ce topic</a> qui m'a inspiré cette idée.</p><h5 id="r-presentation-128" data-claire-element-id="475962">Présentation</h5><p id="r-475951" data-claire-element-id="475951">Vous avez dessiné une piste comme ci-dessous :</p><figure id="r-475953" data-claire-element-id="475954"><img id="r-475952" data-claire-element-id="475952" src="medias/uploads.siteduzero.com_files_245001_246000_245962.png" alt="Image utilisateur"/></figure><p id="r-475955" data-claire-element-id="475955">Votre route est la zone marron. Vous êtes le véhicule bleu, et vous souhaitez tester les collisions avec le décor (le vert). L'idée étant de ne pas sortir. Vous déplacez votre véhicule et vous voulez tester la collision avec le décor.</p><h6 id="r-pourquoi-un-cercle" data-claire-element-id="475961">Pourquoi un cercle</h6><p id="r-475956" data-claire-element-id="475956">Dans ce genre de jeux, la voiture peut tourner à 360°. Nous pouvons donc considérer une OBB qui s'adaptera à l'angle de rotation de la voiture, ou bien considérer que la voiture n'est pas trop longue, et donc s'inscrira dans un cercle qui lui ne dépendra donc pas de l'angle de rotation, ce sera plus simple, et tout aussi efficace.</p><p id="r-475957" data-claire-element-id="475957">Voici une image du jeu &quot;micro machine&quot; qui gère probablement ses collisions avec des cercles. J'ai rajouté les cercles moi même sur l'image, en mauve :</p><figure id="r-475959" data-claire-element-id="475960"><img id="r-475958" data-claire-element-id="475958" src="medias/uploads.siteduzero.com_files_245001_246000_245975.png" alt="Image utilisateur"/></figure><h5 id="r-premiere-idee-1" data-claire-element-id="475965">Première idée</h5><p id="r-475963" data-claire-element-id="475963">Si on considère le problème de cette manière, la première idée est de tester la collision d'un cercle avec des pixels verts. En effet, si un seul pixel bleu touche le vert, alors il y a collision. Nous pensons donc à ce lourd algorithme qu'est le <a href="http://www.siteduzero.com/tutoriel-3-279689-collisions-au-pixel-pres.html#ss_part_2">pixel perfect</a>, décrit plus haut dans ce tutoriel.</p><p id="r-475964" data-claire-element-id="475964">L'idée sera donc de tester chaque point du cercle, et voir s'il touche le bord. C'est assez long et lourd.</p><h5 id="r-les-proprietes-du-cercle" data-claire-element-id="475982">Les propriétés du cercle</h5><p id="r-475966" data-claire-element-id="475966">Nous avons donc dit que nous allions nous servir du cercle pour les collisions. Mais au lieu de tester chaque point du cercle, nous allons nous appuyer sur une propriété du cercle :</p><p id="r-475967" data-claire-element-id="475967"><cite>Citation : Prof de maths</cite></p><blockquote id="r-475969" data-claire-element-id="475969"><p id="r-475968" data-claire-element-id="475968">Tous les points du cercle sont à égale distance du centre, cette distance s'appelle rayon</p></blockquote><p id="r-475970" data-claire-element-id="475970">Donc l'idée est simple, au lieu de considérer tout le cercle et chacun de ses points, on ne considère que le centre du cercle, et on regarde si sa distance au bord de la route est inférieure ou supérieure au rayon. Pour cela, nous allons dessiner sur la carte les zones ou la distance au bord est plus petite que le rayon. Cela, on peut le définir graphiquement, regardez :</p><figure id="r-475972" data-claire-element-id="475973"><img id="r-475971" data-claire-element-id="475971" src="medias/uploads.siteduzero.com_files_245001_246000_245963.png" alt="Image utilisateur"/></figure><p id="r-475974" data-claire-element-id="475974">Ici, j'ai redessiné la même route, mais, j'ai dessiné au bord une bande rouge qui a pour largeur le rayon du cercle.<br/> J'ai redessiné le cercle bleu. Le cercle touche la bordure verte. On constate que son centre, lui, touche la bordure rouge.<br/> On peut donc dire :</p><aside id="r-475976" data-claire-element-id="475976" data-claire-semantic="information"><p id="r-475975" data-claire-element-id="475975">Le cercle touche le vert si et seulement si le centre du cercle touche le rouge</p></aside><p id="r-475977" data-claire-element-id="475977">L'idée sera donc de dessiner cette bande rouge sur le schéma de vos circuits. Évidemment, vous ne serez pas obligés de l'afficher. Nous utiliserons donc le concept plus rapide <a href="http://www.siteduzero.com/tutoriel-3-279689-collisions-au-pixel-pres.html#ss_part_1">des masques</a> décrite dans le chapitre précédent, vous pourrez avoir deux images : une pour le circuit, une pour le masque.</p><h6 id="r-collision-1" data-claire-element-id="475979">Collision</h6><p id="r-475978" data-claire-element-id="475978">Pour savoir si votre voiture touche le bord, il suffira donc de tester si le pixel centre du cercle touche, dans le masque, un pixel rouge (ou vert), ou pas. Un seul pixel à tester !</p><h6 id="r-dessiner-la-bande-rouge" data-claire-element-id="475981">Dessiner la bande rouge</h6><p id="r-475980" data-claire-element-id="475980">Pour avoir de belles collisions, il faudra que la bande rouge ait bien la largueur correspondante au rayon du cercle. Pour cela, les logiciels de dessins proposent un pinceau dont on peut souvent définir la largueur. Cela rend de bons résultats, suffisants.</p><h5 id="r-approche-mathematique-3" data-claire-element-id="475993">Approche mathématique</h5><p id="r-475983" data-claire-element-id="475983">Pour la plupart d'entre vous, cette partie ne servira pas. Un coup de pinceau de bonne largeur dans Paint suffit à donner un bon résultat.</p><p id="r-475984" data-claire-element-id="475984">Cette partie sert juste à définir mathématiquement le concept évoqué.</p><figure id="r-475986" data-claire-element-id="475987"><img id="r-475985" data-claire-element-id="475985" src="medias/uploads.siteduzero.com_files_245001_246000_245964.gif" alt="Image utilisateur"/></figure><p id="r-475988" data-claire-element-id="475988">Si on considère que le bord de la route est une courbe C, alors le bord de la zone rouge est la courbe offset O de la courbe C, à distance d. <br/> Une courbe d'offset, c'est une courbe dont chaque point est à une distance d fixée de la courbe originale. Ci dessus, si on regarde la courbe bleu ciel, elle est en tout point à égale distance de la courbe marron. Chaque segment bleu fait la même longueur.</p><p id="r-475989" data-claire-element-id="475989">La courbe offset O(u), à distance d, de la courbe C(u) se définit par la formule suivante :</p><p id="r-475990" data-claire-element-id="475990">O(u) = C(u) + d*N(u)</p><p id="r-475991" data-claire-element-id="475991">N(u) est la normale à la courbe au point de paramètre u.</p><p id="r-475992" data-claire-element-id="475992">N(u) = \frac{C'(u)\wedge{A}}{||C'(u)\wedge{A}||} avec A vecteur normal au plan A = {0,0,1}</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
<span class="arrow"></span>
<span class="next">Pong</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
<span class="next">Labyrinthe</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Labyrinthe"></a><h2>Labyrinthe</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
<span class="arrow"></span>
<span class="next">Course vue du dessus</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">
<span class="next">Formes simples</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-labyrinthe" data-claire-element-id="476047">Labyrinthe</h4><p id="r-475995" data-claire-element-id="475995">Voici maintenant des petits algorithmes de collision pour les labyrinthes.</p><h5 id="r-definition-65" data-claire-element-id="476023">Définition</h5><p id="r-475996" data-claire-element-id="475996">Nous allons parler des labyrinthes basés sur une grille, comme ci-dessous :</p><figure id="r-475998" data-claire-element-id="475999"><img id="r-475997" data-claire-element-id="475997" src="medias/uploads.siteduzero.com_files_247001_248000_247550.png" alt="Image utilisateur"/></figure><p id="r-476000" data-claire-element-id="476000">Il existe plusieurs types de codage pour les labyrinthes.</p><p id="r-476001" data-claire-element-id="476001">En voici deux formes :</p><figure id="r-476003" data-claire-element-id="476004"><img id="r-476002" data-claire-element-id="476002" src="medias/uploads.siteduzero.com_files_247001_248000_247552.png" alt="Image utilisateur"/></figure><figure id="r-476006" data-claire-element-id="476007"><img id="r-476005" data-claire-element-id="476005" src="medias/uploads.siteduzero.com_files_247001_248000_247551.png" alt="Image utilisateur"/></figure><p id="r-476008" data-claire-element-id="476008">La première forme, nous l'avons déjà rencontrée quand nous parlions du <a href="http://www.siteduzero.com/tutoriel-3-254499-decor.html#ss_part_2">tile mapping</a> dans ce tutoriel. La collision est donc du même type, à savoir déterminer au dessus de quelle(s) case(s) est notre personnage, puis dire qu'il y a collision si une de ces cases est un mur.</p><p id="r-476009" data-claire-element-id="476009">Nous allons nous intéresser au deuxième cas, où cette fois les murs sont fins, et sont les bords de chaque carré de la grille.</p><h6 id="r-codage" data-claire-element-id="476022">Codage</h6><p id="r-476010" data-claire-element-id="476010">Avant de parler collision, il faut voir comment ceci est codé en mémoire. Ici, nous considèrerons un codage basé sur une grille comme le tile mapping.</p><p id="r-476011" data-claire-element-id="476011">Nous aurons donc le labyrinthe stocké en tant que tableau en deux dimensions de &quot;Case&quot;. Chaque case aura chacun de ses bords qui sera un mur ou non. La première idée est donc de se dire &quot;chaque case a donc 4 murs potentiels&quot;, un en haut, un en bas, un à gauche, un à droite. Mais si vous regardez mieux, vous verrez qu'on peut même considérer chaque case comme ayant potentiellement 2 murs : un en haut, un à gauche.</p><p id="r-476012" data-claire-element-id="476012">Regardez cette image :</p><figure id="r-476014" data-claire-element-id="476015"><img id="r-476013" data-claire-element-id="476013" src="medias/uploads.siteduzero.com_files_247001_248000_247637.png" alt="Image utilisateur"/></figure><p id="r-476016" data-claire-element-id="476016">Voici les 4 types de cases nécessaires et suffisants pour reconstruire le labyrinthe ci-dessus. Regardez l'image ci-dessus et constatez que l'on peut construire ce résultat avec seulement ces 4 cases là.</p><p id="r-476017" data-claire-element-id="476017">C'est économique, et il n'y a pas de redondances, contrairement à un codage avec 4 murs par case.</p><p id="r-476018" data-claire-element-id="476018">Le seul inconvénient, qui n'en est pas vraiment un, est qu'on n'ira jamais sur les cases tout à droite et tout en bas du labyrinthe : l'image ci-dessus le montre, on a l'impression que la ligne du bas, et la colonne de droite sont de trop, alors qu'elles permettent simplement de ne pas faire d'exceptions pour notre codage.</p><p id="r-476019" data-claire-element-id="476019">Bref, un labyrinthe est donc un tableau en 2D de cases qui contiennent chacune uniquement 2 bits : une pour le mur d'en haut (présent ou non), un pour le mur de gauche.</p><p id="r-476020" data-claire-element-id="476020">Si on illustre cela par du pseudo code, on obtient :</p><pre id="r-476021" data-claire-element-id="476021"><code data-claire-semantic="c">struct Case
{
  unsigned int murgauche:1;  // variable d'un bit
  unsigned int murhaut:1;  // variable d'un bit
};

struct Laby
{
   struct Case** Tableau;   // tableau 2D. Certains préfèreront la syntaxe : Case[X][Y];
   int X,Y;  // taille labyrinthe
   int LARGEURCASE,HAUTEURCASE; // nom explicite
   int Orx,Ory;  // Origine du labyrinthe en x et y : si la première case ne commence pas à (0,0)
};</code></pre><h5 id="r-calcul-de-collision-10" data-claire-element-id="476046">Calcul de collision</h5><p id="r-476024" data-claire-element-id="476024">A partir de là, voici comment on va faire pour savoir si on touche un mur. Observons ci-dessous une image qui nous servira d'exemple :</p><figure id="r-476026" data-claire-element-id="476027"><img id="r-476025" data-claire-element-id="476025" src="medias/uploads.siteduzero.com_files_247001_248000_247638.png" alt="Image utilisateur"/></figure><p id="r-476028" data-claire-element-id="476028">Les carrés de couleur creux représentent les AABB de notre personnage, et les zones de couleurs derrière représentent les cases de la grille impliquées.</p><p id="r-476029" data-claire-element-id="476029">Le calcul de zones de couleur derrière se fait de la même manière que dans le cas des tiles vu plus haut. Rappelez-vous, la zone sera rectangulaire, les coordonnées minimales seront les coordonnées de la zone que touche le point en haut à gauche, et les coordonnées maximales seront les coordonnées de la zone que touche le point en bas à droite.</p><p id="r-476030" data-claire-element-id="476030">Tout s'appuie donc sur une fonction GetPointPosition, qui va, pour un pixel x,y donné, dire dans quelle case (xc,yc) il est :</p><pre id="r-476031" data-claire-element-id="476031"><code data-claire-semantic="c">void GetPointPosition(Laby L,int x,int y,int* xc,int* yc)
{
   *xc = (x-L.Orx)/L.LARGEURCASE;
   *yc = (x-L.Ory)/L.HAUTEURCASE;
}</code></pre><p id="r-476032" data-claire-element-id="476032">Notez que si votre grille commence à la coordonnée (0,0), alors on retombe sur une simple division.</p><p id="r-476033" data-claire-element-id="476033">Le début de la fonction collision consiste donc à calculer xmin,ymin,xmax,ymax, coordonnées minimales et maximales des cases à analyser en fonction de la AABB de notre personnage à tester.</p><pre id="r-476034" data-claire-element-id="476034"><code data-claire-semantic="c">int Collision(Laby L,AABB box)
{
   int xmin,xmax,ymin,ymax;
   GetPointPosition(L,box.x,box.y,&amp;xmin,&amp;ymin);
   GetPointPosition(L,box.x+box.w-1,box.y+box.h-1,&amp;xmin,&amp;ymin);
   ...
}</code></pre><p id="r-476035" data-claire-element-id="476035">Une fois que nous avons xmin,xmax,ymin,ymax, il ne reste plus qu'à tester s'il y a un mur au milieu de la zone.</p><p id="r-476036" data-claire-element-id="476036">Si on regarde la zone rouge ci-dessus : le personnage est inclus dans une seule case. On a xmin = xmax et ymin = ymax : pas de collision avec le mur possible.</p><p id="r-476037" data-claire-element-id="476037">Si on regarde la zone bleue : il y aura collision uniquement si la case de droite a son mur gauche actif (concrètement, le mur vertical entre les deux).</p><p id="r-476038" data-claire-element-id="476038">Si on regarde la zone violette, il faudra vérifier tous les murs (traits noirs) au milieu, et pareil pour la zone jaune, où l'on considère un gros personnage !</p><aside id="r-476040" data-claire-element-id="476040" data-claire-semantic="information"><p id="r-476039" data-claire-element-id="476039">L'idée est donc de regarder le mur haut de toutes les cases, sauf celles d'en haut de la zone, et le mur gauche de toutes les cases, sauf celles d'à gauche de la zone.</p></aside><p id="r-476041" data-claire-element-id="476041">Si un seul de ces murs est présent, alors notre personnage touche un mur, et il y a collision.</p><p id="r-476042" data-claire-element-id="476042">Le code suivant illustre simplement cela :</p><pre id="r-476043" data-claire-element-id="476043"><code data-claire-semantic="c">int Collision(Laby L,AABB box)
{
   int xmin,xmax,ymin,ymax;
   GetPointPosition(L,box.x,box.y,&amp;xmin,&amp;ymin);
   GetPointPosition(L,box.x+box.w-1,box.y+box.h-1,&amp;xmin,&amp;ymin);
   for(i=xmin;i&lt;=xmax;i++)
   {
     for(j=ymin;j&lt;=ymax;j++)
     {
       if (i!=xmin &amp;&amp; L.Tableau[i][j].murgauche==1)
          return 1;
       if (j!=ymin &amp;&amp; L.Tableau[i][j].murhaut==1)
          return 1;
     }
   }
   return 0; // pas de collision.
}</code></pre><p id="r-476044" data-claire-element-id="476044">Cette partie pourra s'étoffer avec le temps. Je pioche bien souvent mes idées dans les différents sujets que je peux lire sur ce site.</p><p id="r-476045" data-claire-element-id="476045">D'autres algorithmes existent et seront abordés plus tard, selon l'avancement de ce tutoriel.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
<span class="arrow"></span>
<span class="next">Course vue du dessus</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">
<span class="next">Formes simples</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Formessimples"></a><h2>Formes simples</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
<span class="arrow"></span>
<span class="next">Labyrinthe</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
<span class="next">AABB 3D</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-476051" data-claire-element-id="476051">Passons maintenant à la 3D !<br/> Vous allez voir dans ce chapitre que la collisions des formes 3D simples ressemble étrangement à leur équivalent en 2D.</p>
</div><a name="AABB3D"></a><h2>AABB 3D</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">
<span class="arrow"></span>
<span class="next">Formes simples</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
<span class="next">Sphères</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-aabb-3d" data-claire-element-id="476074">AABB 3D</h4><p id="r-476052" data-claire-element-id="476052">Voici maintenant quelques algorithmes de collision en 3D.<br/> Pour commencer, voyons les collisions AABB mais en 3D.</p><h5 id="r-definition-66" data-claire-element-id="476061">Définition</h5><p id="r-476053" data-claire-element-id="476053">Une Bounding Box 3D, alignée avec les axes, est comme une bounding box 2D vue au dessus, mais avec une dimension supplémentaire.</p><figure id="r-476055" data-claire-element-id="476056"><img id="r-476054" data-claire-element-id="476054" src="medias/uploads.siteduzero.com_files_235001_236000_235110.png" alt="Image utilisateur"/></figure><p id="r-476057" data-claire-element-id="476057">Nous pourrons définir la structure suivante :</p><pre id="r-476058" data-claire-element-id="476058"><code data-claire-semantic="c">struct AABB3D
{
  float x,y,z;
  float w,h,d; 
};</code></pre><p id="r-476059" data-claire-element-id="476059">Nous avons les coordonnées x,y,z du point le plus proche de l'origine du monde, et la largeur w (width), la hauteur h (height) et la profondeur d (depth).</p><p id="r-476060" data-claire-element-id="476060">En 3D, il est d'usage de travailler avec des coordonnées réelles, donc des nombres flottants. Nous travaillons donc dans l'espace réel R^3.</p><h5 id="r-applications-13" data-claire-element-id="476066">Applications</h5><p id="r-476062" data-claire-element-id="476062">Ce type de collision est très utilisé dans les jeux 3D. Ici dans Descent FreeSpace pour détecter les collisions entre vos tirs et les vaisseaux ennemis :</p><figure id="r-476064" data-claire-element-id="476065"><img id="r-476063" data-claire-element-id="476063" src="medias/uploads.siteduzero.com_files_235001_236000_235111.gif" alt="Image utilisateur"/></figure><h5 id="r-calcul-de-collision-11" data-claire-element-id="476073">Calcul de collision</h5><h6 id="r-point-dans-aabb3d" data-claire-element-id="476069">Point dans AABB3D</h6><p id="r-476067" data-claire-element-id="476067">Le calcul est très similaire à celui du premier chapitre. Il suffit de vérifier si le point (de coordonnées x,y,z est entre 6 parois de la AABB3D.</p><pre id="r-476068" data-claire-element-id="476068"><code data-claire-semantic="c">bool Collision(float x,float y,float z,AABB3D box)
{
   if (x &gt;= box.x 
    &amp;&amp; x &lt; box.x + box.w
    &amp;&amp; y &gt;= box.y 
    &amp;&amp; y &lt; box.y + box.h
    &amp;&amp; z &gt;= box.z 
    &amp;&amp; z &lt; box.z + box.d)
       return true;
   else
       return false;
}</code></pre><h6 id="r-collision-de-deux-aabb3d" data-claire-element-id="476072">Collision de deux AABB3D</h6><p id="r-476070" data-claire-element-id="476070">De même, le concept ici est vraiment très proche de celui de collision de deux AABB (2D). Il faudra vérifier, pour une box1, si la box2 n'est pas &quot;trop à gauche&quot;, &quot;trop à droite&quot;, &quot;trop en haut&quot; ou &quot;trop en bas&quot;, comme pour les box 2D, mais également qu'elle ne soit pas non plus &quot;trop devant&quot; et &quot;trop derrière&quot;.<br/> Il suffit d'enrichir le if de la fonction, et nous obtenons alors la fonction suivante :</p><pre id="r-476071" data-claire-element-id="476071"><code data-claire-semantic="c">bool Collision(AABB3D box1,AABB3D box2)
{
   if((box2.x &gt;= box1.x + box1.w)      // trop à droite
	|| (box2.x + box2.w &lt;= box1.x) // trop à gauche
	|| (box2.y &gt;= box1.y + box1.h) // trop en bas
	|| (box2.y + box2.h &lt;= box1.y)  // trop en haut	
        || (box2.z &gt;= box1.z + box1.d)   // trop derrière
	|| (box2.z + box2.d &lt;= box1.z))  // trop devant
          return false; 
   else
          return true; 
}</code></pre>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">
<span class="arrow"></span>
<span class="next">Formes simples</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
<span class="next">Sphères</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Sphres"></a><h2>Sphères</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
<span class="arrow"></span>
<span class="next">AABB 3D</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">
<span class="next">Sol</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-spheres" data-claire-element-id="476099">Sphères</h4><p id="r-476075" data-claire-element-id="476075">Les bounding sphères sont une application en 3D des algorithmes sur les cercles que nous avons vu plus haut.</p><h5 id="r-definition-67" data-claire-element-id="476082">Définition</h5><p id="r-476076" data-claire-element-id="476076">Une sphère est définie par son centre (x,y,z) et son rayon.</p><figure id="r-476078" data-claire-element-id="476079"><img id="r-476077" data-claire-element-id="476077" src="medias/uploads.siteduzero.com_files_235001_236000_235112.jpg" alt="Image utilisateur"/></figure><p id="r-476080" data-claire-element-id="476080">En C, on peut définir cette structure :</p><pre id="r-476081" data-claire-element-id="476081"><code data-claire-semantic="c">struct Sphere
{
  float x,y,z;
  float rayon;
};</code></pre><h5 id="r-applications-14" data-claire-element-id="476087">Applications</h5><p id="r-476083" data-claire-element-id="476083">Un jeu de billard en 3D peut utiliser ce type de collisions. Également d'autres shoot'em up 3D (tel Descent FreeSpace vu ci-dessus) si on considère les vaisseaux inscrits dans des sphères au lieu de AABB3D, les 2 formes peuvent donner de bons résultats).</p><figure id="r-476085" data-claire-element-id="476086"><img id="r-476084" data-claire-element-id="476084" src="medias/uploads.siteduzero.com_files_235001_236000_235113.jpg" alt="Image utilisateur"/></figure><h5 id="r-calcul-de-collision-12" data-claire-element-id="476098">Calcul de collision</h5><p id="r-476088" data-claire-element-id="476088">Les calculs sont très similaires à ceux vus dans le chapitre sur les cercles en 2D.<br/> Ils se basent sur le calcul de distance 3D. Ce calcul est une généralisation de Pythagore dans l'espace :</p><p id="r-476089" data-claire-element-id="476089">d = sqrt((x-C.x)^2 + (y-C.y)^2 + (z-C.z)^2)</p><p id="r-476090" data-claire-element-id="476090">Avec la même astuce, considérant la distance au carré, nous arrivons aux deux fonctions suivantes :</p><h6 id="r-point-dans-une-sphere" data-claire-element-id="476093">Point dans une sphère</h6><p id="r-476091" data-claire-element-id="476091">Soit le point (x,y,z), nous souhaitons savoir s'il est dans la sphère :</p><pre id="r-476092" data-claire-element-id="476092"><code data-claire-semantic="c">bool Collision(float x,float y,float z,Sphere S)
{
   int d2 = (x-S.x)*(x-S.x) + (y-S.y)*(y-S.y) + (z-S.z)*(z-S.z);
   if (d2&gt;S.rayon*S.rayon)
      return false;
   else
      return true;
}</code></pre><h6 id="r-collision-de-deux-spheres" data-claire-element-id="476097">Collision de deux sphères</h6><p id="r-476094" data-claire-element-id="476094">Collision de 2 sphères : voyons si la distance entre les deux centres est supérieure ou inférieure à la somme des rayons.</p><pre id="r-476095" data-claire-element-id="476095"><code data-claire-semantic="c">bool Collision(Sphere S1,Sphere S2)
{
   int d2 = (S1.x-S2.x)*(S1.x-S2.x) + (S1.y-S2.y)*(S1.y-S2.y) + (S1.z-S2.z)*(S1.z-S2.z);
   if (d2 &gt; (S1.rayon + S2.rayon)*(S1.rayon + S2.rayon);
      return false;
   else
      return true;
}</code></pre><p id="r-476096" data-claire-element-id="476096">De même qu'en 2D, ces collisions sont rapides et efficaces.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
<span class="arrow"></span>
<span class="next">AABB 3D</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">
<span class="next">Sol</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Sol"></a><h2>Sol</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
<span class="arrow"></span>
<span class="next">Sphères</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
<span class="next">Heightmap</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-476101" data-claire-element-id="476101">Ici, nous allons voir les collisions 3D avec des décors fixes.</p>
</div><a name="Heightmap"></a><h2>Heightmap</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">
<span class="arrow"></span>
<span class="next">Sol</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-heightmap" data-claire-element-id="476165">Heightmap</h4><p id="r-476102" data-claire-element-id="476102">La Heigtmap (ou carte des hauteurs) est très utilisée dans les jeux 3D pour définir des sols non plats.</p><h5 id="r-definition-68" data-claire-element-id="476117">Définition</h5><p id="r-476103" data-claire-element-id="476103">Considérons une généralisation de la collision sur sol 2D courbe, que nous avons vu au-dessus, mais en 3D. Rappelez-vous, l'idée était de savoir, pour tout x, quel était le y associé avec une fonction y = f(x). À partir de là, on pouvait marcher sur une courbe.</p><p id="r-476104" data-claire-element-id="476104">L'idée est la même ici, savoir pour un x,y donné, quel est le z du sol.<br/> Autrement dit de connaître z = f(x,y).</p><p id="r-476105" data-claire-element-id="476105">Le problème, comme plus haut, est de définir cette fonction f(x,y). Afin d'avoir un contrôle des reliefs, nous allons définir cette fonction à partir d'une simple image. Et c'est cette image que nous appellerons Heigtmap.</p><p id="r-476106" data-claire-element-id="476106">Voici une Heightmap, à gauche, et le terrain qu'elle permettra de générer, à droite :</p><figure id="r-476108" data-claire-element-id="476109"><img id="r-476107" data-claire-element-id="476107" src="medias/uploads.siteduzero.com_files_235001_236000_235116.png" alt="Image utilisateur"/></figure><figure id="r-476111" data-claire-element-id="476112"><img id="r-476110" data-claire-element-id="476110" src="medias/uploads.siteduzero.com_files_235001_236000_235117.png" alt="Image utilisateur"/></figure><p id="r-476113" data-claire-element-id="476113">Source : <a href="http://en.wikipedia.org/wiki/Heightmap">http://en.wikipedia.org/wiki/Heightmap</a></p><p id="r-476114" data-claire-element-id="476114">La heightmap est une image (un BMP par exemple) en noir et blanc, avec des nuances de gris.<br/> À partir de cette image, on reconstruit le sol 3D de droite.<br/> Le concept est simple, pour un x,y donné, on regarde la couleur du pixel sur le BMP. Plus le pixel est blanc, plus l'altitude à cette position est élevée.</p><p id="r-476115" data-claire-element-id="476115">Regardez, on voit bien que les zones noires à gauche sont représentées par des creux à droite, et les zones blanches par des pics de montagne.</p><p id="r-476116" data-claire-element-id="476116">La couleur du pixel à un x,y donné est finalement le z attendu. Nous avons donc notre fonction z = f(x,y). C'est le BMP.</p><h5 id="r-applications-15" data-claire-element-id="476126">Applications</h5><p id="r-476118" data-claire-element-id="476118">Beaucoup de jeux où vous pouvez marcher en extérieur dans un monde fait de relief. Beaucoup de jeux de voitures actuels sont fait avec un Heightmap.</p><figure id="r-476120" data-claire-element-id="476121"><img id="r-476119" data-claire-element-id="476119" src="medias/uploads.siteduzero.com_files_235001_236000_235269.jpg" alt="Image utilisateur"/></figure><figure id="r-476123" data-claire-element-id="476124"><img id="r-476122" data-claire-element-id="476122" src="medias/uploads.siteduzero.com_files_235001_236000_235272.jpg" alt="Image utilisateur"/></figure><p id="r-476125" data-claire-element-id="476125">Notez qu'on peut définir une altitude minimale (qui correspondra au pixel noir) et une altitude maximale (qui correspondra au pixel blanc) de notre choix.<br/> Cela permet de faire des dénivelés plus ou moins importants, en fonction de nos besoins. Par exemple, à gauche, le sol est peu vallonné, alors qu'il l'est énormément dans le jeu de voiture (Monster Truck).</p><h5 id="r-calcul-de-collision-13" data-claire-element-id="476131">Calcul de collision</h5><p id="r-476127" data-claire-element-id="476127">La fonction &quot;simple&quot; de collision sur une HeightMap n'est pas si compliquée. Nous ne définirons pas de structure Image, nous partirons juste du principe qu'on peut demander la valeur Z (la blancheur) d'un pixel x,y.</p><p id="r-476128" data-claire-element-id="476128">Nous calculerons donc d'abord, pour une AABB3D, le point en bas au centre, de la même façon que nous l'avions fait pour le chapitre sur le sol courbe. Nous considèrerons, pour notre AABB3D, l'axe z de bas en haut.</p><pre id="r-476129" data-claire-element-id="476129"><code data-claire-semantic="c">bool Collision(AABB3D box,Image Im)
{
   float x = box.x + box.w/2;
   float y = box.y + box.h/2;
   float z = box.z + box.d;
   int ix = round(x);
   int iy = round(y);
   int hauteursol = GetPixel(Image,ix,iy);
   if (hauteursol&gt;z)
      return true;
   else
      return false;
}</code></pre><p id="r-476130" data-claire-element-id="476130">Cette fonction va prendre, pour un x (ou un y) donné, la valeur entière la plus proche (la fonction round) pour trouver l'altitude.</p><h5 id="r-affinage-mathematique" data-claire-element-id="476164">Affinage mathématique</h5><p id="r-476132" data-claire-element-id="476132">Cette partie requiert certaines connaissances mathématiques universitaires (ou fin de lycée).</p><h6 id="r-probleme-de-discontinuite" data-claire-element-id="476139">Problème de discontinuité</h6><p id="r-476133" data-claire-element-id="476133">La fonction que nous avons vu juste au-dessus présente un inconvénient majeur, elle nous génère un &quot;escalier&quot;. Cela ne se voit pas trop si le terrain est &quot;serré&quot;, c'est-à-dire s'il y a peu de distance entre f(x,y) et f(x+1,y) (et de même pour y). Mais cela va faire de grandes cassures dans le cas contraire.<br/> Voyons le schéma ci-dessous :</p><figure id="r-476135" data-claire-element-id="476136"><img id="r-476134" data-claire-element-id="476134" src="medias/uploads.siteduzero.com_files_235001_236000_235273.png" alt="Image utilisateur"/></figure><p id="r-476137" data-claire-element-id="476137">Ce que nous avons vu, c'est le cas A. Imaginez qu'on regarde une seule ligne de notre terrain, et de profil. Les points verts sont les points d'altitude, de coordonnées x= 0, 1, 2 et 3. <br/> Les traits rouges sont les valeurs de la fonction entre 0 et 1, entre 1 et 2, et entre 2 et 3.</p><p id="r-476138" data-claire-element-id="476138">La fonction round() arrondit au nombre entier le plus proche, donc typiquement, la limite est au milieu, à 0.5, 1.5, 2.5<br/> Et c'est la que nous avons une belle cassure. Et si nous faisons ainsi avancer notre personnage, quand il atteindra la limite, il va monter ou descendre d'un coup, ce qui pourra être bien moche.</p><h6 id="r-interpolation-lineaire-1" data-claire-element-id="476149">Interpolation linéaire</h6><p id="r-476140" data-claire-element-id="476140">Si nous regardons pour le moment la courbe, cas A, nous connaissons les valeurs de y que pour x = 0, x = 1, x = 2 ... Mais nous ne les connaissons pas pour x = 1.5 par exemple.<br/> Un calcul d'interpolation permet de trouver des valeurs correctes pour toutes les valeurs de x, même si x est un nombre décimal.</p><p id="r-476141" data-claire-element-id="476141">Le principe de l'interpolation linéaire est le suivant : pour un x donné, nous séparons sa partie entière de sa partie décimale comme ceci :</p><p id="r-476142" data-claire-element-id="476142">i = \lfloor x floor \\d = x - i</p><p id="r-476143" data-claire-element-id="476143">Par exemple, pour x = 1.5, nous obtenons i = 1 et d = 0.5.</p><p id="r-476144" data-claire-element-id="476144">La formule d'interpolation linéaire est la suivante :<br/>y = f(i+1)*d + f(i)*(1-d)</p><p id="r-476145" data-claire-element-id="476145">Exemple : soit f(1) = 4, f(2) = 5. Nous cherchons f(1.4)<br/> i = 1, d = 0.4<br/>y = 4*0.4 + 5*0.6 = 4.6</p><p id="r-476146" data-claire-element-id="476146">Cela fonctionne dans tous les cas, même si nous avons une valeur de x entière. Nous cherchons f(2)<br/> i = 2, d = 0.0<br/>y = f(3)*0 + f(2)*1 = f(2) = 5</p><aside id="r-476148" data-claire-element-id="476148" data-claire-semantic="information"><p id="r-476147" data-claire-element-id="476147">La formule fonctionne donc dans tous les cas, pour un x quelconque, compris dans le domaine de la courbe.</p></aside><h6 id="r-interpolation-bilineaire" data-claire-element-id="476156">Interpolation bilinéaire</h6><p id="r-476150" data-claire-element-id="476150">Si nous considérons une surface z = f(x,y) dont nous ne connaissons que x et y entiers (une Heightmap typiquement), nous pouvons calculer une interpolation avec des x,y réels de la même manière. Tout d'abord, nous prenons la partie entière et décimale de x et y :</p><p id="r-476151" data-claire-element-id="476151">i_x = \lfloor x floor \\d_x = x - i_xi_y = \lfloor y floor \\d_y = y - i_y</p><p id="r-476152" data-claire-element-id="476152">La formule générale est similaire à celle de l'interpolation linéaire :</p><p id="r-476153" data-claire-element-id="476153">z = ((1-d_x)*f(i_x,i_y)+d_x*f(i_x+1,i_y))*(1-d_y)\\+((1-d_x)*f(i_x,i_y+1)+d_x*f(i_x+1,i_y+1))*d_y</p><p id="r-476154" data-claire-element-id="476154">Cela nous donne la formule de collision suivante :</p><pre id="r-476155" data-claire-element-id="476155"><code data-claire-semantic="c">bool Collision(AABB3D box,Image Im)
{
   float x = box.x + box.w/2;
   float y = box.y + box.h/2;
   float z = box.z + box.d;
   int ix = (int)(x);
   int iy = (int)(y);
   float dx = x - ix;
   float dy = y - iy;
   float hauteursol = ((1-dx)*GetPixel(Image,ix,iy) + dx*GetPixel(Image,ix+1,iy)) * (1-dy)
                     +((1-dx)*GetPixel(Image,ix,iy+1) + dx*GetPixel(Image,ix+1,iy+1)) * dy;
   if (hauteursol&gt;z)
      return true;
   else
      return false;
}</code></pre><h6 id="r-interpolation-cubique-et-bicubique" data-claire-element-id="476163">Interpolation cubique et bicubique</h6><p id="r-476157" data-claire-element-id="476157">L'interpolation cubique permet un lissage beaucoup plus joli de la courbe ou de la surface (bicubique), en utilisant des polynômes de degré 3. C'est le cas C que j'ai dessiné plus haut. Je ne développerai pas cette partie complexe, je voulais juste vous informer que ça existe.<br/> C'est cependant peu utilisé dans les jeux, l'interpolation bilinéaire étant souvent suffisante.</p><p id="r-476158" data-claire-element-id="476158">Ce chapitre s'étoffera avec le temps pour d'autre types des décors.</p><p id="r-476159" data-claire-element-id="476159">Cette rubrique s'étoffera avec le temps, soyez patients !</p><p id="r-476160" data-claire-element-id="476160">Voici donc quelques techniques pour la gestion des collisions.<br/> Plus tard, je rajouterai des chapitres pour parler d'autres techniques, comme les collisions par masque, le pixel perfect, le quadtree, l'octree, le BSP...</p><p id="r-476161" data-claire-element-id="476161">Si vous connaissez d'autres techniques de collisions auxquelles je n'ai pas pensé, envoyez moi un message privé (ne postez pas cela dans les commentaires du tuto).</p><p id="r-476162" data-claire-element-id="476162">Merci de votre lecture. :)</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions">Théorie des collisions</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Collisions en 2D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-aabb">
Point dans AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collision-aabb">
Collision AABB
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles">
Cercles
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-plus-complexes">Formes plus complexes</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-dans-polygone">
Point dans polygone
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-cercle">
Segment cercle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/segment-segment">
Segment Segment
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/cercles-aabb">
Cercles-AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-au-pixel-pres">Collisions au pixel près</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/utilisation-de-masques">
Utilisation de masques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pixel-perfect">
Pixel perfect
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/decor">Décor</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol">
Sol
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-droits">
Tiles droits
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/tiles-isometriques">
Tiles isométriques
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/partitionnement">Partitionnement</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/problematique-2">
Problématique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/la-grille-6">
La grille
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-quadtree">
Le quadtree
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/le-bsp-2d">
Le BSP 2D
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sprites-enrichis">Sprites enrichis</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/point-chaud-et-point-d-action">
Point chaud et point d&#039;action
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sous-aabb">
Sous AABB
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/collisions-specifiques">Collisions spécifiques</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/pong">
Pong
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/course-vue-du-dessus">
Course vue du dessus
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/labyrinthe">
Labyrinthe
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
Collisions en 3D
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/formes-simples-1">Formes simples</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/aabb-3d">
AABB 3D
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/spheres">
Sphères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">Sol</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/heightmap">
Heightmap
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/theorie-des-collisions/sol-1">
<span class="arrow"></span>
<span class="next">Sol</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/eorie-des-collisions.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Oct 2013 23:50:38 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/eorie-des-collisions.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:12:21 GMT -->
</html>
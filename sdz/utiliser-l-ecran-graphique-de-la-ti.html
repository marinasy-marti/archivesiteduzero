<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/utiliser-l-ecran-graphique-de-la-ti.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 04:34:29 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/utiliser-l-ecran-graphique-de-la-ti.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:54:55 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Utiliser l&#039;écran graphique de la TI</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Utiliser l&#039;écran graphique de la TI</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Utiliserl039crangraphiquedelaTI">Utiliser l&#039;écran graphique de la TI</a><br/><a href="#Utilisationprincipaledugraphique">Utilisation principale du graphique</a><br/><a href="#Lesfonctionsdedessin">Les fonctions de dessin</a><br/><a href="#UnRPGcompletenTI-Basic">Un RPG complet en TI-Basic</a><br/></div>
<a name="Utiliserl039crangraphiquedelaTI"></a><h2>Utiliser l&#039;écran graphique de la TI</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/utilisation-principale-du-graphique">
<span class="next">Utilisation principale du graphique</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-549863" data-claire-element-id="549863">Salut les Zéros :p !</p><p id="r-549864" data-claire-element-id="549864">Moi c'est dark link38, et je vais vous apprendre à utiliser l'écran graphique de votre TI !<br/> Pour suivre mon premier tutoriel, vous aurez besoin de :</p><ul id="r-549869" data-claire-element-id="549869"><li id="r-549866" data-claire-element-id="549866"><p id="r-549865" data-claire-element-id="549865">une TI-82 Stats, TI-83+ ou supérieure ;</p></li><li id="r-549868" data-claire-element-id="549868"><p id="r-549867" data-claire-element-id="549867">quelques connaissances en TI-Basic. Je vous conseille pour cela le <a href="http://www.siteduzero.com/tuto-3-1524-0-le-ti-basic.html">tutoriel de Lanfeust 313</a>. Notez que j'utiliserai pour ce big-tuto une TI-83+, ne vous étonnez donc pas si les fonctions sont légèrement différentes des vôtres ;) .</p></li></ul><p id="r-549870" data-claire-element-id="549870">À la fin de ce cours, vous saurez vous servir de l'écran graphique et vous saurez même programmer un jeu qui l'utilise.</p>
</div><a name="Utilisationprincipaledugraphique"></a><h2>Utilisation principale du graphique</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/les-fonctions-de-dessin">
<span class="next">Les fonctions de dessin</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-549871" data-claire-element-id="549871">Configurez l'écran graphique et apprenez à vous servir des fonctions principales, par exemple pour les mathématiques.</p><h2 id="r-configurer-l-ecran-graphique" data-claire-element-id="549877">Configurer l'écran graphique</h2><p id="r-549872" data-claire-element-id="549872">Pour ce premier chapitre, nous allons voir comment configurer l'écran graphique pour pouvoir l'utiliser correctement.<br/> Lorsque vous lancez un jeu ou que vous modifiez les paramètres de votre TI, il est courant que vous rendiez impossible l'affichage des fonctions par exemple. Et ça, ce n'est pas bon si vous êtes en interro de maths.<br/>Note : dans ce big-tuto, j'utiliserai des images obtenues à partir de Virtual-TI, un programme de Rusty Wagner.</p><h3 id="r-les-parametres-par-defaut" data-claire-element-id="549876">Les paramètres par défaut</h3><p id="r-549873" data-claire-element-id="549873">Lorsque vous achetez votre TI, celle-ci est configurée d'une certaine façon qui est commune à toutes : on appelle ça les <strong>réglages d'usine</strong>. Il est très simple de les restaurer, en effet il suffit d'aller dans l'écran de mémoire (2ND:MEM) puis <code>Réinitialiser</code> et enfin <code>Défaut</code>.</p><p id="r-549874" data-claire-element-id="549874">Cette réinitialisation aura pour effet de restaurer les réglages d'usine, mais vos programmes et autres fichiers stockés en mémoire ne seront pas touchés.</p><p id="r-549875" data-claire-element-id="549875">Nous allons apprendre à quoi servent ces paramètres par défaut.</p><h2 id="r-les-parametres-de-fenetre" data-claire-element-id="549896">Les paramètres de FENÊTRE</h2><p id="r-549878" data-claire-element-id="549878">On accède aux paramètres de fenêtre par la touche <code>WINDOW</code> (FENÊTRE).<br/> L'écran suivant s'affiche :</p><figure id="r-549880" data-claire-element-id="549881"><img id="r-549879" data-claire-element-id="549879" src="medias/uploads.siteduzero.com_files_111001_112000_111811.jpg" alt="Image utilisateur"/></figure><p id="r-549882" data-claire-element-id="549882"><code>Xmin</code> et <code>Xmax</code> modifient l'<strong>ensemble de définition</strong> des fonctions affichées sur le graphique. Ainsi, le graphique affichera les représentations graphiques des fonctions sur <code>[Xmin;Xmax]</code>.</p><p id="r-549883" data-claire-element-id="549883">De même pour <code>Ymin</code> et <code>Ymax</code>, le graphique n'affichera que les points dont l'ordonnée est comprise entre -10 et 10.</p><p id="r-549884" data-claire-element-id="549884"><code>Xscl</code> et <code>Yscl</code> modifient la <strong>graduation</strong> des axes X et Y. Pour <code>Xscl=3</code>, on aura une marque pour chaque multiple de 3.</p><p id="r-549885" data-claire-element-id="549885">Enfin, <code>Xres</code> permet de modifier la résolution du graphique. Plus cette valeur est grande, plus l'affichage sera rapide, mais moins la courbe sera précise.</p><p id="r-549886" data-claire-element-id="549886">Concrètement, si <code>Xres=8</code>, on aura un seul point calculé au lieu de huit. On laisse donc souvent cette valeur à 1, mais pour une fonction affine on peut évidemment avoir <code>Xres=8</code>, 8 étant le maximum.</p><p id="r-549887" data-claire-element-id="549887">Voici l'exemple de la fonction sin(x) affichée avec une résolution de 1 puis de 8 :</p><figure id="r-549889" data-claire-element-id="549890"><img id="r-549888" data-claire-element-id="549888" src="medias/uploads.siteduzero.com_files_111001_112000_111812.jpg" alt="Image utilisateur"/></figure><figure id="r-549892" data-claire-element-id="549893"><img id="r-549891" data-claire-element-id="549891" src="medias/uploads.siteduzero.com_files_111001_112000_111813.jpg" alt="Image utilisateur"/></figure><p id="r-549894" data-claire-element-id="549894">Notez que sur ces graphiques, <code>Ymin</code> vaut -2 et <code>Ymax</code> vaut 2. Les autres valeurs sont par défaut.</p><p id="r-549895" data-claire-element-id="549895">On peut constater que la seconde est totalement fausse, mais elle aura été affichée 8 fois plus rapidement. C'est donc à vous de trouver un bon compromis entre qualité et fluidité.</p><h2 id="r-les-parametres-de-zoom" data-claire-element-id="549904">Les paramètres de ZOOM</h2><p id="r-549897" data-claire-element-id="549897">Parfois, vous n'aurez pas besoin de modifier manuellement les paramètres de la fenêtre puisque le menu <code>ZOOM</code> permet de définir des fenêtres déjà configurées.</p><p id="r-549898" data-claire-element-id="549898"><code>ZBox</code> est assez utile car il permet de sélectionner sur le graphique le rectangle contenant les points à afficher : sélectionnez le premier point du rectangle puis choisissez le second afin d'avoir la partie de la courbe que vous souhaitez.</p><p id="r-549899" data-claire-element-id="549899"><code>Zoom In</code> et <code>Zoom Out</code>, comme leur nom l'indique, permettent de zoomer et de dézoomer sur un point du graphique.</p><p id="r-549900" data-claire-element-id="549900">Le <code>ZDecimal</code> permet d'avoir 1 pixel = 0,1 X = 0,1 Y.</p><p id="r-549901" data-claire-element-id="549901">Le <code>ZStandard</code> a le même effet que la réinitialisation des paramètres fenêtre.</p><p id="r-549902" data-claire-element-id="549902">Le <code>Zinteger</code> permet d'avoir 1 pixel = 1X = 1Y.</p><p id="r-549903" data-claire-element-id="549903">Les zooms les plus utilisés sont, comme vous pouvez vous en douter, <code>ZStandard</code> et <code>Zinteger</code>. Dans le chapitre suivant, nous allons aussi utiliser <code>ZoomStat</code> qui permet d'afficher la totalité d'un graphique.</p><h2 id="r-les-parametres-de-tableau" data-claire-element-id="549913">Les paramètres de TABLEAU</h2><p id="r-549905" data-claire-element-id="549905">Ces paramètres sont accessibles par <code>2ND:GRAPH</code>. Cette fois, le menu affiché est beaucoup plus simple :</p><figure id="r-549907" data-claire-element-id="549908"><img id="r-549906" data-claire-element-id="549906" src="medias/uploads.siteduzero.com_files_111001_112000_111814.jpg" alt="Image utilisateur"/></figure><p id="r-549909" data-claire-element-id="549909">En effet, il n'y a que quatre paramètres :<br/><code>TblStart</code>, c'est la valeur de X affichée en premier dans le tableau. Modifiez cette valeur pour éviter d'avoir à appuyer 30 minutes sur la flèche bas pour atteindre des valeurs importantes de X.</p><p id="r-549910" data-claire-element-id="549910"><code>DeltaTbl</code> permet de modifier l'<strong>intervalle</strong> des valeurs de X affichées dans le tableau. Par exemple, si l'on met ce paramètre à 3, le tableau affichera une valeur de X toutes les 3 unités.</p><p id="r-549911" data-claire-element-id="549911"><code>Indpnt</code> permet de choisir entre un affichage automatique ou manuel des valeurs de X. Si vous mettez <strong>Ask</strong>, vous pourrez rentrer dans le tableau une valeur pour X qui sera calculée automatiquement. Cette fonction est pratique lorsque vous devez trouver des ordonnées éloignées.</p><p id="r-549912" data-claire-element-id="549912"><code>Depend</code>, c'est pour choisir entre un affichage automatique ou manuel des valeurs de Y. Si vous mettez <strong>Ask</strong>, il faudra sélectionner une case de la colonne Y pour afficher la valeur correspondante à X. Cette fonction permet par exemple d'éviter à la calculatrice de calculer inutilement des valeurs dont on n'a pas besoin.</p><h2 id="r-les-parametres-de-format" data-claire-element-id="549928">Les paramètres de FORMAT</h2><p id="r-549914" data-claire-element-id="549914">Vous pouvez accéder aux paramètres de format par <code>2ND:ZOOM</code>. Vous obtiendrez cette liste de paramètres :</p><figure id="r-549916" data-claire-element-id="549917"><img id="r-549915" data-claire-element-id="549915" src="medias/uploads.siteduzero.com_files_111001_112000_111815.jpg" alt="Image utilisateur"/></figure><p id="r-549918" data-claire-element-id="549918">Les options sélectionnées par défaut sont les premières de chaque ligne.</p><p id="r-549919" data-claire-element-id="549919">Le paramètre <strong>RectGC/PolarGC</strong> permet de choisir le type d'affichage des coordonnées. Vous pouvez choisir d'afficher des axes X et Y (abscisses et ordonnées) en sélectionnant <code>RectGC</code>, ou R et THETA si vous sélectionnez <code>PolarGC</code>.<br/> Nous ne nous servirons pas de cette dernière option, restez donc sur <code>RectGC</code>.</p><p id="r-549920" data-claire-element-id="549920">Pour afficher ou masquer les coordonnées, choisissez entre <strong>CoordOn</strong> ou <strong>CoordOff</strong>.</p><p id="r-549921" data-claire-element-id="549921"><strong>Grid</strong> contrôle l'affichage ou non de points placés à chaque graduation de X et Y. On obtient donc une grille.</p><p id="r-549922" data-claire-element-id="549922"><strong>AxesOn/Off</strong> sert à afficher ou non les axes X et Y.</p><p id="r-549923" data-claire-element-id="549923"><strong>LabelOn/Off</strong> permet d'afficher les lettres x et y aux extrémités du graphique. C'est une option peu utile.</p><p id="r-549924" data-claire-element-id="549924">Lorsque vous voulez faire une représentation graphique d'une fonction, vous pouvez choisir par <strong>ExprOn</strong> d'afficher l'équation de la courbe lorsque vous utilisez la fonction <code>TRACE</code>, que nous allons voir plus tard.</p><h3 id="r-modifier-les-parametres-1" data-claire-element-id="549927">Modifier les paramètres</h3><p id="r-549925" data-claire-element-id="549925">En fonction de ce que vous voulez afficher avec le graphique ou le tableau, vous aurez besoin de modifier les paramètres de ceux-ci.</p><p id="r-549926" data-claire-element-id="549926">Nous allons voir dans cette partie à quoi servent ces modifications et comment les effectuer en TI-Basic.</p><h2 id="r-modifier-la-fenetre" data-claire-element-id="549939">Modifier la FENÊTRE</h2><p id="r-549929" data-claire-element-id="549929">Comme vous le savez déjà, modifier les paramètres de la fenêtre permet pour l'affichage des fonctions de choisir un ensemble de définition, une graduation et une résolution.</p><p id="r-549930" data-claire-element-id="549930">Mais il est aussi possible de modifier ces paramètres <em>via</em> un programme ! Et ça, ça va bien nous aider pour les jeux et les dessins. Si vous avez lu l'introduction du big-tuto, vous devriez savoir créer un nouveau programme, alors allez-y parce que l'on a quelques trucs à tester :p .</p><p id="r-549931" data-claire-element-id="549931">Pour commencer, on va apprendre à modifier l'ensemble de définition des représentations de fonctions. Voici ce que l'on va faire :</p><figure id="r-549933" data-claire-element-id="549934"><img id="r-549932" data-claire-element-id="549932" src="medias/uploads.siteduzero.com_files_111001_112000_111816.jpg" alt="Image utilisateur"/></figure><p id="r-549935" data-claire-element-id="549935">Alors d'accord, vous auriez pu le trouver tout seul, mais Xmin et Xmax, il faut savoir où les chercher !<br/> En effet, il n'est pas forcément facile de trouver le menu où sont cachées ces variables. Vous devez aller dans <code>VARS-Window...</code> ;) .</p><p id="r-549936" data-claire-element-id="549936">Vous trouverez d'ailleurs dans ce menu tous les paramètres de fenêtre que l'on a vus : Xres, Yscl, etc.</p><aside id="r-549938" data-claire-element-id="549938" data-claire-semantic="information"><p id="r-549937" data-claire-element-id="549937">Au fait, faites bien attention à ne pas confondre les deux signes « - » de la TI : le plus long d'entre eux ne sert qu'à la soustraction, et le plus petit (qui est un peu en hauteur) ne sert qu'à indiquer le <strong>signe</strong> du nombre ! Pour que vous ne confondiez pas, je vais noter ce signe négatif par (-) et la soustraction par -.</p></aside><h2 id="r-modifier-le-tableau" data-claire-element-id="549948">Modifier le TABLEAU</h2><p id="r-549940" data-claire-element-id="549940">Vous avez sûrement déjà eu affaire au tableau de valeurs (que j'appellerai simplement « tableau » dans ce tutoriel, étant donné qu'il n'y a aucun risque de confusion) ; comme son nom l'indique, c'est un tableau qui utilise l'écran graphique pour afficher les valeurs de vos équations en fonction de X.</p><p id="r-549941" data-claire-element-id="549941">Appuyez sur la touche <code>TABLE</code> pour l'afficher :</p><figure id="r-549943" data-claire-element-id="549944"><img id="r-549942" data-claire-element-id="549942" src="medias/uploads.siteduzero.com_files_116001_117000_116970.jpg" alt="Image utilisateur"/></figure><p id="r-549945" data-claire-element-id="549945">Déjà, vous devez savoir que modifier les paramètres du tableau dans un programme n'est <strong>pas</strong> utilisé pour les jeux (ou alors c'en est un bien exotique), mais nous allons cependant nous y intéresser un peu, car cela peut toujours être utile dans un programme traitant de matières scientifiques.</p><p id="r-549946" data-claire-element-id="549946">Tout comme les variables de fenêtre, on trouve celles du tableau dans <code>VARS-Table...</code>.<br/> L'utilisation de ces variables est la même que pour la fenêtre, on stocke une valeur dans la variable et c'est fait.</p><p id="r-549947" data-claire-element-id="549947">Notez que vous pouvez afficher le tableau directement dans un programme grâce à la fonction <code>PRGM-I/O-DispTable</code>.</p><h2 id="r-modifier-le-format" data-claire-element-id="549960">Modifier le FORMAT</h2><p id="r-549949" data-claire-element-id="549949">Ah, ben là par contre, on a des options vraiment utiles ! Si vous faites un jeu, vous aurez dans la plupart des cas besoin de <strong>désactiver</strong> les fonctions d'affichage de la TI. Ben oui, un <em>Mario</em> avec les axes X et Y affichés c'est pas terrible je trouve :p .</p><p id="r-549950" data-claire-element-id="549950">Et ce qui est bien avec les paramètres de format c'est que c'est ridiculement simple à modifier : on ouvre le menu FORMAT dans un programme, on sélectionne <code>On</code> ou <code>Off</code> pour l'option qui nous intéresse et voilà, l'instruction est ajoutée au programme et il n'y a rien à ajouter dans la ligne ^^ .</p><p id="r-549951" data-claire-element-id="549951">Une petite illustration pour vous montrer la simplicité de l'instruction :</p><figure id="r-549953" data-claire-element-id="549954"><img id="r-549952" data-claire-element-id="549952" src="medias/uploads.siteduzero.com_files_111001_112000_111817.jpg" alt="Image utilisateur"/></figure><figure id="r-549956" data-claire-element-id="549957"><img id="r-549955" data-claire-element-id="549955" src="medias/uploads.siteduzero.com_files_111001_112000_111818.jpg" alt="Image utilisateur"/></figure><p id="r-549958" data-claire-element-id="549958">Et voilà, au lancement du programme les coordonnées seront masquées et n'apparaîtront pas sur l'écran graphique. Évidemment la méthode est la même pour les autres options de format.</p><p id="r-549959" data-claire-element-id="549959">Maintenant que vous savez tout de la configuration de l'écran graphique, on peut attaquer son <strong>utilisation</strong> !<br/> Bon on reste dans les mathématiques hein, mais le dessin et les jeux arriveront bientôt ^^ .</p><h2 id="r-fonctions-et-graphiques" data-claire-element-id="549963">Fonctions et graphiques</h2><p id="r-549961" data-claire-element-id="549961">Dans cette partie, axée sur l'utilisation de la calculatrice dans un milieu naturel scientifique, nous allons voir comment nous servir de la TI pour afficher des courbes, des histogrammes et des tableaux, et nous allons apprendre à récupérer les valeurs qui nous intéressent. Cette partie n'est pas utile pour les dessins, vous pouvez donc faire l'impasse s'ils sont votre seul intérêt. <br/> Si vous souhaitez programmer un jeu utilisant des statistiques (de score ou je-ne-sais-quoi) ou si vous souhaitez profiter de vos connaissances pour les mathématiques, vous y trouverez un grand intérêt.</p><h3 id="r-les-courbes-2" data-claire-element-id="549962">Les courbes</h3><h2 id="r-afficher-une-courbe" data-claire-element-id="549981">Afficher une courbe</h2><p id="r-549964" data-claire-element-id="549964">L'affichage des courbes est assez simple, il suffit d'entrer l'équation de la courbe et les paramètres de la fenêtre pour qu'elle s'affiche sur l'écran graphique.</p><p id="r-549965" data-claire-element-id="549965">Pour entrer l'équation de la droite, on appuie sur la touche Y= (<code>f(x)</code> sur les TI-82 stats.fr). Le menu suivant s'affiche :</p><figure id="r-549967" data-claire-element-id="549968"><img id="r-549966" data-claire-element-id="549966" src="medias/uploads.siteduzero.com_files_111001_112000_111862.jpg" alt="Image utilisateur"/></figure><p id="r-549969" data-claire-element-id="549969">Vous pouvez afficher jusqu'à 10 courbes en même temps sur l'écran graphique.<br/> Positionnez le curseur après l'un des signes « = » pour écrire l'équation de votre courbe. Pour une équation de type f(x), vous devez appuyer sur la touche <code>[X,T,0,n]</code> pour insérer la variable X. Lorsque vous entrez une équation, le signe « = » de la courbe correspondante est surligné.</p><p id="r-549970" data-claire-element-id="549970">Pour désactiver l'affichage d'une courbe tout en gardant en mémoire son équation, vous devez placer le curseur sur ce signe « = » et appuyer sur <code>ENTER</code>.</p><p id="r-549971" data-claire-element-id="549971">Voici ce à quoi ressemble l'affichage d'une équation de type sin(x) :</p><figure id="r-549973" data-claire-element-id="549974"><img id="r-549972" data-claire-element-id="549972" src="medias/uploads.siteduzero.com_files_111001_112000_111863.jpg" alt="Image utilisateur"/></figure><p id="r-549975" data-claire-element-id="549975">Notez la présence de <code>Plot1, Plot2</code> et <code>Plot3</code>. Nous y reviendrons plus tard dans la sous-partie « Les graphiques ».<br/> Une fois l'équation rentrée, choisissez les paramètres de la fenêtre dans le menu <code>WINDOW</code> comme nous l'avons fait dans le chapitre 1, puis appuyez sur la touche <code>GRAPH</code> pour afficher le graphique.</p><p id="r-549976" data-claire-element-id="549976">Si vous êtes en zoom standard, vous devriez obtenir la courbe suivante :</p><figure id="r-549978" data-claire-element-id="549979"><img id="r-549977" data-claire-element-id="549977" src="medias/uploads.siteduzero.com_files_111001_112000_111864.jpg" alt="Image utilisateur"/></figure><p id="r-549980" data-claire-element-id="549980">Profitez-en pour choisir des zooms différents et observez les changements.</p><h2 id="r-modifier-l-apparence-de-la-courbe" data-claire-element-id="550023">Modifier l'apparence de la courbe</h2><p id="r-549982" data-claire-element-id="549982">Lorsque vous affichez plusieurs fonctions sur l'écran graphique, il est possible que vous vous y perdiez un peu : les courbes se superposent et le graphe est vite confus. Prenez par exemple celui-là :</p><figure id="r-549984" data-claire-element-id="549985"><img id="r-549983" data-claire-element-id="549983" src="medias/uploads.siteduzero.com_files_112001_113000_112031.jpg" alt="Image utilisateur"/></figure><p id="r-549986" data-claire-element-id="549986">On s'y perd vite dans ces deux sinusoïdes ;) .<br/> Maintenant, regardez celui-ci et dites-moi ce que vous en pensez :</p><figure id="r-549988" data-claire-element-id="549989"><img id="r-549987" data-claire-element-id="549987" src="medias/uploads.siteduzero.com_files_112001_113000_112033.jpg" alt="Image utilisateur"/></figure><p id="r-549990" data-claire-element-id="549990">C'est mieux, non ? Si vous essayez de suivre une seule courbe du regard, vous vous apercevrez que la lecture du graphique est beaucoup plus facile ^^ .</p><p id="r-549991" data-claire-element-id="549991">Nous allons voir comment modifier l'apparence des courbes représentées à l'écran, pour améliorer leur lisibilité.</p><p id="r-549992" data-claire-element-id="549992">Commencez par ouvrir le menu <code>Y=</code>. Avez-vous remarqué les lignes continues à gauche des équations ? Je les ai encadrées de rouge sur cette capture d'écran :</p><figure id="r-549994" data-claire-element-id="549995"><img id="r-549993" data-claire-element-id="549993" src="medias/uploads.siteduzero.com_files_112001_113000_112034.jpg" alt="Image utilisateur"/></figure><p id="r-549996" data-claire-element-id="549996">Elles permettent de choisir l'apparence des courbes. Pointez une de ces lignes avec le curseur puis appuyez sur la touche <code>ENTER</code>. Vous verrez la ligne devenir plus épaisse ; appuyez encore sur <code>ENTER</code> pour qu'elle se change en triangle plein.</p><p id="r-549997" data-claire-element-id="549997">Il y a en tout sept apparences différentes, mais en général on peut les associer deux par deux : certaines se ressemblent beaucoup.</p><h3 id="r-la-ligne-continue" data-claire-element-id="550000">La ligne continue</h3><p id="r-549998" data-claire-element-id="549998">Le groupe des lignes continues comprend les premières et secondes apparences, à savoir la ligne fine (par défaut) et la ligne épaisse. Regardez sur l'exemple que je vous ai montré tout à l'heure : l'une des sinusoïdes est représentée par un trait fin, l'autre par un trait épais.</p><p id="r-549999" data-claire-element-id="549999">Ces deux apparences sont à mon avis les plus utiles car elles permettent de bien différencier deux courbes sans trop surcharger le graphique.</p><h3 id="r-la-coloration-du-graphique" data-claire-element-id="550010">La coloration du graphique</h3><p id="r-550001" data-claire-element-id="550001">Ce groupe contient les 3e et 4e apparences, dont les icônes sont des triangles rectangles pleins.<br/> Voici deux images : la première montre une droite d'équation Y=X représentée avec l'apparence n°3, tandis que la seconde montre cette droite avec la 4e apparence.</p><figure id="r-550003" data-claire-element-id="550004"><img id="r-550002" data-claire-element-id="550002" src="medias/uploads.siteduzero.com_files_112001_113000_112041.jpg" alt="Image utilisateur"/></figure><figure id="r-550006" data-claire-element-id="550007"><img id="r-550005" data-claire-element-id="550005" src="medias/uploads.siteduzero.com_files_112001_113000_112042.jpg" alt="Image utilisateur"/></figure><p id="r-550008" data-claire-element-id="550008">Comme vous pouvez le voir, la zone supérieure ou inférieure à la courbe est colorée de lignes verticales. Vous ne voyez peut-être pas l'intérêt d'une telle apparence sur une droite, par contre si vous voulez afficher par exemple le taux de précipitations en fonction du mois de l'année, là ça peut être intéressant : plus c'est noir, plus il a plu dans le mois :) .</p><p id="r-550009" data-claire-element-id="550009">Malheureusement/ironiquement, il est impossible d'appliquer une apparence à la courbe d'un graphique créé grâce aux plots ; on peut seulement le faire pour une courbe dont on a entré l'équation dans le menu <code>Y=</code>. Nous verrons donc plus tard pour les précipitations, quand nous étudierons les plots.</p><h3 id="r-les-curseurs-3" data-claire-element-id="550020">Les curseurs</h3><p id="r-550011" data-claire-element-id="550011">C'est un groupe assez spécial, il comprend les apparences 5 et 6 dont les icônes sont respectivement une ellipse précédée d'un trait et une ellipse simple, que voici :</p><figure id="r-550013" data-claire-element-id="550014"><img id="r-550012" data-claire-element-id="550012" src="medias/uploads.siteduzero.com_files_112001_113000_112047.jpg" alt="Image utilisateur"/></figure><p id="r-550015" data-claire-element-id="550015">Ces deux apparences servent à afficher un <strong>curseur circulaire</strong> sur le point de la courbe qui vient d'être calculé. Le curseur de la première de ces apparences laisse un trait continu derrière lui, tandis que la seconde ne fait qu'afficher le curseur. <br/> Cette dernière permet de calculer la courbe sans encombrer le graphique, par exemple pour se donner une idée de la tête de la courbe avant d'utiliser les calculs exécutés.<br/> Quant à la première, prenons l'exemple de la fonction exponentielle, d'équation <code>y=e^X</code>. Grâce à l'apparence 5, vous saurez à l'aide du curseur <strong>où</strong> passe votre courbe :</p><figure id="r-550017" data-claire-element-id="550018"><img id="r-550016" data-claire-element-id="550016" src="medias/uploads.siteduzero.com_files_141001_142000_141852.jpg" alt="Image utilisateur"/></figure><p id="r-550019" data-claire-element-id="550019">Comme vous pouvez le voir, cette courbe est presque confondue avec l'axe des abscisses. Sans le curseur, il est difficile de savoir au premier coup d'%u0153il si la fonction exponentielle est indéfinie sur cet intervalle ou si c'est simplement, comme dans notre cas, qu'on la confond avec l'axe des abscisses à cause d'un zoom mal choisi.</p><h3 id="r-le-trait-en-pointilles" data-claire-element-id="550022">Le trait en pointillés</h3><p id="r-550021" data-claire-element-id="550021">Bon ben là c'est comme pour les traits continus, mais en pointillés :-° ...<br/> Je ne vais pas m'attarder trop longtemps sur cette apparence car elle est très simple, regardez sur l'exemple au début : la droite a été représentée avec cette apparence (n°7).</p><h2 id="r-les-fonctions-trace-et-calc-sur-des-courbes" data-claire-element-id="550087">Les fonctions TRACE et CALC sur des courbes</h2><p id="r-550024" data-claire-element-id="550024">La TI possède quelques fonctions très utiles pour utiliser des courbes.<br/> Appuyez sur la touche <code>TRACE</code>. Vous verrez apparaître sur l'écran un curseur assez imposant.</p><p id="r-550025" data-claire-element-id="550025">Cette fonction sert à <strong>suivre la courbe</strong> avec le curseur afin d'observer les valeurs x et y à un endroit précis, en étant certain que le point affiché appartient bien à cette courbe.</p><p id="r-550026" data-claire-element-id="550026">Utilisez les flèches directionnelles pour constater les effets : les flèches droite et gauche permettent d'afficher les valeurs de X et Y tout en restant sur la courbe. Un <code>ZInteger</code> (menu <code>ZOOM</code>) peut être dans ce cas très utile pour que les résultats soient lisibles.<br/> Les flèches haut et bas, quant à elles, permettent de changer de courbe : le curseur ne suivra plus Y1, mais Y2 par exemple.</p><p id="r-550027" data-claire-element-id="550027">Essayez de vous familiariser avec cette fonction car les fonctions <code>CALC</code> l'utilisent très souvent.</p><h3 id="r-le-menu-calc" data-claire-element-id="550043">Le menu CALC</h3><p id="r-550028" data-claire-element-id="550028">Le menu <code>CALC</code> (2ND:TRACE) est composé de 7 fonctions très utiles.</p><figure id="r-550030" data-claire-element-id="550031"><img id="r-550029" data-claire-element-id="550029" src="medias/uploads.siteduzero.com_files_111001_112000_111865.jpg" alt="Image utilisateur"/></figure><p id="r-550032" data-claire-element-id="550032">La fonction <code>value</code> permet d'obtenir la valeur Y du point appartenant à la courbe choisie et d'abscisse X. Entrez la valeur de X, sélectionnez la courbe avec les flèches haut et bas et vous pourrez lire la valeur Y en bas à droite de l'écran.<br/> Notez que si vous rentrez un chiffre lorsque la fonction <code>TRACE</code> est activée, cela aura pour effet d'activer la fonction value, sans avoir à la chercher dans le menu <code>CALC</code> donc.</p><p id="r-550033" data-claire-element-id="550033">Les fonctions <code>zero, minimum</code> et <code>maximum</code> s'utilisent de la même façon : choisissez la courbe à étudier (toujours avec les flèches).</p><p id="r-550034" data-claire-element-id="550034">La calculatrice vous demandera d'entrer le « left bound » : pour éviter de calculer chaque point de la courbe, vous devez choisir l'intervalle à étudier. <code>Left bound</code> et <code>right bound</code> sont donc les extrémités de l'intervalle à étudier : prenez des points pour lesquels vous êtes certains que le <code>zero, le minimum</code> ou le <code>maximum</code> sont inclus dans l'intervalle.</p><p id="r-550035" data-claire-element-id="550035">Vous aurez ensuite un 3e point à choisir, « Guess ». Pour celui-ci, vous devez sélectionner le point de la courbe que vous pensez être le plus proche du résultat. Ce choix n'est pas extrêmement important, mais il permet de raccourcir le temps de calcul.</p><p id="r-550036" data-claire-element-id="550036">La fonction <code>intersect</code> permet de trouver le point d'intersection de deux courbes. Sélectionnez la première courbe, puis la seconde et enfin le « Guess ». La calculatrice vous montrera le point d'intersection de ces deux courbes le plus proche de votre point <code>Guess</code>.</p><p id="r-550037" data-claire-element-id="550037"><code>dy/dx</code> renvoie tout simplement la dérivée de la fonction en un point sélectionné.</p><p id="r-550038" data-claire-element-id="550038">La 7e fonction permet de calculer l'intégrale de la fonction sur intervalle donné. De plus, sont « remplis » de noir les points compris entre l'axe X et la courbe, dans l'intervalle choisi. Voyez plutôt :</p><figure id="r-550040" data-claire-element-id="550041"><img id="r-550039" data-claire-element-id="550039" src="medias/uploads.siteduzero.com_files_111001_112000_111866.jpg" alt="Image utilisateur"/></figure><p id="r-550042" data-claire-element-id="550042">Le menu <code>CALC</code> est donc très utile, en mathématiques particulièrement.</p><h3 id="r-les-tableaux-39" data-claire-element-id="550050">Les tableaux</h3><p id="r-550044" data-claire-element-id="550044">Les tableaux ne sont <em>a priori</em> pas utilisés dans les jeux. <br/> Pour afficher un tableau, il faut rentrer l'équation dans <code>Y=</code> (comme pour les courbes) puis appuyer sur 2ND:GRAPH.</p><figure id="r-550046" data-claire-element-id="550047"><img id="r-550045" data-claire-element-id="550045" src="medias/uploads.siteduzero.com_files_111001_112000_111867.jpg" alt="Image utilisateur"/></figure><p id="r-550048" data-claire-element-id="550048">Dans la colonne Y1, on lit la valeur de f(x) pour le x affiché sur la même ligne.<br/> Notez que le tableau peut afficher plusieurs équations à la fois pour le même X.</p><p id="r-550049" data-claire-element-id="550049">Pour récupérer f(x) sans passer par le tableau, on peut utiliser l'instruction <code>Y1(x)</code>, par les menus <code>VARS-YVARS-Function...-Y1</code>.<br/> Entrez ensuite la valeur de x entre parenthèses pour que la fonction renvoie f(x).</p><h3 id="r-les-graphiques-7" data-claire-element-id="550086">Les graphiques</h3><p id="r-550051" data-claire-element-id="550051">Les graphiques sont de très bons outils pour visualiser des statistiques.<br/> Pour afficher un graphique, il faut ouvrir le menu <code>Y=</code> et activer un des Plots.</p><p id="r-550052" data-claire-element-id="550052">Désactivez vos courbes en sélectionnant les signes « = » de chaque courbe ; vous devriez obtenir l'écran suivant :</p><figure id="r-550054" data-claire-element-id="550055"><img id="r-550053" data-claire-element-id="550053" src="medias/uploads.siteduzero.com_files_111001_112000_111868.jpg" alt="Image utilisateur"/></figure><p id="r-550056" data-claire-element-id="550056">Ouvrez ensuite le menu de graphiques par 2ND:Y=. Sélectionnez Plot1, voici ce que vous devez avoir :</p><figure id="r-550058" data-claire-element-id="550059"><img id="r-550057" data-claire-element-id="550057" src="medias/uploads.siteduzero.com_files_111001_112000_111869.jpg" alt="Image utilisateur"/></figure><p id="r-550060" data-claire-element-id="550060">Assurez-vous que le graphique est activé en sélectionnant <strong>On</strong>, puis choisissez le type de graphique que vous voulez. Dans cet exemple, nous utiliserons l'histogramme (3e sur la première ligne dans les types).</p><p id="r-550061" data-claire-element-id="550061">Configurez l'écran graphique de façon à avoir <code>Xmin = 0</code>. De cette façon, seule la partie occupée par l'histogramme sera affichée. Si les valeurs de votre graphique ne peuvent pas être négatives, mettez aussi <code>Ymin</code> à 0 afin de limiter l'espace inutilisé.</p><p id="r-550062" data-claire-element-id="550062">Dans <code>Xlist</code>, vous devez mettre la liste contenant les abscisses des barres à afficher.</p><p id="r-550063" data-claire-element-id="550063">Dans <code>freq</code>, écrivez la liste contenant les valeurs pour chaque X.<br/> Ainsi, si l'on a <code>L1={1,2,3,4,5,6}</code> et <code>L2={10,5,6,8,9,1}</code>, et que l'on met respectivement L1 et L2 dans <code>Xlist</code> et <code>freq</code>, on obtient l'histogramme suivant :</p><figure id="r-550065" data-claire-element-id="550066"><img id="r-550064" data-claire-element-id="550064" src="medias/uploads.siteduzero.com_files_111001_112000_111870.jpg" alt="Image utilisateur"/></figure><figure id="r-550068" data-claire-element-id="550069"><img id="r-550067" data-claire-element-id="550067" src="medias/uploads.siteduzero.com_files_111001_112000_111871.jpg" alt="Image utilisateur"/></figure><figure id="r-550071" data-claire-element-id="550072"><img id="r-550070" data-claire-element-id="550070" src="medias/uploads.siteduzero.com_files_111001_112000_111872.jpg" alt="Image utilisateur"/></figure><figure id="r-550074" data-claire-element-id="550075"><img id="r-550073" data-claire-element-id="550073" src="medias/uploads.siteduzero.com_files_111001_112000_111873.jpg" alt="Image utilisateur"/></figure><p id="r-550076" data-claire-element-id="550076">Les différents types de graphiques s'utilisent de la même façon, essayez en particulier la courbe (le second de la première ligne). C'est le plus important avec l'histogramme.</p><p id="r-550077" data-claire-element-id="550077">Si vous souhaitez afficher votre graphique de façon simple, sans trifouiller les paramètres fenêtre, vous pouvez utiliser le <code>ZoomStat</code> (les zooms sont tous dans le menu <code>ZOOM</code>). Celui-ci permet d'adapter la fenêtre à votre graphique afin de l'afficher en entier.</p><p id="r-550078" data-claire-element-id="550078">Cependant, son utilisation est déconseillée pour les histogrammes car on a parfois droit à des <strong>trous</strong> dans le graphique : certaines barres ne sont pas affichées car l'axe X ne correspond pas aux valeurs entrées dans <code>Xlist</code>. Regardez sur cette image :</p><figure id="r-550080" data-claire-element-id="550081"><img id="r-550079" data-claire-element-id="550079" src="medias/uploads.siteduzero.com_files_112001_113000_112056.jpg" alt="Image utilisateur"/></figure><figure id="r-550083" data-claire-element-id="550084"><img id="r-550082" data-claire-element-id="550082" src="medias/uploads.siteduzero.com_files_112001_113000_112057.jpg" alt="Image utilisateur"/></figure><p id="r-550085" data-claire-element-id="550085">Comme vous pouvez le constater, il n'y a pas de 0 dans la liste <strong>Freq</strong>, pourtant la 6e colonne est vide : la valeur de L2(6) est affichée dans la 7e. La 6e a donc été sautée.<br/> Nous allons examiner de plus près la cause de ce problème avec la fonction <strong>TRACE</strong>.</p><h2 id="r-la-fonction-trace-sur-un-graphique" data-claire-element-id="550105">La fonction TRACE sur un graphique</h2><p id="r-550088" data-claire-element-id="550088">Affichez le même graphique que sur l'image précédente : copiez les valeurs de <code>L1</code> et <code>L2</code>, réglez le <code>Plot1</code> de la même façon que sur l'image d'avant : <code>On, histogramme, L1, L2</code>. <br/> Allez ensuite dans le menu <code>ZOOM</code> et choisissez <strong>ZoomStat</strong>. Vous devriez avoir la même chose à l'écran.</p><p id="r-550089" data-claire-element-id="550089">Maintenant, activez la fonction <code>TRACE</code> en appuyant sur la touche du même nom : comme pour les courbes, un curseur est affiché en même temps que des valeurs : <strong>min, max</strong>, et <strong>n</strong> :</p><figure id="r-550091" data-claire-element-id="550092"><img id="r-550090" data-claire-element-id="550090" src="medias/uploads.siteduzero.com_files_112001_113000_112061.jpg" alt="Image utilisateur"/></figure><p id="r-550093" data-claire-element-id="550093">Déplacez un peu le curseur : vous verrez qu'il suit le graphique en s'arrêtant sur le milieu de chacune des colonnes, tout en affichant les valeurs relatives à la colonne pointée.</p><p id="r-550094" data-claire-element-id="550094"><code>n</code>, c'est la valeur que vous avez rentrée dans <code>L2</code>, la liste <strong>Freq</strong>. Elle change donc en fonction de x. Quant à <code>min</code>, c'est la valeur de la première abscisse de la colonne pointée. <code>max</code> est la valeur de la dernière.</p><p id="r-550095" data-claire-element-id="550095">Cela signifie que pour <code>0&lt;x&lt;8,33...</code>, on a <code>n=4</code>. Ce n'est pas ce que l'on veut : on voulait <code>0&lt;x&lt;1</code>, car 0 et 1 sont les valeurs que l'on a entrées dans <code>L1</code> !</p><p id="r-550096" data-claire-element-id="550096">Cependant, <code>ZoomStat</code> voit les choses autrement : il divise la taille de l'écran par le nombre de colonnes à afficher. On n'obtient donc pas ce que l'on voulait.</p><p id="r-550097" data-claire-element-id="550097">Si vous avez bien suivi, vous devriez avoir compris pourquoi la 6e colonne est vide : utilisez la fonction <code>TRACE</code> pour afficher les données relatives à cette colonne. Vous obtenez l'écran suivant :</p><figure id="r-550099" data-claire-element-id="550100"><img id="r-550098" data-claire-element-id="550098" src="medias/uploads.siteduzero.com_files_112001_113000_112063.jpg" alt="Image utilisateur"/></figure><p id="r-550101" data-claire-element-id="550101">La variable <code>n</code> de cette colonne contient les <strong>effectifs pour 4,167 &lt;= x &lt; 5</strong>. Nous avons des effectifs pour 4, d'autres pour 5, mais entre les deux <strong>il n'y a rien</strong> !</p><p id="r-550102" data-claire-element-id="550102">Et à cause de la façon dont <code>ZoomStat</code> configure la fenêtre, cette colonne est affichée même si on ne l'a pas définie. C'est la raison pour laquelle il vaut mieux configurer « manuellement » la fenêtre lorsque l'on affiche un histogramme.</p><p id="r-550103" data-claire-element-id="550103">Par contre, pour l'affichage d'autres graphiques comme les courbes, il n'y a pas le moindre problème et l'utilisation de <code>ZoomStat</code> rend les choses plus faciles ;) .<br/> Je vous conseille donc d'utiliser <code>ZoomStat</code> tout le temps, sauf dans le cas d'un histogramme ou d'un autre type de graphique utilisant une liste <code>freq</code>.</p><p id="r-550104" data-claire-element-id="550104">Une dernière chose : la liste <strong>freq</strong> ne peut pas contenir de valeurs inférieures à 0, donc si vous voulez afficher un graphique dont les valeurs peuvent être négatives, un bilan financier par exemple, vous devrez utiliser un type de graphique qui utilise la mention « Ylist » à la place de « Freq ». La courbe est particulièrement adaptée à ce genre de cas.</p><h2 id="r-bilan-creer-un-graphique-dans-un-programme" data-claire-element-id="550254">Bilan : créer un graphique dans un programme</h2><p id="r-550106" data-claire-element-id="550106">Maintenant que nous avons vu comment configurer l'écran et afficher manuellement des graphiques, nous pouvons passer à l'étape suivante : l'écriture d'un programme permettant d'afficher un graphique à partir des données entrées par l'utilisateur.</p><h3 id="r-preparation-23" data-claire-element-id="550120">Préparation</h3><aside id="r-550108" data-claire-element-id="550108" data-claire-semantic="information"><p id="r-550107" data-claire-element-id="550107">Pour ce chapitre, je vais vous demander de faire l'effort de <strong>programmer avant moi</strong>, c'est-à-dire de vous servir des informations que je donne avant chaque bout de code pour essayer de le faire sans regarder la solution ! Si vous voyez du noir, arrêtez-vous et sortez votre calculatrice ^^ !<br/> Il est important de procéder ainsi, ça vous permettra de savoir si vous êtes prêt à lire la suite du tutoriel ou non ;) . Si vous n'arrivez pas à coder un bout de programme sans regarder la solution, n'hésitez pas à relire les chapitres précédents et même les chapitres d'autres tutoriels de TI-Basic qui traitent du sujet.<br/> Si vous trouvez la solution par vous-même, vous êtes sûr(e) de savoir le refaire sans aide !</p></aside><p id="r-550109" data-claire-element-id="550109">Le but du programme est d'afficher un graphique élaboré à partir de données entrées par l'utilisateur.<br/> Voici l'ordre dans lequel nous allons programmer.</p><ul id="r-550118" data-claire-element-id="550118"><li id="r-550111" data-claire-element-id="550111"><p id="r-550110" data-claire-element-id="550110">D'abord, on va demander à l'utilisateur la quantité de données qu'il veut stocker : par exemple si son axe X représente les mois de l'année, cette quantité sera 12.<br/> Il y aura <strong>autant</strong> de données pour l'axe X que pour les effectifs (Y), sinon on ne peut pas établir un graphique complet :) ! Inutile donc de lui demander une fois pour les X et une autre pour les Y.</p></li><li id="r-550113" data-claire-element-id="550113"><p id="r-550112" data-claire-element-id="550112">Une fois que cette quantité sera rentrée, on utilisera une boucle <strong>For</strong> pour lui demander chacune des valeurs à rentrer.</p></li><li id="r-550115" data-claire-element-id="550115"><p id="r-550114" data-claire-element-id="550114">On lui demandera ensuite le <strong>type de graphique</strong> à afficher.</p></li><li id="r-550117" data-claire-element-id="550117"><p id="r-550116" data-claire-element-id="550116">Enfin, on affichera le graphique qu'il a demandé ;) .</p></li></ul><p id="r-550119" data-claire-element-id="550119">Je vous laisse dix secondes de repos, revenez TI en mains.<br/> (...) Bien, nous pouvons commencer à <strong>coder ce programme</strong> !</p><h3 id="r-presentation-et-gestion-des-donnees" data-claire-element-id="550133">Présentation et gestion des données</h3><p id="r-550121" data-claire-element-id="550121">Notre première mission est de demander à l'utilisateur le <strong>nombre de données à stocker pour chaque axe</strong>.<br/> Pour cela, il faut lui expliquer le but du programme et bien lui faire comprendre ce que l'on attend de lui ;) .</p><p id="r-550122" data-claire-element-id="550122">Vous pouvez écrire absolument ce que vous voulez dans la présentation du programme. D'ailleurs, si celui-ci n'est destiné qu'à vous, il est inutile d'expliquer le but du programme, à moins que vous ne le dépoussiériez trois ans après l'avoir écrit :p !</p><p id="r-550123" data-claire-element-id="550123">Voici ce que j'ai écrit pour la présentation de mon programme :</p><pre id="r-550124" data-claire-element-id="550124"><code data-claire-semantic="console">:ClrHome
:Disp &quot;ENTREZ LES&quot;,&quot;DONNEES DU&quot;,&quot;GRAPHIQUE POUR&quot;,&quot;QU'IL SOIT CREE&quot;,&quot;AUTOMATIQUEMENT
:Pause
:ClrHome</code></pre><p id="r-550125" data-claire-element-id="550125">On utilise donc tout simplement un <code>Disp</code> pour afficher cette information. Ensuite, une pause pour demander à l'utilisateur d'appuyer sur <code>ENTER</code>, puis on efface l'écran.</p><p id="r-550126" data-claire-element-id="550126">Note : pour l'apostrophe, j'ai utilisé le caractère du menu <code>ANGLE</code> (2ND:APPS).</p><p id="r-550127" data-claire-element-id="550127">Après cette courte mais suffisante explication sur l'utilité du programme, nous allons demander à l'utilisateur de rentrer le nombre de données qu'il souhaite voir apparaître sur le graphique.</p><p id="r-550128" data-claire-element-id="550128">Pour cela, un simple <code>Input</code> suffira. Avant, on indique quand même avec un <code>Disp</code> ce que l'on veut que l'utilisateur rentre.</p><figure id="r-550130" data-claire-element-id="550131"><img id="r-550129" data-claire-element-id="550129" src="medias/uploads.siteduzero.com_files_112001_113000_112081.jpg" alt="Image utilisateur"/></figure><p id="r-550132" data-claire-element-id="550132">On définit par la même occasion la dimension des listes <code>L1</code> et <code>L2</code>, qui est la même, comme on l'a déjà expliqué ;) .</p><h3 id="r-gestion-des-donnees-number-2" data-claire-element-id="550152">Gestion des données number 2</h3><p id="r-550134" data-claire-element-id="550134">Maintenant que l'on connaît la quantité d'informations à stocker, nous pouvons demander à l'utilisateur <strong>quelles sont ces informations</strong>.<br/> Autrement dit, on va le faire rentrer toutes ces valeurs une par une :diable: .</p><p id="r-550135" data-claire-element-id="550135">Quoique (un peu de bonté dans ce monde de brutes), finalement il ne sera pas nécessaire de rentrer les abscisses une par une : l'utilisateur entrera l'<strong>intervalle</strong> entre deux valeurs de X ainsi que l'abscisse de départ. À partir de là, nous pourrons calculer chacune des abscisses que l'on veut.</p><p id="r-550136" data-claire-element-id="550136">Pour cela, une boucle <code>for</code> fera très bien l'affaire : <code>L1(1)</code> contiendra la valeur de départ, <code>L1(2)</code> aura la valeur de L1(1) à laquelle on aura ajouté l'intervalle I, et ainsi de suite.</p><p id="r-550137" data-claire-element-id="550137">Voici comment j'ai codé cette partie du programme :</p><pre id="r-550138" data-claire-element-id="550138"><code data-claire-semantic="console">:ClrHome
:Disp &quot;ABSCISSES
:Input &quot;DEPART:&quot;,D
:Input &quot;INTERVALLE:&quot;,I
:For(Z,1,N
:D+I(Z-1-&gt;L1(Z)
:End</code></pre><p id="r-550139" data-claire-element-id="550139">On fait donc une boucle <code>For</code> allant de 1 à N. <br/> À chaque boucle, une nouvelle case de la liste <code>L1</code> est remplie. On y stocke la valeur de départ à laquelle on aura ajouté (Z-1) fois l'intervalle I. Ainsi dans la première case de L1, c'est-à-dire <code>L1(1)</code>, on a <code>D+I(1-1)</code>. Cela revient à dire que <code>L1(1)</code> vaut D. Dans le cas des cases suivantes, on ajoute à chaque fois I.</p><p id="r-550140" data-claire-element-id="550140">Lorsque vous codez des formules de ce genre, il vaut mieux vérifier qu'elles marchent correctement avant de continuer. Exécutez donc le programme, puis vérifiez les valeurs contenues dans <code>L1</code>.</p><figure id="r-550142" data-claire-element-id="550143"><img id="r-550141" data-claire-element-id="550141" src="medias/uploads.siteduzero.com_files_112001_113000_112090.jpg" alt="Image utilisateur"/></figure><p id="r-550144" data-claire-element-id="550144">La liste commence bien à 0, et on a bien un intervalle de 10.</p><p id="r-550145" data-claire-element-id="550145">On ne le voit pas sur la capture d'écran, mais la liste comporte 6 nombres, comme je l'ai demandé dans le programme. Ces valeurs ne sont pas toutes affichées, il aurait fallu appuyer sur la flèche droite pour faire défiler la liste.</p><p id="r-550146" data-claire-element-id="550146">S'il y a un problème à ce niveau-là dans votre programme, il faut vérifier le contenu de vos boucles <code>for</code> ;) .</p><p id="r-550147" data-claire-element-id="550147">On a donc notre première liste qui contient chacune des abscisses qui nous intéressent. On passe à la suite.</p><p id="r-550148" data-claire-element-id="550148">On va utiliser une boucle <code>for</code> pour demander chacune des valeurs jusqu'à ce que l'on ait atteint la quantité d'informations désirée. Ainsi, nous aurons toutes les valeurs nécessaires pour la création du graphique.</p><p id="r-550149" data-claire-element-id="550149">Cette partie du code est encore plus simple que la précédente, voici la façon dont je l'ai écrite :</p><pre id="r-550150" data-claire-element-id="550150"><code data-claire-semantic="console">:For(Z,1,N
:ClrHome
:Disp &quot;ORDONNEES :&quot;,&quot;VALEUR N°&quot;
:Output(2,10,Z
:Input P
:P-&gt;L2(Z
:End</code></pre><p id="r-550151" data-claire-element-id="550151">Comme tout à l'heure, on vérifie que ça marche correctement ;) !</p><h3 id="r-choix-du-type-de-graphique" data-claire-element-id="550199">Choix du type de graphique</h3><p id="r-550153" data-claire-element-id="550153">On continue, maintenant il faut que l'utilisateur puisse choisir quel type de graphique il veut : nous allons mettre les trois principaux, à savoir la courbe, le nuage de points et l'histogramme. Les trois sont sur la première ligne dans les types de graphique.</p><p id="r-550154" data-claire-element-id="550154">Le plus simple pour demander ça à l'utilisateur, c'est de faire un menu. Et puis, vous pourrez toujours le compléter avec les trois autres types de graphiques plus tard, bien que je n'y trouve personnellement pas d'utilité.</p><p id="r-550155" data-claire-element-id="550155">Pour ce menu, j'ai choisi les labels A, B et C (on ne va pas se compliquer la vie :p ).<br/> Ah oui, je mets toujours un « quitter » ou « retour » dans mes menus. J'avoue que là ça ne sert pas à grand chose mais bon, je trouve que c'est une bonne habitude à prendre ^^ .</p><p id="r-550156" data-claire-element-id="550156">Voici donc notre menu :</p><pre id="r-550157" data-claire-element-id="550157"><code data-claire-semantic="console">:Menu(&quot; TYPE GRAPHIQUE &quot;,&quot;NUAGE POINTS&quot;,A,&quot;COURBE&quot;,B,&quot;HISTOGRAMME&quot;,C,&quot;QUITTER&quot;,Q</code></pre><p id="r-550158" data-claire-element-id="550158">C'est un menu tout bête.<br/> On va coder tout de suite le label Q, comme ça ce sera fait.</p><pre id="r-550159" data-claire-element-id="550159"><code data-claire-semantic="console">:Lbl Q
:ClrHome
:Output(1,1,&quot;
:Return</code></pre><p id="r-550160" data-claire-element-id="550160">La ligne <strong>:Output(1,1,&quot;</strong> permet d'empêcher l'apparition du message « done » lorsque le programme se termine. Cette ligne n'est pas indispensable, mais c'est quand même plus esthétique.</p><p id="r-550161" data-claire-element-id="550161">Le <code>Return</code> permet de terminer le programme s'il a été exécuté directement, et de retourner au programme parent s'il a été exécuté à partir d'un autre programme.<br/> Comme ça, vous pourrez vous servir de ce programme sans changer son contenu si vous avez besoin un jour de l'appeler dans un autre programme.</p><p id="r-550162" data-claire-element-id="550162">Maintenant, nous allons nous occuper des labels A et B. La configuration de ces graphiques sera très simple.<br/> Pour configurer un <code>Plot</code>, il faut suivre la syntaxe suivante : <code>Plot1(type,liste1,liste2,marque)</code>.</p><p id="r-550163" data-claire-element-id="550163">L'instruction <strong>Plot1(</strong>, les types de graphiques et les marques différentes sont disponibles dans le menu <code>STAT PLOT</code> (2ND:Y=). Vous remarquerez que le contenu de ce menu n'est pas du tout le même en dehors et dans un programme.</p><p id="r-550164" data-claire-element-id="550164">Une fois que le graphique est configuré, on utilise le <code>ZoomStat</code> pour afficher le graphique et configurer la fenêtre en même temps.</p><p id="r-550165" data-claire-element-id="550165">Ainsi, pour notre nuage de points, on écrira :</p><figure id="r-550167" data-claire-element-id="550168"><img id="r-550166" data-claire-element-id="550166" src="medias/uploads.siteduzero.com_files_112001_113000_112102.jpg" alt="Image utilisateur"/></figure><aside id="r-550170" data-claire-element-id="550170" data-claire-semantic="warning"><p id="r-550169" data-claire-element-id="550169">Le petit signe « + » n'est pas celui de l'addition ! C'est le type de marque qu'utilisera le graphique, il est accessible par <code>2ND:Y=-MARK</code>.<br/> On aurait aussi pu prendre l'un des deux autres types de marque, mais je pense que ce point est le plus adapté pour un nuage de points.</p></aside><p id="r-550171" data-claire-element-id="550171">Pour terminer chaque label, nous mettrons un <code>Goto Q</code> pour terminer le programme : il ne faudrait pas que l'on affiche les trois types de graphique à la suite ^^ .</p><p id="r-550172" data-claire-element-id="550172">Pour le label B, c'est exactement pareil :</p><figure id="r-550174" data-claire-element-id="550175"><img id="r-550173" data-claire-element-id="550173" src="medias/uploads.siteduzero.com_files_112001_113000_112103.jpg" alt="Image utilisateur"/></figure><p id="r-550176" data-claire-element-id="550176">Seuls le type de graphique et la lettre du label changent.</p><p id="r-550177" data-claire-element-id="550177">Nous avons terminé l'affichage de la courbe et du nuage de points.<br/> Pour l'histogramme, c'est un peu plus compliqué, car on ne peut pas se servir du <code>ZoomStat</code>, comme nous l'avons vu dans le chapitre précédent.<br/> Nous allons donc configurer la fenêtre en fonction des listes que nous avons.</p><p id="r-550178" data-claire-element-id="550178">Pour configurer la fenêtre, nous avons besoin de :</p><ul id="r-550191" data-claire-element-id="550191"><li id="r-550180" data-claire-element-id="550180"><p id="r-550179" data-claire-element-id="550179"><code>Xmin</code> et <code>Xmax</code> : ce sont les <em>extremum</em> de <code>L1</code> ;</p></li><li id="r-550182" data-claire-element-id="550182"><p id="r-550181" data-claire-element-id="550181"><code>Xscl</code> : c'est tout simplement l'intervalle que l'utilisateur a choisi ;</p></li><li id="r-550184" data-claire-element-id="550184"><p id="r-550183" data-claire-element-id="550183"><code>Ymax</code> : c'est la valeur maximum de <code>L2</code> ;</p></li><li id="r-550186" data-claire-element-id="550186"><p id="r-550185" data-claire-element-id="550185"><code>Ymin</code> : cette valeur vaut 0 : il est très rare d'avoir besoin d'une origine différente, et les effectifs ne peuvent pas être inférieurs à 0 avec les histogrammes ;</p></li><li id="r-550188" data-claire-element-id="550188"><p id="r-550187" data-claire-element-id="550187"><code>Yscl</code> : pour cette valeur, on va prendre la partie entière de <code>Ymax</code> divisée par 10, ça permettra d'avoir un bon aperçu ;</p></li><li id="r-550190" data-claire-element-id="550190"><p id="r-550189" data-claire-element-id="550189"><code>Xres</code> : ben là, on va mettre 1, tout simplement ^^ . Nous n'avons pas besoin d'une grande rapidité pour ce programme, donc c'est le meilleur choix.</p></li></ul><p id="r-550192" data-claire-element-id="550192">C'est parti ! On vient de voir ce qu'il faut mettre dans les valeurs de la fenêtre, maintenant il ne reste plus qu'à transformer ça en TI-Basic ;) !</p><pre id="r-550193" data-claire-element-id="550193"><code data-claire-semantic="console">:Lbl C
:Plot1(Histogram,L1,L2
:min(L1)-&gt;Xmin
:max(L1)-&gt;Xmax
:I-&gt;Xscl
:max(L2)-&gt;Ymax
:0-&gt;Ymin
:iPart(Ymax/10)-&gt;Yscl
:1-&gt;Xres
:DispGraph
:Goto Q</code></pre><p id="r-550194" data-claire-element-id="550194">Observons ce code de plus près.</p><p id="r-550195" data-claire-element-id="550195">Tout d'abord, on n'a pas mis de type de marque dans les paramètres de <code>Plot1</code>. C'est parce que, comme nous l'avons déjà dit, l'histogramme ne nécessite pas de type de marque.</p><p id="r-550196" data-claire-element-id="550196">Pour ce qui est des réglages <em>fenêtre</em>, nous venons de voir à quoi correspondaient ces valeurs. Je vous rappelle que les variables de fenêtre sont accessibles par <code>VARS-Window</code>...</p><p id="r-550197" data-claire-element-id="550197">Quant aux instructions <em>min </em>et <em>max</em>, vous pourrez les trouver dans <code>2ND:STAT-MATH</code>.<br/><code>DispGraph</code> permet d'afficher l'écran graphique.</p><p id="r-550198" data-claire-element-id="550198">Et nous avons fini :p !<br/> Enfin non, pas tout à fait...</p><h3 id="r-anticipation-des-eventuels-problemes" data-claire-element-id="550204">Anticipation des éventuels problèmes</h3><p id="r-550200" data-claire-element-id="550200">Notre programme est tout beau tout neuf ! Et il marche :D ! Seulement voilà, ce n'est pas toujours le cas...</p><p id="r-550201" data-claire-element-id="550201">De nombreux problèmes peuvent survenir dans notre programme selon la configuration de votre TI.</p><p id="r-550202" data-claire-element-id="550202">Par exemple, si l'utilisateur a huit courbes activées dans son menu <code>Y=</code>, vous pensez que le graphique sera satisfaisant ?<br/> C'est ce genre de problèmes que nous allons résoudre dans cette sous-partie.</p><p id="r-550203" data-claire-element-id="550203">Commençons !</p><h3 id="r-les-pause" data-claire-element-id="550207">Les Pause</h3><p id="r-550205" data-claire-element-id="550205">Vous l'avez sûrement remarqué si vous avez essayé votre programme : il manque des <strong>Pause</strong> !<br/> Vous allez me faire le plaisir de rajouter un <code>Pause</code> avant chaque <code>Goto Q</code> !</p><p id="r-550206" data-claire-element-id="550206">Maintenant, l'utilisateur peut admirer son graphique sans avoir besoin d'appuyer sur la touche <code>GRAPH</code>.</p><h3 id="r-affichage-de-l-histogramme" data-claire-element-id="550218">Affichage de l'histogramme</h3><p id="r-550208" data-claire-element-id="550208">Pour le moment, l'histogramme n'est pas affiché complètement sur l'écran graphique : la dernière colonne est en dehors de l'écran.</p><p id="r-550209" data-claire-element-id="550209">En effet, nous avons mis <code>Xmax</code> à la valeur maximale de L1. Et étant donné que les effectifs sont représentés par des <strong>rectangles</strong>, on ne voit que la première ligne de celui-ci à l'écran ! Regardez sur cette image, sachant que normalement l'histogramme devrait comporter six colonnes :</p><figure id="r-550211" data-claire-element-id="550212"><img id="r-550210" data-claire-element-id="550210" src="medias/uploads.siteduzero.com_files_112001_113000_112121.jpg" alt="Image utilisateur"/></figure><p id="r-550213" data-claire-element-id="550213">La première ligne, c'est l'axe Y. Tout va bien donc.</p><p id="r-550214" data-claire-element-id="550214">Par contre, la ligne de droite, c'est la première <strong>ligne de pixels</strong> de la 6e colonne !<br/> Il faut donc <strong>rajouter de la place</strong> à droite pour afficher le graphique entièrement.</p><p id="r-550215" data-claire-element-id="550215">Combien de place ? Eh bien, la place que prend une colonne, c'est-à-dire I : l'intervalle entre deux abscisses.<br/> On modifie donc la ligne <code>:max(L1)-&gt;Xmax</code> par :</p><pre id="r-550216" data-claire-element-id="550216"><code data-claire-semantic="console">:max(L1)+I-&gt;Xmax</code></pre><p id="r-550217" data-claire-element-id="550217">Et là, notre histogramme est affiché parfaitement.</p><h3 id="r-fonctions-et-plots" data-claire-element-id="550226">Fonctions et plots</h3><p id="r-550219" data-claire-element-id="550219">Nous devons <strong>absolument</strong> désactiver l'affichage des fonctions et des plots 2 et 3 pour que le graphique soit correct.</p><p id="r-550220" data-claire-element-id="550220">Pour cela, retournons au début de notre programme.<br/> Nous allons rajouter quelques lignes de code <strong>tout au début</strong> pour désactiver ces représentations.</p><p id="r-550221" data-claire-element-id="550221">Les instructions qui nous intéressent sont <code>FnOff</code> et <code>PlotsOff</code>.<br/><code>FnOff</code> se trouve dans le menu <code>VARS-YVARS-On/Off</code> et <code>PlotsOff</code> dans <code>2ND:Y=</code>.</p><p id="r-550222" data-claire-element-id="550222">Ces fonctions prennent comme paramètres les numéros des fonctions ou plots à désactiver. Si l'on ne met aucun paramètre, elles désactivent <strong>toutes les fonctions ou tous les graphiques</strong>.</p><p id="r-550223" data-claire-element-id="550223">Pour <code>FnOff</code>, c'est ce que nous voulons : nous allons donc écrire <code>FnOff</code> sans paramètre, au début du programme.</p><p id="r-550224" data-claire-element-id="550224">Par contre, nous ne voulons pas désactiver le <code>Plot1</code>. On pourrait par conséquent écrire <code>PlotsOff 2,3</code>, mais ce n'est pas ce que nous allons faire.</p><p id="r-550225" data-claire-element-id="550225">En effet, le Plot1 est automatiquement activé lorsqu'on le définit par <code>Plot1()</code>. C'est donc tout simplement <strong>PlotsOff</strong> sans paramètre que nous allons mettre dans notre programme.</p><h3 id="r-les-parametres-de-format-1" data-claire-element-id="550230">Les paramètres de FORMAT</h3><p id="r-550227" data-claire-element-id="550227">Vous vous rappelez du premier chapitre sur les paramètres <code>FORMAT</code> ? Nous allons nous y intéresser de plus près.</p><p id="r-550228" data-claire-element-id="550228">En effet, si l'utilisateur a désactivé les axes ou activé la grille, le résultat risque de ne pas être très joli ^^ .</p><p id="r-550229" data-claire-element-id="550229">Toujours dans le début du programme, on va ajouter<code>AxesOn</code> et <code>GridOff</code>. Les autres paramètres de format ne nous intéressent pas : le graphique ne changera pas selon ces derniers.</p><h3 id="r-a-propos-de-trace" data-claire-element-id="550234">À propos de TRACE</h3><p id="r-550231" data-claire-element-id="550231">Il faut bien l'avouer, notre graphique est tout à fait correct :p .</p><p id="r-550232" data-claire-element-id="550232">Cependant, il est particulièrement dommage que l'utilisateur ne puisse pas voir la <strong>légende</strong> et les <strong>valeurs</strong> de son graphique. C'est pourquoi nous allons enclencher pour lui la fonction <code>TRACE</code>, afin qu'il puisse récolter toutes les informations dont il a besoin !</p><p id="r-550233" data-claire-element-id="550233">Après chaque <code>ZoomStat</code> et après le <code>DispGraph</code>, et avant les <strong>Pause</strong>, vous allez m'ajouter l'instruction <code>Trace</code> ! Pour cela, il suffit d'appuyer sur la touche <code>TRACE</code> dans votre programme ;) .</p><h3 id="r-le-code-final-4" data-claire-element-id="550253">Le code final</h3><p id="r-550235" data-claire-element-id="550235">Après ajout de toutes ces corrections, voici le <strong>code final !</strong></p><pre id="r-550236" data-claire-element-id="550236"><code data-claire-semantic="console">PROGRAM:GRAPHIQU
:FnOff
:PlotsOff
:AxesOn
:GridOff
:ClrHome
:Disp &quot;ENTREZ LES&quot;,&quot;DONNEES DU&quot;,&quot;GRAPHIQUE POUR&quot;,&quot;QU'IL SOIT CREE&quot;,&quot;AUTOMATIQUEMENT
:Pause
:ClrHome
:Disp &quot;NB DE DONNEES
:Input &quot;PAR AXE:&quot;,N
:N-&gt;dim(L1
:N-&gt;dim(L2
:ClrHome
:Disp &quot;ABSCISSES
:Input &quot;DEPART:&quot;,D
:Input &quot;INTERVALLE:&quot;,I
:D-&gt;L1(1)
:For(Z,2,N
:D+I(Z-1-&gt;L1(Z)
:End
:For(Z,1,N
:ClrHome
:Disp &quot;ORDONNEES :&quot;,&quot;VALEUR N°
:Output(2,10,Z
:Input P
:P-&gt;L2(Z
:End
:Menu(&quot; TYPE GRAPHIQUE &quot;,&quot;NUAGE POINTS&quot;,A,&quot;COURBE&quot;,B,&quot;HISTOGRAMME&quot;,C,&quot;QUITTER&quot;,Q
:Lbl Q
:ClrHome
:Output(1,1,&quot;
:Return
:Lbl A
:Plot1(Scatter,L1,L2,*marque*
:ZoomStat
:Trace
:Pause
:Goto Q
:Lbl B
:Plot1(xyLine,L1,L2,*marque*
:ZoomStat
:Trace
:Pause
:Goto Q
:Lbl C
:Plot1(Histogram,L1,L2
:min(L1)-&gt;Xmin
:max(L1)+I-&gt;Xmax
:I-&gt;Xscl
:max(L2)-&gt;Ymax
:0-&gt;Ymin
:iPart(Ymax/10)-&gt;Yscl
:1-&gt;Xres
:DispGraph
:Trace
:Pause
:Goto Q</code></pre><p id="r-550237" data-claire-element-id="550237">Et voici les trois graphiques que l'on obtient pour six données par axe, un départ des X de 0 avec intervalle de 10, et pour valeurs 2,4,8,9,8,1 :</p><figure id="r-550239" data-claire-element-id="550240"><img id="r-550238" data-claire-element-id="550238" src="medias/uploads.siteduzero.com_files_112001_113000_112122.jpg" alt="Image utilisateur"/></figure><figure id="r-550242" data-claire-element-id="550243"><img id="r-550241" data-claire-element-id="550241" src="medias/uploads.siteduzero.com_files_112001_113000_112123.jpg" alt="Image utilisateur"/></figure><figure id="r-550245" data-claire-element-id="550246"><img id="r-550244" data-claire-element-id="550244" src="medias/uploads.siteduzero.com_files_112001_113000_112124.jpg" alt="Image utilisateur"/></figure><p id="r-550247" data-claire-element-id="550247">Hé ben, moi je dis que pour un premier programme en écran graphique, c'est un beau programme en écran graphique ^^ !</p><p id="r-550248" data-claire-element-id="550248">Je parie que si vous aviez vu ce code dès le départ vous auriez abandonné ; quand je vous dis qu'il faut réfléchir à un programme et le coder par petits bouts !<br/> Et c'est encore mieux si vous y êtes arrivé tout seul (ou quasiment, vous ne pouviez pas inventer la syntaxe de <code>Plot1()</code> par exemple).</p><p id="r-550249" data-claire-element-id="550249">D'ailleurs si vous avez un problème quelque part, si vous ne savez pas à quoi sert une fonction ou comment l'utiliser, je vous conseille de jeter un coup d'oeil à la <strong>documentation</strong>, elle est vraiment complète ! Vous pouvez télécharger cette documentation <a href="http://education.ti.com/educationportal/downloadcenter/SoftwareList.do?website=US&amp;amp%3BtabId=2&amp;amp%3BpaneId=17">par ici.</a> Choisissez votre type de TI, sélectionnez français dans le menu de droite puis cliquez sur le lien de téléchargement :) .</p><p id="r-550250" data-claire-element-id="550250">Enfin bref, maintenant que vous maîtrisez la configuration de la fenêtre, du graphique, du tableau, des fonctions, du format, que vous savez utiliser <code>GRAPH, TRACE, CALC, ZOOM, Y=, STAT PLOT, TABLE</code>, et que vous vous êtes rafraîchi la mémoire quant au TI-Basic (on a bien bossé mine de rien ^^ ), nous pouvons passer à la <strong>partie suivante !</strong></p><p id="r-550251" data-claire-element-id="550251">J'aurais bien voulu ne pas mettre de QCM pour cette fin de partie, mais c'est plus fort que moi, et on a quand même appris des trucs dans ce chapitre, il va falloir vérifier que vous avez bien retenu tout ça :diable: ! On se revoit dans la seconde partie... peut-être...</p><p id="r-550252" data-claire-element-id="550252">La première partie est terminée ! Vous pouvez oublier les fonctions et les histogrammes un petit moment, maintenant ce n'est que du dessin. ;)</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti">Utiliser l&#039;écran graphique de la TI</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/utilisation-principale-du-graphique">
Utilisation principale du graphique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/les-fonctions-de-dessin">
Les fonctions de dessin
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/un-rpg-complet-en-ti-basic">
Un RPG complet en TI-Basic
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/les-fonctions-de-dessin">
<span class="next">Les fonctions de dessin</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesfonctionsdedessin"></a><h2>Les fonctions de dessin</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/utilisation-principale-du-graphique">
<span class="arrow"></span>
<span class="next">Utilisation principale du graphique</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/un-rpg-complet-en-ti-basic">
<span class="next">Un RPG complet en TI-Basic</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-550256" data-claire-element-id="550256">Apprenez à dessiner sur votre écran graphique manuellement et en TI-Basic.</p><h2 id="r-le-dessin-3" data-claire-element-id="550318">Le dessin</h2><p id="r-550257" data-claire-element-id="550257">Pour commencer cette seconde partie sur le dessin, nous allons étudier les différentes fonctions disponibles pour vous aider à dessiner facilement.</p><p id="r-550258" data-claire-element-id="550258">Ces fonctions se divisent en trois groupes et la plupart peuvent être utilisées sur l'écran graphique et en TI-Basic.</p><p id="r-550259" data-claire-element-id="550259">Pour dessiner, nous allons utiliser un écran vide : désactivez donc toutes les fonctions de format.<br/> Pour les réglages de la fenêtre, j'ai l'habitude de mettre Xmin à 0, Xmax à 94, Ymin à -62 et Ymax à 0 (1 pixel pour 1 unité).</p><p id="r-550260" data-claire-element-id="550260">Mettre les Y en négatif permet d'avoir le même système de coordonnées que sur... <em>Paint</em>. :p On peut donc dessiner sur <em>Paint</em> pour avoir un aperçu puis recopier les coordonnées des lignes, des cercles (...) en ajoutant simplement le signe « - » aux Y.</p><h3 id="r-draw-les-fonctions" data-claire-element-id="550263">Draw : les fonctions</h3><p id="r-550261" data-claire-element-id="550261">Le menu <code>draw</code> est accessible depuis <code>2ND:PRGM</code>. Il contient trois sous-menus : <code>draw, points</code> et <code>sto</code>.</p><p id="r-550262" data-claire-element-id="550262">Le sous-menu <code>draw</code> contient les fonctions les plus importantes pour le dessin. Celles-ci permettent par exemple de tracer des lignes, des cercles...</p><h3 id="r-clrdraw" data-claire-element-id="550265">ClrDraw</h3><p id="r-550264" data-claire-element-id="550264"><code>ClrDraw</code> (<em>EffDessin</em> en français) permet d'effacer l'écran graphique.<br/> Attention : les axes et les autres paramètres de fenêtre ne seront pas effacés si vous les avez activés.</p><h3 id="r-line-2" data-claire-element-id="550275">Line(</h3><p id="r-550266" data-claire-element-id="550266">La fonction <code>Line(</code> permet de tracer une ligne.</p><p id="r-550267" data-claire-element-id="550267">Sur l'écran graphique, il suffit de sélectionner les deux extrémités de la ligne.<br/> En TI-Basic, la fonction est utilisée comme <code>Line(X1,Y1,X2,Y2)</code>, (X1;Y1) étant les coordonnées du point 1 et (X2;Y2) celles du point 2.</p><p id="r-550268" data-claire-element-id="550268">En écrivant <code>Line(X1,Y1,X2,Y2,0)</code> avec le 0 à la fin, on efface tous les points appartenant à cette ligne.</p><figure id="r-550270" data-claire-element-id="550271"><img id="r-550269" data-claire-element-id="550269" src="medias/uploads.siteduzero.com_files_111001_112000_111874.jpg" alt="Image utilisateur"/></figure><figure id="r-550273" data-claire-element-id="550274"><img id="r-550272" data-claire-element-id="550272" src="medias/uploads.siteduzero.com_files_111001_112000_111875.jpg" alt="Image utilisateur"/></figure><h3 id="r-horizontal-et-vertical" data-claire-element-id="550277">Horizontal et Vertical</h3><p id="r-550276" data-claire-element-id="550276"><code>Horizontal Y</code> et <code>Vertical X</code> permettent de tracer une ligne horizontale ou verticale sur tout l'écran graphique, avec X et Y les abscisses ou ordonnées de cette ligne.<br/> Sur l'écran graphique, on sélectionne l'endroit où l'on veut placer sa ligne horizontale ou verticale.</p><h3 id="r-circle-1" data-claire-element-id="550288">Circle(</h3><p id="r-550278" data-claire-element-id="550278">Cette fonction permet de tracer des cercles.</p><p id="r-550279" data-claire-element-id="550279">Sur l'écran graphique, on sélectionne le centre du cercle, puis un des points du cercle (on trace son rayon).<br/> En TI-Basic, on utilise cette fonction comme suit : <code>Circle(X,Y,R)</code> où (X;Y) sont les coordonnées du centre du cercle et R son rayon.</p><figure id="r-550281" data-claire-element-id="550282"><img id="r-550280" data-claire-element-id="550280" src="medias/uploads.siteduzero.com_files_111001_112000_111876.jpg" alt="Image utilisateur"/></figure><figure id="r-550284" data-claire-element-id="550285"><img id="r-550283" data-claire-element-id="550283" src="medias/uploads.siteduzero.com_files_111001_112000_111877.jpg" alt="Image utilisateur"/></figure><aside id="r-550287" data-claire-element-id="550287" data-claire-semantic="warning"><p id="r-550286" data-claire-element-id="550286">La fonction <code>circle</code> est <strong>très</strong> lente ; en effet, pour tracer ce cercle, il aura fallu plus de deux secondes à la calculatrice !</p></aside><h3 id="r-text-4" data-claire-element-id="550303">Text(</h3><p id="r-550289" data-claire-element-id="550289">La fonction <code>Text(</code> permet d'afficher du texte sur l'écran graphique. La police n'est pas la même que sur l'autre écran : un caractère prend 5 pixels de hauteur et 3 de largeur, sauf certains caractères, comme l'espace qui prend 5x1 pixels.</p><p id="r-550290" data-claire-element-id="550290">Voici la plupart des caractères utilisés, à l'échelle 2:1 :</p><figure id="r-550292" data-claire-element-id="550293"><img id="r-550291" data-claire-element-id="550291" src="medias/uploads.siteduzero.com_files_111001_112000_111878.jpg" alt="Image utilisateur"/></figure><p id="r-550294" data-claire-element-id="550294">Sur l'écran graphique, il suffit de positionner le curseur à 1 pixel au-dessus de l'endroit où l'on veut écrire du texte, puis de taper directement le texte à afficher.<br/> En TI-Basic, on écrit du texte par la fonction <code>Text(Y,X,&quot;texte&quot;)</code>. Notez que, comme pour <em>Output</em>, les Y sont en premier. Vous pouvez aussi <strong>concaténer</strong> les chaînes à afficher. Par exemple, <code>Text(Y,X,&quot;TU AS &quot;,L,&quot; POINTS&quot;)</code> affichera, si L=5 : TU AS 5 POINTS.</p><aside id="r-550296" data-claire-element-id="550296" data-claire-semantic="warning"><p id="r-550295" data-claire-element-id="550295">Contrairement aux autres fonctions du sous-menu <code>Draw</code>, X et Y renvoient aux pixels et non pas aux points du graphique. Ainsi, alors que les Y sont négatifs sur mon écran graphique, je dois les écrire en nombres positifs.</p></aside><figure id="r-550298" data-claire-element-id="550299"><img id="r-550297" data-claire-element-id="550297" src="medias/uploads.siteduzero.com_files_111001_112000_111879.jpg" alt="Image utilisateur"/></figure><figure id="r-550301" data-claire-element-id="550302"><img id="r-550300" data-claire-element-id="550300" src="medias/uploads.siteduzero.com_files_111001_112000_111880.jpg" alt="Image utilisateur"/></figure><h3 id="r-pen" data-claire-element-id="550309">Pen</h3><p id="r-550304" data-claire-element-id="550304">L'outil <code>pen</code> (<em>stylo</em> sur les calculatrices françaises) n'est utilisable que sur l'écran graphique ; on ne peut donc pas s'en servir dans un programme.</p><p id="r-550305" data-claire-element-id="550305">Pour l'utiliser, on place le curseur à l'endroit où l'on veut commencer à dessiner, et on appuie sur <code>ENTER</code> pour activer le stylo. Une fois activé, il suffit de déplacer le curseur pour noircir le point survolé. Il faut appuyer à nouveau sur <code>ENTER</code> pour désactiver le stylo.</p><figure id="r-550307" data-claire-element-id="550308"><img id="r-550306" data-claire-element-id="550306" src="medias/uploads.siteduzero.com_files_111001_112000_111881.jpg" alt="Image utilisateur"/></figure><h3 id="r-points-le-pixel-par-pixel" data-claire-element-id="550317">Points : le pixel par pixel</h3><p id="r-550310" data-claire-element-id="550310">Les fonctions de dessin <em>point par point</em> permettent d'effacer ou de modifier des points facilement.<br/> Elles sont accessibles par le sous-menu <code>2ND:PRGM-POINTS</code>.</p><figure id="r-550312" data-claire-element-id="550313"><img id="r-550311" data-claire-element-id="550311" src="medias/uploads.siteduzero.com_files_111001_112000_111882.jpg" alt="Image utilisateur"/></figure><p id="r-550314" data-claire-element-id="550314">Comme vous pouvez le constater, ces fonctions sont divisées en deux groupes : les points et les pixels.<br/> Par <em>point</em>, il faut comprendre <strong>point du graphique</strong>. Par conséquent, si vous voulez afficher un point au milieu de l'écran et que vous utilisez <code>Pt-On</code>, les paramètres à utiliser seront différents en fonction des réglages de la fenêtre.</p><p id="r-550315" data-claire-element-id="550315">En revanche, pour les <em>pixels</em>, peu importent vos réglages, le point sera toujours au même endroit si vous utilisez une même instruction.</p><p id="r-550316" data-claire-element-id="550316">La grande différence entre ces deux groupes, c'est que les fonctions de pixels ne sont <strong>utilisables qu'en TI-Basic</strong>, contrairement aux points qui le sont <strong>aussi</strong> directement sur l'écran graphique.</p><h2 id="r-les-fonctions-pt" data-claire-element-id="550336">Les fonctions Pt</h2><p id="r-550319" data-claire-element-id="550319">Sur l'écran graphique, l'utilisation des fonctions <code>Pt</code> est très simple : il suffit d'appuyer sur <code>ENTER</code> lorsque l'on veut activer, désactiver ou inverser un point.</p><p id="r-550320" data-claire-element-id="550320">En TI-Basic, ce n'est pas beaucoup plus compliqué, mais on a droit à des options : il faut juste indiquer les coordonnées du point à travailler, puis le <strong>type de point à afficher</strong>, comme vous pouvez le voir sur l'illustration suivante :</p><figure id="r-550322" data-claire-element-id="550323"><img id="r-550321" data-claire-element-id="550321" src="medias/uploads.siteduzero.com_files_111001_112000_111883.jpg" alt="Image utilisateur"/></figure><figure id="r-550325" data-claire-element-id="550326"><img id="r-550324" data-claire-element-id="550324" src="medias/uploads.siteduzero.com_files_111001_112000_111884.jpg" alt="Image utilisateur"/></figure><figure id="r-550328" data-claire-element-id="550329"><img id="r-550327" data-claire-element-id="550327" src="medias/uploads.siteduzero.com_files_111001_112000_111885.jpg" alt="Image utilisateur"/></figure><figure id="r-550331" data-claire-element-id="550332"><img id="r-550330" data-claire-element-id="550330" src="medias/uploads.siteduzero.com_files_111001_112000_111886.jpg" alt="Image utilisateur"/></figure><aside id="r-550334" data-claire-element-id="550334" data-claire-semantic="information"><p id="r-550333" data-claire-element-id="550333">Si vous mettez un type de point supérieur à 3, celui-ci sera par défaut, c'est-à-dire de type 1. De plus, le dernier paramètre est facultatif : si vous n'indiquez que les coordonnées, alors le point créé sera de type 1.</p></aside><p id="r-550335" data-claire-element-id="550335">L'utilisation des autres fonctions <code>Pt</code> est la même. Pour ceux qui ne l'auraient pas compris, <code>Pt-change</code> permet d'<strong>inverser</strong> un point : s'il est activé, on le désactive, et s'il est désactivé, on l'active. C'est aussi simple que ça.</p><h2 id="r-les-fonctions-pxl" data-claire-element-id="550367">Les fonctions Pxl</h2><p id="r-550337" data-claire-element-id="550337">Vous avez sûrement remarqué qu'il y a une fonction <code>Pxl</code> de plus par rapport aux fonctions <code>Pt</code> : <code>pxl-Test</code>. Les plus perspicaces d'entre vous auront compris que cette fonction permet de savoir si un pixel est noir ou non.</p><p id="r-550338" data-claire-element-id="550338">La fonction renvoie 1 si le pixel est noir et 0 s'il est blanc.</p><p id="r-550339" data-claire-element-id="550339">Il y a une seconde différence majeure entre les fonctions <code>Pt</code> et <code>Pxl</code> : les fonctions <code>Pxl</code> ont pour syntaxe <code>(Y,X)</code> tandis que les <code>Pt</code> sont utilisées comme <code>(X,Y)</code>.</p><p id="r-550340" data-claire-element-id="550340">À part ces quelques points spéciaux, le fonctionnement est le même que pour tout le reste :</p><figure id="r-550342" data-claire-element-id="550343"><img id="r-550341" data-claire-element-id="550341" src="medias/uploads.siteduzero.com_files_111001_112000_111887.jpg" alt="Image utilisateur"/></figure><figure id="r-550345" data-claire-element-id="550346"><img id="r-550344" data-claire-element-id="550344" src="medias/uploads.siteduzero.com_files_111001_112000_111888.jpg" alt="Image utilisateur"/></figure><figure id="r-550348" data-claire-element-id="550349"><img id="r-550347" data-claire-element-id="550347" src="medias/uploads.siteduzero.com_files_111001_112000_111889.jpg" alt="Image utilisateur"/></figure><p id="r-550350" data-claire-element-id="550350">Ce <code>pxl-Test</code> peut vous être très utile ou totalement futile ; tout dépend de la façon dont vous programmez.</p><h3 id="r-sto-l-utilisation-des-images" data-claire-element-id="550352">Sto : l'utilisation des images</h3><p id="r-550351" data-claire-element-id="550351">Ah, là on rentre dans le vif du sujet. Vous ne voudriez pas que votre beau dessin soit effacé, ni que vous ne puissiez rien en faire ! Il faut donc <strong>sauvegarder</strong> votre image.</p><h3 id="r-storepic" data-claire-element-id="550359">StorePic</h3><p id="r-550353" data-claire-element-id="550353">Accessible depuis <code>2ND:PRGM-STO</code>, la fonction <code>StorePic</code> vous permet d'enregistrer jusqu'à 10 images sur votre calculatrice. Pour l'utiliser, il suffit de rajouter le numéro de fichier dans lequel vous souhaitez l'enregistrer. Vous pouvez donc écrire <code>StorePic 0</code>, <code>StorePic 1</code>, jusqu'à 9.</p><aside id="r-550355" data-claire-element-id="550355" data-claire-semantic="warning"><p id="r-550354" data-claire-element-id="550354">La calculatrice ne demande pas de confirmation pour écraser une image déjà existante. Faites attention à l'emplacement où vous sauvegardez votre image !</p></aside><p id="r-550356" data-claire-element-id="550356">Voilà, votre image est enregistrée et vous ne risquez plus de l'effacer par erreur. Attention quand même, car une image utilise 767 octets (et ce quelque soit l'image) et sur 24Ko de RAM, ça fait quand même pas mal !</p><p id="r-550357" data-claire-element-id="550357">D'ailleurs puisqu'on en parle, n'oubliez pas que si vous avez une TI83+ ou supérieure, vous pouvez archiver vos programmes, images, etc. dans la mémoire ARC de la TI (sur TI-83, c'est environ 160Ko, donc tout de suite on peut stocker plus de choses ^^ ). Pour cela, vous devez aller dans <code>2ND:+, MEMMgmt/Del</code> et choisir le type d'objet à archiver. Appuyez ensuite sur <code>ENTER</code> pour archiver le fichier pointé.</p><p id="r-550358" data-claire-element-id="550358">Les objets archivés ne peuvent pas être utilisés. Ils sont simplement stockés en mémoire pour une utilisation ultérieure. Pour les réutiliser, il faut les désarchiver, dans le même menu et de la même manière que précédemment. Appuyer sur <code>ENTER</code> sur un fichier archivé le désarchivera.</p><h3 id="r-recallpic" data-claire-element-id="550362">RecallPic</h3><p id="r-550360" data-claire-element-id="550360">La fonction <code>RecallPic</code> permet d'afficher une image sauvegardée. L'image est affichée par dessus les points déjà existants sur l'écran graphique. Si ce n'est pas ce que vous souhaitez, faites un <code>ClrDraw</code>. ;)</p><p id="r-550361" data-claire-element-id="550361">Pour rappeler une image, vous devez, comme pour <code>StorePic</code>, entrer le numéro de l'image en question. Si vous avez écrit <code>StorePic 1</code>, il faudra utiliser <code>RecallPic 1</code> pour afficher cette image. Essayer de rappeler une image non existante aura pour effet d'afficher un beau <code>ERR:UNDEFINED</code> vous signalant que celle-ci n'existe pas.</p><h3 id="r-storegdb-et-recallgdb" data-claire-element-id="550366">StoreGDB et RecallGDB</h3><p id="r-550363" data-claire-element-id="550363">Ces deux fonctions permettent respectivement d'enregistrer et de rappeler les réglages de l'écran graphique, que l'on appelle <strong>Base de Données de Graphe</strong>. Un GDB prend 124 octets et, personnellement, je préfère modifier chaque paramètre grâce à un programme, c'est moins volumineux.</p><p id="r-550364" data-claire-element-id="550364">En effet, un GDB contient plusieurs données qui ne sont que rarement utiles. Il est composé des réglages de <code>MODE</code> (que l'on n'a pas vu : ce n'est pas ou très peu du domaine du graphique), <code>WINDOW, FORMAT, Y=</code> et <code>PLOT</code>.</p><p id="r-550365" data-claire-element-id="550365">Dans ce chapitre, nous avons vu la grande majorité des fonctions de dessin ; nous pouvons donc attaquer l'<strong>utilisation de ces fonctions dans un programme</strong> !</p><h2 id="r-utiliser-le-dessin-dans-un-programme" data-claire-element-id="550378">Utiliser le dessin dans un programme</h2><p id="r-550368" data-claire-element-id="550368">Nous avons vu comment dessiner en TI-Basic et sur l'écran graphique, mais vous n'imaginez pas ce que l'on peut faire avec quelques variables pour paramètres de ces fonctions : on approche de plus en plus de la programmation du RPG !</p><p id="r-550369" data-claire-element-id="550369">D'ailleurs, vous avez déjà les connaissances pour faire la plupart des jeux (bon dans les limites de la TI bien sûr, mais la quasi-totalité des jeux 2D sont réalisables sur TI). Dans ce chapitre, nous n'allons voir que des exemples concrets de ce que nous avons déjà appris !</p><p id="r-550370" data-claire-element-id="550370">Les plus courageux d'entre vous peuvent essayer de programmer un morpion avant de continuer le tutoriel, et si vous y arrivez croyez-moi vous avez tout compris ^^ .</p><p id="r-550371" data-claire-element-id="550371">À la fin de ce chapitre, tout le monde devrait être capable de faire un morpion. Allez hop, un petit TP pour le prochain chapitre !</p><h3 id="r-un-menu-sur-l-ecran-graphique" data-claire-element-id="550377">Un menu sur l'écran graphique</h3><p id="r-550372" data-claire-element-id="550372">Jusque là, on n'utilisait quasiment que ce qu'on a appris dans ce big-tuto. Maintenant, on va voir comment utiliser l'écran graphique avec ce que l'on connaissait déjà, c'est-à-dire tous les points énoncés par Lanfeust 313 dans <a href="http://www.siteduzero.com/tuto-3-1524-0-le-ti-basic.html">son tutoriel</a>.</p><p id="r-550373" data-claire-element-id="550373">Alors pour ceux qui n'auraient pas suivi, j'ai l'habitude de définir mon écran graphique avec <code>Xmin=0; Xmax=94; Ymin=-62; Ymax=0</code>. Ne vous étonnez donc pas si mes ordonnées sont négatives.</p><p id="r-550374" data-claire-element-id="550374">D'ailleurs je vous conseille de faire pareil, au moins pendant ce big-tuto, ça vous évitera quelques problèmes de compréhension et vous pourrez toujours utiliser vos propres réglages après ;) .</p><p id="r-550375" data-claire-element-id="550375">Prenez bien soin de mettre chaque option de <code>FORMAT</code> sur <code>OFF</code> et de désactiver chacune des courbes et chacun des graphiques dans <code>Y=</code>.</p><p id="r-550376" data-claire-element-id="550376">C'est fait ? On peut commencer ^^ .</p><h2 id="r-affichage-des-options-dans-le-menu" data-claire-element-id="550397">Affichage des options dans le menu</h2><p id="r-550379" data-claire-element-id="550379">Je vous explique ce que l'on veut faire :</p><figure id="r-550381" data-claire-element-id="550382"><img id="r-550380" data-claire-element-id="550380" src="medias/uploads.siteduzero.com_files_111001_112000_111891.jpg" alt="Image utilisateur"/></figure><figure id="r-550384" data-claire-element-id="550385"><img id="r-550383" data-claire-element-id="550383" src="medias/uploads.siteduzero.com_files_111001_112000_111892.jpg" alt="Image utilisateur"/></figure><p id="r-550386" data-claire-element-id="550386">On affiche des options précédées d'un numéro.</p><p id="r-550387" data-claire-element-id="550387">Lorsque l'utilisateur appuie sur 1, 2 ou 3 (<code>getKey</code>(<code>codeTouche</code> en français), vous vous souvenez ?), le programme enregistre son choix et affiche l'option choisie.</p><p id="r-550388" data-claire-element-id="550388">Ensuite, une petite pause, puis on efface l'écran graphique et on affiche l'écran principal.</p><aside id="r-550390" data-claire-element-id="550390" data-claire-semantic="information"><p id="r-550389" data-claire-element-id="550389">Au cas où vous ne le sauriez pas, l'instruction <code>Disp</code> sans paramètre permet d'afficher l'écran principal.</p></aside><p id="r-550391" data-claire-element-id="550391">Alors pour afficher ces options, c'est très simple, et nous venons de l'apprendre ! On va utiliser la fonction <strong>Text</strong>.</p><p id="r-550392" data-claire-element-id="550392">Il n'y a pas besoin d'une grande réflexion pour savoir ce que l'on doit écrire, il faut juste se souvenir que les Y viennent avant dans la fonction Text :</p><pre id="r-550393" data-claire-element-id="550393"><code data-claire-semantic="console">:ClrDraw
:Text(0,0,&quot;1. OPTION 1
:Text(6,0,&quot;2. COMMANDE 2
:Text(12,0,&quot;3. CHOIX 3</code></pre><p id="r-550394" data-claire-element-id="550394">Je suppose que vous vous souvenez que les parenthèses, guillemets et autres décorations ne nécessitent pas leur fermeture ; celle-ci est automatique et cela permet d'utiliser moins de mémoire.</p><p id="r-550395" data-claire-element-id="550395">En programmation, on essaie en général de coder proprement, mais là on a moins de 24 Ko disponibles alors le purisme on n'en a pas grand chose à faire ! :p</p><p id="r-550396" data-claire-element-id="550396">Sur un gros programme, le fait de ne pas fermer les parenthèses et les guillemets réduit <strong>énormément</strong> la mémoire requise. Chaque caractère en moins est important.</p><h2 id="r-gestion-de-l-appui-sur-une-touche" data-claire-element-id="550435">Gestion de l'appui sur une touche</h2><p id="r-550398" data-claire-element-id="550398">Une fois les options affichées, l'utilisateur doit appuyer sur une touche. Oui mais pas n'importe laquelle, il doit appuyer sur les touches 1, 2 ou 3.</p><p id="r-550399" data-claire-element-id="550399">Les codes de ces touches sont respectivement 92, 93 et 94 : ce sont des <strong>suites</strong>. On peut donc établir un rapport entre le numéro de la touche et son code : en effet, le numéro de la touche est égal au code moins 91 : 94 - 91 = 3 : on affiche la commande 3.</p><p id="r-550400" data-claire-element-id="550400">Alors évidemment, ça ne marche pas forcément si on utilise d'autres touches, mais il y a quasiment toujours une équation permettant de raccourcir le code, et donc d'utiliser moins de mémoire.</p><p id="r-550401" data-claire-element-id="550401">Par exemple si l'on veut gérer la touche 4, on rajoutera une condition : si le code touche est compris entre 92 et 94, on soustrait 91, s'il est compris entre 82 et 84, on soustrait 78. Le gain de mémoire est moins évident, mais il est là ;) . En plus, cela <strong>accélère l'exécution du programme</strong> : par rapport au « <code>If G=92, If G=93</code> » et ainsi de suite, il y a des conditions, certes, mais il y en a moins. Et un jeu rapide, c'est un jeu qui n'ennuie pas son utilisateur ^^ .</p><p id="r-550402" data-claire-element-id="550402">On va donc mettre en pratique ce que l'on vient de voir. Après avoir affiché les options, le code est le suivant :</p><pre id="r-550403" data-claire-element-id="550403"><code data-claire-semantic="console">:Repeat G&gt;91 and G&lt;95
:getKey-&gt;G
:End
:G-91-&gt;D
:Text(18,0,&quot;TU AS CHOISI LE &quot;,D
:Pause
:ClrDraw
:Disp</code></pre><p id="r-550404" data-claire-element-id="550404">Nous avons déjà expliqué ce code. Tant que l'utilisateur n'appuie pas sur 1, 2 ou 3, le programme attend la pression d'une touche. Ensuite, on affiche le numéro de l'option correspondante.</p><p id="r-550405" data-claire-element-id="550405">Il n'était pas nécessaire d'utiliser deux variables (on aurait pu faire <code>:G-91-&gt;G</code>), mais cela permet dans cet exemple de bien différencier chaque affectation.</p><p id="r-550406" data-claire-element-id="550406">Notez la concaténation à la ligne 5 : c'est un procédé aussi utile qu'important qui vous permettra de gagner temps, mémoire et souvent esthétique par rapport à l'utilisation de deux instructions <code>Text</code> à la suite.</p><h3 id="r-un-menu-plus-esthetique" data-claire-element-id="550434">Un menu plus esthétique</h3><p id="r-550407" data-claire-element-id="550407">Dans la sous-partie précédente, nous n'avons utilisé que la fonction <code>Text</code> pour ce qui est du graphique. Ici, on passe au niveau supérieur. On souhaite un rendu bien plus esthétique, voici ce que l'on doit avoir :</p><figure id="r-550409" data-claire-element-id="550410"><img id="r-550408" data-claire-element-id="550408" src="medias/uploads.siteduzero.com_files_111001_112000_111893.jpg" alt="Image utilisateur"/></figure><figure id="r-550412" data-claire-element-id="550413"><img id="r-550411" data-claire-element-id="550411" src="medias/uploads.siteduzero.com_files_111001_112000_111894.jpg" alt="Image utilisateur"/></figure><figure id="r-550415" data-claire-element-id="550416"><img id="r-550414" data-claire-element-id="550414" src="medias/uploads.siteduzero.com_files_111001_112000_111895.jpg" alt="Image utilisateur"/></figure><p id="r-550417" data-claire-element-id="550417">Comme vous pouvez le voir, en appuyant sur les flèches haut et bas, l'utilisateur choisit directement l'option qu'il souhaite puis appuie sur <code>ENTER</code>. Nous allons donc créer un <strong>curseur</strong>, ou plutôt un <strong>focus</strong>, appelez-le comme vous voulez :p .</p><p id="r-550418" data-claire-element-id="550418">Pour cela, nous aurons besoin d'une variable. Celle-ci a pour valeur le <strong>numéro</strong> de l'option survolée. On affichera un cadre (composé de quatre lignes) autour du texte survolé, les instructions <code>Line</code> auront donc la variable dans leurs paramètres.</p><p id="r-550419" data-claire-element-id="550419">Ensuite, l'utilisateur doit appuyer sur <code>ENTER</code>, flèche haut ou flèche bas. Ces deux dernières touches ne seront actives que si l'option survolée n'est respectivement pas la plus haute et la plus basse : on ne pourra pas donner à la variable une valeur qui ne correspond à aucune option, sinon le cadre entourerait du vide :-° ...</p><p id="r-550420" data-claire-element-id="550420">Une fois que l'utilisateur a appuyé sur l'une de ces touches actives, le cadre est <strong>supprimé</strong> grâce à la fonction <code>Line(X1,Y1,X2,Y2,0)</code>. En fait, les paramètres de cette fonction, appelée quatre fois (une par côté du cadre), sont <strong>les mêmes</strong> que pour l'affichage, on rajoutera simplement un 0.</p><p id="r-550421" data-claire-element-id="550421">Si l'utilisateur appuie sur flèche haut ou flèche bas, on modifie la valeur de la variable pour que le prochain cadre créé le soit autour de la <strong>nouvelle sélection</strong>.</p><p id="r-550422" data-claire-element-id="550422">Essayez de programmer ce menu sans mon aide, vous pouvez y arriver ;) .</p><p id="r-550423" data-claire-element-id="550423">Si vous préférez comprendre sans chercher par vous-même (je suppose que vous êtes au courant que c'est un mauvais choix), voici la façon dont j'ai codé ce menu :</p><pre id="r-550424" data-claire-element-id="550424"><code data-claire-semantic="console">:ClrDraw
:Text(2,2,&quot;OPTION 1
:Text(10,2,&quot;COMMANDE 2
:Text(18,2,&quot;CHOIX 3
:1-&gt;D
:Repeat G=105
:Line(0,7-8*D,0,-1-8*D
:Line(0,-1-8*D,40,-1-8*D
:Line(40,-1-8*D,40,7-8*D
:Line(40,7-8*D,0,7-8*D
:Repeat G=105 or (G=25 and D&gt;1) or (G=34 and D&lt;3
:getKey-&gt;G
:End
:Line(0,7-8*D,0,-1-8*D,0
:Line(0,-1-8*D,40,-1-8*D,0
:Line(40,-1-8*D,40,7-8*D,0
:Line(40,7-8*D,0,7-8*D,0
:D-(G=25)+(G=34)-&gt;D
:End
:Text(40,0,&quot;TU AS CHOISI LE &quot;,D
:Pause
:ClrDraw
:Disp</code></pre><p id="r-550425" data-claire-element-id="550425">Ah ouais, ça rigole plus là :D ! En fait, tout ce qu'il y a de nouveau, ce sont les huit lignes d'instructions <strong>Line</strong>.</p><p id="r-550426" data-claire-element-id="550426">La ligne <code>:D-(G=25)+(G=34)-&gt;D</code> permet de modifier la valeur de D en fonction de la touche appuyée.</p><p id="r-550427" data-claire-element-id="550427">Vous savez qu'une condition <strong>if</strong> signifie en fait « si cette expression est vraie ». En effet, tous les tests effectués avec « = » ou « &lt; » par exemple renvoient soit 0 (faux), soit 1 (vrai) : ce sont des <strong>booléens</strong>.</p><p id="r-550428" data-claire-element-id="550428">Lorsque <code>G=25</code>, on veut soustraire 1 à D. Si G est différent de 25, on ne veut rien soustraire (<code>G-0</code>). Eh bien lorsque la TI lit <code>D-(G=25)</code>, elle remplace le test « G=25 » par 1 (vrai) ou 0 (faux).</p><p id="r-550429" data-claire-element-id="550429">Donc, si l'on a appuyé sur la touche de code 25 (flèche haut), la TI lira : <code>D-1</code>. Sinon, elle lira <code>D-0</code>.</p><p id="r-550430" data-claire-element-id="550430">Usez et abusez de cette méthode, elle est très rapide et très légère ! ;)</p><p id="r-550431" data-claire-element-id="550431">Notez que l'on ne vérifie pas si D est supérieur à 1 à la ligne « <code>:D-(G=25)+(G=34)-&gt;D</code> » : c'est parce qu'on l'a déjà vérifié dans le <code>Repeat</code>.</p><p id="r-550432" data-claire-element-id="550432">En effet, pour que le programme lise cette ligne, il faut que l'on ait appuyé sur une touche active : or la flèche haut n'est active que si D est supérieur à 1.</p><p id="r-550433" data-claire-element-id="550433">Vous vous demandez peut-être d'où viennent ces « 7-8*D » et « -1-8*D » ? Eh bien je vais vous confier un secret : ici, ce sont des valeurs assez simples donc il suffit de réfléchir un peu pour les trouver, mais dans des cas plus complexes, on utilise une fonction bien pratique de la calculatrice : j'ai nommé...</p><h2 id="r-linreg-ax-b" data-claire-element-id="550455">LinReg(ax+b)</h2><p id="r-550436" data-claire-element-id="550436">Je vous explique le principe : vous avez plusieurs boutons : b1, b2, b3 et b4. Ces boutons sont situés respectivement aux abscisses 10, 20, 30 et 40. Ce que l'on veut, c'est afficher quatre points X1, X2, X3 et X4 d'abscisses respectives 4, 9, 14 et 19. Pour cela, on utilise un <code>For(A,10,40,10)</code> pour nos quatre points à afficher.</p><p id="r-550437" data-claire-element-id="550437">Dans ce <code>For</code>, on aura une seule instruction : <code>Pt-On(X,0)</code>. Que mettre à la place de X ? Excellente question. C'est là que <code>LinReg(ax+b)</code> entre en scène : cette fonction va calculer pour nous le paramètre X de la fonction <code>Pt-On</code>.</p><p id="r-550438" data-claire-element-id="550438">Ce que l'on doit faire, c'est entrer nos valeurs dans deux listes. On va prendre <code>L1</code> et <code>L2</code>.</p><pre id="r-550439" data-claire-element-id="550439"><code data-claire-semantic="console">:{10,20,30,40}-&gt;L1
:{4,9,14,19}-&gt;L2</code></pre><p id="r-550440" data-claire-element-id="550440">Une fois que l'on a nos deux listes, on peut utiliser <code>LinReg(ax+b)</code>. Cette fonction est accessible par <code>STAT-CALC</code> et prend deux listes comme paramètres.</p><figure id="r-550442" data-claire-element-id="550443"><img id="r-550441" data-claire-element-id="550441" src="medias/uploads.siteduzero.com_files_111001_112000_111896.jpg" alt="Image utilisateur"/></figure><figure id="r-550445" data-claire-element-id="550446"><img id="r-550444" data-claire-element-id="550444" src="medias/uploads.siteduzero.com_files_111001_112000_111897.jpg" alt="Image utilisateur"/></figure><p id="r-550447" data-claire-element-id="550447">L'écran obtenu nous indique une équation de droite. C'est en fait l'équation de la droite représentant une fonction affine et passant par les points de coordonnées (L1(1);L2(1)), (L1(2);L2(2)) etc.</p><p id="r-550448" data-claire-element-id="550448">Et comme nous ne sommes plus dans la partie maths du tutoriel, nous n'allons pas étudier les fonctions affines :D ! Non, nous, notre équation va nous servir à autre chose. Vous l'avez deviné, c'est le paramètre de l'instruction <code>For</code> de notre exemple !</p><p id="r-550449" data-claire-element-id="550449">D'après l'écran obtenu, on a <code>y=ax+b ; a=0.5 ; b=-1</code>. Par conséquent, on a <code>y=0.5x-1</code>, où X est notre variable... <strong>A</strong> !<br/> On écrit donc dans notre programme :</p><pre id="r-550450" data-claire-element-id="550450"><code data-claire-semantic="console">:For(A,10,40,10
:Pt-On(0.5*A-1,0
:End</code></pre><p id="r-550451" data-claire-element-id="550451">À partir de là, on peut aisément trouver une façon plus courte d'écrire ce code.</p><pre id="r-550452" data-claire-element-id="550452"><code data-claire-semantic="console">:For(A,1,4
:Pt-On(5A-1,0
:End</code></pre><p id="r-550453" data-claire-element-id="550453">N'oubliez pas que chaque caractère compte, et là on en gagne huit sur seulement trois lignes de code (et encore je compte le End comme une ligne) ;) .</p><p id="r-550454" data-claire-element-id="550454">Imaginez un programme de 100 lignes (ce qui est loin d'être énorme) : à raison de huit caractères gagnés sur trois lignes, on gagnerait 260 octets sur le programme. Et 260 octets de gagnés, c'est un programme plus complet ! Bon évidemment vous aurez rarement l'occasion d'optimiser autant votre code, mais il y a toujours des caractères à économiser ^^ .</p><h2 id="r-revenons-a-nos-moutons-2" data-claire-element-id="550478">Revenons à nos moutons...</h2><p id="r-550456" data-claire-element-id="550456">Bon c'est bien beau tout ça, mais on n'a pas fini d'expliquer le code ! Je vous remets les lignes importantes ici afin de ménager la molette de votre souris :</p><pre id="r-550457" data-claire-element-id="550457"><code data-claire-semantic="console">:Repeat G=105
:Line(0,7-8*D,0,-1-8*D
:Line(0,-1-8*D,40,-1-8*D
:Line(40,-1,-8*D,40,7-8*D
:Line(40,7-8*D,0,7-8*D
:Repeat G=105 or (G=25 and D&gt;1) or (G=34 and D&lt;3
:getKey-&gt;G
:End
:Line(0,7-8*D,0,-1-8*D,0
:Line(0,-1-8*D,40,-1-8*D,0
:Line(40,-1-8*D,40,7-8*D,0
:Line(40,7-8*D,0,7-8*D,0
:D-(G=25)+(G=34)-&gt;D
:End</code></pre><p id="r-550458" data-claire-element-id="550458">Bon alors pour commencer, le <code>Repeat</code> au début permet tout simplement de ne continuer le programme que lorsque l'utilisateur aura appuyé sur la touche <code>ENTER</code>.</p><p id="r-550459" data-claire-element-id="550459">On affiche ensuite nos lignes pour former un cadre. Notez que D a été initialisée à 1 avant le <code>repeat</code>. Comme nous l'avons vu avec <code>LinReg(ax+b)</code>, les instructions <code>Line</code> prennent en paramètre des formules contenant D. C'est exactement la même utilisation que ce qu'on a vu, seulement on a quatre lignes au lieu d'un point. Le raisonnement est le même.</p><p id="r-550460" data-claire-element-id="550460">Ensuite, on a à nouveau un <code>Repeat</code>. Cette fois, il ne se limite plus à la touche <code>ENTER</code> : si l'on appuie sur la flèche haut et que l'option survolée n'est pas la plus haute, ou si on appuie sur la flèche bas et que l'option survolée n'est pas la plus basse, alors on sort de la boucle. Et dans cette boucle, eh bien on attend que l'utilisateur presse une touche.</p><p id="r-550461" data-claire-element-id="550461">Une fois qu'il a appuyé sur une touche active, on efface le cadre - comme je vous l'avais dit, ce sont exactement les mêmes paramètres auxquels on aura ajouté un 5e, le 0 - et si c'est sur une flèche qu'on a appuyé, l'option survolée n'est plus la même.</p><p id="r-550462" data-claire-element-id="550462">Notez que l'on n'a pas besoin de vérifier que l'option n'est pas un <em>extremum</em> puisqu'on l'a déjà fait dans la seconde boucle <code>Repeat</code>.</p><p id="r-550463" data-claire-element-id="550463">Ainsi, tant qu'on n'appuie pas sur entrée, appuyer sur une flèche fera disparaître le cadre, et celui-ci sera créé ailleurs.</p><aside id="r-550465" data-claire-element-id="550465" data-claire-semantic="information"><p id="r-550464" data-claire-element-id="550464">Vous devez avoir bien compris cette sous-partie, car cette méthode de programmation est omniprésente dans les jeux graphiques en TI-Basic ! C'est la base même du déplacement que nous allons voir dans la prochaine sous-partie.</p></aside><p id="r-550466" data-claire-element-id="550466">Et ce qui est bien avec ce genre de menu, c'est qu'avec un petit dessin en fond et par exemple le titre du jeu dans une police originale... ça le fait ^^ !</p><p id="r-550467" data-claire-element-id="550467">Tenez, vous allez allier dessin et programmation : je vous propose un petit exercice non corrigé (c'est le même code que ce que l'on vient de faire, seules les valeurs changent) : dessinez un écran principal où vous mettrez un titre stylisé et trois options : « NOUVEAU », « CHARGER », « QUITTER ».</p><p id="r-550468" data-claire-element-id="550468">Enregistrez votre image puis faites un programme qui rappellera votre image puis affichera un curseur sur ces options (pas de <code>ClrDraw</code> après le <code>RecallPic</code> donc), comme on vient de le faire ;) .</p><p id="r-550469" data-claire-element-id="550469">Si vous n'y arrivez pas, relisez cette sous-partie, c'est vraiment important ! Et si rien n'y fait, allez jeter un coup d'oeil dans la partie trois du big-tuto, on y apprendra justement à faire cet écran-titre pour notre RPG.</p><p id="r-550470" data-claire-element-id="550470">Voici un exemple de ce que vous pouvez faire, c'est l'écran-titre du jeu en question :</p><figure id="r-550472" data-claire-element-id="550473"><img id="r-550471" data-claire-element-id="550471" src="medias/uploads.siteduzero.com_files_111001_112000_111898.jpg" alt="Image utilisateur"/></figure><p id="r-550474" data-claire-element-id="550474">Il n'y a pas de bouton « QUITTER », mais cette commande est activée en appuyant sur la touche <code>CLEAR</code>.</p><h3 id="r-deplacement-d-un-personnage" data-claire-element-id="550477">Déplacement d'un personnage</h3><p id="r-550475" data-claire-element-id="550475">Peut-être que cela n'en a pas l'air, mais déplacer un personnage sur l'écran graphique est exactement la même chose que créer un curseur pour un menu.</p><p id="r-550476" data-claire-element-id="550476">Pour commencer, il faut créer deux variables pour les coordonnées du personnage. On va prendre A et B pour ne pas confondre avec les réglages du graphique. Il faut <strong>initialiser</strong> ces variables ; on pourrait les mettre à 0, mais je veux que mon personnage apparaisse au centre de l'écran. On va donc prendre <code>A = 47</code> et <code>B = -31</code>.</p><h2 id="r-un-soupcon-de-dessin" data-claire-element-id="550493">Un soupçon de dessin...</h2><p id="r-550479" data-claire-element-id="550479">Ensuite, il faut commencer à dessiner notre personnage, mais tout doit être fait en TI-Basic, sinon sa position sera fixe.</p><p id="r-550480" data-claire-element-id="550480">On pourrait représenter notre personnage par une croix (un point de type 3), mais je veux vous montrer qu'il est très simple de déplacer n'importe quelle forme (à part peut-être les cercles qui sont très lents à dessiner) à l'écran.</p><p id="r-550481" data-claire-element-id="550481">Nous allons donc dessiner un bonhomme (façon maternelle... va falloir vous adapter à mes compétences !).</p><p id="r-550482" data-claire-element-id="550482">Notre bonhomme va être composé de 18 points. Le voici en grossissement x4, son centre de coordonnées (A;B) est en rouge.</p><figure id="r-550484" data-claire-element-id="550485"><img id="r-550483" data-claire-element-id="550483" src="medias/uploads.siteduzero.com_files_111001_112000_111899.jpg" alt="Image utilisateur"/></figure><p id="r-550486" data-claire-element-id="550486">Pour le dessiner point par point, on doit donc écrire :</p><pre id="r-550487" data-claire-element-id="550487"><code data-claire-semantic="console">:Pt-On(X,Y
:Pt-On(A-1,B
:Pt-On(A-2,B
:Pt-On(A+1,B
:Pt-On(A+2,B
:Pt-On(A,B+1
:Pt-On(A,B+2
:Pt-On(A-1,B+3
:Pt-On(A,B+4
:Pt-On(A+1,B+3
:Pt-On(A,B-1
:Pt-On(A,B-2
:Pt-On(A-1,B-3
:Pt-On(A-1,B-4
:Pt-On(A-2,B-5
:Pt-On(A+1,B-3
:Pt-On(A+1,B-4
:Pt-On(A+2,B-5</code></pre><p id="r-550488" data-claire-element-id="550488">Vous serez sûrement d'accord pour utiliser quelques fonctions de dessin et des petites boucles for, histoire de raccourcir tout ça !</p><pre id="r-550489" data-claire-element-id="550489"><code data-claire-semantic="console">:For(C,-2,2
:Pt-On(A+C,B
:Pt-On(A,B+C
:End
:Pt-On(A,B+3,3
:Pt-Off(A,B+3
:Line(A-2,B-5,A,B-2
:Line(A,B-2,A+2,B-5</code></pre><p id="r-550490" data-claire-element-id="550490">C'est déjà mieux. Le torse et les bras du bonhomme sont créés lors de la boucle <code>For</code>.</p><p id="r-550491" data-claire-element-id="550491">Le <code>Pt-On</code> de type 3 permet d'afficher une croix à l'emplacement de la tête, puis le <code>Pt-Off</code> désactive le point central de la croix, résultat : un petit cercle rapidement dessiné !</p><p id="r-550492" data-claire-element-id="550492">Enfin, les jambes sont dessinées par deux fonctions <code>Line</code>. La vitesse d'affichage du bonhomme est correcte, on peut donc continuer le code ;) .</p><h2 id="r-et-une-once-de-programmation" data-claire-element-id="550510">Et une once de programmation</h2><p id="r-550494" data-claire-element-id="550494">Notre bonhomme a une dimension de 10x5 pixels, son centre a pour coordonnées (3;6). On peut en déduire que les coordonnées du bonhomme sont définies par <code>Xmin+3&lt;A&lt;Xmax-3</code> et <code>Ymin+5&lt;B&lt;Ymax-5</code>. On ne pourra donc déplacer le bonhomme que si ces valeurs sont vérifiées.</p><p id="r-550495" data-claire-element-id="550495">Le joueur doit pouvoir arrêter le déplacement en appuyant sur la touche <code>ENTER</code>.</p><p id="r-550496" data-claire-element-id="550496">Après avoir affiché le bonhomme, le programme attend que le joueur appuie sur l'une des flèches directionnelles et le bonhomme se déplace.</p><p id="r-550497" data-claire-element-id="550497">Pour effacer le bonhomme, il suffit d'inverser le code précédent :</p><pre id="r-550498" data-claire-element-id="550498"><code data-claire-semantic="console">:For(C,-2,2
:Pt-Off(A+C,B
:Pt-Off(A,B+C
:End
:Pt-Off(A,B+3,3
:Line(A-2,B-5,A,B-2,0
:Line(A,B-2,A+2,B-5,0</code></pre><p id="r-550499" data-claire-element-id="550499">À vos TI ! Vous n'avez plus besoin de moi pour un code comme ça maintenant !<br/> Bon, je mets quand même la correction mais c'est bien parce que c'est vous.</p><pre id="r-550500" data-claire-element-id="550500"><code data-claire-semantic="console">:ClrDraw
:47-&gt;A
:-31-&gt;B
:Repeat G=105
:For(C,-2,2
:Pt-On(A+C,B
:Pt-On(A,B+C
:End
:Pt-On(A,B+3,3
:Pt-Off(A,B+3
:Line(A-2,B-5,A,B-2
:Line(A,B-2,A+2,B-5
:Repeat G=105 or (G=24 and A&gt;3) or (G=25 and B&lt;-8) or (G=26 and A&lt;91) or (G=34 and B&gt;-54
:getKey-&gt;G
:End
:For(C,-2,2
:Pt-Off(A+C,B
:Pt-Off(A,B+C
:End
:Pt-Off(A,B+3,3
:Line(A-2,B-5,A,B-2,0
:Line(A,B-2,A+2,B-5,0
:A-5(G=24)+5(G=26
:B-5(G=25)+5(G=34
:End
:Disp</code></pre><p id="r-550501" data-claire-element-id="550501">Alors, c'était pas bien dur hein ? Si vous avez réussi le second menu, il n'y avait aucune raison pour que vous n'arriviez pas à coder ce programme.</p><p id="r-550502" data-claire-element-id="550502">Je ne pense pas avoir besoin de commenter ce code étant donné que 95% de celui-ci sont déjà expliqués dans la sous-partie du menu 2. Cependant, s'il y a une ligne à commenter, c'est celle-ci :</p><pre id="r-550503" data-claire-element-id="550503"><code data-claire-semantic="console">:Repeat G=105 or (G=24 and A&gt;3) or (G=25 and B&lt;-8) or (G=26 and A&lt;91) or (G=34 and B&gt;-54</code></pre><p id="r-550504" data-claire-element-id="550504">C'est une instruction très facile à comprendre : pour chaque flèche directionnelle, on vérifie que le personnage ne risque pas de sortir de l'écran. Par exemple pour <code>G=34</code> (flèche bas), on vérifie que l'ordonnée du personnage est supérieure à -54, car sinon il pourrait sortir de l'écran et ça ne fait pas très pro ^^ .</p><p id="r-550505" data-claire-element-id="550505">Ce chapitre était certainement le plus important du tuto : vous venez d'apprendre comment vous servir de l'écran graphique dans un jeu : avec le contenu de ce chapitre et ce que vous avez appris avant, vous êtes capables de coder <strong>absolument tout</strong> en TI-Basic : quand vous aurez un peu plus d'expérience, vous n'aurez plus que deux limites : la mémoire et la vitesse d'exécution.</p><p id="r-550506" data-claire-element-id="550506">Entraînez-vous à programmer des jeux ou des bouts de menus : codez l'affichage d'un inventaire, avec pourquoi pas des illustrations, ou encore un Snake... il suffit de réfléchir au moyen d'y arriver et de ne pas se lancer tête baissée sur sa TI ;) .</p><p id="r-550507" data-claire-element-id="550507">Vous pouvez même coder un RPG sans avoir touché à la 3e partie du tuto, ou programmer un morpion sans vous aider du prochain chapitre. En effet tous les chapitres suivants traitent de l'application concrète de la théorie que vous avez amassée jusqu'ici.</p><p id="r-550508" data-claire-element-id="550508">Je trouve que le morpion est un très bon exercice, car bien qu'il reste simple, on y utilise matrices, getKey, fonctions de dessin, système de sauvegarde/chargement, de scores, et plein d'autres bonnes choses.</p><p id="r-550509" data-claire-element-id="550509">Quant au RPG, c'est sans conteste le meilleur moyen de faire vos preuves en TI-Basic : absolument tous les aspects du langage y trouvent leur place et je trouve que c'est le type de jeu le mieux adapté à la TI, car les ralentissements n'y sont que minimes et très peu dérangeants. On élimine donc l'une des deux limites du TI-Basic ^^ .</p><h2 id="r-tp-programmation-d-un-morpion" data-claire-element-id="550538">TP : programmation d'un morpion</h2><p id="r-550511" data-claire-element-id="550511">Nous y voilà. ^^ <br/> Maintenant que vous connaissez quelques méthodes de programmation sur écran graphique, nous pouvons attaquer le TP morpion ! <br/><em>A priori</em>, vous savez déjà le faire mais on va étudier ça étape par étape. ;)</p><h3 id="r-ce-que-l-on-veut-faire" data-claire-element-id="550531">Ce que l'on veut faire</h3><p id="r-550512" data-claire-element-id="550512">Vous devriez le savoir : avant de commencer à programmer quoi que ce soit, il faut <strong>réfléchir à ce que l'on veut faire</strong>.</p><p id="r-550513" data-claire-element-id="550513">Je suppose que tout le monde sait jouer au morpion : les deux joueurs placent à tour de rôle un pion (en général, c'est une croix pour le premier joueur et un cercle pour le second) sur l'un des carreaux d'une grille de 3 cases sur 3. Le but du jeu est d'aligner 3 de ses pions avant que l'autre n'y parvienne.</p><p id="r-550514" data-claire-element-id="550514"><strong>Ce que l'on veut faire</strong>, c'est donc :</p><ul id="r-550525" data-claire-element-id="550525"><li id="r-550516" data-claire-element-id="550516"><p id="r-550515" data-claire-element-id="550515">afficher une grille de dimensions 3 x 3 ;</p></li><li id="r-550518" data-claire-element-id="550518"><p id="r-550517" data-claire-element-id="550517">faire jouer les utilisateurs à tour de rôle ;</p></li><li id="r-550520" data-claire-element-id="550520"><p id="r-550519" data-claire-element-id="550519">afficher les pions placés par les joueurs ;</p></li><li id="r-550522" data-claire-element-id="550522"><p id="r-550521" data-claire-element-id="550521">vérifier si l'un d'eux a gagné ;</p></li><li id="r-550524" data-claire-element-id="550524"><p id="r-550523" data-claire-element-id="550523">afficher le gagnant.</p></li></ul><p id="r-550526" data-claire-element-id="550526">Une fois que l'on aura fait cela, on ajoutera quelques fonctionnalités telles que la sauvegarde des scores pour chacun des joueurs, et pourquoi pas l'affichage d'un graphique pour vanter le meilleur d'entre eux ;) .</p><p id="r-550527" data-claire-element-id="550527">Les possibilités sont multiples ; nous essaierons d'en voir plusieurs différentes pour vérifier vos compétences en TI-Basic, et par la même occasion vous entraîner à utiliser l'écran graphique.</p><p id="r-550528" data-claire-element-id="550528">La programmation du morpion est assez simple si l'on prend le temps d'y réfléchir. Les prochaines sous-parties vous donneront conseils et indices pour parvenir à coder ce jeu. Nous étudierons ensuite la correction afin d'éclaircir les points qui vous auraient éventuellement échappé :) .</p><aside id="r-550530" data-claire-element-id="550530" data-claire-semantic="information"><p id="r-550529" data-claire-element-id="550529">NOTE : tant que le chapitre n'est pas entièrement écrit, nous n'allons pas suivre cet ordre : nous allons faire comme nous avons fait dans les chapitres précédents, c'est-à-dire bout de code + explication.<br/> Une fois terminé, je respecterai l'ordre de lecture de tout TP qui se respecte ;) .<br/> Si vous souhaitez suivre le TP sans voir la solution, eh bien lisez tout sauf le code (facilement repérable, il est sur fond noir :D ).</p></aside><h3 id="r-ecran-titre-et-initialisation-de-la-partie" data-claire-element-id="550537">Écran-titre et initialisation de la partie</h3><p id="r-550532" data-claire-element-id="550532">On commence par le plus simple. Lorsque l'utilisateur exécute le programme, il doit avoir devant ses yeux l'<strong>écran-titre</strong> du jeu.</p><p id="r-550533" data-claire-element-id="550533">Il faut savoir qu'afficher un écran-titre est assez handicapant : si votre programme est très gros, le fait d'utiliser de la mémoire (comptez 1 Ko) pour un menu illustré et, disons-le, inutile au niveau de l'engouement, est souvent un mauvais choix par rapport à la possibilité d'utiliser ce Ko pour améliorer votre programme en le rendant plus complet.</p><p id="r-550534" data-claire-element-id="550534">Cependant, notre morpion est loin d'utiliser toute la RAM de la calculatrice, et c'est un moyen de vérifier que vous avez bien suivi pendant cette seconde partie du tuto, alors ne nous en privons pas ^^ .</p><p id="r-550535" data-claire-element-id="550535">Vous devriez avoir déjà codé un écran-titre similaire dans le chapitre précédent. En fait, il vous suffit de modifier l'image qui est rappelée dans le programme pour adapter votre code à un autre jeu.</p><p id="r-550536" data-claire-element-id="550536">Comme c'était un exercice non corrigé, nous allons profiter de ce TP pour l'expliquer point par point.<br/> Je vous conseille de relire le chapitre précédent si vous ne savez pas comment coder un menu à curseur.</p><h2 id="r-l-ecran-titre" data-claire-element-id="550642">L'écran-titre</h2><h3 id="r-creation-d-une-image" data-claire-element-id="550548">Création d'une image</h3><p id="r-550539" data-claire-element-id="550539">La base de l'écran-titre, c'est l'<strong>image</strong> : elle permet d'avoir un rendu correct sans trop se donner de mal :p .</p><p id="r-550540" data-claire-element-id="550540">Vous savez ce qu'il vous reste à faire : effacez l'écran graphique et ouvrez le menu <code>DRAW</code>. Faites-moi une belle image pour donner envie au joueur.</p><p id="r-550541" data-claire-element-id="550541">Voici la mienne ; attention, je colle un zéro à celui qui se moque :</p><figure id="r-550543" data-claire-element-id="550544"><img id="r-550542" data-claire-element-id="550542" src="medias/uploads.siteduzero.com_files_112001_113000_112389.jpg" alt="Image utilisateur"/></figure><p id="r-550545" data-claire-element-id="550545">On aurait aussi pu faire une image à thème, en l'occurrence dessiner une grille en perspective, des pions...<br/> À vous de voir, personnellement je vais me contenter de celle-là.</p><p id="r-550546" data-claire-element-id="550546">Bien, maintenant que l'on a notre image, on l'<strong>enregistre</strong> : mettez-la dans l'emplacement de votre choix, écrivez par exemple <code>StorePic 1</code>. Je vous rappelle que la fonction <code>StorePic</code> se trouve dans <code>2ND:PRGM-STO</code>.</p><p id="r-550547" data-claire-element-id="550547">Vous vous rappelez de ce que l'on doit faire ensuite ? Il faut créer le <strong>curseur</strong> dans notre programme. On va en profiter pour le créer : faites un nouveau programme et donnez-lui un nom, pour moi ce sera MORPION. :D</p><h3 id="r-creation-d-un-curseur" data-claire-element-id="550561">Création d'un curseur</h3><p id="r-550549" data-claire-element-id="550549">J'espère que vous n'avez pas déjà oublié comment on crée un curseur : vous savez, la sous-partie sur les menus... non ? :euh:</p><p id="r-550550" data-claire-element-id="550550">Ah là là, il faut tout vous redire, hein ! Pour faire un curseur, on affiche quatre lignes autour de l'option sur laquelle on souhaite créer un focus. Résultat : l'option est <strong>encadrée</strong>. Lorsque l'utilisateur appuie sur les touches fléchées, le cadre est déplacé autour d'une autre option, ce qui lui permet de choisir celle qu'il souhaite. Je vois que ça commence à vous revenir.</p><p id="r-550551" data-claire-element-id="550551">Allez : au boulot, je veux que vous me transformiez l'image que l'on vient de dessiner en <strong>menu</strong> !</p><aside id="r-550553" data-claire-element-id="550553" data-claire-semantic="information"><p id="r-550552" data-claire-element-id="550552">Notre TP va être constitué de plusieurs sous-programmes. Afin que vous sachiez dans quel sous-programme on travaille, je vais noter au début de chaque code « <code>PROGRAM:X</code> », X étant le nom du sous-programme.</p></aside><p id="r-550554" data-claire-element-id="550554">Voici un exemple de ce que vous pouvez obtenir :</p><figure id="r-550556" data-claire-element-id="550557"><img id="r-550555" data-claire-element-id="550555" src="medias/uploads.siteduzero.com_files_112001_113000_112399.jpg" alt="Image utilisateur"/></figure><figure id="r-550559" data-claire-element-id="550560"><img id="r-550558" data-claire-element-id="550558" src="medias/uploads.siteduzero.com_files_112001_113000_112400.jpg" alt="Image utilisateur"/></figure><h3 id="r-actions-en-fonction-de-l-option-choisie" data-claire-element-id="550571">Actions en fonction de l'option choisie</h3><p id="r-550562" data-claire-element-id="550562">Faire un menu, c'est bien, mais si le fait d'appuyer sur <code>ENTER</code> ne produit rien, ça n'a pas d'intérêt.</p><p id="r-550563" data-claire-element-id="550563">On va donc, pour chaque valeur de D, écrire les actions à effectuer par le programme.</p><p id="r-550564" data-claire-element-id="550564">Comme d'habitude, on commence par la fin le plus simple : l'option « QUITTER », c'est-à-dire la <strong>seconde</strong> option (<code>D=2</code>).</p><p id="r-550565" data-claire-element-id="550565">On écrira donc à la suite de ce que l'on vient de faire : si <code>D=2</code> quand on a appuyé sur <code>ENTER</code>, alors on quitte le programme.</p><p id="r-550566" data-claire-element-id="550566">Pour quitter le jeu, on affiche l'écran-texte que l'on efface ; sinon, à la fin du programme, on aura toujours l'écran graphique affiché. Cela évite au joueur de devoir appuyer sur <code>CLEAR</code>.</p><p id="r-550567" data-claire-element-id="550567">Au point où on en est, l'affichage ne correspondra peut-être pas à votre attente. En effet, nous n'avons pas traité un problème majeur dans l'affichage de l'écran graphique.</p><p id="r-550568" data-claire-element-id="550568">Vous avez deviné ? Il faut le <strong>configurer</strong>. Vous ne croyez quand même pas que le joueur, qui ne veut que s'amuser, prendra le temps d'aller configurer sa fenêtre et ses fonctions ^^ .<br/> Si ça se trouve, il ne sait d'ailleurs pas comment le faire.</p><p id="r-550569" data-claire-element-id="550569">Je suppose que vous en avez un peu marre de devoir configurer votre écran à chaque fois que vous vous en servez dans un programme. Je suis du même avis que vous : c'est particulièrement ennuyeux.</p><p id="r-550570" data-claire-element-id="550570">C'est pourquoi nous allons revendiquer notre flemmardise en <strong>écrivant un programme de configuration d'écran</strong>.</p><h3 id="r-deux-nouveaux-sous-programmes-configuration-de-l-ecran" data-claire-element-id="550600">Deux nouveaux sous-programmes : configuration de l'écran</h3><p id="r-550572" data-claire-element-id="550572">Pourquoi deux, me direz-vous ?</p><p id="r-550573" data-claire-element-id="550573">Eh bien, c'est très simple : un pour notre jeu, et un autre pour la <strong>réinitialisation</strong> : notre joueur sera perdu s'il essaie d'afficher une courbe après avoir joué au morpion, il faut donc que notre programme remette l'écran graphique à sa configuration par défaut lorsque l'on a fini de jouer.</p><p id="r-550574" data-claire-element-id="550574">Nous allons d'abord nous occuper de la réinitialisation de l'écran graphique. Créez pour cela un nouveau programme : j'appellerai celui-ci <strong>RESETGRF</strong> pour « reset » (réinitialiser) et « graphe ».</p><p id="r-550575" data-claire-element-id="550575">Dans ce programme, nous allons mettre tous les paramètres par défaut de l'écran graphique : nous allons donc nous occuper de <code>WINDOW, FORMAT</code>, ainsi que l'affichage des fonctions et graphiques.</p><pre id="r-550576" data-claire-element-id="550576"><code data-claire-semantic="console">PROGRAM:RESETGRF
:PlotsOff
:FnOff
:ClrDraw
:ZStandard
:Disp
:CoordOn
:GridOff
:AxesOn
:LabelOff
:ExprOn
:FnOn</code></pre><p id="r-550577" data-claire-element-id="550577">Regardons ce programme de plus près.</p><p id="r-550578" data-claire-element-id="550578">Les deux premières lignes peuvent vous sembler bizarres, puisque l'on désactive les graphiques et les fonctions alors que le but est de les afficher.<br/> Oui, mais jetez un coup d'%u0153il à la dernière ligne, <code>:FnOn</code> ; on les désactive au début pour les activer à la fin.</p><p id="r-550579" data-claire-element-id="550579">À quoi ça sert ? Eh bien, tout simplement à configurer le graphique sans que le programme ne représente les fonctions : on perdrait du temps à voir s'afficher les courbes après avoir quitté le jeu.<br/> On n'active donc les courbes qu'à la fin, quand l'écran graphique n'est plus actif : les courbes ne sont pas dessinées.</p><p id="r-550580" data-claire-element-id="550580">Pour ce qui est des Plots, j'ai trouvé beaucoup plus pratique pour l'utilisateur de les désactiver automatiquement : cela permet d'éviter que l'écran ne soit trop surchargé. <br/> En effet, vous avez sûrement constaté que les Plots sont <strong>déjà définis</strong> par défaut : lorsque vous achetez votre calculatrice, votre <code>Plot1</code> par exemple est déjà réglé sur <code>L1</code> et <code>L2</code>.</p><p id="r-550581" data-claire-element-id="550581">Résultat : si l'on active les Plots, ils seront tous affichés sur l'écran graphique et ça peut vite devenir du grand n'importe quoi, c'est pourquoi je préfère laisser les Plots désactivés.</p><p id="r-550582" data-claire-element-id="550582">Et voici l'écran graphique que l'on obtient après exécution de <strong>RESETGRF</strong> :</p><figure id="r-550584" data-claire-element-id="550585"><img id="r-550583" data-claire-element-id="550583" src="medias/uploads.siteduzero.com_files_112001_113000_112409.jpg" alt="Image utilisateur"/></figure><p id="r-550586" data-claire-element-id="550586">Alors attention, pour avoir ça, il faut appuyer sur la touche <code>GRAPH</code>, l'exécution du programme ne provoque pas l'affichage de l'écran graphique (En fait il l'affiche, mais pendant une fraction de seconde ;) . Vous pourrez donc parfois apercevoir les axes gradués pendant l'exécution de <code>RESETGRF</code>.) !</p><p id="r-550587" data-claire-element-id="550587">Maintenant, nous allons passer au sous-programme de configuration, si vous êtes d'accord ^^ .<br/> Je vais appeler celui-ci <code>SETGRAPH</code>, toujours pour la même raison : « set » (fixer) et « graphe ».</p><p id="r-550588" data-claire-element-id="550588">Le but de ce programme, c'est de pouvoir utiliser l'écran graphique pour notre jeu sans rencontrer de problèmes d'affichage. Si vous prêtez attention au code, vous verrez que c'est en quelque sorte l'inverse de <code>RESETGRF</code>.</p><pre id="r-550589" data-claire-element-id="550589"><code data-claire-semantic="console">PROGRAM:SETGRAPH
:PlotsOff
:FnOff
:0-&gt;Xmin
:94-&gt;Xmax
:-62-&gt;Ymin
:0-&gt;Ymax
:CoordOff
:GridOff
:AxesOff
:LabelOff
:ExprOff
:ClrDraw</code></pre><p id="r-550590" data-claire-element-id="550590">Cette fois je ne vous fais pas de capture d'écran, car c'est tout simplement vide, et c'est exactement ce que l'on veut ! ;)</p><p id="r-550591" data-claire-element-id="550591">L'énorme avantage de ces deux programmes, c'est que vous pouvez les utiliser dans <strong>tous</strong> vos jeux !</p><p id="r-550592" data-claire-element-id="550592">Par contre, cela implique une condition : vous devrez toujours utiliser les mêmes paramètres fenêtres (<code>Xmin, Xmax</code>, etc.), c'est pourquoi j'utilise toujours des Y négatifs, même quand je n'en ai <em>a priori</em> pas besoin.</p><p id="r-550593" data-claire-element-id="550593">Si vous préférez une autre configuration de fenêtre que la mienne, prenez l'habitude de garder toujours la même, sinon vous allez vous perdre, car vous confondrez les configurations de plusieurs programmes. Ce serait à mon avis la source de beaucoup d'erreurs au bout d'un certain moment ^^ .</p><p id="r-550594" data-claire-element-id="550594">Bon : nous avons nos deux sous-programmes, alors utilisons-les ! Vous savez comment faire j'espère :D .<br/> Allez tout au début de <code>MORPION</code> et ajoutez la ligne suivante :</p><p id="r-550595" data-claire-element-id="550595"><code>:prgmSETGRAPH</code></p><p id="r-550596" data-claire-element-id="550596">La fonction <code>prgm</code> se trouve dans le menu du même nom. Il y a plusieurs façons d'exécuter un sous-programme : la première est d'utiliser la fonction <code>prgm</code> suivie du nom de votre programme écrit en toutes lettres (vous écrivez vous-même le nom à grands coups d'Alpha).</p><p id="r-550597" data-claire-element-id="550597">L'autre méthode est de choisir votre programme dans la liste (<code>PRGM-EXEC</code>) et d'appuyer sur la touche <code>ENTER</code>. Cela affichera automatiquement la fonction <strong>prgm</strong> suivie du nom de votre programme.</p><p id="r-550598" data-claire-element-id="550598">Vous allez faire la même chose avec <code>RESETGRF</code> dans la boucle de l'option « QUITTER ».</p><p id="r-550599" data-claire-element-id="550599">Et voilà ! Vous l'avez sûrement compris, pour ce TP cela serait revenu au même d'écrire directement le contenu de <code>RESETGRF</code> et <code>SETGRAPH</code> dans notre programme principal (<code>MORPION</code>). L'intérêt est évidemment de ne <strong>pas avoir à réécrire ces programmes</strong> : dans nos futurs jeux, nous écrirons « <code>prgmSETGRAPH</code> » et voilà, le graphique sera prêt à être utilisé ! Génial, non ? :p</p><h3 id="r-affichage-de-la-grille" data-claire-element-id="550619">Affichage de la grille</h3><p id="r-550601" data-claire-element-id="550601">Vous vous souvenez de ce que l'on a dit au début du chapitre ? On va devoir <strong>afficher une grille de dimensions 3 x 3</strong>. C'est ce que l'on va faire maintenant, et on va en profiter pour initialiser les variables que l'on va utiliser dans le jeu ;) .</p><p id="r-550602" data-claire-element-id="550602">Pour afficher la grille, on ne va pas trop se fouler, on va dessiner <strong>quatre lignes</strong> et ce sera bon.</p><p id="r-550603" data-claire-element-id="550603">Nous allons aussi dessiner une ligne pour séparer le plateau de jeu (la grille) des données (score actuel, à qui le tour, etc.).</p><p id="r-550604" data-claire-element-id="550604">On pourrait aussi dessiner la grille dans une image et la rappeler dans le programme, mais ça prendrait <strong>beaucoup</strong> plus de place ! Vous vous rappelez qu'une image prend 767 octets ? En traçant des lignes, on va faire ça en en utilisant 64. Alors d'accord, le morpion ne prendra pas toute la RAM, mais la perte de mémoire est beaucoup trop grande pour être ignorée.</p><p id="r-550605" data-claire-element-id="550605">D'ailleurs, pensez aux utilisateurs de TI-82stats qui n'ont pas de mémoire ARC (c'est peut-être même votre cas).</p><p id="r-550606" data-claire-element-id="550606">Dessinons nos lignes !</p><pre id="r-550607" data-claire-element-id="550607"><code data-claire-semantic="console">PROGRAM:MORPION
:If D=1
:Then
:Line(51,0,51,-61
:Line(73,0,73,-61
:Line(31,-20,93,-20
:Line(31,-41,93,-41
:Line(28,0,28,-62</code></pre><p id="r-550608" data-claire-element-id="550608">Les quatre premières lignes permettent de représenter la grille, et on en affiche une cinquième pour délimiter l'espace du plateau de jeu.</p><p id="r-550609" data-claire-element-id="550609">Notez que l'on ne ferme pas le <code>If D=1</code> : cette condition va contenir quasiment la totalité du reste de notre programme, je vous préviendrai en temps voulu quand nous aurons besoin de fermer ce <code>If</code>.</p><div id="r-550611" data-claire-element-id="550611" data-claire-semantic="question"><p id="r-550610" data-claire-element-id="550610">Bon, c'est bien beau ton code, mais on peut voir le résultat ?</p></div><p id="r-550612" data-claire-element-id="550612">J'allais justement vous le proposer :) .</p><p id="r-550613" data-claire-element-id="550613">(Au fait, si vous voulez tester le morpion à la fin de ce chapitre, je vous conseille d'écrire le code en même temps que moi, parce que si vous essayez de recopier le code entier à la fin, vous avez de grandes chances d'attraper le genre de migraine qui peut priver notre nation entière de sa Sécurité Sociale.)</p><figure id="r-550615" data-claire-element-id="550616"><img id="r-550614" data-claire-element-id="550614" src="medias/uploads.siteduzero.com_files_112001_113000_112424.jpg" alt="Image utilisateur"/></figure><p id="r-550617" data-claire-element-id="550617">C'est sobre, on est d'accord, mais c'est quand même zoli, non ?</p><p id="r-550618" data-claire-element-id="550618">N'oubliez pas que la partie gauche contiendra les informations relatives à la partie, et la grille de droite représente le plateau de jeu : c'est ici que l'on verra les pions s'afficher.</p><h3 id="r-initialisation-des-variables" data-claire-element-id="550639">Initialisation des variables</h3><p id="r-550620" data-claire-element-id="550620">La grande question quand on arrive à ce genre de partie du code, c'est : « De quelles variables va-t-on avoir besoin ? ».</p><p id="r-550621" data-claire-element-id="550621">Eh bien, comme vous pouvez vous en douter, il nous faut en particulier une <strong>matrice de dimensions 3 x 3</strong>. Celle-ci va bien sûr représenter notre grille : à chaque case de la grille correspond une certaine valeur, c'est-à-dire un certain pion. Voici les valeurs de la matrice que je vous propose :</p><ul id="r-550628" data-claire-element-id="550628"><li id="r-550623" data-claire-element-id="550623"><p id="r-550622" data-claire-element-id="550622">0 pour une case vide ;</p></li><li id="r-550625" data-claire-element-id="550625"><p id="r-550624" data-claire-element-id="550624">1 pour une case contenant l'un des pions du joueur 1 ;</p></li><li id="r-550627" data-claire-element-id="550627"><p id="r-550626" data-claire-element-id="550626">2 pour les pions du joueur 2.</p></li></ul><p id="r-550629" data-claire-element-id="550629">Ensuite, nous avons besoin d'une variable contenant <strong>le tour du joueur</strong> : elle permettra de déterminer quel joueur doit poser un pion. J'appellerai cette variable T : elle pourra contenir 1 pour le joueur 1, et 0 pour le joueur 2.</p><aside id="r-550631" data-claire-element-id="550631" data-claire-semantic="information"><p id="r-550630" data-claire-element-id="550630">On met 0 pour le joueur 2 car cela permet d'utiliser cette variable comme on utiliserait un booléen. Si vous voulez, on peut traduire <code>If(T)</code> par : « est-ce le tour du joueur 1 ? ». Si T vaut 1 c'est que c'est vrai, donc c'est bien le tour du joueur 1. Si T vaut 0, c'est que c'est faux : ce n'est pas le tour du joueur 1. C'est donc celui du joueur 2, puisqu'il n'y a que deux joueurs.</p></aside><p id="r-550632" data-claire-element-id="550632">Il nous faudra aussi une variable N, qui contiendra le nombre total de pions posés sur le plateau de jeu.<br/> Cette variable nous permettra de clôturer le jeu sur un match nul si la grille est complète (<code>N=9</code>) et que personne n'a aligné trois de ses pions.</p><p id="r-550633" data-claire-element-id="550633">En plus, histoire d'accélérer l'exécution du jeu, si l'on n'a pas posé au moins cinq pions (trois pour le joueur qui commence et deux pour celui qui joue en second), il est <strong>impossible</strong> que l'on ait un gagnant.<br/> Ainsi, on ne vérifiera si quelqu'un a gagné que si le nombre de pions posés sur le plateau est <strong>supérieur ou égal</strong> à 5.</p><p id="r-550634" data-claire-element-id="550634">Cela permettra d'<strong>accélérer</strong> le début de la partie, en rajoutant <strong>une</strong> condition supplémentaire qui ralentira <strong>très</strong> légèrement la fin de la partie et qui ne prendra que 6 octets de plus.</p><p id="r-550635" data-claire-element-id="550635">Nous avons donc besoin d'une matrice (on utilisera <code>[A]</code>) et de deux variables (T et N).</p><p id="r-550636" data-claire-element-id="550636">Vous vous souvenez de la méthode pour initialiser une matrice ?<br/> On stocke une liste de deux nombres dans la dimension de la matrice. Ces deux nombres représentent la taille de la matrice en longueur et en largeur.</p><p id="r-550637" data-claire-element-id="550637">Ensuite, il faut <strong>initialiser</strong> chacune des valeurs contenues dans la matrice grâce à la fonction <code>Fill(nombre, matrice)</code>.</p><p id="r-550638" data-claire-element-id="550638">Parfait : maintenant que nous savons comment initialiser l'écran graphique et les variables pour notre jeu, nous allons passer à la suite ;) .</p><h3 id="r-le-jeu-en-lui-meme" data-claire-element-id="550641">Le jeu en lui-même</h3><p id="r-550640" data-claire-element-id="550640">Dans cette partie du code, nous allons nous occuper de la partie jouable du programme : c'est là que l'utilisateur va jouer au morpion avec l'un de ses confrères.</p><h2 id="r-choix-d-une-case" data-claire-element-id="550682">Choix d'une case</h2><p id="r-550643" data-claire-element-id="550643">Nous allons donc lui demander de <strong>choisir la case</strong> où il veut placer son pion. Pendant ce temps, le second utilisateur patiente en réfléchissant à sa stratégie ;) .</p><p id="r-550644" data-claire-element-id="550644">Lorsqu'il aura joué, on affichera son pion dans la case qu'il a demandée. On vérifiera ensuite s'il a gagné ou s'il y a match nul et, le cas échéant, on donnera le tour au second joueur.</p><p id="r-550645" data-claire-element-id="550645">Au début de la partie, la grille est vide et c'est au joueur 1 de placer son pion (<code>T=0</code>).</p><p id="r-550646" data-claire-element-id="550646">Pour choisir un emplacement, je vois principalement trois possibilités.</p><ul id="r-550653" data-claire-element-id="550653"><li id="r-550648" data-claire-element-id="550648"><p id="r-550647" data-claire-element-id="550647">On utilise un <code>Input</code> pour rentrer le nombre associé à la case voulue.</p></li><li id="r-550650" data-claire-element-id="550650"><p id="r-550649" data-claire-element-id="550649">On utilise un <code>getKey</code> en associant une touche à une case.</p></li><li id="r-550652" data-claire-element-id="550652"><p id="r-550651" data-claire-element-id="550651">On crée un curseur pour pouvoir sélectionner la case choisie.</p></li></ul><h3 id="r-a-l-ancienne-1" data-claire-element-id="550658">À l'ancienne</h3><p id="r-550654" data-claire-element-id="550654">Dans le premier cas, on entrera par exemple le chiffre « 3 » pour placer son pion dans la troisième case (on aura préalablement indiqué à l'utilisateur les numéros des cases).</p><p id="r-550655" data-claire-element-id="550655">C'est le procédé le plus simple. Cependant, il comporte deux problèmes majeurs : l'utilisateur peut rentrer n'importe quoi, et surtout c'est extrêmement laid :p .</p><p id="r-550656" data-claire-element-id="550656">Attendez, on est en écran graphique là, on ne va quand même pas utiliser un vieux <code>Input</code> qui empêcherait l'utilisateur de voir la grille de jeu !</p><p id="r-550657" data-claire-element-id="550657">On raye donc cette possibilité. La seconde, qui est cette fois utilisable sur l'écran graphique, consiste à appuyer sur une touche pour placer son pion.</p><h3 id="r-un-peu-plus-pousse" data-claire-element-id="550662">Un peu plus poussé</h3><p id="r-550659" data-claire-element-id="550659">Observez la position des touches sur votre TI. Les chiffres de 1 à 9 sont disposés sur 3 lignes de 3 touches ; rien de plus intuitif pour l'utilisateur que d'appuyer sur « 5 » pour choisir la case centrale ;) .</p><p id="r-550660" data-claire-element-id="550660">Cette possibilité est donc tout à fait acceptable. C'est simple, rapide, intuitif.</p><p id="r-550661" data-claire-element-id="550661">Et pourtant, comme vous êtes à présent surentraînés, on ne va pas choisir cette méthode (beaucoup trop simple pour vous ^^ ). On va utiliser la troisième.</p><h3 id="r-la-methode-new-gen" data-claire-element-id="550681">La méthode new-gen</h3><p id="r-550663" data-claire-element-id="550663">D'accord, vous en avez peut-être assez des menus à curseur, mais c'est en vous entraînant que ça rentrera et que vous saurez le faire instinctivement.</p><p id="r-550664" data-claire-element-id="550664">En plus, là, on a un menu à 2 dimensions : on aura les quatre flèches à gérer au lieu de deux, et les variables seront donc présentes dans chacun des paramètres de nos fonctions <code>Line</code> ! C'est comme si l'on déplaçait un personnage ;) .</p><p id="r-550665" data-claire-element-id="550665">Voici ce que je veux :</p><figure id="r-550667" data-claire-element-id="550668"><img id="r-550666" data-claire-element-id="550666" src="medias/uploads.siteduzero.com_files_114001_115000_114296.jpg" alt="Image utilisateur"/></figure><figure id="r-550670" data-claire-element-id="550671"><img id="r-550669" data-claire-element-id="550669" src="medias/uploads.siteduzero.com_files_114001_115000_114298.jpg" alt="Image utilisateur"/></figure><p id="r-550672" data-claire-element-id="550672">On a donc un <code>getKey</code> dont les touches actives sont les quatre flèches et la touche ENTER. Il est suivi de plusieurs conditions pour modifier les <strong>coordonnées A et B</strong> du curseur.</p><p id="r-550673" data-claire-element-id="550673">Pour programmer ce curseur, nous allons voir en détail comment calculer les paramètres des fonctions <code>Line</code>.</p><p id="r-550674" data-claire-element-id="550674">Exécutez le programme MORPION afin d'afficher la grille, puis quittez le programme pour que celle-ci reste en mémoire sur l'écran graphique. Ouvrez ensuite le menu <code>FORMAT</code> (<code>2ND:ZOOM</code>) pour activer l'option <code>CoordOn</code>.</p><p id="r-550675" data-claire-element-id="550675">Utilisez la fonction <code>Pen</code> du menu <code>DRAW</code> (<code>2ND:PRGM</code>) et pointez sur le pixel correspondant au coin haut droit du rectangle que vous souhaitez afficher. Notez ses coordonnées ; pour moi, c'est <code>X=49</code> et <code>Y=-22</code>.</p><p id="r-550676" data-claire-element-id="550676">Imaginez le rectangle représentant votre curseur, puis pointez sur le coin haut droit, mais cette fois lorsque votre curseur est une case plus à droite, comme sur cette image :</p><figure id="r-550678" data-claire-element-id="550679"><img id="r-550677" data-claire-element-id="550677" src="medias/uploads.siteduzero.com_files_117001_118000_117937.jpg" alt="Image utilisateur"/></figure><p id="r-550680" data-claire-element-id="550680">Notez ses coordonnées, j'ai <code>(71;-22)</code>. Logiquement, vous devriez avoir la même valeur de Y pour les deux points.</p><h2 id="r-un-peu-de-maths-1" data-claire-element-id="550690">Un peu de maths</h2><p id="r-550683" data-claire-element-id="550683">Effectuez une soustraction pour connaître le nombre de pixels séparant vos deux points. J'ai <code>71-49</code>, c'est-à-dire 22 pixels de différence pour un déplacement horizontal.</p><p id="r-550684" data-claire-element-id="550684">Suivez la même méthode pour trouver le nombre de pixels de différence sur l'axe vertical. Si vous avez dessiné un curseur carré, vous devriez trouver le même nombre que précédemment. Le mien est <strong>rectangulaire</strong>, j'ai 21 pixels de différence lors d'un déplacement vertical.</p><p id="r-550685" data-claire-element-id="550685">Les nombres que l'on vient de trouver sont les <strong>coefficients</strong> qui vont nous permettre d'établir une <strong>équation</strong> entre la position du curseur et les coordonnées de chacun de ses points.</p><p id="r-550686" data-claire-element-id="550686">Pour le coin haut droit, on a donc : <code>x2 = x1 + 22</code>. Cela signifie que lorsque la position A du curseur change, on ajoute ou soustrait 22 ;) .</p><p id="r-550687" data-claire-element-id="550687">On cherche une instruction du type <code>x = Xmin + A * 22</code>, où <code>Xmin</code> est la valeur des <strong>abscisses</strong> pour le point 1, le plus à gauche. C'est simple : cette variable correspond à x1, qui vaut 49. On lui retranche 22 car cette valeur est déjà présente dans <code>A * 22</code> (A vaut 1 si le curseur est complètement à gauche) : on a donc <code>x = 27 + 22A</code>.</p><p id="r-550688" data-claire-element-id="550688">Vous pouvez vérifier : si A vaut 3, c'est-à-dire si le curseur est complètement à <strong>droite</strong> de la grille, on a <code>x = 27 + 22*3</code>, ce qui équivaut à <code>x = 93</code>. Regardez sur votre écran graphique, c'est bien la valeur que l'on veut lorsque le curseur est à droite.</p><p id="r-550689" data-claire-element-id="550689">Répétez ces opérations sept fois (pour trouver les valeurs X et Y de chacun des coins du curseur) en prenant soin de noter les coordonnées de chacun des points. C'est long, mais il est indispensable que vous compreniez comment ça marche ^^ . Notez qu'il y a tout de même plus rapide...</p><h2 id="r-le-retour-de-linreg" data-claire-element-id="550702">Le retour de LinReg</h2><p id="r-550691" data-claire-element-id="550691">La fonction <code>LinReg(ax+b)</code> est beaucoup plus simple à utiliser, comme vous pouvez le voir sur les captures d'écran suivantes :</p><figure id="r-550693" data-claire-element-id="550694"><img id="r-550692" data-claire-element-id="550692" src="medias/uploads.siteduzero.com_files_117001_118000_117944.jpg" alt="Image utilisateur"/></figure><figure id="r-550696" data-claire-element-id="550697"><img id="r-550695" data-claire-element-id="550695" src="medias/uploads.siteduzero.com_files_117001_118000_117945.jpg" alt="Image utilisateur"/></figure><p id="r-550698" data-claire-element-id="550698">On retrouve bien <code>27 + 22A</code>. Cette méthode est beaucoup moins ennuyeuse puisqu'il suffit de relever les coordonnées des deux points, et les calculs sont effectués par la machine :p .</p><p id="r-550699" data-claire-element-id="550699">Bon, évidemment, ça reste tout de même répétitif pour trouver chacune des équations. Je compte sur vous, ce serait bête d'abandonner maintenant ^^ .</p><p id="r-550700" data-claire-element-id="550700">Servez-vous des équations que vous venez de résoudre pour coder les quatre fonctions <code>Line</code> qui composent le dessin de notre curseur. N'oubliez pas la méthode que l'on utilise pour les menus : on <strong>affiche le curseur</strong>, puis on l'<strong>efface</strong> pour l'<strong>afficher ailleurs</strong> si l'utilisateur l'a déplacé.</p><p id="r-550701" data-claire-element-id="550701">Attention, on ne peut placer de pion (comprenez « appuyer sur <code>ENTER</code> ») que si la case pointée n'en contient pas déjà un.</p><h2 id="r-dessinons-nos-pions" data-claire-element-id="550707">Dessinons nos pions</h2><p id="r-550703" data-claire-element-id="550703">L'utilisateur vient de choisir la case où il souhaite placer son pion. Il ne reste plus qu'à <strong>enregistrer</strong> son choix dans la matrice <code>[A]</code> et à dessiner un cercle ou une croix.</p><p id="r-550704" data-claire-element-id="550704">Nous allons utiliser un <code>If</code> pour cette partie du code : <strong>si</strong> c'est le joueur 1 qui vient de jouer, on dessine une croix, <strong>sinon</strong> un cercle.</p><p id="r-550705" data-claire-element-id="550705">On n'oubliera pas non plus d'ajouter 1 à <code>N</code>, puisqu'il y a un pion de plus sur le plateau.</p><p id="r-550706" data-claire-element-id="550706">Comme d'habitude, on utilise <code>A</code> et <code>B</code> dans les arguments ; le pion est dessiné sur la case pointée par le curseur.</p><h2 id="r-verification-du-plateau-de-jeu" data-claire-element-id="550725">Vérification du plateau de jeu</h2><p id="r-550708" data-claire-element-id="550708">Si vous avez commencé à coder le programme dès maintenant en suivant mes conseils, vous pouvez obtenir un écran semblable à celui-ci :</p><figure id="r-550710" data-claire-element-id="550711"><img id="r-550709" data-claire-element-id="550709" src="medias/uploads.siteduzero.com_files_119001_120000_119148.jpg" alt="Image utilisateur"/></figure><p id="r-550712" data-claire-element-id="550712">Je vous rappelle le but du jeu : aligner ses trois pions avant que l'adversaire n'y parvienne.</p><p id="r-550713" data-claire-element-id="550713">Ici, on voit clairement deux lignes de pions : le jeu aurait dû s'arrêter bien avant. Nous devons donc demander à la calculatrice de <strong>stopper le match</strong> lorsque quelqu'un a gagné ou que le plateau a été rempli.</p><p id="r-550714" data-claire-element-id="550714">Bon, je vais vous aider un peu dans vos réflexions ^^ . On peut aligner ses pions de trois façons différentes : verticalement, horizontalement ou en diagonale. Vous pouvez voir sur l'image ci-dessous les huit possibilités d'alignement des pions.</p><figure id="r-550716" data-claire-element-id="550717"><img id="r-550715" data-claire-element-id="550715" src="medias/uploads.siteduzero.com_files_119001_120000_119158.jpg" alt="Image utilisateur"/></figure><p id="r-550718" data-claire-element-id="550718">Étant donné qu'il y a deux diagonales, on va faire deux tests pour celles-ci. Par contre, pour les autres alignements, il faudrait faire six tests : la grille est composée de trois colonnes et trois lignes. Il serait trop répétitif de faire ces six instructions, c'est pourquoi nous allons utiliser des boucles <code>For</code>.</p><p id="r-550719" data-claire-element-id="550719">Il ne faut pas oublier non plus de vérifier le nombre de pions placés. Si <code>N=9</code>, le plateau est rempli, on doit donc annoncer la fin de la partie.</p><p id="r-550720" data-claire-element-id="550720">Lors de cette vérification du plateau, la valeur de la variable <code>W</code> va être <strong>modifiée</strong>. À chaque fois que l'on trouve une raison d'arrêter le jeu (pions alignés ou plateau rempli), on <strong>incrémente cette variable</strong>. Cela signifie que si <code>W</code> a une valeur supérieure à 0, on <strong>stoppe la partie</strong>.</p><p id="r-550721" data-claire-element-id="550721">Bien sûr, cette condition n'est testée que si <code>W&gt;0</code>, puisque si ce test est faux, il n'y a pas de raison de terminer la partie ;) . De plus, rappelez-vous ce que l'on a décidé au début : pour accélérer l'exécution du code en début de partie, nous ne ferons ces tests que si le nombre de pions placés le permet (<code>N&gt;4</code>).</p><p id="r-550722" data-claire-element-id="550722">Je vous laisse réfléchir sur ce bout de code, il ne devrait pas dépasser la quinzaine de lignes.</p><p id="r-550723" data-claire-element-id="550723">Maintenant, imaginez que l'on ait placé neuf pions sur le plateau. Si personne n'a gagné, la valeur de <code>W</code> aura été incrémentée une seule fois. Par contre, si quelqu'un a aligné trois pions, <code>W</code> vaudra 2, puisque <strong>deux tests sont positifs</strong> (plateau rempli et trois pions alignés).</p><p id="r-550724" data-claire-element-id="550724">Donc, <strong>si</strong> le plateau est rempli mais que <code>W</code> ne vaut que 1, cela signifie que personne n'a gagné. <strong>Sinon</strong>, il y a deux possibilités : soit <code>N&lt;9</code> (le plateau n'est pas rempli), soit <code>W&gt;1</code> (quelqu'un a aligné ses pions). On peut donc réunir ces deux possibilités dans un seul <strong>Else</strong>, qui contiendra le code à exécuter en fin de partie.</p><h2 id="r-fin-de-la-partie-1" data-claire-element-id="550732">Fin de la partie</h2><p id="r-550726" data-claire-element-id="550726">Pour terminer la partie, il suffira de rajouter quelques <code>End</code> (autant qu'il y a de boucles ou de conditions ouvertes). Ainsi, le programme se terminera lorsqu'il y aura un gagnant ou en cas de match nul.</p><p id="r-550727" data-claire-element-id="550727">À ce stade du code, votre morpion devient <strong>jouable</strong>, bien qu'il reste pas mal de choses à améliorer ;) .</p><h3 id="r-correction-193" data-claire-element-id="550731">Correction !</h3><p id="r-550728" data-claire-element-id="550728">J'espère que vous avez réussi à faire un morpion potable, sinon je vous conseille fortement de réessayer : si vous lisez la correction, vous penserez avoir compris (l'éternel « Ah ouiii ! » :D ) alors que ce ne sera pas le cas. Vous aurez tout oublié le lendemain.</p><p id="r-550729" data-claire-element-id="550729">La seule façon d'y arriver, c'est de le faire par vous-même, sans que l'on vous donne la solution.<br/> Si vous séchez réellement sur un certain point, vous pouvez évidemment tricher un peu en regardant la partie du code qui vous intéresse :-° .</p><p id="r-550730" data-claire-element-id="550730">Enfin bref, c'est parti pour la correction !</p><h2 id="r-etape-par-etape-2" data-claire-element-id="550767">Étape par étape</h2><h3 id="r-l-ecran-titre-1" data-claire-element-id="550737">L'écran-titre</h3><p id="r-550733" data-claire-element-id="550733">Pour cet écran-titre vous deviez, comme nous l'avons fait plusieurs fois à présent, partir d'une image et la transformer en menu à curseur.</p><pre id="r-550734" data-claire-element-id="550734"><code data-claire-semantic="console">PROGRAM:MORPION
:ClrDraw
:RecallPic 1
:1-&gt;D
:Repeat G=105
:Line(30,-25-10D,30,-33-10D
:Line(30,-33-10D,64,-33-10D
:Line(64,-33-10D,64,-25-10D
:Line(64,-25-10D,30,-25-10D
:Repeat G=105 or (G=25 and D&gt;1) or (G=34 and D&lt;2
:getKey-&gt;G
:End
:Line(30,-25-10D,30,-33-10D,0
:Line(30,-33-10D,64,-33-10D,0
:Line(64,-33-10D,64,-25-10D,0
:Line(64,-25-10D,30,-25-10D,0
:If G=25
:D-1-&gt;D
:If G=34
:D+1-&gt;D
:End
:ClrDraw</code></pre><p id="r-550735" data-claire-element-id="550735">Alors évidemment, cette partie du code dépend beaucoup de votre image, les paramètres des fonctions <code>Line</code> changeront assurément, mais si ça marche chez vous, c'est forcément bon ^^ .</p><p id="r-550736" data-claire-element-id="550736">Notez qu'à la place de <code>D&gt;1</code> et <code>D&lt;2</code>, on aurait pu écrire respectivement <code>D=2</code> et <code>D=1</code>. Cependant, cette écriture a l'avantage de permettre une modification ultérieure du code : si on voulait rajouter une option plus tard, il n'y aurait plus qu'à remplacer <code>D&lt;2</code> par <code>D&lt;3</code>. Et ce serait absolument la seule chose qui changerait dans le bout de code que l'on vient d'écrire.</p><h3 id="r-structure-de-base-du-programme-actions-en-fonction-de-l-option-choisie" data-claire-element-id="550741">Structure de base du programme - actions en fonction de l'option choisie</h3><p id="r-550738" data-claire-element-id="550738">Cette fois, nous allons voir la structure du programme en fonction de la variable D, que nous avons définie ci-dessus.</p><pre id="r-550739" data-claire-element-id="550739"><code data-claire-semantic="console">PROGRAM:MORPION
:If D=2
:Then
:Disp
:ClrHome
:Output(1,1,&quot;
:Return
:End</code></pre><p id="r-550740" data-claire-element-id="550740">Un code tout ce qu'il y a de plus banal.</p><h3 id="r-initialisation-des-variables-1" data-claire-element-id="550744">Initialisation des variables</h3><pre id="r-550742" data-claire-element-id="550742"><code data-claire-semantic="console">PROGRAM:MORPION
:{3,3}-&gt;dim([A]
:Fill(0,[A]
:1-&gt;T
:0-&gt;N</code></pre><p id="r-550743" data-claire-element-id="550743">Je ne pense pas qu'il y ait grand-chose à dire sur ce bout de code, on y voit simplement la déclaration de la matrice <code>[A]</code>.</p><h3 id="r-placement-des-pions" data-claire-element-id="550752">Placement des pions</h3><p id="r-550745" data-claire-element-id="550745">Là encore, nous allons faire un menu à curseur, en 2D cette fois.<br/> Observez le code :</p><pre id="r-550746" data-claire-element-id="550746"><code data-claire-semantic="console">PROGRAM:MORPION
:Repeat G=105 and [A](A,B)=0
:Repeat (G=105 and [A](A,B)=0) or (G=24 and A&gt;1) or (G=25 and B&gt;1) or (G=26 and A&lt;3) or (G=34 and B&lt;3)
:Line(27+22A,20-21B,27+22A,3-21B
:Line(27+22A,3-21B,9+22A,3-21B
:Line(9+22A,20-21B,9+22A,3-21B
:Line(9+22A,20-21B,27+22A,20-21B
:getKey-&gt;G
:End
:Line(27+22A,20-21B,27+22A,3-21B,0
:Line(27+22A,3-21B,9+22A,3-21B,0
:Line(9+22A,20-21B,9+22A,3-21B,0
:Line(9+22A,20-21B,27+22A,20-21B,0
:A-(G=24)+(G=26)-&gt;A
:B-(G=25)+(G=34)-&gt;B
:End</code></pre><p id="r-550747" data-claire-element-id="550747">Bon eh bien rien de nouveau, à part que c'est la première fois que l'on utilise une matrice dans ce tuto. Souvenez-vous de la syntaxe : <code>[matrice](ligne,colonne)</code>.</p><aside id="r-550749" data-claire-element-id="550749" data-claire-semantic="warning"><p id="r-550748" data-claire-element-id="550748">Les crochets « [] » et la lettre de la matrice « A » ne sont pas écrits à la main : ils sont ajoutés automatiquement lorsque vous sélectionnez votre matrice dans le menu <code>MATRX</code> (2ND:x-1). Ainsi, vous obtiendrez directement « [A] ».</p></aside><p id="r-550750" data-claire-element-id="550750">On utilise deux <code>Repeat</code> différents : le premier pour déplacer le curseur, le second pour sélectionner la case pointée par l'utilisateur.</p><p id="r-550751" data-claire-element-id="550751">Pour le reste, c'est du vu et revu, je ne m'y attarde pas plus longtemps.</p><h3 id="r-dessin-et-affichage-des-pions" data-claire-element-id="550756">Dessin et affichage des pions</h3><p id="r-550753" data-claire-element-id="550753">Le joueur a choisi sa case, maintenant il faut la remplir :) .</p><pre id="r-550754" data-claire-element-id="550754"><code data-claire-semantic="console">PROGRAM:MORPION
:T+1-&gt;[A](A,B)
:If T=0
:Then
:Line(27+22A,20-21B,9+22A,3-21B
:Line(27+22A,3-21B,9+22A,20-21B
:Else
:Circle(18+22A,11-21B,7
:End
:N+1-&gt;N</code></pre><p id="r-550755" data-claire-element-id="550755">Notez que l'on stocke <code>T+1</code> dans la matrice, et non <code>T</code>. On était obligé de le faire, puisque la valeur 0 correspond à une case vide. Pour une fois, les valeurs correspondent donc aux numéros des joueurs (2 pour le joueur n°2 par exemple).</p><h3 id="r-verification-du-plateau" data-claire-element-id="550762">Vérification du plateau</h3><p id="r-550757" data-claire-element-id="550757">Ah, là ça devient intéressant :) .<br/> C'est le genre de code qui peut être écrit d'une multitude de façons différentes. Certaines sont meilleures, d'autres moins bonnes, les critères de sélection étant la taille du code et sa vitesse d'exécution.</p><p id="r-550758" data-claire-element-id="550758">Je vous propose ce code, ce n'est pas le meilleur mais il fonctionne et son exécution ne fait pas ralentir tout le programme, donc bon ^^ .</p><pre id="r-550759" data-claire-element-id="550759"><code data-claire-semantic="console">PROGRAM:MORPION
:If N&gt;4
:Then
:N=9-&gt;W
:For(Z,1,2)
:For(M,1,3)
:W+([A](M,1)=Z and [A](M,2)=Z and [A](M,3)=Z)-&gt;W
:W+([A](1,M)=Z and [A](2,M)=Z and [A](3,M)=Z)-&gt;W
:End
:W+([A](1,1)=Z and [A](2,2)=Z and [A](3,3)=Z)-&gt;W
:W+([A](3,1)=Z and [A](2,2)=Z and [A](1,3)=Z)-&gt;W
:End
:End</code></pre><p id="r-550760" data-claire-element-id="550760">Pour commencer, les tests ne sont effectués que si <code>N&gt;4</code>. Ceux-ci comprennent l'affectation de <code>(N=9)</code> à la variable W. W vaut toujours 0 avant la lecture de cette ligne, c'est donc une façon plus courte d'écrire <code>W+(N=9)-&gt;W</code>. Je vous rappelle que <code>N=9</code> est « remplacé » par 1 si le test est vrai, ou par 0 s'il est faux.</p><p id="r-550761" data-claire-element-id="550761">Les boucles <code>For</code> permettent de diminuer la taille du programme, en testant les trois lignes et les trois colonnes.</p><h3 id="r-c-est-tout-4" data-claire-element-id="550764">C'est tout !</h3><p id="r-550763" data-claire-element-id="550763">Voilà pour la correction. Bien sûr, ce n'est que le début... :diable:</p><h3 id="r-quelques-ajouts-sympathiques" data-claire-element-id="550766">Quelques ajouts sympathiques</h3><p id="r-550765" data-claire-element-id="550765">Maintenant que l'on peut réellement jouer à ce morpion, il faut penser à ajouter quelques informations, et même certaines fonctionnalités qui rendront le jeu plus agréable.</p><h2 id="r-affichage-du-gagnant" data-claire-element-id="550774">Affichage du gagnant</h2><p id="r-550768" data-claire-element-id="550768">Pour l'instant, à la fin d'une partie, les utilisateurs doivent vérifier eux-mêmes qui a gagné. D'accord, il n'y a jamais de doute sur ce point, mais d'un autre côté, que penseriez-vous d'un jeu qui n'affiche pas le gagnant et se contente de terminer la partie ?</p><p id="r-550769" data-claire-element-id="550769">L'implémentation de cette fonctionnalité est très simple. Le gagnant est celui qui vient de jouer, et si c'est un cas de match nul, on a <code>N=9 and W=1</code>, comme on l'a vu ci-dessus ;) .</p><p id="r-550770" data-claire-element-id="550770">Cela ne devrait absolument pas vous poser de problème, c'est une condition toute simple. Par contre, faites attention à l'endroit où vous l'écrivez, une erreur de structure est si vite arrivée ^^ .<br/> On peut en effet écrire :</p><pre id="r-550771" data-claire-element-id="550771"><code data-claire-semantic="console">PROGRAM:MORPION
:If N=9 and W=1
:Then
:Text(29,30,&quot;MATCH NUL
:Else
:Text(29,17,&quot;LE JOUEUR &quot;,T+1,&quot; GAGNE
:End
:Pause
:End        // Dernière ligne du programme, on l'a déjà écrite.</code></pre><p id="r-550772" data-claire-element-id="550772">Ce code se situe donc entre les deux derniers End du programme MORPION.<br/> Comme vous pouvez le voir, le gagnant est le joueur n°<code>(T+1)</code> ; n'oubliez pas que T vaut 0 ou 1, alors que les joueurs ont pour numéro 1 et 2 ! ;)</p><p id="r-550773" data-claire-element-id="550773">Et comme le changement de joueur est au début du code et non à la fin, cette ligne est exécutée quand le gagnant est celui qui est <strong>en train</strong> de jouer.</p><h2 id="r-a-qui-le-tour" data-claire-element-id="550792">À qui le tour ?</h2><p id="r-550775" data-claire-element-id="550775">Eh bien, le problème majeur de notre morpion, c'est qu'il n'est écrit nulle part quel joueur doit poser son pion. En milieu de partie, les joueurs se perdent rarement, mais lorsque le premier pion doit être posé, on ne sait pas qui doit le faire...</p><p id="r-550776" data-claire-element-id="550776">D'où l'importance d'écrire explicitement, à chaque nouveau tour, le <strong>numéro</strong> du joueur qui doit poser son pion. Pour cela, vous allez devoir vous servir de la fonction <code>Text</code>, et n'oubliez pas qu'avec elle, vous pouvez utiliser la concaténation (si vous ne vous souvenez plus de cette méthode, revoyez le chapitre sur les fonctions <code>Draw</code> !)</p><p id="r-550777" data-claire-element-id="550777">Si vous avez utilisé une grille semblable à la mienne, vous noterez qu'il y a un espace vide à gauche de l'écran ; utilisez-le pour afficher ces informations.</p><p id="r-550778" data-claire-element-id="550778">Là encore, c'est très simple. Il est possible de faire cela en une seule ligne, j'en ai cependant utilisé deux, regardez pourquoi :</p><pre id="r-550779" data-claire-element-id="550779"><code data-claire-semantic="console">PROGRAM:MORPION
:Text(1,1+16T,&quot;       &quot;
:not(T)-&gt;T        // Nous avons déjà écrit cette ligne
:Text(1,1+16T,&quot;J&quot;,T+1</code></pre><div id="r-550781" data-claire-element-id="550781" data-claire-semantic="question"><p id="r-550780" data-claire-element-id="550780">« Pourquoi t'effaces le texte alors qu'il fera toujours le même nombre de caractères ? »</p></div><p id="r-550782" data-claire-element-id="550782">Eh bien, regardez les deux lignes de plus près : le texte est écrit aux coordonnées <code>(1+16T,1)</code> (je rappelle en passant la syntaxe de la fonction : <code>Text(Y,X,text)</code>).</p><p id="r-550783" data-claire-element-id="550783">Cela signifie que le texte est affiché plus ou moins à droite, en fonction du joueur qui doit placer son pion ; voici le rendu :</p><figure id="r-550785" data-claire-element-id="550786"><img id="r-550784" data-claire-element-id="550784" src="medias/uploads.siteduzero.com_files_123001_124000_123612.jpg" alt="Image utilisateur"/></figure><figure id="r-550788" data-claire-element-id="550789"><img id="r-550787" data-claire-element-id="550787" src="medias/uploads.siteduzero.com_files_123001_124000_123613.jpg" alt="Image utilisateur"/></figure><p id="r-550790" data-claire-element-id="550790">Je trouve que ce petit décalage permet de savoir intuitivement qui doit jouer, cela peut par exemple éviter les confusions.</p><p id="r-550791" data-claire-element-id="550791">Après ces deux ajouts, la suite peut être considérée comme inutile pour ce qui est du jeu ; par contre, ce n'est pas sans intérêt pédagogique ! Et on est là pour ça, non ? :p</p><h2 id="r-sauvegarde-des-scores-introduction" data-claire-element-id="550820">Sauvegarde des scores - introduction</h2><p id="r-550793" data-claire-element-id="550793">Alors pour commencer, il faut savoir que sur votre TI, il est plus facile de sauvegarder que de supprimer :p (je veux dire par là qu'une variable est <strong>toujours</strong> enregistrée dans la RAM de votre TI, et que par conséquent cette sauvegarde est « automatique », tandis que la suppression doit être demandée pour être exécutée).</p><p id="r-550794" data-claire-element-id="550794">Par conséquent, une <strong>sauvegarde</strong>, ce n'est rien d'autre qu'une liste. En général, on n'utilise pas <code>L1, L2</code>, etc. mais des listes dont <strong>vous</strong> choisissez le nom. Vous savez certainement en créer, il y a plusieurs façons de le faire.</p><h3 id="r-avec-le-menu-stat" data-claire-element-id="550808">Avec le menu STAT</h3><p id="r-550795" data-claire-element-id="550795">Ouvrez le menu <code>STAT</code> et choisissez <code>&quot;Edit...&quot;</code> ; vous accédez ainsi à ce genre de tableau :</p><figure id="r-550797" data-claire-element-id="550798"><img id="r-550796" data-claire-element-id="550796" src="medias/uploads.siteduzero.com_files_123001_124000_123620.jpg" alt="Image utilisateur"/></figure><figure id="r-550800" data-claire-element-id="550801"><img id="r-550799" data-claire-element-id="550799" src="medias/uploads.siteduzero.com_files_123001_124000_123621.jpg" alt="Image utilisateur"/></figure><figure id="r-550803" data-claire-element-id="550804"><img id="r-550802" data-claire-element-id="550802" src="medias/uploads.siteduzero.com_files_123001_124000_123622.jpg" alt="Image utilisateur"/></figure><p id="r-550805" data-claire-element-id="550805">Sur la première image, vous observez que l'on peut écrire le nom d'une liste lorsqu'il y a des pointillés. Après avoir entré un nom, appuyez sur <code>ENTER</code> pour obtenir un résultat similaire à l'image 2.</p><p id="r-550806" data-claire-element-id="550806">Si cette liste (en l'occurrence MORP) existe, ses valeurs sont affichées dans le tableau. Sinon, cette liste est créée ;) . On peut ensuite entrer les valeurs de la liste directement dans le tableau. Notez que si vous entrez une expression, celle-ci est remplacée par sa valeur approchée (sur l'image 3, j'ai entré le symbole PI qui a été remplacé par sa valeur approchée). Une liste ne contient donc <strong>que</strong> des constantes.</p><p id="r-550807" data-claire-element-id="550807">L'avantage de ce tableau, c'est qu'il est très simple d'utilisation. Le problème, c'est qu'il est évidemment inutilisable en TI-Basic, et ça ne nous arrange pas vraiment ^^ . Passons à la seconde méthode.</p><h3 id="r-en-ti-basic" data-claire-element-id="550819">En TI-Basic</h3><p id="r-550809" data-claire-element-id="550809">En TI-Basic, on peut utiliser ces différentes instructions pour définir une liste :</p><pre id="r-550810" data-claire-element-id="550810"><code data-claire-semantic="console">// Méthode 1
:{1,2,4,8}-&gt;LNOM

// Méthode 2
:4-&gt;dim(LNOM
:Fill(0,LNOM</code></pre><aside id="r-550812" data-claire-element-id="550812" data-claire-semantic="warning"><p id="r-550811" data-claire-element-id="550811">Dans « LNOM », le L n'est pas un caractère normal ; il ressemble à un L majuscule mais de plus petite taille. Vous pouvez le trouver dans <code>2ND:LIST-OPS</code>, c'est la toute dernière ligne du sous-menu.<br/> Pour ce qui est du code, j'estime que vous pouvez facilement le différencier d'un « L » normal, étant donné qu'il précède toujours un nom de liste.</p></aside><p id="r-550813" data-claire-element-id="550813">La première méthode permet de définir des valeurs par défaut pour chaque « case » de la liste, tandis que la seconde sert à définir la <strong>taille</strong> de la liste et à remplir toutes ses cases d'une même valeur.</p><p id="r-550814" data-claire-element-id="550814">Vous vous en doutez, plus la liste est grande, plus on a tendance à utiliser la seconde technique.</p><p id="r-550815" data-claire-element-id="550815"><strong>Petit rappel</strong> : pour accéder à une case précise de la liste, on utilise <code>LNOM(numero_case)</code>. Ainsi, si on veut affecter 6 à la 3e case de la liste « NOM », on écrit : <code>6-&gt;LNOM(3)</code>.</p><p id="r-550816" data-claire-element-id="550816">Sachez que LNOM(3) s'utilise <strong>exactement</strong> comme une variable ; <strong>c'est</strong> une variable. J'entends par là que vous pouvez tout à fait affecter sa valeur à une autre variable, ou vous en servir indépendamment du reste de la liste. Vous avez utilisé toutes les variables de A à Z, en passant par thêta, et vous voulez stocker l'âge de chacun de vos 127 hippopotames ? Créez une liste.</p><p id="r-550817" data-claire-element-id="550817">De plus, vous pouvez aussi utiliser une variable pour la case de la liste, en écrivant par exemple <code>LNOM(A)</code>.</p><p id="r-550818" data-claire-element-id="550818">Vous devriez évidemment savoir tout cela, mais un petit rappel ne fait sûrement pas de mal ^^ . Passons aux <strong>choses sérieuses</strong> !</p><h2 id="r-sauvegarde-des-scores-implementation" data-claire-element-id="550846">Sauvegarde des scores - implémentation</h2><p id="r-550821" data-claire-element-id="550821">Vous l'avez compris, nous allons utiliser une <strong>liste</strong> pour sauvegarder les scores de nos utilisateurs. On peut par exemple créer 10 slots de sauvegarde (10 cases), chacun contenant un score. En utilisant toujours le même slot de sauvegarde, le joueur pourra ainsi augmenter son score total à chaque partie.</p><p id="r-550822" data-claire-element-id="550822">Pour cela, nous allons ajouter un menu pour choisir son numéro de joueur. Profitons-en pour afficher le score de chacun de ces joueurs. Si le score est égal à 0, on affiche par exemple « nouveau joueur », ou quelque chose du genre :p .</p><p id="r-550823" data-claire-element-id="550823">Que diriez-vous d'un <strong>menu à curseur</strong> ? :) <br/> Comment ça « oh non » ? Allez, et on en fait un simplifié cette fois... pas de fonction <code>Line</code>, juste un point de type 2 (les carrés) !<br/> Au boulot !</p><pre id="r-550824" data-claire-element-id="550824"><code data-claire-semantic="console">PROGRAM:MORPION
:If D=1   // If et Then déjà écrits
:Then
:10-&gt;dim(LMORP
:2-&gt;dim(LPLYR
// Affichage de la liste des slots
:For(Z,1,10
:If LMORP(Z)=0
:Then
:Text(Z*6-5,20,Z,&quot;:NOUVEAU JOUEUR
:Else
:Text(Z*6-5,20,Z,&quot;:&quot;,LMORP(Z),&quot; PTS
:End
:End

:For(P,1,2    // Pour chaque joueur on affiche un menu de choix de slot
:1-&gt;D
:Text(0,0,&quot;J&quot;,P
:Repeat G=105
:Pt-On(Z*-6-5,10,2
:Repeat G=105 or (G=25 and D&gt;1) or (G=34 and D&lt;10
:getKey-&gt;G
:End
:Pt-Off(Z*-6-5,10,2
:D-(G=25)+(G=34)-&gt;D
:End
:D-&gt;LPLYR(P
:End
:ClrDraw

// Suite du code (:Line...)</code></pre><p id="r-550825" data-claire-element-id="550825">Notez l'apparition de deux nouvelles listes : <code>LMORP</code> et <code>LPLYR</code> (pour « PLAYER »).<br/> La première contient les scores de chacun des joueurs, la seconde contient les numéros des joueurs de cette partie. Cette dernière permet de modifier les scores totaux des joueurs en fin de partie.</p><p id="r-550826" data-claire-element-id="550826">En effet, le code suivant utilise <code>LPLYR</code> pour modifier les valeurs de <code>LMORP</code> concernant les joueurs qui participent à cette partie :</p><pre id="r-550827" data-claire-element-id="550827"><code data-claire-semantic="console">PROGRAM:MORPION
:If N=9 and W=1
:Then
:Text(29,30,&quot;MATCH NUL
:Else
:Text(29,17,&quot;LE JOUEUR &quot;,T+1,&quot; GAGNE
:LMORP(LPLYR(T+1))+1-&gt;LMORP(LPLYR(T+1    // Seule cette ligne est nouvelle
:End</code></pre><p id="r-550828" data-claire-element-id="550828">Cette ligne de code permet de stocker le nouveau score du gagnant dans <code>LMORP</code>.</p><p id="r-550829" data-claire-element-id="550829">C'est terminé pour les petits ajouts, je vous propose de passer au code final ^^ .</p><h3 id="r-le-code-final-5" data-claire-element-id="550845">Le code final !</h3><p id="r-550830" data-claire-element-id="550830">Après ces quelques ajouts, nous allons établir le <strong>code final</strong>. Vous y trouverez certainement les réponses à vos problèmes si vous êtes bloqué quelque part.<br/> Si vous n'avez pas terminé votre programme, ne lisez que la partie qui vous permettra de vous débloquer, c'est important pour bien comprendre et savoir le refaire sans aide ^^ .</p><p id="r-550831" data-claire-element-id="550831">Sans plus tarder, voici le code :</p><pre id="r-550832" data-claire-element-id="550832"><code data-claire-semantic="console">ClrDraw
prgmSETGRAPH
RecallPic 1
1-&gt;D
Repeat G=105        //écran-titre
        Line(30,-24-11D,-30,-32-11D        // Affiche le cadre
        Line(30,-32-11D,64,-32-11D
        Line(64,-32,-11D,64,-24-11D
        Line(64,-24-11D,30,-24-11D
        Repeat G=105 or (G=25 and D&gt;1) or (G=34 and D&lt;2
                getKey-&gt;G
        End
        Line(30,-24-11D,-30,-32-11D,0        // Efface le cadre
        Line(30,-32-11D,64,-32-11D,0
        Line(64,-32,-11D,64,-24-11D,0
        Line(64,-24-11D,30,-24-11D,0
        D-(G=25)+(G=34)-&gt;D        // Le cadre est déplacé
End
ClrDraw
If D=2        // Quitter
Then
        prgmRESETGRF
        ClrHome
        Output(1,1,&quot;
        Return
End
If D=1 // Jouer
Then
        10-&gt;dim(LMORP
        2-&gt;dim(LPLYR
        For(Z,1,10
                If LMORP(Z)=0
                Then
                        Text(Z*6-5,20,Z,&quot;:NOUVEAU JOUEUR
                Else
                        Text(Z*6-5,20,Z,&quot;:&quot;,LMORP(Z),&quot; PTS
                End
        End
        
        For(P,1,2        // Choix du slot de sauvegarde pour chacun des joueurs
        1-&gt;D
                Text(0,0,&quot;J&quot;,P
                Repeat G=105
                        Pt-On(Z*-6-5,10,2
                        Repeat G=105 or (G=25 and D&gt;1) or (G=34 and D&lt;10
                                getKey-&gt;G
                        End
                        Pt-Off(Z*-6-5,10,2
                        D-(G=25)+(G=34)-&gt;D
                End
                D-&gt;LPLYR(P                // Le numéro de slot est stocké dans une liste
        End
        ClrDraw
        
        //Début de la partie
        Line(51,0,51,-61        // Affichage du plateau de jeu
        Line(73,0,73,-61
        Line(31,-20,90,-20
        Line(31,-41,93,-41
        Line(28,0,28,-62
        {3,3}-&gt;dim([A]
        Fill(0,[A]
        randInt(0,1)-&gt;T
        0-&gt;N
        2-&gt;A
        2-&gt;B
        0-&gt;W
        Text(9,1,&quot;SCORE :
        Text(16,1,LMORP(LPLYR(1
        Text(16,16,LMORP(LPLYR(2
        Repeat W&gt;0
                Text(1,1+16T,&quot;       &quot;
                not(T)-&gt;T                                        // C'est au tour du joueur suivant
                Text(1,1+16T,&quot;J&quot;,T+1
                Repeat G=105 and [A](A,B)=0
                        Line(27+22A,20-21B,27+22A,3-21B        // Affiche le cadre du plateau de jeu
                        Line(27+22A,3-21B,9+22A,3-21B
                        Line(9+22A,20-21B,9+22A,3-21B
                        Line(9+22A,20-21B,27+22A,20-21B
                        Repeat (G=105 and [A](A,B)=0) or (G=24 and A&gt;1) or (G=25 and B&gt;1) or (G=26 and A&lt;3) or (G=34 and B&lt;3)
                                getKey-&gt;G
                        End        
                        Line(27+22A,20-21B,27+22A,3-21B,0        // Efface le cadre du plateau de jeu
                        Line(27+22A,3-21B,9+22A,3-21B,0
                        Line(9+22A,20-21B,9+22A,3-21B,0
                        Line(9+22A,20-21B,27+22A,20-21B,0
                        A-(G=24)+(G=26)-&gt;A        // Le cadre change de coordonnées
                        B-(G=25)+(G=34)-&gt;B
                End
                T+1-&gt;[A](A,B)        // La case est déclarée comme pleine
                If T=0        // Affichage du pion du joueur
                Then
                        Line(27+22A,20-21B,9+22A,3-21B
                        Line(27+22A,3-21B,9+22A,20-21B
                Else 
                        Circle(18+22A,11-21B,7
                End
                N+1-&gt;N
                If N&gt;4        // Si le nombre de pions placés permet une victoire
                Then
                        N=9-&gt;W
                        For(Z,1,2)        // Teste si 3 cases alignées contiennent le même type de pions
                                For(M,1,3)
                                        W+([A](M,1)=Z and [A](M,2)=Z and [A](M,3)=Z)-&gt;W
                                        W+([A](1,M)=Z and [A](2,M)=Z and [A](3,M)=Z)-&gt;W
                                End
                                W+([A](1,1)=Z and [A](2,2)=Z and [A](3,3)=Z)-&gt;W
                                W+([A](3,1)=Z and [A](2,2)=Z and [A](1,3)=Z)-&gt;W
                        End        // W vaut plus de 0 si le jeu doit se terminer.
                End
        End
        ClrDraw
        If N=9 and W=1
        Then
                Text(29,30,&quot;MATCH NUL
        Else
                Text(29,17,&quot;LE JOUEUR &quot;,T+1,&quot; GAGNE
                LMORP(LPLYR(T+1))+1-&gt;LMORP(LPLYR(T+1
        End
        Pause
End</code></pre><p id="r-550833" data-claire-element-id="550833">Bien sûr, il est possible que votre structure ne soit pas la même que la mienne. Sachez que ce n'est pas grave, au contraire ; mon programme est loin d'être parfait. Si votre programme fonctionne et que les délais d'attente ne sont pas gênants, c'est bon ! ;)</p><p id="r-550834" data-claire-element-id="550834">Ce TP clôt la seconde partie. La dernière partie, traitant de la création d'un RPG, est une sorte de gros TP : vous avez remarqué que dans ce chapitre, vous n'avez rien appris, sauf quelques méthodes d'application de ce que vous connaissiez déjà. C'est le principe d'un TP. Autrement dit, si vous vous sentez de faire un autre jeu ou d'améliorer votre morpion, ne vous gênez pas :p .</p><p id="r-550835" data-claire-element-id="550835">Si vous souhaitez vous entraîner en TI-Basic, voici quelques idées d'amélioration :</p><ul id="r-550842" data-claire-element-id="550842"><li id="r-550837" data-claire-element-id="550837"><p id="r-550836" data-claire-element-id="550836">donner aux joueurs la possibilité de recommencer une partie, en gardant les mêmes slots de sauvegarde pour ne pas les ennuyer ;</p></li><li id="r-550839" data-claire-element-id="550839"><p id="r-550838" data-claire-element-id="550838">au lieu d'utiliser une liste de 10 cases, commencer avec une seule case (nouveau joueur) et ajouter des cases à chaque fois qu'un nouveau joueur est ajouté ;</p></li><li id="r-550841" data-claire-element-id="550841"><p id="r-550840" data-claire-element-id="550840">ajouter une IA pour donner la possibilité à l'utilisateur de jouer seul contre la machine, et pourquoi pas avec plusieurs niveaux de difficulté : facile (place ses pions au hasard), normal (au hasard, sauf s'il peut empêcher le joueur d'aligner ses pions), difficile (essaie de coincer le joueur). Si vous vous intéressez au développement de l'IA, n'oubliez pas de faire des recherches sur les techniques de jeu du morpion (en plus, comme ça, vous serez aussi forts que votre programme :D ).</p></li></ul><p id="r-550843" data-claire-element-id="550843">Et comme une bonne nouvelle ne vient jamais seule, j'ai encore de bonnes idées pour vous exercer. :diable: <br/> Les possibilités ne manquent pas : jeu de plates-formes, Mastermind, Memory (où il faut trouver des paires), Sokoban, Snake, etc. Si vous êtes fort, vous pouvez même coder un Wii Fit ou un Super Smash Bros. :D</p><p id="r-550844" data-claire-element-id="550844">Sur ce, je vous laisse, en attendant la 3e partie du tuto !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti">Utiliser l&#039;écran graphique de la TI</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/utilisation-principale-du-graphique">
Utilisation principale du graphique
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/les-fonctions-de-dessin">
Les fonctions de dessin
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/un-rpg-complet-en-ti-basic">
Un RPG complet en TI-Basic
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/utilisation-principale-du-graphique">
<span class="arrow"></span>
<span class="next">Utilisation principale du graphique</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/un-rpg-complet-en-ti-basic">
<span class="next">Un RPG complet en TI-Basic</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="UnRPGcompletenTI-Basic"></a><h2>Un RPG complet en TI-Basic</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/les-fonctions-de-dessin">
<span class="arrow"></span>
<span class="next">Les fonctions de dessin</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-550848" data-claire-element-id="550848">Apprenez à programmer votre propre jeu en utilisant l'écran graphique. Ici, on étudiera un <a href="http://fr.wikipedia.org/wiki/Jeu_de_rôle_(jeu_vidéo)">RPG</a> car c'est un type de jeu assez complexe et qui permet donc de vérifier vos connaissances dans plusieurs aspects du TI-Basic. ;)</p><p id="r-550849" data-claire-element-id="550849">Vous voilà maintenant fin prêt à programmer tout ce dont vous avez envie sur votre TI ! ^^</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti">Utiliser l&#039;écran graphique de la TI</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/utilisation-principale-du-graphique">
Utilisation principale du graphique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/les-fonctions-de-dessin">
Les fonctions de dessin
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/un-rpg-complet-en-ti-basic">
Un RPG complet en TI-Basic
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/utiliser-l-ecran-graphique-de-la-ti/les-fonctions-de-dessin">
<span class="arrow"></span>
<span class="next">Les fonctions de dessin</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/utiliser-l-ecran-graphique-de-la-ti.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 04:34:50 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/utiliser-l-ecran-graphique-de-la-ti.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:55:13 GMT -->
</html>
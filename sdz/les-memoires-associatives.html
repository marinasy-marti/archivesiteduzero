<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/les-memoires-associatives.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 07:18:43 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-memoires-associatives.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:20:07 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Les mémoires associatives</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/les-memoires-associatives.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Les mémoires associatives</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Lesmmoiresassociatives">Les mémoires associatives</a><br/><a href="#Aquoicasert">A quoi ca sert ?</a><br/><a href="#Interface">Interface</a><br/><a href="#Planmmoire">Plan mémoire</a><br/><a href="#Contrleurmmoire">Contrôleur mémoire</a><br/><a href="#Architecturesassociatives">Architectures associatives</a><br/></div>
<a name="Lesmmoiresassociatives"></a><h2>Les mémoires associatives</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/a-quoi-ca-sert-17">
<span class="next">A quoi ca sert ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-549318" data-claire-element-id="549318">Quand on vous a parlé de mémoire pour la première fois, on vous a surement parlé des mémoires qui étaient adressables. Il est naturel de penser que toutes les mémoires sont des mémoires adressables : chaque <em>Byte</em> de la mémoire est numéroté par une adresse mémoire qui fait office d'identifiant permettant de sélectionner un Byte en particulier. Pour accéder à un Byte bien précis, il suffit d'envoyer son adresse à la mémoire, et celle-ci se chargera de fournir son contenu sur le bus de données.</p><p id="r-549319" data-claire-element-id="549319">Mais lorsqu'on vous a parlé pour la première fois de mémoires, on a surement oublié de vous dire certaines mémoires ne fonctionnaient absolument pas sur ce principe ! Je tiens à vous signaler que vous connaissez déjà une forme de mémoire qui n'est pas adressable : la mémoire cache d'un ordinateur. Elle fonctionne sur un principe de <em>Tags</em> assez complexe et non sur des adresses mémoires. Et oui, c'est la triste réalité : certaines mémoires ne sont pas adressables. Parmi toutes ces mémoires adressables, nos mémoires caches tiennent une place assez importante. Mais celles-ci ne sont qu'un sous-ensemble d'un type de mémoire bien plus grand. Il s'agit des <strong>mémoires adressables par contenu</strong>.</p><p id="r-549320" data-claire-element-id="549320">Il existe deux types de mémoires adressables par contenu : les mémoires caches en sont un premier type. Mais il existe aussi les <em><strong>mémoires associatives</strong></em>. Sur les mémoires associatives, on fait à peu-prêt la même chose qu'avec une mémoire à accès aléatoire, mais dans le sens inverse. Au lieu d'envoyer l'adresse pour accéder à la donnée, on va envoyer la donnée pour récupérer son adresse.</p><figure id="r-549322" data-claire-element-id="549323"><img id="r-549321" data-claire-element-id="549321" src="../../user.oc-static.com/files/418001_419000/418533.png" alt="Image utilisateur"/></figure>
</div><a name="Aquoicasert"></a><h2>A quoi ca sert ?</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/interface-4">
<span class="next">Interface</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-549324" data-claire-element-id="549324">On peut légitimement se demander à quoi peuvent bien servir des mémoires aussi bizarroïdes. Franchement, si on a une donnée, à quoi cela peut-il bien servir de récupérer son adresse ? Et bien rassurez-vous : ceux qui ont inventés ces mémoires avaient toute leur santé mentale : ces mémoires servent à quelque chose ! Elles servent lorsque l'on doit effectuer des recherches d'une donnée en mémoire rapidement.</p><h2 id="r-recherche-4" data-claire-element-id="549329">Recherche</h2><p id="r-549325" data-claire-element-id="549325">Il n'est pas rare que l'on doive<strong> rechercher une donnée dans un ensemble de données</strong>. C'est une problématique assez connue des programmeurs, qui y font face tous les jours. Généralement, ces données sont toutes regroupées dans ce qu'on appelle des structures de données : tableaux, listes, graphes, sets, tables de hachage, arbres, etc. Effectuer des recherches dans ces structures de données n'est pas une chose des plus aisée.</p><p id="r-549326" data-claire-element-id="549326">Dans le pire des cas, à savoir des données stockées dans un tableau non-trié, il faut parcourir le tableau jusqu'à tomber sur la bonne. Bien sûr, les informaticiens ont depuis longtemps inventés des solutions algorithmiques qui permettent de rechercher plus rapidement des données dans un ensemble. Mais celles-ci ne sont pas des solutions miracles, et on perd toujours un peu de temps : on ne peut pas toujours tomber sur la bonne donnée du premier coup.</p><p id="r-549327" data-claire-element-id="549327">Les mémoires associatives sont une solution matérielle au problème de la recherche d'un élément dans un ensemble de données. Le processeur envoie la donnée recherchée à la mémoire associative, et celle-ci va vérifier tous ses Bytes pour voir s'il y a correspondance. Une fois la donnée trouvée, la mémoire peut alors permettre de modifier ou de lire notre donnée, ainsi que de récupérer son adresse : on tombe directement sur la donnée cherchée.</p><p id="r-549328" data-claire-element-id="549328">Grâce à ces mémoires, la complexité algorithmique de la recherche d'un élément dans un ensemble est très fortement diminuée et est de complexité constante : à peine un seul cycle d'horloge de la mémoire. On est bien loin des complexités que l'on peut obtenir avec des tableaux ou des listes, et l'ensemble est plus efficace que ce que l'on obtient avec des structures de données optimisées, même pour des complexités identiques.</p><h2 id="r-routeurs" data-claire-element-id="549332">Routeurs</h2><p id="r-549330" data-claire-element-id="549330">Un cas d'utilisation basique est celui des <strong>routeurs</strong>. Comme vous le savez, nos ordinateurs ne communiquent pas sur un réseau n'importe comment. Nos ordinateurs sont tous identifiés par des numéros, des IP, qui servent à identifier l’émetteur et le destinataire d'un paquet de donnée. Ensuite, des machines spécialisées, les routeurs, vont se charger de faire passer chaque paquet de donnée émis par un ordinateur de proche en proche, d'un routeur vers un autre, jusqu'à ce que ce paquet arrive à destination. Pour savoir vers quel autre routeur envoyer un paquet, un routeur doit avoir une sorte de table, qui fait la correspondance entre une partie de l'adresse de destination d'un paquet, et la connexion sur laquelle notre routeur va devoir envoyer le paquet.</p><p id="r-549331" data-claire-element-id="549331">Cette table de correspondance s'implémente facilement en utilisant des mémoires associatives : il suffit de coupler une RAM avec une mémoire associative. Ainsi, si j'ai une liste de N correspondances IP-Route, il me suffit de stocker ces N ips dans une mémoire associative, et mes N routes dans une RAM. On place celle-ci dans l'ordre : la route stockée dans la RAM à l'adresse i correspondra à l'IP stockée dans l'adresse i de la mémoire associative. Si jamais l'adresse IP du paquet en cours de traitement est dans cette mémoire, celle-ci peut dire son adresse en un cycle d'horloge. Une fois cette adresse connue, il suffit d'aller lire la RAM à cette adresse. C'est nettement plus efficace que de stocker nos correspondances dans une RAM : on aurait du parcourir la mémoire jusqu’à ce qu'on tombe sur la bonne correspondance IP-Route.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives">Les mémoires associatives</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/a-quoi-ca-sert-17">
A quoi ca sert ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/interface-4">
Interface
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/plan-memoire-1">
Plan mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/controleur-memoire">
Contrôleur mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/architectures-associatives">
Architectures associatives
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/interface-4">
<span class="next">Interface</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Interface"></a><h2>Interface</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/a-quoi-ca-sert-17">
<span class="arrow"></span>
<span class="next">A quoi ca sert ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/plan-memoire-1">
<span class="next">Plan mémoire</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-549334" data-claire-element-id="549334">Reste à déduire à quoi ressemble notre mémoire vu de l'extérieur.</p><h2 id="r-retour-d-adresse" data-claire-element-id="549348">Retour d'adresse</h2><p id="r-549335" data-claire-element-id="549335">Tout d'abord, notre mémoire va renvoyer l'adresse à laquelle elle a trouvée la donnée.</p><figure id="r-549337" data-claire-element-id="549338"><img id="r-549336" data-claire-element-id="549336" src="medias/uploads.siteduzero.com_files_415001_416000_415879.png" alt="Image utilisateur"/></figure><p id="r-549339" data-claire-element-id="549339">Évidemment, il se peut que notre donnée ne soit pas présente dans la mémoire. Notre mémoire est donc obligée de préciser si elle a trouvé la donnée recherchée. Pour cela, elle va renvoyer un signal qui dit : j'ai trouvé la donnée (ou non) !</p><figure id="r-549341" data-claire-element-id="549342"><img id="r-549340" data-claire-element-id="549340" src="medias/uploads.siteduzero.com_files_415001_416000_415878.png" alt="Image utilisateur"/></figure><p id="r-549343" data-claire-element-id="549343">Petit détail : il se peut parfaitement que notre donnée soit présente en plusieurs exemplaires en mémoire. Dans ce cas, on doit trouver un moyen pour gérer ces duplicats. Sur les mémoires les plus simples, on va choisir un des exemplaires de la donnée et renvoyer son adresse. Les adresses des autres exemplaires sont passés sous le tapis. Sur d'autres mémoires, les adresses seront envoyées unes par unes au processeur, en rafale.</p><p id="r-549344" data-claire-element-id="549344">Notre mémoire est donc reliée à un bus de donnée, accessible en lecture et en écriture. Elle est aussi reliée à un bus d'adresse accessible en lecture (et parfois en écriture sur certaines). Et enfin, elle est reliée à un bus de commande, qui contient au minimum le signal Trouvé / Non-trouvé.</p><figure id="r-549346" data-claire-element-id="549347"><img id="r-549345" data-claire-element-id="549345" src="medias/uploads.siteduzero.com_files_415001_416000_415548.png" alt="Image utilisateur"/></figure>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives">Les mémoires associatives</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/a-quoi-ca-sert-17">
A quoi ca sert ?
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/interface-4">
Interface
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/plan-memoire-1">
Plan mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/controleur-memoire">
Contrôleur mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/architectures-associatives">
Architectures associatives
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/a-quoi-ca-sert-17">
<span class="arrow"></span>
<span class="next">A quoi ca sert ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/plan-memoire-1">
<span class="next">Plan mémoire</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Planmmoire"></a><h2>Plan mémoire</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/interface-4">
<span class="arrow"></span>
<span class="next">Interface</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/controleur-memoire">
<span class="next">Contrôleur mémoire</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-549350" data-claire-element-id="549350">Maintenant que l'on sait ce que sont ces mémoires, voyons un peu comment les fabriquer. De ce qu'on sait de ces mémoires, elles peuvent sembler assez difficile à fabriquer. Mais il n'en est rien, et leur implémentation ressemble fortement à celle d'une mémoire normale, moyennant quelques modifications.</p><p id="r-549351" data-claire-element-id="549351">Notre mémoire a un fonctionnement assez simple : elle va prendre en entrée une donnée, et va vérifier si celle-ci est présente dans la mémoire. Une fois la donnée trouvée, elle va agir en conséquence. La recherche d'une donnée s'effectue donc en deux étapes : trouver la case mémoire qui contient la donnée, et ensuite faire ce qu'il faut (renvoyer l'adresse, un signal trouve/non-trouvé, etc). Voyons tout d'abord comment est gérée cette vérification.</p><h2 id="r-stockage-4" data-claire-element-id="549357">Stockage</h2><p id="r-549352" data-claire-element-id="549352">Une case mémoire d'une mémoire adressable par contenu a deux fonctions : <strong>stocker un bit</strong>, et effectuer une comparaison. Pour commencer, quelle que soit la mémoire associative utilisée, notre bit est stocké comme sur une mémoire normale. On peut utiliser une cellule mémoire de SRAM ordinaire, sans vraiment se fatiguer. Pour rappel, un bit de SRAM est stocké dans un montage à base de deux inverseurs, reliés comme indiqué dans le schéma du dessous. Sur ce schéma, la sortie notée Q est celle sur lequel on lire le bit mémorisé. La sortie /Q est celle sur laquelle on peut lire l'inverse du bit mémorisé.</p><figure id="r-549354" data-claire-element-id="549355"><img id="r-549353" data-claire-element-id="549353" src="medias/uploads.siteduzero.com_files_419001_420000_419034.png" alt="Image utilisateur"/></figure><p id="r-549356" data-claire-element-id="549356">Au fait, dans ce schéma, ainsi que dans tous les schémas qui vont suivre, je ne montrerai pas les transistors qui servent à autoriser les écritures dans notre bit de SRAM. Je fais ainsi pour alléger un peu les schémas et me concentrer sur l'essentiel. Mais sachez que ces transistors d'écritures existent : il faut bien écrire dans notre mémoire si on veut qu'elle serve à quelque chose.</p><h2 id="r-comparaison-naive" data-claire-element-id="549368">Comparaison naïve</h2><p id="r-549358" data-claire-element-id="549358">Reste la <strong>comparaison</strong>, qui est effectuée différemment suivant les cellules mémoires. Vérifier si une case mémoire contient la donnée, ainsi que faire nos comparaisons, s'effectue en utilisant un comparateur. Il s'agit d'un circuit qui compare deux données. C'est ce comparateur qui effectuera la comparaison d'égalité.</p><figure id="r-549360" data-claire-element-id="549361"><img id="r-549359" data-claire-element-id="549359" src="medias/uploads.siteduzero.com_files_415001_416000_415885.png" alt="Image utilisateur"/></figure><p id="r-549362" data-claire-element-id="549362">Dans le cas le plus simple, notre comparateur est séparé de la case mémoire et est conçu avec des portes <strong><em>NXOR</em></strong> et une porte <em><strong>ET</strong></em>.</p><p id="r-549363" data-claire-element-id="549363">Dans une mémoire associative, toutes les cases mémoires sont vérifiées en même temps. La donnée à rechercher dans la mémoire est envoyée à toutes les cases mémoires simultanément et toutes les comparaisons sont effectuées en parallèle. Sur le principe, tout se passe comme si chaque case mémoire était reliée à un comparateur qui s'occupe de vérifier si la case mémoire est bien celle qui contient la donnée envoyée en entrée.</p><figure id="r-549365" data-claire-element-id="549366"><img id="r-549364" data-claire-element-id="549364" src="medias/uploads.siteduzero.com_files_415001_416000_415884.png" alt="Image utilisateur"/></figure><p id="r-549367" data-claire-element-id="549367">Et tout ces comparateurs ne sont pas gratuits : ils utilisent beaucoup de transistors. A cause de cela, les mémoires associatives utilisent plus de transistors pour la même capacité : on peut se passer de ces comparateurs sur une mémoire normale, mais pas sur une mémoire associative. Et cela a pas mal de désavantages : ces mémoires chauffent, sont chères, ont une faible capacité mémoire, rendent les hommes impuissants, sont à l'origine d'épidémies de choléra, etc.</p><h2 id="r-comparaison-optimisee" data-claire-element-id="549404">Comparaison optimisée</h2><p id="r-549369" data-claire-element-id="549369">Pour limiter le nombres de portes logiques utilisées pour le comparateur, il arrive que le comparateur soit intégré dans la case mémoire. Les circuits chargés d'effectuer la comparaison sont fusionnés directement avec les cellules mémoires (les circuits de mémorisation), afin de gagner un peu de place.</p><figure id="r-549371" data-claire-element-id="549372"><img id="r-549370" data-claire-element-id="549370" src="medias/uploads.siteduzero.com_files_415001_416000_415886.png" alt="Image utilisateur"/></figure><p id="r-549373" data-claire-element-id="549373">On va voir dans la suite comment il est possible de réaliser ce genre de prouesse.</p><h3 id="r-nor" data-claire-element-id="549385">NOR</h3><p id="r-549374" data-claire-element-id="549374">La première possibilité est celle-ci :</p><figure id="r-549376" data-claire-element-id="549377"><img id="r-549375" data-claire-element-id="549375" src="medias/uploads.siteduzero.com_files_419001_420000_419040.png" alt="Image utilisateur"/></figure><p id="r-549378" data-claire-element-id="549378">Son principe est simple. Regardez les deux transistors placés en série : si ces deux transistors ont chacun leur grille à 1, alors ils vont se comporter comme des interrupteurs fermés, et relier leur sortie Trouvé / Non-trouvé au zéro volt : la sortie vaudra alors zéro. Les transistors de gauche correspondent au cas où le bit mémorisé vaut 0 et le bit envoyé sur le bus vaut 1. Et les transistors de droite correspondent au cas où le bit mémorisé vaut 1 et le bit envoyé sur le bus vaut 0. Ces deux situations sont les seules dans lesquelles le bit mémorisé et le bit envoyé sur le bus sont différents.</p><p id="r-549379" data-claire-element-id="549379">Dans les autres cas, les transistors se comporteront comme des interrupteurs ouverts et ne relieront pas le signal Trouvé / Non-trouvé au zéro volts. Ce signal sera alors mis à 1 par des mécanismes extérieurs à la cellule mémoire (lorsqu'elle sera préchargée, plus précisément).</p><p id="r-549380" data-claire-element-id="549380">Nos différents signaux Trouvé / Non-trouvé des différents bits d'un seul Byte sont alors reliés ensemble comme ceci :</p><figure id="r-549382" data-claire-element-id="549383"><img id="r-549381" data-claire-element-id="549381" src="medias/uploads.siteduzero.com_files_419001_420000_419047.png" alt="Image utilisateur"/></figure><p id="r-549384" data-claire-element-id="549384">Le transistor du dessus sert à mettre notre signal Trouvé / Non-trouvé de notre Byte à 1. Ce transistor s'ouvre durant un moment afin de précharger le fil qui transportera le signal Trouvé / Non-trouvé, avant de se fermer juste avant que nos cellules mémoires de 1 bit commencent leur comparaison. Ensuite, nos cases mémoires effectueront leurs comparaison. Si pour un seul bit, la comparaison est fausse, alors le signal Trouvé / Non-trouvé sera relié au zéro volt. Dans le cas contraire, le fil contiendra encore une tension correspondant à un 1, qui sera alors amplifiée par divers amplificateurs de tension, et donnera un joli petit 1 en sortie.</p><h3 id="r-nand" data-claire-element-id="549403">NAND</h3><p id="r-549386" data-claire-element-id="549386">Il est possible de câbler notre cellule mémoire autrement. Cette autre façon de faire est celle qui est indiquée sur le schéma ci-dessous :</p><figure id="r-549388" data-claire-element-id="549389"><img id="r-549387" data-claire-element-id="549387" src="medias/uploads.siteduzero.com_files_419001_420000_419055.png" alt="Image utilisateur"/></figure><p id="r-549390" data-claire-element-id="549390">Pour comprendre ce câblage, vous devez savoir que toutes les cellules d'un Byte sont reliées ensemble comme ceci :</p><figure id="r-549392" data-claire-element-id="549393"><img id="r-549391" data-claire-element-id="549391" src="medias/uploads.siteduzero.com_files_419001_420000_419058.png" alt="Image utilisateur"/></figure><p id="r-549394" data-claire-element-id="549394">Ce faisant, le signal Trouvé / Non-trouvé est relié à la masse quand toutes les cellules vont fermer le transistor du haut. Et inversement, il suffit qu'un seul transistor ouvre ce transistor pour que le signal soit relié à la tension d'alimentation. En somme, le signal obtenu vaut zéro si jamais la donnée et le contenu du Byte sont identiques, et 1 sinon.</p><p id="r-549395" data-claire-element-id="549395">Mais revenons à notre circuit.</p><figure id="r-549397" data-claire-element-id="549398"><img id="r-549396" data-claire-element-id="549396" src="medias/uploads.siteduzero.com_files_419001_420000_419055.png" alt="Image utilisateur"/></figure><p id="r-549399" data-claire-element-id="549399">Le principe caché derrière ce circuit est assez simple. Si jamais nos deux bits sont identiques, le transistor du haut recevra un 1 sur sa grille, et se comportera comme un interrupteur fermé.</p><p id="r-549400" data-claire-element-id="549400">Si jamais nos deux bits valent 1, le transistors de droite se fermera : cela reliera la grille du transistor du haut sur le bit envoyé par la donnée. Vu que ce bit vaut 1, le transistor du haut se fermera.</p><p id="r-549401" data-claire-element-id="549401">Inversement, si nos deux bits valent zéro, alors ce sera le transistor de gauche qui se fermera. Et cela reliera la grille du transistor du haut sur l'inverse du bit envoyé par la donnée. Vu que cet inverse vaut 1, le transistor du haut se fermera.</p><p id="r-549402" data-claire-element-id="549402">Dans tous les autres cas, le transistor du haut recevra un zéro sur sa grille : il restera ouvert.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives">Les mémoires associatives</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/a-quoi-ca-sert-17">
A quoi ca sert ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/interface-4">
Interface
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/plan-memoire-1">
Plan mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/controleur-memoire">
Contrôleur mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/architectures-associatives">
Architectures associatives
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/interface-4">
<span class="arrow"></span>
<span class="next">Interface</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/controleur-memoire">
<span class="next">Contrôleur mémoire</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Contrleurmmoire"></a><h2>Contrôleur mémoire</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/plan-memoire-1">
<span class="arrow"></span>
<span class="next">Plan mémoire</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/architectures-associatives">
<span class="next">Architectures associatives</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-549406" data-claire-element-id="549406">Maintenant que l'on sait trouver une donnée dans la mémoire, reste à savoir quoi en faire. On a vu plus haut que notre mémoire adressable par contenu devait faire plusieurs choses : renvoyer un signal indiquant que la donnée était trouvée, et éventuellement renvoyer l'adresse de la donnée trouvée. Tout d'abord, on doit créer notre Signal Trouve / Non-trouvé. Et il faut avouer qu'il ne faut pas s’appeler Einstein pour trouver comment faire. Par définition, ce signal vaut 1 si jamais au moins un comparateur renvoie Trouvé. Donc, un simple ET entre toutes les sorties des comparateurs suffit.</p><p id="r-549407" data-claire-element-id="549407">Mais pour ce qui est de récupérer l'adresse de notre donnée, c'est une autre paire de manches. Pour commencer, on va se mettre dans un cas simple : seule une case mémoire peut contenir la donnée recherchée. On n'a aucun duplicat : pas de données présente en double dans la mémoire. L'idée de base est alors assez simple. Un seul comparateur va avoir son Signal Trouve / Non-trouvé à 1. A partir de ce signal à 1, on va pouvoir déduire l'adresse de la case mémoire. Si vous regardez bien, le problème qui est posé est l'exact inverse de celui qu'on trouve dans une mémoire adressable.</p><h2 id="r-decodeur" data-claire-element-id="549412">Décodeur</h2><p id="r-549408" data-claire-element-id="549408">Dans une mémoire adressable, on va prendre une adresse mémoire, et en déduire quelle case mémoire connecter au bus. Ce choix s'effectue en envoyant un signal &quot;Sésame, ouvre-toi&quot; à la case mémoire adressée, et en envoyant un signal &quot;Sésame, ferme-toi&quot; à toutes les autres. Ces deux signaux sont codés sur un seul bit, et sont donc envoyés sur un seul fil. La case mémoire est choisie si ce fil contient un 1, tandis qu'elle est déconnectée si ce fil contient un zéro. La traduction entre adresse et signaux &quot;Sésame, ouvre-toi&quot; / &quot;Sésame, ferme-toi&quot; s'effectue grâce à un composant qu'on appelle un décodeur. L'intérieur d'une mémoire adressable ressemble donc à ceci :</p><figure id="r-549410" data-claire-element-id="549411"><img id="r-549409" data-claire-element-id="549409" src="medias/uploads.siteduzero.com_files_415001_416000_415889.png" alt="Image utilisateur"/></figure><h2 id="r-encodeur" data-claire-element-id="549427">Encodeur</h2><p id="r-549413" data-claire-element-id="549413">Et bien avec les mémoires adressables par contenu, on se retrouve dans le cas inverse : on n'a pas l'adresse, mais les signaux sont là. On doit donc faire la traduction dans l'autre sens. La traduction va donc devoir se faire par un circuit, assez semblable au décodeur. Celui-ci s'appelle un <strong>Encodeur</strong>.</p><figure id="r-549415" data-claire-element-id="549416"><img id="r-549414" data-claire-element-id="549414" src="medias/uploads.siteduzero.com_files_415001_416000_415895.png" alt="Image utilisateur"/></figure><p id="r-549417" data-claire-element-id="549417">Cet encodeur est un circuit qui répond à plusieurs critères :</p><ul id="r-549426" data-claire-element-id="549426"><li id="r-549419" data-claire-element-id="549419"><p id="r-549418" data-claire-element-id="549418">Il doit fournir une adresse codée sur n bits : ce contrôleur a donc n sorties ;</p></li><li id="r-549421" data-claire-element-id="549421"><p id="r-549420" data-claire-element-id="549420">notre adresse de n bits peut adresser 2^{n} bytes : notre contrôleur mémoire doit donc posséder 2^{n} entrées ;</p></li><li id="r-549423" data-claire-element-id="549423"><p id="r-549422" data-claire-element-id="549422">chacune de ces entrée va identifier une adresse parmi toute les autres ;</p></li><li id="r-549425" data-claire-element-id="549425"><p id="r-549424" data-claire-element-id="549424">et enfin, deux entrées différentes donnerons des adresses différentes.</p></li></ul><h2 id="r-priority-encoder" data-claire-element-id="549448">Priority Encoder</h2><p id="r-549428" data-claire-element-id="549428">Bien évidemment, notre mémoire doit prendre en compte le fait qu'il se peut que plusieurs Bytes puissent être sélectionnés par la requête envoyée à la mémoire. Dans ce cas, la mémoire va devoir sélectionner un de ces Bytes parmi tous les autres. La solution de choix la plus simple consiste à prendre le Byte qui a l'adresse la plus petite (ou la plus grande). Pour cela, l'encodeur doit subir quelques modifications : il devient alors un <strong>Priority Encoder</strong>. Fabriquer un tel priority encoder est assez simple : on peut tout simplement écrire sa table de vérité et en déduire le circuit directement. Mais il va de soit qu'effectuer de telles manipulations pour créer des circuits avec un grand nombre d'entrée n'est pas la meilleure des solutions. Il est possible de faire autrement.</p><p id="r-549429" data-claire-element-id="549429">Première solution : on peut créer un Priority Encoder en utilisant un encodeur normal, précédé d'un circuit qui se charge de sélectionner un seul des bits passé sur son entrée.</p><figure id="r-549431" data-claire-element-id="549432"><img id="r-549430" data-claire-element-id="549430" src="medias/uploads.siteduzero.com_files_419001_420000_419436.png" alt="Image utilisateur"/></figure><p id="r-549433" data-claire-element-id="549433">Ce circuit est composé de petites briques de bases, reliées les unes à la suite des autres.</p><figure id="r-549435" data-claire-element-id="549436"><img id="r-549434" data-claire-element-id="549434" src="medias/uploads.siteduzero.com_files_419001_420000_419285.png" alt="Image utilisateur"/></figure><p id="r-549437" data-claire-element-id="549437">Ce circuit est basé sur un principe très simple : chaque brique de base va permettre de détecter le premier bit à 1 et va propager l’information aux briques de bases suivantes.</p><p id="r-549438" data-claire-element-id="549438">Voici à quoi ressemblent ces briques de base :</p><figure id="r-549440" data-claire-element-id="549441"><img id="r-549439" data-claire-element-id="549439" src="medias/uploads.siteduzero.com_files_419001_420000_419198.png" alt="Image utilisateur"/></figure><p id="r-549442" data-claire-element-id="549442">Chaque brique de base va fonctionner comme suit : elle va regarder le signal d'entrée RAZ et va en déduire si elle doit recopier le bit passé en entrée ou le mettre à zéro. Si le bit RAZ vaut 1, alors la sortie sera mise à zéro automatiquement. Dans le cas contraire, le bit passé en entrée sera recopié. Si jamais le bit d'entrée vaut 1 ou que le signal d'entrée RAZ est à 1, alors le signal RAZ de sortie sera mit à 1.</p><p id="r-549443" data-claire-element-id="549443">Ce circuit est constitué d'un paquet de Portes OU et NOR. Si vous cherchez à la concevoir à partir d'un table de vérité, vous obtiendrez ceci :</p><figure id="r-549445" data-claire-element-id="549446"><img id="r-549444" data-claire-element-id="549444" src="medias/uploads.siteduzero.com_files_419001_420000_419196.png" alt="Image utilisateur"/></figure><p id="r-549447" data-claire-element-id="549447">Évidemment, des implémentations plus efficaces existent, mais on ne va pas ne parler ici.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives">Les mémoires associatives</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/a-quoi-ca-sert-17">
A quoi ca sert ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/interface-4">
Interface
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/plan-memoire-1">
Plan mémoire
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/controleur-memoire">
Contrôleur mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/architectures-associatives">
Architectures associatives
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/plan-memoire-1">
<span class="arrow"></span>
<span class="next">Plan mémoire</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/architectures-associatives">
<span class="next">Architectures associatives</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Architecturesassociatives"></a><h2>Architectures associatives</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/controleur-memoire">
<span class="arrow"></span>
<span class="next">Contrôleur mémoire</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-549450" data-claire-element-id="549450">Il est possible d'utiliser une mémoire associative en supplément d'une mémoire RAM normale, pour accélérer certaines portions d'un programme.</p><figure id="r-549452" data-claire-element-id="549453"><img id="r-549451" data-claire-element-id="549451" src="medias/uploads.siteduzero.com_files_419001_420000_419298.png" alt="Image utilisateur"/></figure><p id="r-549454" data-claire-element-id="549454">Mais il est aussi possible d'utiliser une mémoire associative comme mémoire principale. On obtient alors une architecture assez spéciale, différentes des architectures usuelles, mais qui fonctionne tout à fait normalement.</p><p id="r-549455" data-claire-element-id="549455">Toutefois, la mémoire associative ne peut marcher que si celle-ci sert de mémoires pour les données : elle ne peut pas contenir les instructions d'un programme (sauf dans l'esprit de quelques chercheurs). Des architectures bâties autour de mémoires associatives sont donc forcément des architectures de type Harvard.</p><figure id="r-549457" data-claire-element-id="549458"><img id="r-549456" data-claire-element-id="549456" src="medias/uploads.siteduzero.com_files_419001_420000_419259.png" alt="Image utilisateur"/></figure><p id="r-549459" data-claire-element-id="549459">Avec de telles architectures, on peut effectuer des opérations sur un Byte de la mémoire associative à la fois : on récupère son adresse, puis le processeur effectue une lecture pour récupérer son contenu, l’opération est effectuée dans le processeur, et enfin le résultat est écrit dans la mémoire associative. Pour traiter tous les Bytes qui correspondent à une condition, il suffit de les parcourir les uns après les autres, en utilisant une boucle.</p><h2 id="r-processeurs-associatifs" data-claire-element-id="549519">Processeurs associatifs</h2><p id="r-549460" data-claire-element-id="549460">Toutefois, ces architectures ne sont pas les seules qui sont bâties autour de mémoires associatives. Après les mémoires associatives, il est maintenant temps de voir les <strong>processeurs associatifs</strong>. En gros, un processeur associatif est une sorte de mémoire associative sous stéroïdes.</p><h3 id="r-comparaisons-2" data-claire-element-id="549511">Comparaisons</h3><p id="r-549461" data-claire-element-id="549461">Sur une mémoire associative, on peut comparer la donnée passée en entrée avec chaque Byte. Mais avec un processeur associatif, on peut faire mieux : d'autres opérations sont disponibles. On trouve notamment des comparaisons supplémentaires. Ainsi, un processeur associatif supporte souvent les opérations suivantes :</p><table id="r-549509" data-claire-element-id="549509"><thead id="r-549467" data-claire-element-id="549467"><tr id="r-549466" data-claire-element-id="549466"><th id="r-549463" data-claire-element-id="549463"><p id="r-549462" data-claire-element-id="549462">Opération</p></th><th id="r-549465" data-claire-element-id="549465"><p id="r-549464" data-claire-element-id="549464">Effet</p></th></tr></thead><tbody id="r-549508" data-claire-element-id="549508"><tr id="r-549472" data-claire-element-id="549472"><td id="r-549469" data-claire-element-id="549469"><p id="r-549468" data-claire-element-id="549468">&gt;</p></td><td id="r-549471" data-claire-element-id="549471"><p id="r-549470" data-claire-element-id="549470">Sélectionne la première donnée en mémoire qui est supérieure à la donnée envoyée sur le bus de données.</p></td></tr><tr id="r-549477" data-claire-element-id="549477"><td id="r-549474" data-claire-element-id="549474"><p id="r-549473" data-claire-element-id="549473">&lt;</p></td><td id="r-549476" data-claire-element-id="549476"><p id="r-549475" data-claire-element-id="549475">Sélectionne la première donnée en mémoire qui est inférieure à la donnée envoyée sur le bus de données.</p></td></tr><tr id="r-549482" data-claire-element-id="549482"><td id="r-549479" data-claire-element-id="549479"><p id="r-549478" data-claire-element-id="549478">&gt;=</p></td><td id="r-549481" data-claire-element-id="549481"><p id="r-549480" data-claire-element-id="549480">Sélectionne la première donnée en mémoire qui est supérieure ou égale à la donnée envoyée sur le bus de données.</p></td></tr><tr id="r-549487" data-claire-element-id="549487"><td id="r-549484" data-claire-element-id="549484"><p id="r-549483" data-claire-element-id="549483">&lt;=</p></td><td id="r-549486" data-claire-element-id="549486"><p id="r-549485" data-claire-element-id="549485">Sélectionne la première donnée en mémoire qui est inférieure ou égale à la donnée envoyée sur le bus de données.</p></td></tr><tr id="r-549492" data-claire-element-id="549492"><td id="r-549489" data-claire-element-id="549489"><p id="r-549488" data-claire-element-id="549488">==</p></td><td id="r-549491" data-claire-element-id="549491"><p id="r-549490" data-claire-element-id="549490">Sélectionne la première donnée en mémoire qui est égale à la donnée envoyée sur le bus de données.</p></td></tr><tr id="r-549497" data-claire-element-id="549497"><td id="r-549494" data-claire-element-id="549494"><p id="r-549493" data-claire-element-id="549493">!=</p></td><td id="r-549496" data-claire-element-id="549496"><p id="r-549495" data-claire-element-id="549495">Sélectionne la première donnée en mémoire qui est différente de la donnée envoyée sur le bus de données.</p></td></tr><tr id="r-549502" data-claire-element-id="549502"><td id="r-549499" data-claire-element-id="549499"><p id="r-549498" data-claire-element-id="549498">Between A And B</p></td><td id="r-549501" data-claire-element-id="549501"><p id="r-549500" data-claire-element-id="549500">Sélectionne la première donnée en mémoire qui est comprise entre deux valeurs A et B.</p></td></tr><tr id="r-549507" data-claire-element-id="549507"><td id="r-549504" data-claire-element-id="549504"><p id="r-549503" data-claire-element-id="549503">Not Between A And B</p></td><td id="r-549506" data-claire-element-id="549506"><p id="r-549505" data-claire-element-id="549505">Sélectionne la première donnée en mémoire qui n'est pas comprise entre deux valeurs A et B.</p></td></tr></tbody></table><p id="r-549510" data-claire-element-id="549510">Sur ces processeurs, chaque opération de comparaison va permettre de sélectionner les données. En clair : les Bytes sélectionnés par une instruction de comparaison vont rester sélectionnés durant un ou plusieurs cycles. Pendant ce temps, on pourra demander à notre processeur d'effectuer d'autres opérations sur ces Bytes sélectionnés.</p><h3 id="r-masking" data-claire-element-id="549514">Masking</h3><p id="r-549512" data-claire-element-id="549512">Encore mieux : il est possible pour notre mémoire de traiter des &quot;requêtes&quot; un peu plus complexes. Elle peut sélectionner les bits à prendre en compte dans une comparaison. En clair : elle peut effectuer ses comparaisons sur certains bits de ses données, et laisser tranquille les autres.</p><p id="r-549513" data-claire-element-id="549513">Pour cela, il suffit d'envoyer à notre mémoire un mot, qui permettra de savoir quels bits sont à prendre en compte dans notre donnée. Ce mot s'appelle le <strong>masque </strong>et il a la même taille qu'un Byte. Dans ce mot, si le I-éme bit est à 1, cela veut dire que ce bit est à prendre en compte dans notre comparaison. S'il est à zéro, il ne doit pas être pris en compte. Ce masque est envoyé à la mémoire via un second bus, séparé du bus de données.</p><h3 id="r-calculs-2" data-claire-element-id="549516">Calculs</h3><p id="r-549515" data-claire-element-id="549515">Ces opérations peuvent être une simple écriture, ou des opérations plus complexes. Généralement, nos processeurs associatifs permettent d'effectuer une opération Bitwise comme un ET ou un OU, entre la donnée passée en entrée, et les Bytes sélectionnés. Le résultat est stocké directement dans le Byte. Il faut dire que les circuits qui effectuent nos opérations logiques sont déjà présents dans nos mémoires associatives : les circuits qui effectuent du masquage, pour ne pas traiter certains bits lors d'une comparaison, sont ces circuits qu'on peut réutiliser facilement pour faire des opérations Bitwise. Mais sur certains processeurs, d'autres opérations sont disponibles, comme des opérations arithmétiques.</p><h3 id="r-branchements-2" data-claire-element-id="549518">Branchements</h3><p id="r-549517" data-claire-element-id="549517">Bien sûr, comme tout processeur qui se respecte, notre processeur associatif va aller lire ses instructions depuis une mémoire. Et comme sur tous les processeurs, celui-ci gère des instructions de contrôle de flot, à savoir des tests simples, et des branchements. Ces tests simples permettent de savoir si on a trouvé une donnée dans la mémoire ou non. Ainsi, après avoir envoyé une comparaison à la mémoire associative intégrée dans notre processeur, le processeur peut savoir si au moins une donnée a été trouvée ou non. Et il peut agir en conséquence.</p><h2 id="r-classifications" data-claire-element-id="549556">Classifications</h2><p id="r-549520" data-claire-element-id="549520">En gros, avec un tel processeur, on peut effectuer des opérations identiques sur un grand nombre de Bytes en parallèles. Il s'agit donc de processeurs qui appartiennent au paradigme SIMD. Pour continuer dans ces histoires de classifications, on peut signaler qu'il existe plusieurs types de processeurs associatifs. Dans ce qui va suivre, on va vous en montrer deux.</p><h3 id="r-fully-parallel" data-claire-element-id="549530">Fully Parallel</h3><p id="r-549521" data-claire-element-id="549521">Le premier type correspond à ce qu'on appelle les processeurs <strong>Fully Parallel</strong>. Dans les grandes lignes, une case mémoire de ce genre de processeur associatif est constituée d'une case mémoire, d'un ou de plusieurs registres, et d'une ALU qui sert aussi de comparateur. L'ensemble est câblé comme ceci :</p><figure id="r-549523" data-claire-element-id="549524"><img id="r-549522" data-claire-element-id="549522" src="medias/uploads.siteduzero.com_files_419001_420000_419119.png" alt="Image utilisateur"/></figure><p id="r-549525" data-claire-element-id="549525">Cette ALU est capable de traiter tous les bits de notre case mémoire d'un seul coup. Évidemment, devoir rajouter une ALU pour chaque Byte n'est pas gratuit : cela bouffe énormément de transistors. En clair : on ne risque pas de construire des processeurs de ce type qui contiennent beaucoup de mémoire.</p><p id="r-549526" data-claire-element-id="549526">Un processeur de ce type est composé d'un paquet de cases mémoires, couplées à une unité de contrôle.</p><figure id="r-549528" data-claire-element-id="549529"><img id="r-549527" data-claire-element-id="549527" src="medias/uploads.siteduzero.com_files_419001_420000_419300.png" alt="Image utilisateur"/></figure><h3 id="r-bit-serial" data-claire-element-id="549547">Bit Serial</h3><p id="r-549531" data-claire-element-id="549531">Pour réduire la quantité de circuits utilisés, une solution assez simple est envisageable : chaque Byte se voit toujours associé à une ALU, mais celle-ci est castrée et ne peut traiter qu'un seul bit de notre case mémoire à la fois. On rentre alors dans la catégorie des architecture dites <strong>Bit-Serial</strong>.</p><p id="r-549532" data-claire-element-id="549532">Pour pouvoir traiter un seul bit à la fois, notre case mémoire est implémentée en utilisant un registre à décalage. De plus, la donnée envoyée sur le bus de donnée est recopiée dans un registre à décalage.</p><figure id="r-549534" data-claire-element-id="549535"><img id="r-549533" data-claire-element-id="549533" src="medias/uploads.siteduzero.com_files_419001_420000_419121.png" alt="Image utilisateur"/></figure><p id="r-549536" data-claire-element-id="549536">Pour faciliter l'implémentation des comparaisons ou de certaines opérations, cette ALU est souvent reliée à une petite mémoire de 1 bit.</p><p id="r-549537" data-claire-element-id="549537">Dans le cas d'une comparaison, celle-ci sert à mémoriser le résultat de la comparaison des bits antérieurs : la comparaison s'effectue bit par bit, et le résultat des comparaisons précédentes est sauvegardé dans ce bit. Il peut aussi servir dans l'implémentation d'autres opérations, comme des additions.</p><figure id="r-549539" data-claire-element-id="549540"><img id="r-549538" data-claire-element-id="549538" src="medias/uploads.siteduzero.com_files_419001_420000_419286.png" alt="Image utilisateur"/></figure><p id="r-549541" data-claire-element-id="549541">Pour donner un exemple, je vais prendre l'exemple d'un test d'égalité entre un Byte qui contient la valeur 1100, et une donnée qui vaut 0100. Pour effectuer ce test, notre processeur va devoir comparer chaque bit un par un en utilisant une porte NXOR, tout en prenant en compte le bit indiquant le résultats des comparaisons précédentes avec une porte ET.</p><figure id="r-549543" data-claire-element-id="549544"><img id="r-549542" data-claire-element-id="549542" src="medias/uploads.siteduzero.com_files_419001_420000_419405.gif" alt="Image utilisateur"/></figure><p id="r-549545" data-claire-element-id="549545">Le résultat de la comparaison est disponible dans notre bascule de 1 bit une fois la comparaison terminée. Notre bascule sera donc reliée à la sortie sur laquelle on envoie le signal Trouvé / Non-trouvé.</p><p id="r-549546" data-claire-element-id="549546">Mais cette bascule peut aussi servir dans d'autres opérations. Par exemple, si notre processeur implémente des opérations d'addition, notre addition peut se faire bit par bit. Notre bascule sert alors à stocker la retenue de l'addition des deux bits précédents.</p><h3 id="r-word-serial" data-claire-element-id="549555">Word Serial</h3><p id="r-549548" data-claire-element-id="549548">Enfin, il existe un dernier type de processeur associatif : les processeurs dits <strong>Word Serial</strong>. Ces processeurs sont une véritable arnaque : avec eux, on trouve une unité de calcul pour toute la mémoire. Cette unité peut être une vulgaire unité de 1 bit, ou peut traiter un Byte complet de la mémoire, peu importe. Tout ce qu'il faut savoir, c'est que l'opération que va effectuer l'ALU (sauf les comparaisons), seront effectués sur chaque Byte, mais ceux-ci seront traités uns par uns.</p><p id="r-549549" data-claire-element-id="549549">Un processeur de ce type est composé d'un paquet de cases mémoires, couplées à une unité de contrôle et une ALU.</p><figure id="r-549551" data-claire-element-id="549552"><img id="r-549550" data-claire-element-id="549550" src="medias/uploads.siteduzero.com_files_419001_420000_419301.png" alt="Image utilisateur"/></figure><p id="r-549553" data-claire-element-id="549553">On peut implémenter de tels processeurs avec une mémoire RAM, et une unité de contrôle qui se charge de parcourir la mémoire adresse par adresse automatiquement. En gros, on se retrouve dans la même situation qu'avec un processeur relié à une mémoire normale, à part que la boucle qui permettait de traiter chaque Byte est incorporée dans la mémoire, via l'unité de contrôle.</p><p id="r-549554" data-claire-element-id="549554">Pour les curieux, sachez qu'il existe encore un peu de documentation sur le sujet, disponible sur Internet. Pour ceux intéressés par le fonctionnement interne des mémoires associatives, je conseille de lire l'article &quot;Content-addressable memory (CAM) circuits and architectures: a tutorial and survey&quot;. Pour les autres, sachez qu'il y a assez peu de documentation sur les processeurs associatifs : il s'agit en effet d'architectures assez anciennes, qui n'existent plus aujourd'hui.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives">Les mémoires associatives</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/a-quoi-ca-sert-17">
A quoi ca sert ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/interface-4">
Interface
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/plan-memoire-1">
Plan mémoire
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/controleur-memoire">
Contrôleur mémoire
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/architectures-associatives">
Architectures associatives
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-memoires-associatives/controleur-memoire">
<span class="arrow"></span>
<span class="next">Contrôleur mémoire</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/les-memoires-associatives.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 07:18:51 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-memoires-associatives.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:20:13 GMT -->
</html>
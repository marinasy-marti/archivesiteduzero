<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/-pendu.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 01:25:44 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/-pendu.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:25:31 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : [TP] Pendu</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/tp-pendu.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : [TP] Pendu</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#TPPendu">[TP] Pendu</a><br/><a href="#Objectifs">Objectifs</a><br/><a href="#Correction">Correction</a><br/><a href="#Amliorations">Améliorations</a><br/></div>
<a name="TPPendu"></a><h2>[TP] Pendu</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-pendu/objectifs-19">
<span class="next">Objectifs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-591186" data-claire-element-id="591186">Bienvenue ! Le but de ce tutoriel est de créer un Pendu comme dans <a href="http://www.siteduzero.com/tutoriel-3-14071-tp-realisation-d-un-pendu.html">le tuto</a> de M@teo21 sauf qu'il sera réalisé en SDL.</p><aside id="r-591188" data-claire-element-id="591188" data-claire-semantic="information"><p id="r-591187" data-claire-element-id="591187">Avant de commencer à lire ce tutoriel, vous devez avoir lu celui de M@teo21 jusqu'au chapitre 8 soit le chapitre sur SDL_ttf.</p></aside><p id="r-591189" data-claire-element-id="591189">L'intérêt de ce tutoriel est de créer un programme en SDL avec l'utilisation de la bibliothèque SDL_ttf. Si vous venez de lire le tuto sur SDL_ttf, alors le jeu du pendu est un très bon exercice. Et même si vous savez utiliser SDL_ttf, venez tout de même faire un pendu !! :lol:</p><p id="r-591190" data-claire-element-id="591190">N'attendons pas plus longtemps, c'est parti !</p>
</div><a name="Objectifs"></a><h2>Objectifs</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-pendu/correction-208">
<span class="next">Correction</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h3 id="r-regles-du-jeu-1" data-claire-element-id="591209">REGLES DU JEU</h3><p id="r-591191" data-claire-element-id="591191">Pour ceux qui n’auraient pas compris, on veut créer un pendu en SDL.<br/> Hop, un petit rappel des règles pour que l'on fasse le même jeu. Le but est de trouver un mot qui est masqué. Le joueur va donc essayer de découvrir le mot en tapant une lettre. Cependant, le joueur n'a que sept essais. En effet, si le joueur tape un A et que le mot secret en contient effectivement, le joueur ne perd pas d'essais et on découvre tous les A du mot secret. Cependant, si le mot ne contenait pas de A, le joueur perd un essai. Voilà un petit rappel du jeu.</p><div id="r-591193" data-claire-element-id="591193" data-claire-semantic="question"><p id="r-591192" data-claire-element-id="591192">Mais pourquoi on appelle-t-on ce jeu le pendu ?</p></div><p id="r-591194" data-claire-element-id="591194">Car à chaque fois que le joueur perd un essai, un dessin se complète en formant <strong>un bonhomme en train de se faire pendre</strong> ! sisi !!<br/> En effet, lorsque vous avez réalisé le pendu en console, je ne crois pas que vous aviez envie de créer un petit bonhomme rien qu'avec des | , / , et \ surtout quand vous êtes justement arrivé à la fin de la partie II.</p><p id="r-591195" data-claire-element-id="591195">Je vous donne tout de suite quatre écrans obtenus. L'objectif est de réaliser un pendu qui ressemble plus ou moins à cela.</p><figure id="r-591197" data-claire-element-id="591198"><img id="r-591196" data-claire-element-id="591196" src="medias/uploads.siteduzero.com_files_187001_188000_187922.png" alt="Image utilisateur"/></figure><figure id="r-591200" data-claire-element-id="591201"><img id="r-591199" data-claire-element-id="591199" src="medias/uploads.siteduzero.com_files_187001_188000_187919.png" alt="Image utilisateur"/></figure><figure id="r-591203" data-claire-element-id="591204"><img id="r-591202" data-claire-element-id="591202" src="medias/uploads.siteduzero.com_files_187001_188000_187923.png" alt="Image utilisateur"/></figure><figure id="r-591206" data-claire-element-id="591207"><img id="r-591205" data-claire-element-id="591205" src="medias/uploads.siteduzero.com_files_187001_188000_187915.png" alt="Image utilisateur"/></figure><p id="r-591208" data-claire-element-id="591208">Comme vous pouvez le voir, il y a deux versions de pendu. Et oui, comme tout tutoriel qui se respecte, je vais vous donner à la fin de celui-ci <strong>quelques améliorations</strong> que vous pourrez faire. Les deux images du dessus représentent le pendu que nous allons réaliser. Les deux autres images représentent le pendu avec les améliorations.</p><h3 id="r-realisations" data-claire-element-id="591255">REALISATIONS</h3><p id="r-591210" data-claire-element-id="591210">Voici les images dont j'ai eu besoin. Je tiens à signaler que je n'ai pas un très bon niveau avec photoshop.</p><figure id="r-591212" data-claire-element-id="591213"><img id="r-591211" data-claire-element-id="591211" src="medias/uploads.siteduzero.com_files_187001_188000_187932.jpg" alt="Image utilisateur"/></figure><figure id="r-591215" data-claire-element-id="591216"><img id="r-591214" data-claire-element-id="591214" src="medias/uploads.siteduzero.com_files_187001_188000_187933.jpg" alt="Image utilisateur"/></figure><figure id="r-591218" data-claire-element-id="591219"><img id="r-591217" data-claire-element-id="591217" src="medias/uploads.siteduzero.com_files_187001_188000_187934.jpg" alt="Image utilisateur"/></figure><figure id="r-591221" data-claire-element-id="591222"><img id="r-591220" data-claire-element-id="591220" src="medias/uploads.siteduzero.com_files_187001_188000_187935.jpg" alt="Image utilisateur"/></figure><figure id="r-591224" data-claire-element-id="591225"><img id="r-591223" data-claire-element-id="591223" src="medias/uploads.siteduzero.com_files_187001_188000_187936.jpg" alt="Image utilisateur"/></figure><figure id="r-591227" data-claire-element-id="591228"><img id="r-591226" data-claire-element-id="591226" src="medias/uploads.siteduzero.com_files_187001_188000_187937.jpg" alt="Image utilisateur"/></figure><figure id="r-591230" data-claire-element-id="591231"><img id="r-591229" data-claire-element-id="591229" src="medias/uploads.siteduzero.com_files_187001_188000_187938.jpg" alt="Image utilisateur"/></figure><figure id="r-591233" data-claire-element-id="591234"><img id="r-591232" data-claire-element-id="591232" src="medias/uploads.siteduzero.com_files_187001_188000_187940.jpg" alt="Image utilisateur"/></figure><p id="r-591235" data-claire-element-id="591235">Ne dites rien sinon je vais me vexer :colere: et gare à vous :pirate: .</p><p id="r-591236" data-claire-element-id="591236">J'ai créé un fichier zip avec toutes les images, cela vous fera gagner un peu de temps. Mais rien ne vous empêche de créer vos propres images... J'ai aussi rajouté un dictionnaire de plus de 22 000 mots en majuscule avec un retour à la ligne entre chaque mot. Enfin, j'ai ajouté trois polices.<br/> De plus, je me suis permis de rajouter le mot <strong>&quot;ZERO&quot;</strong> qui me semble tout à fait approprié dans ce dictionnaire.</p><p id="r-591237" data-claire-element-id="591237">Télécharger le <a href="http://www.megaupload.com/?d=LAW98LAY">pack d'image</a>.</p><p id="r-591238" data-claire-element-id="591238">Comme vous le voyez sur les images, mon pendu est constitué de deux parties. À gauche le mot secret et en dessous de lui les lettres qui ont déjà été essayées, puis à droite on a les images. Vous pouvez voir sur la capture d'écran que les lettres en dessous du mot secret sont classées dans l'ordre alphabétique. Vous pouvez très bien modifier cela, mais la correction sera adaptée à cette copie d'écran.</p><p id="r-591239" data-claire-element-id="591239">Maintenant, vous avez deux choix :</p><ul id="r-591244" data-claire-element-id="591244"><li id="r-591241" data-claire-element-id="591241"><p id="r-591240" data-claire-element-id="591240">Soit vous commencez à coder le jeu tout de suite. Alors ne lisez pas plus loin.</p></li><li id="r-591243" data-claire-element-id="591243"><p id="r-591242" data-claire-element-id="591242">Soit vous vous aidez de ce que vous avez fait lorsque vous avez réalisé ce programme en console. Alors vous pouvez continuer. Je vous donnerais aussi quelques conseils concernant &quot;le plan&quot; du code à réaliser.</p></li></ul><p id="r-591245" data-claire-element-id="591245">Je vais donc vous redonner ici les fonctions qui nous ont servi lors du précédent épisode pendu.</p><pre id="r-591246" data-claire-element-id="591246"><code data-claire-semantic="c">srand(time(NULL));
nombreMystere = (rand() % (MAX - MIN + 1)) + MIN;</code></pre><p id="r-591247" data-claire-element-id="591247">On fait deux trois petits changements et on obtient une fonction qui renvoi un int au hasard entre min et max.</p><pre id="r-591248" data-claire-element-id="591248"><code data-claire-semantic="c">int nombreAleatoire(int max, int min);
int main(int argc, char *argv[])
{
	srand(time(NULL));
	intAuHasard = nombreAleatoire(10, 1500);
}
int nombreAleatoire(int max, int min)
{
    return (rand() % (max - min + 1)) + min;
}</code></pre><div id="r-591250" data-claire-element-id="591250" data-claire-semantic="question"><p id="r-591249" data-claire-element-id="591249">N'y aurait-il pas une autre fonction qui pourrait nous aider ?</p></div><p id="r-591251" data-claire-element-id="591251">Oui. C'est bien beau d'avoir un dictionnaire mais encore faut-il trouver un mot dedans, qui plus est au hasard. :colere2: <br/> Voici donc pour vous :</p><pre id="r-591252" data-claire-element-id="591252"><code data-claire-semantic="c">int piocherMot(char *motPioche);

int main(int argc, char *argv[])
{
...
}

int piocherMot(char *motPioche)
{
    FILE* dico = NULL;
    int nombreMots = 0, numMotChoisi = 0;
    int caractereLu = 0;
    dico = fopen(&quot;sources/dico.txt&quot;, &quot;r&quot;);	// ATTENTION à l'emplacement
    if (dico == NULL)   //
    {
        return 0;
    }
    do
    {
        caractereLu = fgetc(dico);
        if (caractereLu == '\n')
            nombreMots++;
    }
    while (caractereLu != EOF);
    numMotChoisi = nombreAleatoire(nombreMots);
    rewind(dico);
    while (numMotChoisi &gt; 0)
    {
        caractereLu = fgetc(dico);
        if (caractereLu == '\n')
            numMotChoisi--;
    }
    fgets(motPioche, 100, dico);
    motPioche[strlen(motPioche) - 1] = '\0';
    fclose(dico);
    return 1;
}</code></pre><p id="r-591253" data-claire-element-id="591253">La fonction piocherMot renvoi 0 si elle n'arrive pas à charger le dictionnaire et renvoi 1 si tout se passe bien. Elle prend en paramètre un tableau de chars.</p><p id="r-591254" data-claire-element-id="591254">Je tiens à signaler que l'objectif n'est pas de créer un pendu mais bien de créer<strong> un pendu EN SDL</strong>. Je suppose donc que vous avez déjà compris ces deux fonctions lors des deux premières parties du tutoriel de M@teo21. Si ce n'est pas le cas, on retourne voir son cours : <a href="http://www.siteduzero.com/tutoriel-3-13976-tp-plus-ou-moins-votre-premier-jeu.html#ss_part_1">nombre aléatoire</a> et <a href="http://www.siteduzero.com/tutoriel-3-14052-lire-et-ecrire-dans-des-fichiers.html">lire et écrire dans un fichier</a>.</p><h3 id="r-plan-du-code" data-claire-element-id="591278">Plan du code</h3><p id="r-591256" data-claire-element-id="591256">Vous ne savez pas comment démarrer ? Vous n'arrivez pas à visualiser le code avant de vous lancer sur votre IDE ?<br/> Pas de problème. Voici comment j'ai fait pour réaliser ce code.</p><ul id="r-591276" data-claire-element-id="591276"><li id="r-591258" data-claire-element-id="591258"><p id="r-591257" data-claire-element-id="591257">Première étape : le squelette. Il faut créer le code de base : afficher une fenêtre, insérer les deux fonctions ci-dessus, prévoir la place du switch qui gère les évènements...</p></li><li id="r-591260" data-claire-element-id="591260"><p id="r-591259" data-claire-element-id="591259">Deuxième étape : Création des variables. Cette étape permet de visualiser votre futur code. Si vous connaissez le nombre et le type de variables que vous avez besoin, alors vous pouvez vous lancer. Cette étape est vraiment importante car elle permet de représenter plus ou moins le fonctionnement de votre programme.</p></li><li id="r-591262" data-claire-element-id="591262"><p id="r-591261" data-claire-element-id="591261">troisième étape : la boucle des évènements.</p></li><li id="r-591273" data-claire-element-id="591273"><p id="r-591263" data-claire-element-id="591263">quatrième étape : Le contenu.</p><ul id="r-591272" data-claire-element-id="591272"><li id="r-591265" data-claire-element-id="591265"><p id="r-591264" data-claire-element-id="591264">Dans un premier temps, il faut s'assurer que le joueur a bien tapé une lettre, et aussi qu'il ne l'avait pas déjà essayé. Il vous faudra donc explorer un tableau de 26 caractères pour s'en assurer. Vous pourrez par exemple réaliser ceci à l'aide de 2 conditions de type if.</p></li><li id="r-591267" data-claire-element-id="591267"><p id="r-591266" data-claire-element-id="591266">A partir de maintenant, le joueur tente une lettre. Il vous faut donc gérer le nombre de ses essais. Petit rappel, si le joueur a trouvé au moins une lettre, on ne lui retire pas son essais.</p></li><li id="r-591269" data-claire-element-id="591269"><p id="r-591268" data-claire-element-id="591268">Le nombre d'essais étant fixé, on peut donc définir l'image à blitter, et aussi savoir si le joueur a gagné, a perdu, ou peut encore continuer à jouer.</p></li><li id="r-591271" data-claire-element-id="591271"><p id="r-591270" data-claire-element-id="591270">On blitte tout ! Le texte (le mot secret, les lettres déjà essayées, ...), mais aussi les images. Vous devrez blitter différentes choses si le joueur a gagné ou a perdu.</p></li></ul></li><li id="r-591275" data-claire-element-id="591275"><p id="r-591274" data-claire-element-id="591274">Et on n'oublie pas de libérer la mémoire.</p></li></ul><p id="r-591277" data-claire-element-id="591277">Et voila, maintenant c'est à vous de travailler.<br/>Bon courage les Zéros !!! :soleil:</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tp-pendu">[TP] Pendu</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tp-pendu/objectifs-19">
Objectifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-pendu/correction-208">
Correction
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-pendu/ameliorations-32">
Améliorations
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-pendu/correction-208">
<span class="next">Correction</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Correction"></a><h2>Correction</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-pendu/objectifs-19">
<span class="arrow"></span>
<span class="next">Objectifs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-pendu/ameliorations-32">
<span class="next">Améliorations</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-591280" data-claire-element-id="591280">Fini ou pas fini, si vous lisez ces lignes, c'est parce que vous voulez la correction. Et justement elle arrive ! :lol: <br/> Pour des raisons pratiques j'ai préféré n'utiliser que le fichier main.c. Mais rien ne vous empêche de mettre les deux fonctions dans un .h et un .c et de recréer d'autres fonctions.<br/> Voila comment on va procéder. Je vais découper mon code en plein de petites parties que je vais expliquer séparément. Etant donné que j'ai bien décrit l'objectif final dans la première partie, vous devriez comprendre.<br/> Et maintenant, c'est parti ! :magicien:</p><h3 id="r-creer-la-fenetre" data-claire-element-id="591285">Créer la fenêtre</h3><p id="r-591281" data-claire-element-id="591281">Tout d'abord, on va créer une fenêtre toute simple avec les deux fonctions que j'ai donné dans la partie &quot;objectifs&quot;. On inclut d'avance SDL_ttf car on en aura besoin. N'oubliez pas de linker votre bibliothèque pour pouvoir utiliser SDL_ttf.</p><pre id="r-591282" data-claire-element-id="591282"><code data-claire-semantic="c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;SDL/SDL.h&gt;
#include &lt;time.h&gt;
#include &lt;SDL_image.h&gt;
#include &lt;SDL/SDL_ttf.h&gt;

int piocherMot(char *motPioche);
int nombreAleatoire(int nombreMax);

int main(int argc, char *argv[])
{
    SDL_Surface *ecran = NULL;
    SDL_Event event;
    srand(time(NULL));
    int continuer = 1;

    SDL_Init(SDL_INIT_VIDEO);
    ecran  = SDL_SetVideoMode(750, 320, 32, SDL_HWSURFACE | SDL_DOUBLEBUF);

    TTF_Init();

    SDL_WM_SetCaption(&quot;Pendu en SDL pour les Zeros&quot;, NULL);

    while (continuer)  //Boucle des évenements
    {
        SDL_WaitEvent(&amp;event);
        switch (event.type)
        {
        case SDL_QUIT:
            continuer = 0;
            break;
        case SDL_KEYDOWN:
            switch (event.key.keysym.sym)
            {
            case SDLK_ESCAPE:
                continuer = 0;
                break;
            default:
                    break;
            }
            SDL_Flip(ecran);
        }
    }

    TTF_Quit();
    SDL_Quit();

    return EXIT_SUCCESS;
}

int piocherMot(char *motPioche)
{
    FILE* dico = NULL;
    int nombreMots = 0, numMotChoisi = 0;
    int caractereLu = 0;
    dico = fopen(&quot;sources/dico.txt&quot;, &quot;r&quot;);
    if (dico == NULL)   //
    {
        return 0;
    }
    do
    {
        caractereLu = fgetc(dico);
        if (caractereLu == '\n')
            nombreMots++;
    }
    while (caractereLu != EOF);
    numMotChoisi = nombreAleatoire(nombreMots);
    rewind(dico);
    while (numMotChoisi &gt; 0)
    {
        caractereLu = fgetc(dico);
        if (caractereLu == '\n')
            numMotChoisi--;
    }
    fgets(motPioche, 100, dico);
    motPioche[strlen(motPioche) - 1] = '\0';
    fclose(dico);
    return 1;
}

int nombreAleatoire(int nombreMax)
{
    return (rand() % nombreMax);
}</code></pre><p id="r-591283" data-claire-element-id="591283">Ce code nous permet donc d'ouvrir une fenêtre et de la refermer en appuyant sur ECHAP. Rien de bien passionnant mais ce code va nous servir de base.<br/> Avant de commencer, il va falloir que vous téléchargiez le même pack d'images que moi.</p><p id="r-591284" data-claire-element-id="591284">Télécharger le pack d'image <a href="http://macle.voila.fr/index.php?m=c9ae77e8&amp;a=7d397569&amp;share=LNK41634af88cdb209be">Images_Dico_Polices.zip</a>.</p><h3 id="r-quelques-variables" data-claire-element-id="591309">Quelques variables</h3><p id="r-591286" data-claire-element-id="591286">Premièrement, on crée un define et une énumération anonyme qui vont nous être utiles dans la suite du code.</p><pre id="r-591287" data-claire-element-id="591287"><code data-claire-semantic="c">#define NOMBRE_ESSAIS  7

enum {JEU_TERMINE, JEU_EN_COURS};	// Permet de savoir si on est en train de jouer ou non
enum {OUI, NON};			// Permet d'éviter de mettre des 0 et des 1</code></pre><p id="r-591288" data-claire-element-id="591288">Maintenant, on va compléter le code en rajoutant des variables. Je vais donner toutes les variables d'un coup de façon à ne pas tout le temps remonter jusqu'au début du code pour définir un petit nombre et redescendre encore pour mettre un petit bout de code.<br/> Certaines variables ne vont peut-être pas être tout à fait comprises au début mais vous verrez à quoi elles servent lorsque nous les utiliserons.</p><pre id="r-591289" data-claire-element-id="591289"><code data-claire-semantic="c">SDL_Surface *ecran = NULL, *img = NULL; // On créé 2 surfaces pour le texte et pour l'image

    SDL_Event event;    // Evenement
    int continuer = 1;
    srand(time(NULL));  // pour le nombre aléatoire

    char lettrePropose = '\b';	// on va stocker ici la lettre tapée
    char motMystere[50];	// 	Le mot mystère à découvrir
    if ( piocherMot(motMystere) == 0 )		// on demande un mot qui sera mis dans motMystere
        return EXIT_FAILURE;	// si on n'a pas réussi à charger le dictionnaire on arrête le programme

    const int tailleMot = strlen(motMystere);
    char *motMystereEnCours = NULL;    // Allocation dynamique de la mémoire
    motMystereEnCours = (char *) malloc(tailleMot * sizeof(char));
    if (motMystereEnCours == NULL)  // Verification de l'allocation de mémoire
         return EXIT_FAILURE;  // On arrête tout

    strcpy(motMystereEnCours, motMystere);      // on copie le mot mystère dans une autre chaine
    char tableauDeSaugegardeDesLettresTape[] = &quot;                          &quot; ; 		// 26 caractères on retient les lettres que le joueur a tapé

    int nombreEssais = NOMBRE_ESSAIS;
    int reussi = JEU_EN_COURS;		// Permet de savoir si le joueur à découvert le mot, on pourra aussi lui demander si il veut recommencer une autre partie
    int nombreEssaisRajoute = 0;	// Cette variable a un rapport avec le nombre d'essais.
    int sauterUnTour = NON;		// Cette variable permet de sauter le tour du joueur si il tape une lettre une seconde fois
    int numeroDeLaLettre = 0;	// Le numéro de la lettre permet de dire que A = 1 , B = 2 , . . . Elle est utilisée pour afficher les lettres que le joueur a déjà tapé
    int i = 0;</code></pre><p id="r-591290" data-claire-element-id="591290">Pour les noms de variables, j'ai essayé d'être le plus clair possible. Il y a de multiples possibilités pour coder ce programme. Personnellement, j'ai choisi de créer deux chaines de caractères. L'une contient le mot à découvrir (motMystere) et l'autre est la copie codée de ce mot.</p><p id="r-591291" data-claire-element-id="591291">C'est-à-dire qu'au début de la partie, elle sera composée de *. L'avantage de cette technique est qu'on ne doit pas s'embarrasser de ce qu'on affiche. Dans la suite, on modifiera cette chaine de caractères puis on l'affichera simplement à l'écran.</p><p id="r-591292" data-claire-element-id="591292">Petit remarque, j'ai fixé la longueur des tableaux à 51 caractères car l'un des mots le plus long en français est <a href="http://fr.wikipedia.org/wiki/Hexakosioihexekontahexaphobie"> hexakosioihexekontahexaphobie </a> (peur du nombre 666). Celui-ci ne comporte <strong>que</strong> 29 lettres. Vous avez aussi dans le même genre le mot hippopotomonstrosesquippedaliophobie (peur des mots trop longs). Celui-ci totalise 35 lettres. Bref, tout cela pour dire qu'il nous restera encore de la place dans le tableau.</p><ul id="r-591307" data-claire-element-id="591307"><li id="r-591294" data-claire-element-id="591294"><p id="r-591293" data-claire-element-id="591293">La surface img va permettre d'afficher les différentes images à droite.</p></li><li id="r-591296" data-claire-element-id="591296"><p id="r-591295" data-claire-element-id="591295">lettrePropose va contenir la lettre que le joueur tape. On l'initialise simplement grâce à '\b'.</p></li><li id="r-591298" data-claire-element-id="591298"><p id="r-591297" data-claire-element-id="591297">motMystere est le mot secret à découvrir.</p></li><li id="r-591300" data-claire-element-id="591300"><p id="r-591299" data-claire-element-id="591299">Les deux lignes suivantes permettent d'utiliser la fonction piocherMot. Elle arrêtera le programme si on n'a pas réussi à charger le dictionnaire.</p></li><li id="r-591302" data-claire-element-id="591302"><p id="r-591301" data-claire-element-id="591301">Le tableau motMystereEnCours est une copie de motMystere. C'est lui qui sera codé et affiché tout au long de la partie.</p></li><li id="r-591304" data-claire-element-id="591304"><p id="r-591303" data-claire-element-id="591303">Ensuite, on copie le mot mystère dans l'autre chaine et on crée un int qui va retenir la taille du mot mystère.</p></li><li id="r-591306" data-claire-element-id="591306"><p id="r-591305" data-claire-element-id="591305">Le tableau tableauDeSaugegardeDesLettresTape permet l'affichage des lettres tapées en bas de l'écran. Il permet aussi de gérer la répétition d'une même lettre.</p></li></ul><p id="r-591308" data-claire-element-id="591308">Maintenant, on a toutes les variables pour créer notre pendu. Si vous ne comprenez pas le sens de certaines variables, ce n'est pas grave. Sachez simplement que nous les avons créées. Vous comprendrez leurs utilitées lorsque nous les utiliserons.</p><h3 id="r-initialisation-13" data-claire-element-id="591315">Initialisation</h3><p id="r-591310" data-claire-element-id="591310">On va maintenant initialiser la SDL et SDL_ttf. Nous aurons besoin de trois polices (affichage du mot mystère, affichage des caractères, affichage de la phrase à la fin du jeu), d'une couleur noire, et de deux positions (image et texte).<br/> C'est parti !</p><pre id="r-591311" data-claire-element-id="591311"><code data-claire-semantic="c">SDL_Init(SDL_INIT_VIDEO);
ecran             = SDL_SetVideoMode(750, 320, 32, SDL_HWSURFACE | SDL_DOUBLEBUF);

TTF_Init();
TTF_Font *police  = NULL, *policePourFinal = NULL, *policePourTableau;    // création de 3 polices
police            = TTF_OpenFont(&quot;sources/police.ttf&quot;, 45);
policePourTableau = TTF_OpenFont(&quot;sources/policeRejouer.ttf&quot;, 25);
policePourFinal   = TTF_OpenFont(&quot;sources/policePourTableau.ttf&quot;, 65);

SDL_Color couleurNoire = {0, 0, 0}; // création d'une couleur

SDL_Rect positionTexte, positionImage;    // création de 2 positions
positionTexte.x = 0;
positionTexte.y = 0;

positionImage.x = 400;
positionImage.y = 0;

SDL_WM_SetCaption(&quot;Pendu en SDL pour les Zeros&quot;, NULL);</code></pre><p id="r-591312" data-claire-element-id="591312">Avant de pouvoir faire le switch pour gérer les événements, il faut initialiser motMystereEnCours. On va donc remplir le tableau d'astérisques.</p><pre id="r-591313" data-claire-element-id="591313"><code data-claire-semantic="c">for ( i = 0 ; i &lt; tailleMot ; i++ )    // on code le motMystere
{
    motMystereEnCours[i] = '*';
}</code></pre><p id="r-591314" data-claire-element-id="591314">Notre motMystere est désormais codé. Maintenant place au switch.</p><h3 id="r-gestions-des-evenements" data-claire-element-id="591329">Gestions des événements</h3><p id="r-591316" data-claire-element-id="591316">Ici, on va devoir faire un switch qui doit prendre en compte toutes les lettres de l'alphabet. Mais au lieu de créer un événement pour chaque lettre, on va simplement mettre cette expression : lettrePropose = event.key.keysym.sym. Cela nous permet simplement de sauvegarder la lettre.</p><pre id="r-591317" data-claire-element-id="591317"><code data-claire-semantic="c">while (continuer)
    {
        SDL_WaitEvent(&amp;event);
        switch (event.type)
        {
        case SDL_QUIT:
            continuer = 0;
            break;
        case SDL_KEYDOWN:
            switch (event.key.keysym.sym)
            {
            case SDLK_ESCAPE:
                continuer = 0;
                break;
            default :
                lettrePropose = event.key.keysym.sym;
                switch (lettrePropose)    // Transformation clavier QWERTY -&gt; AZERTY
                {
                    case 'q' :
                        lettrePropose = 'a';
                        break;
                    case ';' :
                        lettrePropose ='m';
                        break;
                    case 'z' :
                        lettrePropose ='w';
                        break;
                    case 'a' :
                        lettrePropose = 'q';
                        break;
                    case 'w' :
                        lettrePropose ='z';
                        break;
                }
                lettrePropose = toupper(lettrePropose);  //majuscule
                break;
            }
        }</code></pre><div id="r-591319" data-claire-element-id="591319" data-claire-semantic="question"><p id="r-591318" data-claire-element-id="591318">Pourquoi utilise-t-on un &quot;\b&quot; ?</p></div><p id="r-591320" data-claire-element-id="591320">Simplement parce qu'il fallait choisir un caractère qui n'est pas une lettre car sinon, on va retirer un essai alors qu'il n'aura pas touché une lettre. D'ailleurs, faisons cela tout de suite. Il suffit de rajouter une condition pour ignorer le backspace.</p><pre id="r-591321" data-claire-element-id="591321"><code data-claire-semantic="c">if ( lettrePropose &gt;= 'A' &amp;&amp;  lettrePropose &lt;= 'Z' || lettrePropose == '\b')    // On annule la touche si ce n'est pas une lettre qui est tapée
{</code></pre><p id="r-591322" data-claire-element-id="591322">Nous avons le droit de réaliser cela car les lettres ne sont que des nombres. Peut importe leurs numéros, il suffit simplement de dire que nous voulons les lettres comprises en A et Z, soit tout l'alphabet des lettres majuscules.<br/> Tout notre code sera placé dans cette condition. D'ailleurs, autant terminer tout de suite notre programme. Il suffit simplement de fermer la SDL et SDL_ttf à la sortie du switch.<br/> Rajoutons la fin du programme : on libère la mémoire et on arrête tout.</p><pre id="r-591323" data-claire-element-id="591323"><code data-claire-semantic="c">TTF_CloseFont(police);    // on vide la mémoire
    TTF_CloseFont(policePourFinal);
    TTF_CloseFont(policePourTableau);
    TTF_Quit();
    SDL_FreeSurface(img);
    SDL_Quit();

    return EXIT_SUCCESS;
}</code></pre><p id="r-591324" data-claire-element-id="591324">Je vous redonne le code en entier.</p><p id="r-591325" data-claire-element-id="591325"></p><div id="r-591327" data-claire-element-id="591327"><pre id="r-591326" data-claire-element-id="591326"><code data-claire-semantic="c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;SDL/SDL.h&gt;
#include &lt;time.h&gt;
#include &lt;SDL_image.h&gt;
#include &lt;SDL_ttf.h&gt;

#define NOMBRE_ESSAIS  7

enum {JEU_TERMINE, JEU_EN_COURS};	// Permet de savoir si on est en train de jouer ou non
enum {OUI, NON};			// Permet d'éviter de mettre des 0 et des 1
//---------------------------------------------------------------------

int piocherMot(char *motPioche);
int nombreAleatoire(int nombreMax);

int main(int argc, char *argv[])
{
    SDL_Surface *ecran = NULL, *img = NULL; // On créé 2 surfaces pour le texte et pour l'image

    SDL_Event event;    // Evenement
    int continuer = 1;
    srand(time(NULL));  // pour le nombre aléatoire

    char lettrePropose = '\b';	// on va stocker ici la lettre tapée
    char motMystere[50];	// 	Le mot mystère à découvrir
    if ( piocherMot(motMystere) == 0 )		// on demande un mot qui sera mis dans motMystere
        return EXIT_FAILURE;	// si on n'a pas réussi à charger le dictionnaire on arrête le programme

    const int tailleMot = strlen(motMystere);
    char *motMystereEnCours = NULL;    // Allocation dynamique de la mémoire
    motMystereEnCours = (char *) malloc(tailleMot * sizeof(char));
    if (motMystereEnCours == NULL)  // Verification de l'allocation de mémoire
        return EXIT_FAILURE;  // On arrête tout

    strcpy(motMystereEnCours, motMystere);      // on copie le mot mystère dans une autre chaine
    char tableauDeSaugegardeDesLettresTape[] = &quot;                          &quot; ; 		// 26 caractères on retient les lettres que le joueur a tapé

    int nombreEssais = NOMBRE_ESSAIS;
    int reussi = JEU_EN_COURS;		// Permet de savoir si le joueur à découvert le mot, on pourra aussi lui demander si il veut recommencer une autre partie
    int nombreEssaisRajoute = 0;	// Cette variable a un rapport avec le nombre d'essais.
    int sauterUnTour = NON;		// Cette variable permet de sauter le tour du joueur si il tape une lettre une seconde fois
    int numeroDeLaLettre = 0;	// Le numéro de la lettre permet de dire que A = 1 , B = 2 , . . . Elle est utilisée pour afficher les lettres que le joueur a déjà tapé
    int i = 0;

    SDL_Init(SDL_INIT_VIDEO);
    ecran             = SDL_SetVideoMode(750, 320, 32, SDL_HWSURFACE | SDL_DOUBLEBUF);

    TTF_Init();
    TTF_Font *police  = NULL, *policePourFinal = NULL, *policePourTableau;    // création de 3 polices
    police            = TTF_OpenFont(&quot;sources/police.ttf&quot;, 45);
    policePourTableau = TTF_OpenFont(&quot;sources/policeRejouer.ttf&quot;, 25);
    policePourFinal   = TTF_OpenFont(&quot;sources/policePourTableau.ttf&quot;, 65);

    SDL_Color couleurNoire = {0, 0, 0}; // création d'une couleur

    SDL_Rect positionTexte, positionImage;    // création de 2 positions
    positionTexte.x = 0;
    positionTexte.y = 0;

    positionImage.x = 400;
    positionImage.y = 0;

    SDL_WM_SetCaption(&quot;Pendu en SDL pour les Zeros&quot;, NULL);

    for ( i = 0 ; i &lt; tailleMot ; i++ )    // on code le motMystere
    {
        motMystereEnCours[i] = '*';
    }

    while (continuer)
    {
        SDL_WaitEvent(&amp;event);
        switch (event.type)
        {
        case SDL_QUIT:
            continuer = 0;
            break;
        case SDL_KEYDOWN:
            switch (event.key.keysym.sym)
            {
            case SDLK_ESCAPE:
                continuer = 0;
                break;
            default :
                lettrePropose = event.key.keysym.sym;
                switch (lettrePropose)
                {
                case 'q' :
                    lettrePropose = 'a';
                    break;
                case ';' :
                    lettrePropose ='m';
                    break;
                case 'z' :
                    lettrePropose ='w';
                    break;
                case 'a' :
                    lettrePropose = 'q';
                    break;
                case 'w' :
                    lettrePropose ='z';
                    break;
                }
                lettrePropose = toupper(lettrePropose);  //majuscule
                break;
            }

            if ( lettrePropose &gt;= 'A' &amp;&amp;  lettrePropose &lt;= 'Z' || lettrePropose == '\b')    // On annule la touche si ce n'est pas une lettre qui est tapée
            {

            }


            SDL_Flip(ecran);
        }
    }

    TTF_CloseFont(police);    // on vide la mémoire
    TTF_CloseFont(policePourFinal);
    TTF_CloseFont(policePourTableau);
    TTF_Quit();
    SDL_FreeSurface(img);
    free(motMystereEnCours);
    SDL_Quit();

    return EXIT_SUCCESS;
}

int piocherMot(char *motPioche)
{
    FILE* dico = NULL;
    int nombreMots = 0, numMotChoisi = 0;
    int caractereLu = 0;
    dico = fopen(&quot;sources/dico.txt&quot;, &quot;r&quot;);
    if (dico == NULL)   //
    {
        return 0;
    }
    do
    {
        caractereLu = fgetc(dico);
        if (caractereLu == '\n')
            nombreMots++;
    }
    while (caractereLu != EOF);
    numMotChoisi = nombreAleatoire(nombreMots);
    rewind(dico);
    while (numMotChoisi &gt; 0)
    {
        caractereLu = fgetc(dico);
        if (caractereLu == '\n')
            numMotChoisi--;
    }
    fgets(motPioche, 100, dico);
    motPioche[strlen(motPioche) - 1] = '\0';
    fclose(dico);
    return 1;
}

int nombreAleatoire(int nombreMax)
{
    return (rand() % nombreMax);
}</code></pre></div><p id="r-591328" data-claire-element-id="591328">Voila, maintenant il ne reste plus qu'à mettre le code dans le if juste avant la fin du switch. Courage !</p><h3 id="r-repetition-d-une-meme-lettre" data-claire-element-id="591335">Répétition d'une même lettre</h3><p id="r-591330" data-claire-element-id="591330">Maintenant, on commence à écrire dans le if juste avant la fin du switch</p><p id="r-591331" data-claire-element-id="591331">Dès le début, on doit définir si le joueur a bien tapé une lettre qu'il n'avait pas déjà proposé. On va donc avoir besoin du tableau qui retient tous les caractères tapés et vérifier si c'est bien la première fois qu'il tape cette lettre.<br/> Si oui, alors on peut continuer. Si non, alors il faut lui faire sauter le tour tout comme on fait sauter son tour s'il ne tape pas une lettre mais une autre touche. En effet, si on ne fait pas ça, le programme va lui retirer un essai car le joueur n'aura évidemment pas trouvé de nouvelles lettres puisqu’elles sont déjà découvertes.</p><pre id="r-591332" data-claire-element-id="591332"><code data-claire-semantic="c">if ( lettrePropose &gt;= 'A' &amp;&amp;  lettrePropose &lt;= 'Z' || lettrePropose == '\b')    // On annule la touche si ce n'est pas une lettre qui est tapée
{
     sauterUnTour = NON;	// on initialise la variable
     for ( i = 0 ; i &lt; 26 ; i++ )	// on parcourt entièrement le tableau qui sauvegarde les lettres
     {
         if ( tableauDeSaugegardeDesLettresTape[i] == lettrePropose &amp;&amp; lettrePropose != '\b')	// Si on a trouvé la lettre que le joueur a tapé
         {
               sauterUnTour = OUI; // on ne joue pas
         }
     }</code></pre><p id="r-591333" data-claire-element-id="591333">Il suffit donc de rajouter une autre condition pour que le programme attende une autre lettre sans exécuter la suite du programme.</p><pre id="r-591334" data-claire-element-id="591334"><code data-claire-semantic="c">if ( sauterUnTour == NON)	// On peut continuer le programme
{
// Suite du code ici
}</code></pre><h3 id="r-on-retire-un-essai" data-claire-element-id="591342">On retire un essai</h3><p id="r-591336" data-claire-element-id="591336">Maintenant qu'on sait que le joueur a bien tenté une lettre qu'il n'a pas déjà essayée, on peut donc lui retirer un essai. Sinon ce serait trop facile.</p><pre id="r-591337" data-claire-element-id="591337"><code data-claire-semantic="c">if ( lettrePropose != '\b')  // Le joueur tente une lettre, on lui retire son essai
     nombreEssais--;</code></pre><p id="r-591338" data-claire-element-id="591338">Je ne retire pas systématiquement un essai car au début de la partie, la lettre a été initialisée par un backspace. Si on ne fait pas cela, au début de la partie, le joueur perdra automatiquement un essai avant même qu'il propose une lettre.</p><div id="r-591340" data-claire-element-id="591340" data-claire-semantic="question"><p id="r-591339" data-claire-element-id="591339">Mais si le joueur trouve une lettre, on ne doit pas lui enlever son essai, non ?</p></div><p id="r-591341" data-claire-element-id="591341">Tout à fait. La prochaine partie du code sera de remettre l'essai au joueur s’il a effectivement trouvé une lettre.</p><h3 id="r-si-le-joueur-a-trouve-un-lettre-on-rajoute-un-essai" data-claire-element-id="591346">Si le joueur a trouvé un lettre, on rajoute un essai</h3><p id="r-591343" data-claire-element-id="591343">Pour cela, nous allons, dans le même temps, modifier le mot qui s'affiche à l'écran afin de faire apparaitre les lettres trouvées. Nous allons utiliser les deux tableaux motMystere et motMystereEnCours et lui rajouter un essai si le joueur a bien trouvé une lettre.</p><pre id="r-591344" data-claire-element-id="591344"><code data-claire-semantic="c">for ( i = 0 ; i &lt;= tailleMot ; i++ ) // On parcourt l'ensemble des lettres du mot mystère
{
     if ( motMystere[i] == lettrePropose )	// Si on a une similitude
     {
          motMystereEnCours[i] = lettrePropose;	// On change le tableau que l'on va afficher
          if ( nombreEssaisRajoute == 0 ) 
          {
               nombreEssais++;	// on lui remet son essai
               nombreEssaisRajoute++;    // on empêche de rajouter autant d'essais qu'il y a de similitudes
          }
     }
}
nombreEssaisRajoute = 0;// le for est fini, on réinitialise la variable</code></pre><p id="r-591345" data-claire-element-id="591345">Quelques explications s’imposent. Si une lettre a été trouvée, on modifie motMystereEnCours pour que le joueur voit s'il a trouvé des lettres ou non.<br/> La suite est peut-être un peu tordue mais c'est la seule solution que j'ai trouvé. Cela permet de ne rajouter qu'un seul essai. Si cette condition n'était pas là, le joueur gagnerait autant d'essais que de lettres trouvées ce qui serait impossible. Imaginer que le joueur termine le pendu avec encore 12 essais alors qu'il n'en a que 7 au début de la partie :lol: .</p><h3 id="r-on-blitte-differentes-images" data-claire-element-id="591350">On blitte différentes images</h3><p id="r-591347" data-claire-element-id="591347">Maintenant que le nombre d'essais restant est connu, on peut savoir quelle image devra être blitter.</p><pre id="r-591348" data-claire-element-id="591348"><code data-claire-semantic="c">switch(nombreEssais)  // On blitte des images différentes en fonctions du nombre d'essais
{
     case 7 : img = IMG_Load(&quot;sources/0.jpg&quot;);  // En pleine forme
     case 6 : img = IMG_Load(&quot;sources/1.jpg&quot;);
     case 5 : img = IMG_Load(&quot;sources/2.jpg&quot;);
     case 4 : img = IMG_Load(&quot;sources/3.jpg&quot;);
     case 3 : img = IMG_Load(&quot;sources/4.jpg&quot;);
     case 2 : img = IMG_Load(&quot;sources/5.jpg&quot;);
     case 1 : img = IMG_Load(&quot;sources/6.jpg&quot;);  // attention, ici
     default: img = IMG_Load(&quot;sources/7.jpg&quot;);  // et pendu !
}</code></pre><p id="r-591349" data-claire-element-id="591349">Le nombre d'essais va donc définir l'image à blitter. On a donc fini la partie image à droite. Il ne reste plus que la partie de gauche.</p><h3 id="r-le-joueur-a-t-il-gagne" data-claire-element-id="591359">Le joueur a-t-il gagné ?</h3><p id="r-591351" data-claire-element-id="591351">Avant de tout blitter, il reste plus qu'une toute petite chose à faire pour savoir si le joueur a trouvé le mot ou non. De plus, on doit sauvegarde la lettre du joueur dans le tableauDeSaugegardeDesLettresTape.</p><pre id="r-591352" data-claire-element-id="591352"><code data-claire-semantic="c">reussi = JEU_TERMINE;	// on initialise la variable
for ( i = 0 ; i&lt;= tailleMot ; i++ ) // on prend le mot secret lettre par lettre
{
    if ( motMystereEnCours[i] == motMystere[i] || motMystereEnCours[i] == '\b');		// Si on a trouvé une lettre                    else
    reussi = JEU_EN_COURS;
}
if ( lettrePropose != '\b' )
tableauDeSaugegardeDesLettresTape[lettrePropose-'A'] = lettrePropose; // on sauvegarde les lettres à son emplacement alphabétique</code></pre><ul id="r-591357" data-claire-element-id="591357"><li id="r-591354" data-claire-element-id="591354"><p id="r-591353" data-claire-element-id="591353">Avant le for, on initialise la variable reussi avec <strong>JEU_TERMINE</strong>. S'il n'y a aucun changement dans la suite, le jeu sera effectivement terminé</p></li><li id="r-591356" data-claire-element-id="591356"><p id="r-591355" data-claire-element-id="591355">Le for va analysé le mot mystère lettre après lettre, s'il y a au moins une lettre qui ne va pas, on va mettre la variable reussi en <strong>JEU_EN_COURS</strong>. La partie n'est donc pas terminée.</p></li></ul><p id="r-591358" data-claire-element-id="591358">Grâce à ce for, on peut savoir si on a trouvé le mot secret ou non.</p><h3 id="r-on-blitte-tout" data-claire-element-id="591365">On blitte tout !</h3><p id="r-591360" data-claire-element-id="591360">Il ne reste plus qu'à blitter le tout et nous obtiendrons un pendu un peu rudimentaire, mais un pendu.</p><pre id="r-591361" data-claire-element-id="591361"><code data-claire-semantic="c">SDL_FillRect(ecran, NULL, SDL_MapRGB(ecran-&gt;format, 210, 210, 255));	// on efface

     SDL_BlitSurface(img, NULL, ecran, &amp;positionImage);	// on blitte l'image
     positionTexte.x = 50;
     positionTexte.y = ecran-&gt;h/2;
     SDL_BlitSurface(TTF_RenderText_Blended(police, motMystereEnCours, couleurNoire), NULL, ecran, &amp;positionTexte);	// on blitte le mot secret
     positionTexte.x = 10;
     positionTexte.y = 275;
     SDL_BlitSurface(TTF_RenderText_Blended(policePourTableau, tableauDeSaugegardeDesLettresTape, couleurNoire), NULL, ecran, &amp;positionTexte);	// on blitte les caractères déjà tapés</code></pre><p id="r-591362" data-claire-element-id="591362">Les deux derniers blittages peuvent être décomposés en deux parties. On blitte une surface sur l'écran à positionTexte. Mais comme cette surface est un texte, on va directement mettre le TTF_Render_Blended dans le premier paramètre de SDL_BlitSurface. Le compilateur le comprendra très bien.</p><p id="r-591363" data-claire-element-id="591363">Bien sur, on n'oublie pas de refermer toutes les accolades ouvertes et de mettre un SDL_Flip(ecran) sinon vous ne verrez rien :-° ...</p><pre id="r-591364" data-claire-element-id="591364"><code data-claire-semantic="c">}
          SDL_Flip(ecran);
     }
}</code></pre><h3 id="r-notre-pendu-est-fini" data-claire-element-id="591381">Notre pendu est fini</h3><p id="r-591366" data-claire-element-id="591366">Je vous donne le code en entier.</p><p id="r-591367" data-claire-element-id="591367"></p><div id="r-591369" data-claire-element-id="591369"><pre id="r-591368" data-claire-element-id="591368"><code data-claire-semantic="c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;SDL/SDL.h&gt;
#include &lt;time.h&gt;
#include &lt;SDL_image.h&gt;
#include &lt;SDL_ttf.h&gt;

#define NOMBRE_ESSAIS  7

enum {JEU_TERMINE, JEU_EN_COURS};
enum {OUI, NON};
//------------------------------------

int piocherMot(char *motPioche);
int nombreAleatoire(int nombreMax);

int main(int argc, char *argv[])
{
    SDL_Surface *ecran = NULL, *img = NULL; // On créé 2 surfaces pour le texte et pour l'image

    SDL_Event event;    // Evenement
    int continuer = 1;
    srand(time(NULL));  // pour le nombre aléatoire

    char lettrePropose = '\b';	// on va stocker ici la lettre tapée
    char motMystere[50];	// 	Le mot mystère à découvrir
    if ( piocherMot(motMystere) == 0 )		// on demande un mot qui sera mis dans motMystere
        return EXIT_FAILURE;	// si on n'a pas réussi à charger le dictionnaire on arrête le programme

    const int tailleMot = strlen(motMystere);
    char *motMystereEnCours = NULL;    // Allocation dynamique de la mémoire
    motMystereEnCours = (char *) malloc(tailleMot * sizeof(char));
    if (motMystereEnCours == NULL)  // Verification de l'allocation de memoire
        return EXIT_FAILURE;  // On arrete tout

    strcpy(motMystereEnCours, motMystere);      // on copie le mot mystère dans une autre chaine
    char tableauDeSaugegardeDesLettresTape[] = &quot;                          &quot; ; 		// 26 caractères on retient les lettres que le joueur a tapé

    int nombreEssais = NOMBRE_ESSAIS;
    int reussi = JEU_EN_COURS;		// Permet de savoir si le joueur à découvert le mot, on pourra aussi lui demander si il veut recommencer une autre partie
    int nombreEssaisRajoute = 0;	// Cette variable a un rapport avec le nombre d'essais.
    int sauterUnTour = NON;		// Cette variable permet de sauter le tour du joueur si il tape une lettre une seconde fois
    int i = 0;

    SDL_Init(SDL_INIT_VIDEO);
    ecran             = SDL_SetVideoMode(750, 320, 32, SDL_HWSURFACE | SDL_DOUBLEBUF);

    TTF_Init();		// initialisation de la SDL
    TTF_Font *police = NULL, *policePourFinal = NULL, *policePourTableau;	// création de 3 polices
    SDL_Color couleurNoire = {0, 0, 0};
    police            = TTF_OpenFont(&quot;sources/police.ttf&quot;, 45);
    policePourTableau = TTF_OpenFont(&quot;sources/policeRejouer.ttf&quot;, 25);
    policePourFinal   = TTF_OpenFont(&quot;sources/policePourTableau.ttf&quot;, 65);

    SDL_Rect positionTexte, positionImage;	// création de 2 positions
    positionTexte.x = 0;
    positionTexte.y = 0;
    positionImage.x = 400;
    positionImage.y = 0;

    SDL_WM_SetCaption(&quot;Pendu en SDL pour les Zeros&quot;, NULL);

    for ( i = 0 ; i &lt; tailleMot ; i++ )    // on code le motMystere
    {
        motMystereEnCours[i] = '*';
    }

    while (continuer)
    {
        SDL_WaitEvent(&amp;event);
        switch (event.type)
        {
        case SDL_QUIT:
            continuer = 0;
            break;
        case SDL_KEYDOWN:
            switch (event.key.keysym.sym)
            {
            case SDLK_ESCAPE:
                continuer = 0;
                break;
            default :
                lettrePropose = event.key.keysym.sym;
                switch (lettrePropose)
                {
                    case 'q' :
                        lettrePropose = 'a';
                        break;
                    case ';' :
                        lettrePropose ='m';
                        break;
                    case 'z' :
                        lettrePropose ='w';
                        break;
                    case 'a' :
                        lettrePropose = 'q';
                        break;
                    case 'w' :
                        lettrePropose ='z';
                        break;
                }
                lettrePropose = toupper(lettrePropose);  //majuscule
                break;
            }
        }

//--------------------------------------------------------------------------------------------------
        if ( lettrePropose &gt;= 'A' &amp;&amp;  lettrePropose &lt;= 'Z' || lettrePropose == '\b')    // On annule la touche si ce n'est pas une lettre qui est tapée
        {
            sauterUnTour = NON;	// on initialise la variable
            for ( i = 0 ; i &lt; 26 ; i++ )	// on parcourt entièrement le tableau qui sauvegarde les lettres
            {
                if ( tableauDeSaugegardeDesLettresTape[i] == lettrePropose &amp;&amp; lettrePropose != '\b')	// Si on a trouvé la lettre que le joueur a tapé
                {
                    sauterUnTour = OUI; // on ne joue pas
                }
            }

//--------------------------------------------------------------------------------------------------
            if ( sauterUnTour == NON)   // On peut continuer le programme
            {

//--------------------------------------------------------------------------------------------------
                if ( lettrePropose != '\b')  // Le joueur tente une lettre, on lui retire son essai
                    nombreEssais--;

//--------------------------------------------------------------------------------------------------
                for ( i = 0 ; i &lt;= tailleMot ; i++ ) // On parcourt l'ensemble des lettres du mot mystère
                {
                    if ( motMystere[i] == lettrePropose )	// Si on a une similitude
                    {
                        motMystereEnCours[i] = lettrePropose;	// On change le tableau que l'on va afficher
                        if ( nombreEssaisRajoute == 0 )
                        {
                            nombreEssais++;	    // on lui remet son essai
                            nombreEssaisRajoute++;    // on empêche de rajouter autant d'essais qu'il y a de similitudes
                        }
                    }
                }
                nombreEssaisRajoute = 0;    // le for est fini, on réinitialise la variable

//--------------------------------------------------------------------------------------------------
                switch(nombreEssais)  // On blitte des images différentes en fonctions du nombre d'essais
                {
                     case 7 : img = IMG_Load(&quot;sources/0.jpg&quot;);  // En pleine forme
                     case 6 : img = IMG_Load(&quot;sources/1.jpg&quot;);
                     case 5 : img = IMG_Load(&quot;sources/2.jpg&quot;);
                     case 4 : img = IMG_Load(&quot;sources/3.jpg&quot;);
                     case 3 : img = IMG_Load(&quot;sources/4.jpg&quot;);
                     case 2 : img = IMG_Load(&quot;sources/5.jpg&quot;);
                     case 1 : img = IMG_Load(&quot;sources/6.jpg&quot;);  // attention, ici
                     default: img = IMG_Load(&quot;sources/7.jpg&quot;);  // et pendu !
                }

//--------------------------------------------------------------------------------------------------
                reussi = JEU_TERMINE;	// on initialise la variable
                for ( i = 0 ; i&lt;= tailleMot ; i++ ) // on prend le mot secret lettre par lettre
                {
                    if ( motMystereEnCours[i] == motMystere[i] || motMystereEnCours[i] == '\b');		// Si on a trouvé une lettre
                    else
                        reussi = JEU_EN_COURS;
                }
                if ( lettrePropose != '\b' )
                tableauDeSaugegardeDesLettresTape[lettrePropose-'A'] = lettrePropose; // on sauvegarde les lettres à son emplacement alphabétique

//On blitte tout------------------------------------------------------------------------------------
                SDL_FillRect(ecran, NULL, SDL_MapRGB(ecran-&gt;format, 210, 210, 255));	// on efface

                SDL_BlitSurface(img, NULL, ecran, &amp;positionImage);	// on blitte l'image
                positionTexte.x = 50;
                positionTexte.y = ecran-&gt;h/2;
                SDL_BlitSurface(TTF_RenderText_Blended(police, motMystereEnCours, couleurNoire), NULL, ecran, &amp;positionTexte);	// on blitte le mot secret
                positionTexte.x = 10;
                positionTexte.y = 275;
                SDL_BlitSurface(TTF_RenderText_Blended(policePourTableau, tableauDeSaugegardeDesLettresTape, couleurNoire), NULL, ecran, &amp;positionTexte);	// on blitte les caractères déjà tapés
            }
            SDL_Flip(ecran);
        }
    }

TTF_CloseFont(police);    // on vide la mémoire
TTF_CloseFont(policePourFinal);
TTF_CloseFont(policePourTableau);
TTF_Quit();
SDL_FreeSurface(img);
free(motMystereEnCours);
SDL_Quit();

return EXIT_SUCCESS;
}

int piocherMot(char *motPioche)
{
    FILE* dico = NULL;
    int nombreMots = 0, numMotChoisi = 0;
    int caractereLu = 0;
    dico = fopen(&quot;sources/dico.txt&quot;, &quot;r&quot;);
    if (dico == NULL)   //
    {
        return 0;
    }
    do
    {
        caractereLu = fgetc(dico);
        if (caractereLu == '\n')
            nombreMots++;
    }
    while (caractereLu != EOF);
    numMotChoisi = nombreAleatoire(nombreMots);
    rewind(dico);
    while (numMotChoisi &gt; 0)
    {
        caractereLu = fgetc(dico);
        if (caractereLu == '\n')
            numMotChoisi--;
    }
    fgets(motPioche, 100, dico);
    motPioche[strlen(motPioche) - 1] = '\0';
    fclose(dico);
    return 1;
}

int nombreAleatoire(int nombreMax)
{
    return (rand() % nombreMax);
}</code></pre></div><p id="r-591370" data-claire-element-id="591370">Je l'ai bien aéré pour que vous voyiez les différentes étapes. Il y a beaucoup de façons différentes de coder ce pendu. Si vous arrivez au même résultat que moi et que vous n'avez pas du tout fait comme cela, et bien, je dirai que c'est normal :o .<br/> J'ai réalisé ce code de manière à pouvoir facilement le découper en petits morceaux délimités par des lignes de tirets. Ce code est simplement un ensemble de petits morceaux. Cela permet de rajouter facilement d'autres morceaux.<br/> Vous pouvez maintenant compiler ce code qui marche parfaitement.</p><div id="r-591372" data-claire-element-id="591372" data-claire-semantic="question"><p id="r-591371" data-claire-element-id="591371">Mais on ne sait pas quand on gagne ? Et on ne peut pas perdre non plus ?</p></div><p id="r-591373" data-claire-element-id="591373">En effet. Il manque encore deux petites choses.</p><ul id="r-591378" data-claire-element-id="591378"><li id="r-591375" data-claire-element-id="591375"><p id="r-591374" data-claire-element-id="591374">L'une est lorsque reussi = JEU_TERMINE. On a gagné. Si le joueur a gagné, on lui dit qu'il a gagné et on lui remet le mot qu'il a trouvé.</p></li><li id="r-591377" data-claire-element-id="591377"><p id="r-591376" data-claire-element-id="591376">Et l'autre est lorsque nombreEssais = 0. Le joueur a perdu. S'il a perdu, on dit au joueur qu'il a perdu et on lui donne la réponse.</p></li></ul><pre id="r-591379" data-claire-element-id="591379"><code data-claire-semantic="c">if ( reussi == JEU_TERMINE )  // Si on a gagné
                {
                    SDL_FillRect(ecran, NULL, SDL_MapRGB(ecran-&gt;format, 210, 210, 255));
                    positionTexte.x = 10;
                    positionTexte.y = 120;
                    SDL_BlitSurface(TTF_RenderText_Blended(policePourFinal, &quot;Felicitation ! Le mot etait bien :&quot;, couleurNoire), NULL, ecran, &amp;positionTexte);
                    positionTexte.x = 50;
                    positionTexte.y = 180;
                    SDL_BlitSurface(img, NULL, ecran, &amp;positionImage);
                    SDL_BlitSurface(TTF_RenderText_Blended(police, motMystereEnCours, couleurNoire), NULL, ecran, &amp;positionTexte);
                }
//--------------------------------------------------------
                if ( nombreEssais == 0 )  // Si on a perdu
                {
                    SDL_FillRect(ecran, NULL, SDL_MapRGB(ecran-&gt;format, 210, 210, 255));
                    positionTexte.x = 10;
                    positionTexte.y = 120;
                    SDL_BlitSurface(TTF_RenderText_Blended(policePourFinal, &quot;Perdu ! Le mot etait : &quot;, couleurNoire), NULL, ecran, &amp;positionTexte);
                    positionTexte.x = 50;
                    positionTexte.y = 180;
                    SDL_BlitSurface(img, NULL, ecran, &amp;positionImage);
                    SDL_BlitSurface(TTF_RenderText_Blended(police, motMystere, couleurNoire), NULL, ecran, &amp;positionTexte);
                }</code></pre><p id="r-591380" data-claire-element-id="591380">On doit donc rajouter cette partie à la fin du jeu.</p><h3 id="r-le-point-sur-notre-pendu" data-claire-element-id="591391">Le point sur notre pendu</h3><p id="r-591382" data-claire-element-id="591382">On a donc fini notre pendu maintenant !</p><p id="r-591383" data-claire-element-id="591383">Je vous donne le code en entier maintenant. J'ai juste rajouté les deux parties du dessus.</p><p id="r-591384" data-claire-element-id="591384"></p><div id="r-591386" data-claire-element-id="591386"><pre id="r-591385" data-claire-element-id="591385"><code data-claire-semantic="c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;SDL/SDL.h&gt;
#include &lt;time.h&gt;
#include &lt;SDL_image.h&gt;
#include &lt;SDL_ttf.h&gt;

#define NOMBRE_ESSAIS  7

enum {JEU_TERMINE, JEU_EN_COURS};
enum {OUI, NON};
//------------------------------------

int piocherMot(char *motPioche);
int nombreAleatoire(int nombreMax);

int main(int argc, char *argv[])
{
    SDL_Surface *ecran = NULL, *img = NULL; // On créé 2 surfaces pour le texte et pour l'image

    SDL_Event event;    // Evenement
    int continuer = 1;
    srand(time(NULL));  // pour le nombre aléatoire

    char lettrePropose = '\b';	// on va stocker ici la lettre tapée
    char motMystere[50];	// 	Le mot mystère à découvrir
    if ( piocherMot(motMystere) == 0 )		// on demande un mot qui sera mis dans motMystere
        return EXIT_FAILURE;	// si on n'a pas réussi à charger le dictionnaire on arrête le programme

    const int tailleMot = strlen(motMystere);
    char *motMystereEnCours = NULL;    // Allocation dynamique de la mémoire
    motMystereEnCours = (char *) malloc(tailleMot * sizeof(char));
    if (motMystereEnCours == NULL)  // Verification de l'allocation de memoire
        return EXIT_FAILURE;  // On arrete tout

    strcpy(motMystereEnCours, motMystere);      // on copie le mot mystère dans une autre chaine
    char tableauDeSaugegardeDesLettresTape[] = &quot;                          &quot; ; 		// 26 caractères on retient les lettres que le joueur a tapé

    int nombreEssais = NOMBRE_ESSAIS;
    int reussi = JEU_EN_COURS;		// Permet de savoir si le joueur à découvert le mot, on pourra aussi lui demander si il veut recommencer une autre partie
    int nombreEssaisRajoute = 0;	// Cette variable a un rapport avec le nombre d'essais.
    int sauterUnTour = NON;		// Cette variable permet de sauter le tour du joueur si il tape une lettre une seconde fois
    int i = 0;

    SDL_Init(SDL_INIT_VIDEO);
    ecran             = SDL_SetVideoMode(750, 320, 32, SDL_HWSURFACE | SDL_DOUBLEBUF);

    TTF_Init();		// initialisation de la SDL
    TTF_Font *police = NULL, *policePourFinal = NULL, *policePourTableau;	// création de 3 polices
    SDL_Color couleurNoire = {0, 0, 0};
    police            = TTF_OpenFont(&quot;sources/police.ttf&quot;, 45);
    policePourTableau = TTF_OpenFont(&quot;sources/policeRejouer.ttf&quot;, 25);
    policePourFinal   = TTF_OpenFont(&quot;sources/policePourTableau.ttf&quot;, 65);

    SDL_Rect positionTexte, positionImage;	// création de 2 positions
    positionTexte.x = 0;
    positionTexte.y = 0;
    positionImage.x = 400;
    positionImage.y = 0;

    SDL_WM_SetCaption(&quot;Pendu en SDL pour les Zeros&quot;, NULL);

    for ( i = 0 ; i &lt; tailleMot ; i++ )    // on code le motMystere
    {
        motMystereEnCours[i] = '*';
    }

    while (continuer)
    {
        SDL_WaitEvent(&amp;event);
        switch (event.type)
        {
        case SDL_QUIT:
            continuer = 0;
            break;
        case SDL_KEYDOWN:
            switch (event.key.keysym.sym)
            {
            case SDLK_ESCAPE:
                continuer = 0;
                break;
            default :
                lettrePropose = event.key.keysym.sym;
                switch (lettrePropose)
                {
                    case 'q' :
                        lettrePropose = 'a';
                        break;
                    case ';' :
                        lettrePropose ='m';
                        break;
                    case 'z' :
                        lettrePropose ='w';
                        break;
                    case 'a' :
                        lettrePropose = 'q';
                        break;
                    case 'w' :
                        lettrePropose ='z';
                        break;
                }
                lettrePropose = toupper(lettrePropose);  //majuscule
                break;
            }
        }

//--------------------------------------------------------------------------------------------------
        if ( lettrePropose &gt;= 'A' &amp;&amp;  lettrePropose &lt;= 'Z' || lettrePropose == '\b')    // On annule la touche si ce n'est pas une lettre qui est tapée
        {
            sauterUnTour = NON;	// on initialise la variable
            for ( i = 0 ; i &lt; 26 ; i++ )	// on parcourt entièrement le tableau qui sauvegarde les lettres
            {
                if ( tableauDeSaugegardeDesLettresTape[i] == lettrePropose &amp;&amp; lettrePropose != '\b')	// Si on a trouvé la lettre que le joueur a tapé
                {
                    sauterUnTour = OUI; // on ne joue pas
                }
            }

//--------------------------------------------------------------------------------------------------
            if ( sauterUnTour == NON)   // On peut continuer le programme
            {

//--------------------------------------------------------------------------------------------------
                if ( lettrePropose != '\b')  // Le joueur tente une lettre, on lui retire son essai
                    nombreEssais--;

//--------------------------------------------------------------------------------------------------
                for ( i = 0 ; i &lt;= tailleMot ; i++ ) // On parcourt l'ensemble des lettres du mot mystère
                {
                    if ( motMystere[i] == lettrePropose )	// Si on a une similitude
                    {
                        motMystereEnCours[i] = lettrePropose;	// On change le tableau que l'on va afficher
                        if ( nombreEssaisRajoute == 0 )
                        {
                            nombreEssais++;	    // on lui remet son essai
                            nombreEssaisRajoute++;    // on empêche de rajouter autant d'essais qu'il y a de similitudes
                        }
                    }
                }
                nombreEssaisRajoute = 0;    // le for est fini, on réinitialise la variable

//--------------------------------------------------------------------------------------------------
                switch(nombreEssais)  // On blitte des images différentes en fonctions du nombre d'essais
                {
                     case 7 : img = IMG_Load(&quot;sources/0.jpg&quot;);  // En pleine forme
                     case 6 : img = IMG_Load(&quot;sources/1.jpg&quot;);
                     case 5 : img = IMG_Load(&quot;sources/2.jpg&quot;);
                     case 4 : img = IMG_Load(&quot;sources/3.jpg&quot;);
                     case 3 : img = IMG_Load(&quot;sources/4.jpg&quot;);
                     case 2 : img = IMG_Load(&quot;sources/5.jpg&quot;);
                     case 1 : img = IMG_Load(&quot;sources/6.jpg&quot;);  // attention, ici
                     default: img = IMG_Load(&quot;sources/7.jpg&quot;);  // et pendu !
                }

//--------------------------------------------------------------------------------------------------
                reussi = JEU_TERMINE;	// on initialise la variable
                for ( i = 0 ; i&lt;= tailleMot ; i++ ) // on prend le mot secret lettre par lettre
                {
                    if ( motMystereEnCours[i] == motMystere[i] || motMystereEnCours[i] == '\b');		// Si on a trouvé une lettre
                    else
                        reussi = JEU_EN_COURS;
                }
                if ( lettrePropose != '\b' )
                tableauDeSaugegardeDesLettresTape[lettrePropose-'A'] = lettrePropose; // on sauvegarde les lettres à son emplacement alphabétique

//On blitte tout------------------------------------------------------------------------------------
                SDL_FillRect(ecran, NULL, SDL_MapRGB(ecran-&gt;format, 210, 210, 255));	// on efface

                SDL_BlitSurface(img, NULL, ecran, &amp;positionImage);	// on blitte l'image
                positionTexte.x = 50;
                positionTexte.y = ecran-&gt;h/2;
                SDL_BlitSurface(TTF_RenderText_Blended(police, motMystereEnCours, couleurNoire), NULL, ecran, &amp;positionTexte);	// on blitte le mot secret
                positionTexte.x = 10;
                positionTexte.y = 275;
                SDL_BlitSurface(TTF_RenderText_Blended(policePourTableau, tableauDeSaugegardeDesLettresTape, couleurNoire), NULL, ecran, &amp;positionTexte);	// on blitte les caractères déjà tapés
//--------------------------------------------------------
                if ( reussi == JEU_TERMINE )  // Si on a gagné
                {
                    SDL_FillRect(ecran, NULL, SDL_MapRGB(ecran-&gt;format, 210, 210, 255));
                    positionTexte.x = 10;
                    positionTexte.y = 120;
                    SDL_BlitSurface(TTF_RenderText_Blended(policePourFinal, &quot;Felicitation ! Le mot etait bien :&quot;, couleurNoire), NULL, ecran, &amp;positionTexte);
                    positionTexte.x = 50;
                    positionTexte.y = 180;
                    SDL_BlitSurface(img, NULL, ecran, &amp;positionImage);
                    SDL_BlitSurface(TTF_RenderText_Blended(police, motMystereEnCours, couleurNoire), NULL, ecran, &amp;positionTexte);
                }
//--------------------------------------------------------
                if ( nombreEssais == 0 )  // Si on a perdu
                {
                    SDL_FillRect(ecran, NULL, SDL_MapRGB(ecran-&gt;format, 210, 210, 255));
                    positionTexte.x = 10;
                    positionTexte.y = 120;
                    SDL_BlitSurface(TTF_RenderText_Blended(policePourFinal, &quot;Perdu ! Le mot etait : &quot;, couleurNoire), NULL, ecran, &amp;positionTexte);
                    positionTexte.x = 50;
                    positionTexte.y = 180;
                    SDL_BlitSurface(img, NULL, ecran, &amp;positionImage);
                    SDL_BlitSurface(TTF_RenderText_Blended(police, motMystere, couleurNoire), NULL, ecran, &amp;positionTexte);
                }

            }
            SDL_Flip(ecran);
        }
    }

TTF_CloseFont(police);    // on vide la mémoire
TTF_CloseFont(policePourFinal);
TTF_CloseFont(policePourTableau);
TTF_Quit();
SDL_FreeSurface(img);
free(motMystereEnCours);
SDL_Quit();

return EXIT_SUCCESS;
}

int piocherMot(char *motPioche)
{
    FILE* dico = NULL;
    int nombreMots = 0, numMotChoisi = 0;
    int caractereLu = 0;
    dico = fopen(&quot;sources/dico.txt&quot;, &quot;r&quot;);
    if (dico == NULL)   //
    {
        return 0;
    }
    do
    {
        caractereLu = fgetc(dico);
        if (caractereLu == '\n')
            nombreMots++;
    }
    while (caractereLu != EOF);
    numMotChoisi = nombreAleatoire(nombreMots);
    rewind(dico);
    while (numMotChoisi &gt; 0)
    {
        caractereLu = fgetc(dico);
        if (caractereLu == '\n')
            numMotChoisi--;
    }
    fgets(motPioche, 100, dico);
    motPioche[strlen(motPioche) - 1] = '\0';
    fclose(dico);
    return 1;
}

int nombreAleatoire(int nombreMax)
{
    return (rand() % nombreMax);
}</code></pre></div><p id="r-591387" data-claire-element-id="591387">Et voila, notre pendu est maintenant complet. Et bien ce n'était pas si dur. :euh:</p><div id="r-591389" data-claire-element-id="591389" data-claire-semantic="question"><p id="r-591388" data-claire-element-id="591388">Incroyables, c'est déjà terminé ? Mais il nous reste encore des choses à faire, non ?</p></div><p id="r-591390" data-claire-element-id="591390">En effet. Il reste encore des choses à améliorer. <strong>Mais</strong> j'ai bien dit améliorer ! Et oui, que serait un TP sans . . . . . . améliorations. :-°</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tp-pendu">[TP] Pendu</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-pendu/objectifs-19">
Objectifs
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tp-pendu/correction-208">
Correction
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-pendu/ameliorations-32">
Améliorations
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-pendu/objectifs-19">
<span class="arrow"></span>
<span class="next">Objectifs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/tp-pendu/ameliorations-32">
<span class="next">Améliorations</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Amliorations"></a><h2>Améliorations</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-pendu/correction-208">
<span class="arrow"></span>
<span class="next">Correction</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-591393" data-claire-element-id="591393">Maintenant que vous avez un pendu, il faudrait peut-être le rendre un peu plus attirant, non ? Alors on y va !</p><h3 id="r-ameliorations-utiles" data-claire-element-id="591407">Améliorations utiles</h3><p id="r-591394" data-claire-element-id="591394">Je vais vous donner une liste de petites améliorations. Nous avons créé ensemble un pendu qui fonctionne, cependant, il est un peu rudimentaire. Laissez libre cours à vos talents artistiques et améliorez ce pendu le plus possible.</p><ul id="r-591405" data-claire-element-id="591405"><li id="r-591396" data-claire-element-id="591396"><p id="r-591395" data-claire-element-id="591395">Ecrire un titre (et ne me demandez pas ce qu'on peut bien y mettre :colere: )</p></li><li id="r-591398" data-claire-element-id="591398"><p id="r-591397" data-claire-element-id="591397">Ecrire une petite phrase d'accueil comme par exemple : trouver le mot mystère.</p></li><li id="r-591400" data-claire-element-id="591400"><p id="r-591399" data-claire-element-id="591399">Lorsque la partie est finie, demander au joueur s'il veut recommencer une autre partie.</p></li><li id="r-591402" data-claire-element-id="591402"><p id="r-591401" data-claire-element-id="591401">Le pendu s'exécute tout de suite. Il serait plus beau d'avoir un menu qui permet d'avoir le choix entre différentes options comme jouer, quitter, à propos, ...</p></li><li id="r-591404" data-claire-element-id="591404"><p id="r-591403" data-claire-element-id="591403">Avoir un fond d'écran qui devient de plus en plus rouge lorsqu'on perd des essais.</p></li></ul><p id="r-591406" data-claire-element-id="591406">Pour vous montrer que toutes ces améliorations sont possibles, vous pouvez télécharger l'exécutable, les DLL, les images, et le code source ici : <br/>Télécharger <a href="http://www.megaupload.com/?d=LAW98LAY">le Pendu</a></p><h3 id="r-ameliorations-inutiles-qui-vous-font-pratiquer" data-claire-element-id="591410">Améliorations inutiles qui vous font pratiquer</h3><p id="r-591408" data-claire-element-id="591408">Voici une idée que j'ai eu. Cependant, elle a besoin d'une autre partie car elle ne sert pas vraiment à grand chose :-° . . .</p><p id="r-591409" data-claire-element-id="591409">Je trouve que le jeu est terminé quand le joueur a déjà trouvé <strong>TOUS</strong> les mots. Donc je me disais qu'il serait intéressant de supprimer dans le dictionnaire chaque mot que le joueur a réussi à trouver. Pour cela, lorsque le jeu est terminé et que le joueur a trouvé le mot, il faudrait appeler une autre fonction qui supprime la ligne dans le dictionnaire (petit conseil : sauvegarder la ligne du mot dans la fonction piocherMot pour ne pas avoir à tout relire le dictionnaire).</p><h3 id="r-les-ameliorations-qui-feront-toute-la-difference" data-claire-element-id="591415">Les améliorations qui feront toute la différence</h3><p id="r-591411" data-claire-element-id="591411">Dans un menu options au démarrage du programme, vous pouvez effectuer plusieurs réglages comme le choix du nombre d'essais, de la police et de la couleur du texte, des thèmes (par exemple, avoir le choix entre plusieurs ensembles d'images de pendu car ici, c'est toujours le même bonhomme qui se fait pendre).</p><p id="r-591412" data-claire-element-id="591412">Et pour ma dernière idée d'amélioration, je vous ai réservé la plus dure mais évidemment la plus belle amélioration : un pendu animé ! En effet, notre petit bonhomme se fait pendre trop rapidement pour moi. Ce serait plus &quot;agréable&quot; à regarder s'il pouvait être un peu animé. Par exemple, dès que le joueur vient de perdre un essai, on peut glisser quelques images une petite demi-seconde pour rendre l'action un peu plus fluide. Pour ce faire, je vous conseille ce tuto : <a href="http://www.siteduzero.com/tutoriel-3-34997-faire-des-animations-avec-sdlp_anim.html">Faire des animations avec sdlp_anim</a> de <a href="http://www.siteduzero.com/membres-294-82924.html">pOpOp99O0</a>.</p><p id="r-591413" data-claire-element-id="591413">Et voilà, fin du tuto.<br/> J'espère qu'il vous a plu. Maintenant, au lieu d'avoir un pendu en console noir et blanc, vous avez un jooooli pendu en SDL.<br/> A consommer sans modération.<br/> Il est bien sûr inutile de dire que vous devez faire TOUS les mots du dictionnaire avant de créer un autre programme sinon :pirate: .</p><p id="r-591414" data-claire-element-id="591414">Je tiens aussi à remercier ma maison de disque le formidable petit bonhomme qui se fait pendre pour nous ! Évidemment, sans lui, tout serait impossible :lol: .</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/tp-pendu">[TP] Pendu</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-pendu/objectifs-19">
Objectifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/tp-pendu/correction-208">
Correction
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/tp-pendu/ameliorations-32">
Améliorations
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/tp-pendu/correction-208">
<span class="arrow"></span>
<span class="next">Correction</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/-pendu.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 01:25:49 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/-pendu.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:25:34 GMT -->
</html>
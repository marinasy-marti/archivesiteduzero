<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/maitrisez-les-nombres-a-virgule-en-c.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Oct 2013 20:34:11 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/maitrisez-les-nombres-a-virgule-en-c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 03:52:49 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Maîtrisez les nombres à virgule en C</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Maîtrisez les nombres à virgule en C</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#MatrisezlesnombresvirguleenC">Maîtrisez les nombres à virgule en C</a><br/><a href="#UtilisationdesnombresvirguleenC">Utilisation des nombres à virgule en C</a><br/><a href="#IEEE754lecodageenmmoiredunnombreflottant">IEEE 754 : le codage en mémoire d’un nombre flottant</a><br/><a href="#Unpeudemathmatiques">Un peu de mathématiques</a><br/><a href="#IEEE754Exceptionsamparrondis">IEEE 754 : Exceptions &amp; arrondis</a><br/><a href="#Comparerdesnombresflottants">Comparer des nombres flottants</a><br/><a href="#Maisqu039enditlanormeC">Mais qu&#039;en dit la norme C ?</a><br/></div>
<a name="MatrisezlesnombresvirguleenC"></a><h2>Maîtrisez les nombres à virgule en C</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/utilisation-des-nombres-a-virgule-en-c">
<span class="next">Utilisation des nombres à virgule en C</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-417636" data-claire-element-id="417636">Vous souhaitez manipuler dans vos programmes en C de très grands nombres et/ou des nombres à virgule ? Ou alors vous avez déjà essayé mais vous rencontrez des problèmes incompréhensibles ? Ce cours vous est destiné !<br/> Vous y apprendrez tout ce qu'il faut savoir sur les nombres à virgule en C.</p><p id="r-417637" data-claire-element-id="417637">Au programme :</p><ul id="r-417648" data-claire-element-id="417648"><li id="r-417639" data-claire-element-id="417639"><p id="r-417638" data-claire-element-id="417638">quelques rappels (ou pas) sur les nombres à virgule en C (types, syntaxe…) ;</p></li><li id="r-417641" data-claire-element-id="417641"><p id="r-417640" data-claire-element-id="417640">la représentation en mémoire d'un nombre à virgule dite « flottante » (selon la norme IEEE 754), et les propriétés qui en découlent (valeurs possibles, etc.) ;</p></li><li id="r-417643" data-claire-element-id="417643"><p id="r-417642" data-claire-element-id="417642">les inconvénients des nombres à virgule flottante en C ;</p></li><li id="r-417645" data-claire-element-id="417645"><p id="r-417644" data-claire-element-id="417644">effectuer une comparaison de nombres flottants ;</p></li><li id="r-417647" data-claire-element-id="417647"><p id="r-417646" data-claire-element-id="417646">le point de vue de la norme C, et les implémentations.</p></li></ul><p id="r-417649" data-claire-element-id="417649">Prérequis :</p><ul id="r-417663" data-claire-element-id="417663"><li id="r-417651" data-claire-element-id="417651"><p id="r-417650" data-claire-element-id="417650">connaître un minimum le langage C ! Au moins jusqu'au chapitre sur les pointeurs (chapitre 2 de la partie II) du <a href="http://www.siteduzero.com/tutoriel-3-14189-apprenez-a-programmer-en-c.html">tutoriel de M@teo21</a> si vous le suivez ;</p></li><li id="r-417653" data-claire-element-id="417653"><p id="r-417652" data-claire-element-id="417652">avoir quelques notions mathématiques (rien de bien méchant) sur les puissances (de 10 et de 2, dans notre cas), et idéalement les bases numériques (mais ce n'est pas indispensable) ;</p></li><li id="r-417655" data-claire-element-id="417655"><p id="r-417654" data-claire-element-id="417654">maîtriser les notions de bit, d'octet, de binaire, etc., ainsi que les deux façons principales de représenter un nombre relatif en mémoire (le bit de signe ou le complément à 2) ; si ce n'est pas le cas, vous pouvez lire <a href="http://www.siteduzero.com/tutoriel-3-32169-les-variables-leur-vrai-visage.html">ce tutoriel sur le « vrai visage des variables » en mémoire</a> ;</p></li><ul id="r-417658" data-claire-element-id="417658"><li id="r-417657" data-claire-element-id="417657"><p id="r-417656" data-claire-element-id="417656"><a href="http://www.siteduzero.com/tutoriel-3-509205-un-ordinateur-c-est-tres-bete-ca-ne-sait-pas-compter-jusqu-a-deux.html">ce tutoriel-ci</a>, à la fois clair et complet, vous introduit toutes les notions listées ci-dessus, et je vous invite à le lire s'il vous manque quelque chose (arrêtez-vous après avoir lu la partie sur les nombres entiers, la suite gâcherait mon suspense) ;</p></li></ul><li id="r-417660" data-claire-element-id="417660"><p id="r-417659" data-claire-element-id="417659">être motivé et curieux ; :ange:</p></li><li id="r-417662" data-claire-element-id="417662"><p id="r-417661" data-claire-element-id="417661"><em>that's all!</em></p></li></ul>
</div><a name="UtilisationdesnombresvirguleenC"></a><h2>Utilisation des nombres à virgule en C</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-le-codage-en-memoire-d-un-nombre-flottant">
<span class="next">IEEE 754 : le codage en mémoire d’un nombre flottant</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-417664" data-claire-element-id="417664">Tout d'abord, une présentation des <strong>nombres à virgule flottante</strong> !</p><p id="r-417665" data-claire-element-id="417665">Bon, je ne vais pas vous expliquer ce qu'est un nombre à virgule. Si vous ne savez pas ce que c'est, ce tutoriel ne vous sera d'aucune utilité. :lol: <br/> On parle de virgule <em>flottante</em> car on peut faire varier la place de la virgule en variant la puissance de 10 (puisque tout nombre peut être écrit avec une puissance de 10). Par exemple : 42,1337 = 42,1337 ×100 = 0,421337 ×102 = 42133,7 ×10-3.</p><p id="r-417666" data-claire-element-id="417666">En informatique, on parle de virgule flottante par opposition à virgule <em>fixe</em>, qui indique une méthode de représentation en mémoire d'un nombre avec un nombre fixe de chiffres après la virgule. En C, nous avons des nombres à virgule flottante.</p><p id="r-417667" data-claire-element-id="417667"><em>Remarque :</em> On parle de la <em>partie entière</em> pour désigner la partie qui se trouve avant la virgule, et de <em>partie décimale</em> (ou <em>fractionnaire</em>) pour celle qui se trouve après.<br/> Je pourrai également parler de la <em>notation scientifique</em>. Ce terme désigne le nombre écrit avec un seul chiffre avant la virgule et multiplié par une puissance de 10 ; par exemple, l’écriture scientifique de 3141,6 sera 3,1416 ×103.<br/> Enfin, on appelle <em>partie significative</em> d'un nombre, ce nombre écrit écrit en notation scientifique sans la puissance de 10 qui va derrière (c'est-à-dire le nombre à virgule avec un seul chiffre avant la virgule) ; par exemple, 3,1416 est la partie significative dans notre exemple précédent.</p><h2 id="r-la-base-de-la-base" data-claire-element-id="417695">La base de la base</h2><h3 id="r-les-types-pour-representer-un-nombre-a-virgule" data-claire-element-id="417670">Les types pour représenter un nombre à virgule</h3><p id="r-417668" data-claire-element-id="417668">En C, un nombre à virgule flottante peut être représenté par les types <code data-claire-semantic="c">float</code> et <code data-claire-semantic="c">double</code> (il existe aussi <code data-claire-semantic="c">long double</code>). Comme pour les types entiers, leur taille en mémoire dépend de l'architecture de l'ordinateur, mais les valeurs sont très fréquemment <strong>32 bits (4 octets) pour un <code data-claire-semantic="c">float</code></strong> et <strong>64 bits (8 octets) pour un <code data-claire-semantic="c">double</code></strong>. Pour vous assurer de la taille chez vous, vous pouvez faire :</p><pre id="r-417669" data-claire-element-id="417669"><code data-claire-semantic="c">printf(&quot;taille d'un float : %u bytes\n&quot;, sizeof(float));
printf(&quot;taille d'un double : %u bytes\n&quot;, sizeof(double));</code></pre><h3 id="r-interet-des-nombres-flottants" data-claire-element-id="417672">Intérêt des nombres flottants</h3><p id="r-417671" data-claire-element-id="417671">Vous pouvez utiliser les types flottants dans vos programmes si vous souhaitez manipuler des <strong>nombres à virgule</strong>, mais également pour stocker de <strong>très grands nombres</strong>. En effet, un <code data-claire-semantic="c">float</code> permet d'atteindre 1038, et un <code data-claire-semantic="c">double</code> 10308 ! Toutefois, pour des raisons de précision, vous ne pourrez évidemment pas conserver la valeur exacte d’un nombre à 38 ou 308 chiffres, ce serait trop beau (il y aurait besoin de bien plus de 32 ou 64 bits) : votre nombre sera arrondi.</p><h3 id="r-ecrire-une-constante" data-claire-element-id="417694">Écrire une constante</h3><p id="r-417673" data-claire-element-id="417673">La syntaxe pour écrire un nombre à virgule est : <code data-claire-semantic="c">-3141.59e7</code> (ou <code data-claire-semantic="c">-3141.59E7</code>, avec un E majuscule), ce qui signifie -3141,59 ×107. Attention, on met un point et non une virgule ! La lettre E collée au nombre signifie « exposant ». Celui-ci peut très bien être négatif comme dans <code data-claire-semantic="c">945.68e-3</code> (ce qui signifie 945.68 ×10-3).</p><p id="r-417674" data-claire-element-id="417674">De plus, si la partie entière ou la partie décimale d’un nombre vaut 0, on peut l’omettre ; de même pour l’exposant. Toutefois, il doit toujours y avoir au moins un point ou un exposant d'écrit, pour signifier au compilateur qu’on veut un nombre à virgule). Par exemple, les constantes suivantes sont équivalentes :</p><pre id="r-417675" data-claire-element-id="417675"><code data-claire-semantic="c">0.0e0 ;     0.0 ;
 0.e0 ;      0. ;
 .0e0 ;      .0 ;
  0e0 ;</code></pre><p id="r-417676" data-claire-element-id="417676">En revanche, écrire <code data-claire-semantic="c">0</code> tout court produira un entier. En effet, le compilateur ne voyant ni point ni lettre E, il ne peut pas savoir qu'il s'agit d'un nombre à virgule flottante.</p><p id="r-417677" data-claire-element-id="417677">Le type par défaut d'une constante à virgule flottante est <code data-claire-semantic="c">double</code>, mais on peut le changer avec un suffixe collé après la constante :</p><ul id="r-417682" data-claire-element-id="417682"><li id="r-417679" data-claire-element-id="417679"><p id="r-417678" data-claire-element-id="417678">la lettre F (minuscule ou majuscule) demande un <code data-claire-semantic="c">float</code> ;</p></li><li id="r-417681" data-claire-element-id="417681"><p id="r-417680" data-claire-element-id="417680">la lettre L (minuscule ou majuscule) demande un <code data-claire-semantic="c">long double</code>.</p></li></ul><p id="r-417683" data-claire-element-id="417683">Par exemple, <code data-claire-semantic="c">.1e-3f</code> sera de type <code data-claire-semantic="c">float</code>, <code data-claire-semantic="c">42.1337e-3l</code> de type <code data-claire-semantic="c">long double</code>.</p><p id="r-417684" data-claire-element-id="417684">Enfin, il peut être utile de savoir que le C99 permet aussi d'écrire ses constantes flottantes en hexadécimal ! :diable: Pour cela :</p><ul id="r-417691" data-claire-element-id="417691"><li id="r-417686" data-claire-element-id="417686"><p id="r-417685" data-claire-element-id="417685">ajoutez le préfixe <code data-claire-semantic="c">0x</code> (ou <code data-claire-semantic="c">0X</code>) avant votre constante (mais après le signe) ;</p></li><li id="r-417688" data-claire-element-id="417688"><p id="r-417687" data-claire-element-id="417687">écrivez la partie significative en base 16 (c'est-à-dire avec les chiffres de 0 à 9 et les lettres de A à F) ;</p></li><li id="r-417690" data-claire-element-id="417690"><p id="r-417689" data-claire-element-id="417689">l'exposant est obligatoire ; il doit être écrit en base 10 comme d'habitude (et non en hexadécimal), mais précédé de la lettre p (ou P) au lieu de e. De plus, il se réfère à une puissance de <strong>2</strong> et non de 10.</p></li></ul><p id="r-417692" data-claire-element-id="417692">Par exemple, <code data-claire-semantic="c">-0xC45.8p3</code> signifie - 0x C45,8 ×<strong>2</strong>3 (soit - 3141,5 ×23 = - 25 132).</p><p id="r-417693" data-claire-element-id="417693">L'intérêt à part faire mal au crâne ? Obtenir un nombre exact ! Les explications suivent…</p><h2 id="r-des-constantes-inexactes" data-claire-element-id="417698">Des constantes inexactes</h2><p id="r-417696" data-claire-element-id="417696">Attention : <strong>tous les nombres décimaux (c'est-à-dire écrits en base 10) ne sont pas forcément représentables de façon finie en binaire, et certains sont donc arrondis</strong> ! Ainsi, 0,1 en base 10 s'écrit en binaire 0b0,00011001100110011… avec une infinité de 0011 (de même que 1/3 = 0,3333… en base 10). <br/> Une partie significative écrite en base 10 ainsi qu'une puissance de 10 négative (c'est-à-dire qu'on divise par une puissance de 10) peuvent donc mener à des nombres inexacts.</p><p id="r-417697" data-claire-element-id="417697">En fait, seuls les nombres dont la partie décimale est le résultat d'une division par une puissance de 2 (comme .5 = 1/2, .75 = 3/4 ou encore .625 = 5/8) sont représentables en binaire avec un nombre fini de décimales.<br/> Spécifier la partie significative en hexadécimal (base 16) et l'exposant en termes de puissance de 2 permet donc un nombre exact (dans la limite de la capacité du type, bien sûr ^^ ).</p><h2 id="r-quelques-informations-pratiques" data-claire-element-id="417765">Quelques informations pratiques</h2><h3 id="r-les-fonctions-d-entree-et-de-sortie-formatees-printf-scanf" data-claire-element-id="417743">Les fonctions d'entrée et de sortie formatées : <code data-claire-semantic="c">printf</code> &amp; <code data-claire-semantic="c">scanf</code></h3><p id="r-417699" data-claire-element-id="417699">Vous voudrez sûrement savoir quels sont les formateurs pour lire ou écrire des nombres flottants. Voici un petit tableau résumé. Pour des infos complètes sur l'utilisation de <code data-claire-semantic="c">printf</code> et <code data-claire-semantic="c">scanf</code> (il y a plein d’options pour configurer l’affichage) : RTFM, <a href="http://linux.die.net/man/3/printf">bien</a><a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?scanf">sûr</a> !</p><table id="r-417725" data-claire-element-id="417725"><thead id="r-417705" data-claire-element-id="417705"><tr id="r-417704" data-claire-element-id="417704"><th id="r-417701" data-claire-element-id="417701"><p id="r-417700" data-claire-element-id="417700">Formateurs</p></th><th id="r-417703" data-claire-element-id="417703"><p id="r-417702" data-claire-element-id="417702">Utilisation</p></th></tr></thead><tbody id="r-417724" data-claire-element-id="417724"><tr id="r-417710" data-claire-element-id="417710"><td id="r-417707" data-claire-element-id="417707"><p id="r-417706" data-claire-element-id="417706"><code data-claire-semantic="c">&quot;%f&quot;</code>, <code data-claire-semantic="c">&quot;%F&quot;</code></p></td><td id="r-417709" data-claire-element-id="417709"><p id="r-417708" data-claire-element-id="417708">Affiche le <code data-claire-semantic="c">double</code> « simplement », comme vous avez l'habitude de l'écrire : l'affichage est du type <code>[-]XXXX.XXX</code>, où les <code>X</code> sont des chiffres de 0 à 9 et <code>[-]</code> symbolise le signe « moins » éventuel.</p></td></tr><tr id="r-417715" data-claire-element-id="417715"><td id="r-417712" data-claire-element-id="417712"><p id="r-417711" data-claire-element-id="417711"><code data-claire-semantic="c">&quot;%e&quot;</code>, <code data-claire-semantic="c">&quot;%E&quot;</code></p></td><td id="r-417714" data-claire-element-id="417714"><p id="r-417713" data-claire-element-id="417713">Affiche le <code data-claire-semantic="c">double</code> en écriture scientifique, c'est-à-dire avec un seul chiffre avant la virgule et un exposant introduit par la lettre e (ou E pour <code data-claire-semantic="c">&quot;%E&quot;</code>) ; l'affichage est donc du type <code>[-]X.XXXXXXeYY</code> (ou <code>[-]X.XXXXXXEYY</code>).</p></td></tr><tr id="r-417720" data-claire-element-id="417720"><td id="r-417717" data-claire-element-id="417717"><p id="r-417716" data-claire-element-id="417716"><code data-claire-semantic="c">&quot;%g&quot;</code>, <code data-claire-semantic="c">&quot;%G&quot;</code></p></td><td id="r-417719" data-claire-element-id="417719"><p id="r-417718" data-claire-element-id="417718">Une sorte de « combinaison » des formateurs précédents : utilise le premier style si le nombre n'est pas trop grand ou trop petit, le deuxième style sinon.</p></td></tr><tr id="r-417723" data-claire-element-id="417723"><td id="r-417722" data-claire-element-id="417722"><p id="r-417721" data-claire-element-id="417721">Remarquez que tous ces formateurs attendent des flottants de type <code data-claire-semantic="c">double</code>. Il n'existe pas de formateurs pour <code data-claire-semantic="c">float</code>, ce qui n'est pas dramatique car vous pouvez convertir vos nombres de <code data-claire-semantic="c">float</code> vers <code data-claire-semantic="c">double</code> pour les afficher (ce qui est fait automatiquement avec la syntaxe de <code data-claire-semantic="c">printf</code>).<br/> Le C99 vous permet d'ajouter la lettre L majuscule entre % et le formateur afin de correspondre à un <code data-claire-semantic="c">long double</code>.</p></td></tr></tbody></table><table id="r-417742" data-claire-element-id="417742"><thead id="r-417731" data-claire-element-id="417731"><tr id="r-417730" data-claire-element-id="417730"><th id="r-417727" data-claire-element-id="417727"><p id="r-417726" data-claire-element-id="417726">Formateurs</p></th><th id="r-417729" data-claire-element-id="417729"><p id="r-417728" data-claire-element-id="417728">Utilisation</p></th></tr></thead><tbody id="r-417741" data-claire-element-id="417741"><tr id="r-417737" data-claire-element-id="417737"><td id="r-417733" data-claire-element-id="417733"><p id="r-417732" data-claire-element-id="417732"><code data-claire-semantic="c">&quot;%e&quot;</code>, <code data-claire-semantic="c">&quot;%E&quot;</code>,<br/><code data-claire-semantic="c">&quot;%f&quot;</code>, <code data-claire-semantic="c">&quot;%F&quot;</code>,<br/><code data-claire-semantic="c">&quot;%g&quot;</code>, <code data-claire-semantic="c">&quot;%G&quot;</code></p></td><td id="r-417736" data-claire-element-id="417736"><p id="r-417734" data-claire-element-id="417734">Lit un nombre à virgule flottante et l'écrit dans la variable de type <code data-claire-semantic="c">float</code> indiquée. Le nombre lu doit être écrit de la même manière que vous écrivez une constante dans votre code source.</p><p id="r-417735" data-claire-element-id="417735">Contrairement à <code data-claire-semantic="c">printf</code>, tous ces formateurs sont équivalents.</p></td></tr><tr id="r-417740" data-claire-element-id="417740"><td id="r-417739" data-claire-element-id="417739"><p id="r-417738" data-claire-element-id="417738">Attention ! Contrairement à <code data-claire-semantic="c">printf</code>, <code data-claire-semantic="c">scanf</code> travaille par défaut avec des <code data-claire-semantic="c">float</code>. Pour lire un <code data-claire-semantic="c">double</code>, il faut ajouter la lettre 'l' minuscule entre % et le formateur ; pour un <code data-claire-semantic="c">long double</code>, il faut ajouter 'L' (ou 'll').</p></td></tr></tbody></table><h3 id="r-les-fonctions-mathematiques-avec-math-h" data-claire-element-id="417764">Les fonctions mathématiques avec <code data-claire-semantic="c">&lt;math.h&gt;</code></h3><p id="r-417744" data-claire-element-id="417744">Matheux, vous serez comblés : la bibliothèque standard du C met à votre disposition toute une gamme de fonctions mathématiques : valeur absolue, maximum de deux nombres, arrondis en tous sens, puissances, fonctions trigonométriques, exponentielles et logarithmes, etc. Ces fonctions sont définies dans le header <code data-claire-semantic="c">&lt;math.h&gt;</code>, qu'il vous faudra donc inclure dans vos sources.</p><p id="r-417745" data-claire-element-id="417745">Comme vous faire la liste complète et détaillée des fonctions disponibles serait inutile et fastidieux, je vous invite à consulter le manuel qui est fait pour ça (tout ça pour ne pas dire encore une fois : RTFM…).<br/> De plus, chacune des fonctions existantes ci-dessus se décline en fait en trois versions :</p><ul id="r-417752" data-claire-element-id="417752"><li id="r-417747" data-claire-element-id="417747"><p id="r-417746" data-claire-element-id="417746">une qui travaille avec des <code data-claire-semantic="c">double</code> : celle qui porte le nom « de base » (par exemple, <code data-claire-semantic="c">floor</code>, qui arrondit à l’inférieur) ;</p></li><li id="r-417749" data-claire-element-id="417749"><p id="r-417748" data-claire-element-id="417748">une qui travaille avec des <code data-claire-semantic="c">float</code> : il faut ajouter la lettre 'f' à la fin du nom de la fonction (<code data-claire-semantic="c">floorf</code> dans notre exemple) ;</p></li><li id="r-417751" data-claire-element-id="417751"><p id="r-417750" data-claire-element-id="417750">une qui travaille avec des <code data-claire-semantic="c">long double</code> : il faut ajouter la lettre 'l' à la fin du nom de la fonction (<code data-claire-semantic="c">floorl</code> dans notre exemple).</p></li></ul><p id="r-417753" data-claire-element-id="417753">Vous devez néanmoins retenir une chose. Ces fonctions ne sont pas incluses dans l'exécutable avec le reste de la bibliothèque standard, lors de l'édition des liens (la phase suivant la compilation). Il faut les lier manuellement.<br/> Sous GCC, cela se fait en passant le paramètre <code data-claire-semantic="console">-lm</code> lors de cette phase.<br/> Si vous travaillez avec Code::Blocks, alors il est probable que ce dernier ajoute automatiquement cette liaison. Si ce n'est pas le cas, vous pouvez suivre la démarche suivante :</p><ul id="r-417762" data-claire-element-id="417762"><li id="r-417755" data-claire-element-id="417755"><p id="r-417754" data-claire-element-id="417754"><em>Project</em> &gt; <em>Build options…</em> &gt; onglet <em>Linker settings</em> ;</p></li><li id="r-417757" data-claire-element-id="417757"><p id="r-417756" data-claire-element-id="417756">dans le champ <em>Link libraries</em> (à gauche), cliquez sur <kbd>Add</kbd> et entrez le nom de la bibliothèque à lier, soit « m », puis validez ;</p></li><li id="r-417759" data-claire-element-id="417759"><p id="r-417758" data-claire-element-id="417758">autre possibilité pour cette dernière étape : taper simplement « -lm » dans le champ <em>Other linker options</em> (à gauche).</p></li><li id="r-417761" data-claire-element-id="417761"><p id="r-417760" data-claire-element-id="417760">Voilà, les fonctions de <code data-claire-semantic="c">&lt;math.h&gt;</code> seront désormais incluses dans vos programmes !</p></li></ul><p id="r-417763" data-claire-element-id="417763">Voilà, on a fini avec les fondamentaux. Vous avez maintenant des connaissances suffisantes pour manier les nombres à virgule en C, vous pouvez aller jouer dans le jardin mais ce serait dommage de s'arrêter en si bon chemin… Après cette brève introduction en la matière, nous allons nous plonger au cœur des nombres flottants pour en étudier le moindre détail. Pas trop fatigué ? Il vaudrait mieux, parce qu'on vient à peine de commencer. <em>Yêêêhaaa !</em></p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c">Maîtrisez les nombres à virgule en C</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/utilisation-des-nombres-a-virgule-en-c">
Utilisation des nombres à virgule en C
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-le-codage-en-memoire-d-un-nombre-flottant">
IEEE 754 : le codage en mémoire d’un nombre flottant
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/un-peu-de-mathematiques-1">
Un peu de mathématiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-exceptions-arrondis">
IEEE 754 : Exceptions &amp; arrondis
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/comparer-des-nombres-flottants">
Comparer des nombres flottants
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/mais-qu-en-dit-la-norme-c">
Mais qu&#039;en dit la norme C ?
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-le-codage-en-memoire-d-un-nombre-flottant">
<span class="next">IEEE 754 : le codage en mémoire d’un nombre flottant</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="IEEE754lecodageenmmoiredunnombreflottant"></a><h2>IEEE 754 : le codage en mémoire d’un nombre flottant</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/utilisation-des-nombres-a-virgule-en-c">
<span class="arrow"></span>
<span class="next">Utilisation des nombres à virgule en C</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/un-peu-de-mathematiques-1">
<span class="next">Un peu de mathématiques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-417767" data-claire-element-id="417767">On va maintenant s'intéresser à la manière dont sont <strong>représentés</strong> en mémoire les nombres à virgule flottante ! Attention, on va faire une grosse partie théorique, alors préparez vos barres céréalées en cas d'hypoglycémie. :D</p><p id="r-417768" data-claire-element-id="417768">Ce que vais vous raconter dans cette partie <strong>n'est pas dans la norme C</strong>. La suite de ce cours se base sur la <strong>norme IEEE 754</strong> (ou plus précisément ANSI/IEEE Std 754-1985). Celle-ci spécifie :</p><ul id="r-417777" data-claire-element-id="417777"><li id="r-417770" data-claire-element-id="417770"><p id="r-417769" data-claire-element-id="417769">la <strong>manière de représenter les nombres flottants en mémoire</strong> avec plusieurs formats ;</p></li><li id="r-417772" data-claire-element-id="417772"><p id="r-417771" data-claire-element-id="417771">cinq <strong>opérations associées</strong> : l'addition (<code data-claire-semantic="c">+</code>), la soustraction (<code data-claire-semantic="c">-</code>), la multiplication (<code data-claire-semantic="c">*</code>), la division (<code data-claire-semantic="c">/</code>) et la racine carrée (<code data-claire-semantic="c">sqrt()</code>) ;</p></li><li id="r-417774" data-claire-element-id="417774"><p id="r-417773" data-claire-element-id="417773">des <strong>modes d'arrondi</strong> ;</p></li><li id="r-417776" data-claire-element-id="417776"><p id="r-417775" data-claire-element-id="417775">des <strong>exceptions</strong>.</p></li></ul><p id="r-417778" data-claire-element-id="417778">Ne vous inquiétez pas pour les deux derniers points, on en reparlera.</p><p id="r-417779" data-claire-element-id="417779">Elle est proposée par l'IEEE (<em>Institute of Electrical and Electronics Engineers</em>, l'Institut des Ingénieurs Électriciens et Électroniciens), une organisation américaine qui est devenue une référence en matière d'informatique.<br/> Cette norme est très suivie (en fait, sur la très grande majorité des ordinateurs aujourd'hui), mais vous pouvez très bien tomber sur une implémentation qui utilise un autre mode de représentation. :( Un point sur la norme C sera fait à la fin de ce chapitre (ainsi qu'une manière de déterminer si IEEE 754 est bien employé sur votre implémentation).<br/> Ce format aura son importance plus loin dans ce tutoriel.</p><h2 id="r-principes-generaux" data-claire-element-id="417862">Principes généraux</h2><p id="r-417780" data-claire-element-id="417780">Tout nombre à virgule peut être écrit en <strong>notation scientifique</strong>, c'est-à-dire avec un seul chiffre avant la virgule et multiplié par une puissance de <em>b</em> (<em>b</em> étant la base dans laquelle on écrit le nombre : 10 pour la base décimale, 2 pour le binaire, 16 pour l'hexa, etc.). Par exemple, le nombre -3141,5 est égal à -3,1415 ×103 . L'écriture binaire de ce nombre est 0b -110001000101,1, soit 0b-1,100010001011 ×211.</p><p id="r-417781" data-claire-element-id="417781">Pour stocker un nombre à virgule flottante, on se base sur sa notation binaire scientifique. En mémoire, un nombre flottant se décompose donc en <strong>3 parties</strong>. À partir du bit de poids fort, on a :</p><ul id="r-417790" data-claire-element-id="417790"><li id="r-417783" data-claire-element-id="417783"><p id="r-417782" data-claire-element-id="417782">le <strong>signe</strong>, codé sur <strong>un bit</strong> : ce bit vaut 0 si le nombre est positif, 1 s'il est négatif.<br/> Remarquez ici que la représentation du signe des nombres flottants se fait selon le bit de poids fort et non selon la règle du complément à 2. En conséquence, il existe deux représentations pour zéro, un positif et un négatif (c'est néanmoins un défaut mineur, les implémentations gérant cette dualité ; par exemple, <code data-claire-semantic="c">+0.0==-0.0</code> renverra vrai), et les valeurs possibles sont totalement « symétriques » par rapport à zéro (c'est la raison pour laquelle j'utiliserai souvent le symbole ±, « plus ou moins », par la suite) ;</p></li><li id="r-417787" data-claire-element-id="417787"><p id="r-417784" data-claire-element-id="417784">l'<strong>exposant</strong>, c'est-à-dire la puissance à laquelle il faut élever <strong>2</strong> (et non 10 !).<br/> Le nombre de bits qu'il occupe dépend de la taille du type.<br/> Ce nombre est un entier et peut être négatif. Pour le représenter, on n'utilise ni la règle du bit de signe, ni celle du complément à 2 (car cela rendrait la comparaison de nombres plus difficile, comme on le verra ensuite) ; on opère un <strong>décalage de l'exposant</strong> réel en lui ajoutant <strong>2e-1-1</strong>, où <em>e</em> représente le nombre de bits occupés par l'exposant ; en clair, ce nombre représente la valeur où tous les bits sauf celui de poids fort sont à 1 (c'est-à-dire 127 = 0b01111111 si l'exposant est codé sur 8 bits, ou 1023 = 0b01111111111 s'il est codé sur 11 bits) ;</p><aside id="r-417786" data-claire-element-id="417786" data-claire-semantic="information"><p id="r-417785" data-claire-element-id="417785">Par la suite, j'emploierai les termes d'exposant <em>décalé</em> et <em>réel</em> pour différencier l'exposant tel qu'il est codé en mémoire de l'exposant ainsi représenté.</p></aside></li><li id="r-417789" data-claire-element-id="417789"><p id="r-417788" data-claire-element-id="417788">la <strong>mantisse</strong>, c'est-à-dire la valeur de la <strong>partie décimale en notation binaire scientifique</strong> (avec un seul chiffre avant la virgule). On ne garde que la partie décimale car, du fait de la notation binaire, la partie entière est forcément égale à 1 (sauf dans les cas particuliers de zéro et de certains nombres très petits dont on reparlera). On parle de <em><strong>bit implicite</strong></em> (un bit « caché » représentant la partie entière, qui ici vaudrait 1).<br/> On économise ainsi un bit, ce qui permet d'avoir une précision plus grande.<br/> La mantisse occupe les bits de poids faibles restants.</p></li></ul><p id="r-417791" data-claire-element-id="417791">IEEE 754 spécifie deux grands formats basés sur ce modèle ; les deux types principaux du C pour les nombres à virgule flottante correspondent à ces deux formats.</p><table id="r-417856" data-claire-element-id="417856"><thead id="r-417816" data-claire-element-id="417816"><tr id="r-417802" data-claire-element-id="417802"><th id="r-417793" data-claire-element-id="417793"><p id="r-417792" data-claire-element-id="417792">Nom dans la<br/> norme IEE 754</p></th><th id="r-417795" data-claire-element-id="417795"><p id="r-417794" data-claire-element-id="417794">Type en C</p></th><th id="r-417797" data-claire-element-id="417797"><p id="r-417796" data-claire-element-id="417796">Taille (en bits)</p></th><th id="r-417799" data-claire-element-id="417799"><p id="r-417798" data-claire-element-id="417798">Chiffres<br/> significatifs<br/> (en base 10)</p></th><th id="r-417801" data-claire-element-id="417801"><p id="r-417800" data-claire-element-id="417800">Valeurs absolues possibles</p></th></tr><tr id="r-417815" data-claire-element-id="417815"><th id="r-417804" data-claire-element-id="417804"><p id="r-417803" data-claire-element-id="417803">Total</p></th><th id="r-417806" data-claire-element-id="417806"><p id="r-417805" data-claire-element-id="417805">s</p></th><th id="r-417808" data-claire-element-id="417808"><p id="r-417807" data-claire-element-id="417807">e</p></th><th id="r-417810" data-claire-element-id="417810"><p id="r-417809" data-claire-element-id="417809">m</p></th><th id="r-417812" data-claire-element-id="417812"><p id="r-417811" data-claire-element-id="417811">minimum</p></th><th id="r-417814" data-claire-element-id="417814"><p id="r-417813" data-claire-element-id="417813">maximum</p></th></tr></thead><tbody id="r-417855" data-claire-element-id="417855"><tr id="r-417835" data-claire-element-id="417835"><td id="r-417818" data-claire-element-id="417818"><p id="r-417817" data-claire-element-id="417817"><em>simple précision</em></p></td><td id="r-417820" data-claire-element-id="417820"><p id="r-417819" data-claire-element-id="417819"><code data-claire-semantic="c">float</code></p></td><td id="r-417822" data-claire-element-id="417822"><p id="r-417821" data-claire-element-id="417821">32 bits</p></td><td id="r-417824" data-claire-element-id="417824"><p id="r-417823" data-claire-element-id="417823">1</p></td><td id="r-417826" data-claire-element-id="417826"><p id="r-417825" data-claire-element-id="417825">8</p></td><td id="r-417828" data-claire-element-id="417828"><p id="r-417827" data-claire-element-id="417827">23</p></td><td id="r-417830" data-claire-element-id="417830"><p id="r-417829" data-claire-element-id="417829">7</p></td><td id="r-417832" data-claire-element-id="417832"><p id="r-417831" data-claire-element-id="417831">1,2 ×10-38</p></td><td id="r-417834" data-claire-element-id="417834"><p id="r-417833" data-claire-element-id="417833">3,4 ×10+38</p></td></tr><tr id="r-417854" data-claire-element-id="417854"><td id="r-417837" data-claire-element-id="417837"><p id="r-417836" data-claire-element-id="417836"><em>double précision</em></p></td><td id="r-417839" data-claire-element-id="417839"><p id="r-417838" data-claire-element-id="417838"><code data-claire-semantic="c">double</code></p></td><td id="r-417841" data-claire-element-id="417841"><p id="r-417840" data-claire-element-id="417840">64 bits</p></td><td id="r-417843" data-claire-element-id="417843"><p id="r-417842" data-claire-element-id="417842">1</p></td><td id="r-417845" data-claire-element-id="417845"><p id="r-417844" data-claire-element-id="417844">11</p></td><td id="r-417847" data-claire-element-id="417847"><p id="r-417846" data-claire-element-id="417846">52</p></td><td id="r-417849" data-claire-element-id="417849"><p id="r-417848" data-claire-element-id="417848">16</p></td><td id="r-417851" data-claire-element-id="417851"><p id="r-417850" data-claire-element-id="417850">2,2 ×10-308</p></td><td id="r-417853" data-claire-element-id="417853"><p id="r-417852" data-claire-element-id="417852">1,8 ×10+308</p></td></tr></tbody></table><p id="r-417857" data-claire-element-id="417857">Nous détaillerons plus tard les deux dernières colonnes.</p><p id="r-417858" data-claire-element-id="417858">En résumé (pour un <code data-claire-semantic="c">float</code> de 32 bits), la représentation de -3141,5 est :</p><figure id="r-417860" data-claire-element-id="417861"><img id="r-417859" data-claire-element-id="417859" src="medias/uploads.siteduzero.com_files_322001_323000_322943.png" alt="schéma : de l'écriture décimale à la représentation en mémoire d'un nombre flottant normalisé"/></figure><h2 id="r-les-differents-types-de-nombres-representables" data-claire-element-id="417998">Les différents types de nombres représentables</h2><p id="r-417863" data-claire-element-id="417863">Il y a cependant des cas particuliers, car un nombre à virgule flottante peut représenter autre chose que des nombres « normaux ». Il peut aussi valoir :</p><ul id="r-417870" data-claire-element-id="417870"><li id="r-417865" data-claire-element-id="417865"><p id="r-417864" data-claire-element-id="417864"><strong>l'infini positif ou négatif</strong> (noté \infty par les mathématiciens). C'est par exemple le résultat de la division d'un nombre non nul par zéro (le signe dépendant alors du signe du numérateur et du zéro en dénominateur) ;</p></li><li id="r-417867" data-claire-element-id="417867"><p id="r-417866" data-claire-element-id="417866"><strong>NaN</strong> (<em>not a number</em>, pas un nombre). <strong>NaN est une valeur spéciale qui est utilisée pour signaler une erreur</strong> (0 \div 0 ou \sqrt{-1} par exemples). N'importe quel calcul avec un NaN doit renvoyer NaN (sauf quelques exceptions), et n'importe quelle comparaison avec un NaN doit renvoyer faux (sauf <code data-claire-semantic="c">!=</code>) ; un NaN n'est même pas égal à lui-même, c'est pourquoi <code data-claire-semantic="c">x==x</code> peut renvoyer faux ;</p></li><li id="r-417869" data-claire-element-id="417869"><p id="r-417868" data-claire-element-id="417868">enfin, on n'a pas encore réglé le problème de zéro.</p></li></ul><p id="r-417871" data-claire-element-id="417871">Quelques calculs avec ces valeurs particulières :</p><div id="r-417874" data-claire-element-id="417874"><p id="r-417872" data-claire-element-id="417872">\begin{matrix} ext{Le symbole}\pm ext{dans le r\'esultat d'une division signifie que le signe} \\ ext{d\'epend de ceux du num\'erateur et du d\'enominateur selon la r\`egle suivante :} \\ ext{- deux signes identiques : signe +} \\ ext{- deux signes diff\'erents : signe -} \\ \end{matrix}</p><p id="r-417873" data-claire-element-id="417873">\begin{matrix} x \div 0 &amp;=&amp; \pm\infty \\ 0 \div 0 &amp;=&amp; NaN \\ \\ x \div \infty &amp;=&amp; \pm0 \\ \infty \div \infty &amp;=&amp; NaN \\ \\ 0 imes \infty &amp;=&amp; NaN \\ \\ (+\infty) + (+\infty) &amp;=&amp; +\infty \\ (+\infty) - (+\infty) &amp;=&amp; NaN \\ \end{matrix}</p></div><aside id="r-417876" data-claire-element-id="417876" data-claire-semantic="warning"><p id="r-417875" data-claire-element-id="417875">Ça ne vous autorise pas à écrire des choses comme <code data-claire-semantic="c">var / 0</code> dans votre programme ! En effet, la division par zéro avec des nombres entiers a un comportement indéterminé, c'est-à-dire non prévu par la norme du langage C. Ça signifie qu'il peut se passer n'importe quoi lorsque vous faites ceci, selon le bon plaisir de votre compilateur, de votre système d'exploitation… Généralement, cela provoque une erreur fatale et un beau plantage en règle de votre programme.<br/> D'ailleurs, le comportement de la division par zéro de nombres flottants est également indéterminé. Les règles de calcul ci-dessus ne sont en fait déterminées que par la norme IEEE 754, et non par la norme C elle-même.</p></aside><p id="r-417877" data-claire-element-id="417877">Pour représenter tout ce petit monde, on utilise des valeurs spéciales de l'exposant (qui ne peuvent donc pas être utilisées pour des nombres normaux) :</p><ul id="r-417888" data-claire-element-id="417888"><li id="r-417879" data-claire-element-id="417879"><p id="r-417878" data-claire-element-id="417878">Si l'exposant vaut sa valeur maximale (tous les bits à 1) et que la mantisse n'est pas nulle, alors c'est <strong>NaN</strong>.</p></li><li id="r-417881" data-claire-element-id="417881"><p id="r-417880" data-claire-element-id="417880">Si l'exposant vaut sa valeur maximale et que la mantisse est nulle, alors c'est <strong>l'infini</strong> (positif ou négatif, selon le bit de signe).</p></li><li id="r-417883" data-claire-element-id="417883"><p id="r-417882" data-claire-element-id="417882">Si l'exposant décalé vaut 0 et que la mantisse est nulle, alors c'est <strong>zéro</strong> (positif ou négatif, selon le bit de signe).</p></li><li id="r-417885" data-claire-element-id="417885"><p id="r-417884" data-claire-element-id="417884">Si l'exposant décalé vaut 0 et que la mantisse n'est pas nulle, alors c'est un <strong>nombre <em>dénormalisé</em></strong> : on considère que le bit implicite (la partie entière en notation scientifique) vaut 0.</p></li><li id="r-417887" data-claire-element-id="417887"><p id="r-417886" data-claire-element-id="417886">Dans tous les autres cas, c'est un <strong>nombre <em>normalisé</em></strong> : on considère que le bit implicite vaut 1. C’est le cas « normal ».</p></li></ul><p id="r-417889" data-claire-element-id="417889">Un petit tableau pour récapituler tout ça de manière visuelle (pour un <code data-claire-semantic="c">float</code> de 32 bits)…</p><table id="r-417949" data-claire-element-id="417949"><thead id="r-417902" data-claire-element-id="417902"><tr id="r-417896" data-claire-element-id="417896"><th id="r-417891" data-claire-element-id="417891"><p id="r-417890" data-claire-element-id="417890">Type</p></th><th id="r-417893" data-claire-element-id="417893"><p id="r-417892" data-claire-element-id="417892">Représentation mémoire</p></th><th id="r-417895" data-claire-element-id="417895"><p id="r-417894" data-claire-element-id="417894">Valeur</p></th></tr><tr id="r-417901" data-claire-element-id="417901"><th id="r-417898" data-claire-element-id="417898"><p id="r-417897" data-claire-element-id="417897">binaire</p></th><th id="r-417900" data-claire-element-id="417900"><p id="r-417899" data-claire-element-id="417899">hexadécimal</p></th></tr></thead><tbody id="r-417948" data-claire-element-id="417948"><tr id="r-417911" data-claire-element-id="417911"><td id="r-417904" data-claire-element-id="417904"><p id="r-417903" data-claire-element-id="417903"><strong><em>Not a Number</em></strong></p></td><td id="r-417906" data-claire-element-id="417906"><p id="r-417905" data-claire-element-id="417905">[0/1] — 11111111 — 11111111111111111111111<br/> …<br/>[0/1] — 11111111 — 00000000000000000000001</p></td><td id="r-417908" data-claire-element-id="417908"><p id="r-417907" data-claire-element-id="417907">[7/F]F FF FF FF<br/> …<br/>[7/F]F 80 00 01</p></td><td id="r-417910" data-claire-element-id="417910"><p id="r-417909" data-claire-element-id="417909">NaN<br/> …<br/> NaN</p></td></tr><tr id="r-417920" data-claire-element-id="417920"><td id="r-417913" data-claire-element-id="417913"><p id="r-417912" data-claire-element-id="417912"><strong>Infini</strong></p></td><td id="r-417915" data-claire-element-id="417915"><p id="r-417914" data-claire-element-id="417914">[0/1] — 11111111 — 00000000000000000000000</p></td><td id="r-417917" data-claire-element-id="417917"><p id="r-417916" data-claire-element-id="417916">[7/F]F 80 00 00</p></td><td id="r-417919" data-claire-element-id="417919"><p id="r-417918" data-claire-element-id="417918">± \infty</p></td></tr><tr id="r-417929" data-claire-element-id="417929"><td id="r-417922" data-claire-element-id="417922"><p id="r-417921" data-claire-element-id="417921"><strong>Nombre normalisé</strong></p></td><td id="r-417924" data-claire-element-id="417924"><p id="r-417923" data-claire-element-id="417923">[0/1] — 11111110 — 11111111111111111111111<br/> …<br/>[0/1] — 00000001 — 00000000000000000000000</p></td><td id="r-417926" data-claire-element-id="417926"><p id="r-417925" data-claire-element-id="417925">[7/F]F 7F FF FF<br/> …<br/>[0/8]0 80 00 00</p></td><td id="r-417928" data-claire-element-id="417928"><p id="r-417927" data-claire-element-id="417927">± 3,4028235 ×10+38<br/> …<br/> ± 1,1754944 ×10-38</p></td></tr><tr id="r-417938" data-claire-element-id="417938"><td id="r-417931" data-claire-element-id="417931"><p id="r-417930" data-claire-element-id="417930"><strong>Nombre dénormalisé</strong></p></td><td id="r-417933" data-claire-element-id="417933"><p id="r-417932" data-claire-element-id="417932">[0/1] — 00000000 — 11111111111111111111111<br/> …<br/>[0/1] — 00000000 — 00000000000000000000001</p></td><td id="r-417935" data-claire-element-id="417935"><p id="r-417934" data-claire-element-id="417934">[0/8]0 7F FF FF<br/> …<br/>[0/8]0 00 00 01</p></td><td id="r-417937" data-claire-element-id="417937"><p id="r-417936" data-claire-element-id="417936">± 1,1754942 ×10-38<br/> …<br/> ± 1,4012985 ×10-45</p></td></tr><tr id="r-417947" data-claire-element-id="417947"><td id="r-417940" data-claire-element-id="417940"><p id="r-417939" data-claire-element-id="417939"><strong>Zéro</strong></p></td><td id="r-417942" data-claire-element-id="417942"><p id="r-417941" data-claire-element-id="417941">[0/1] — 00000000 — 00000000000000000000000</p></td><td id="r-417944" data-claire-element-id="417944"><p id="r-417943" data-claire-element-id="417943">[0/8]0 00 00 00</p></td><td id="r-417946" data-claire-element-id="417946"><p id="r-417945" data-claire-element-id="417945">± 0</p></td></tr></tbody></table><p id="r-417950" data-claire-element-id="417950">À titre informatif, je vous mets aussi le tableau équivalent pour un <code data-claire-semantic="c">double</code> de 64 bits (sans le binaire, ça prend trop de place).</p><table id="r-417995" data-claire-element-id="417995"><thead id="r-417958" data-claire-element-id="417958"><tr id="r-417957" data-claire-element-id="417957"><th id="r-417952" data-claire-element-id="417952"><p id="r-417951" data-claire-element-id="417951">Type</p></th><th id="r-417954" data-claire-element-id="417954"><p id="r-417953" data-claire-element-id="417953">Représentation mémoire</p></th><th id="r-417956" data-claire-element-id="417956"><p id="r-417955" data-claire-element-id="417955">Valeur</p></th></tr></thead><tbody id="r-417994" data-claire-element-id="417994"><tr id="r-417965" data-claire-element-id="417965"><td id="r-417960" data-claire-element-id="417960"><p id="r-417959" data-claire-element-id="417959"><em><strong>Not a Number</strong></em></p></td><td id="r-417962" data-claire-element-id="417962"><p id="r-417961" data-claire-element-id="417961">[7/F]F FF FF FF   FF FF FF FF<br/> …<br/>[7/F]F F0 00 00   00 00 00 01</p></td><td id="r-417964" data-claire-element-id="417964"><p id="r-417963" data-claire-element-id="417963">NaN<br/> …<br/> NaN</p></td></tr><tr id="r-417972" data-claire-element-id="417972"><td id="r-417967" data-claire-element-id="417967"><p id="r-417966" data-claire-element-id="417966"><strong>Infini</strong></p></td><td id="r-417969" data-claire-element-id="417969"><p id="r-417968" data-claire-element-id="417968">[7/F]F F0 00 00   00 00 00 00</p></td><td id="r-417971" data-claire-element-id="417971"><p id="r-417970" data-claire-element-id="417970">± \infty</p></td></tr><tr id="r-417979" data-claire-element-id="417979"><td id="r-417974" data-claire-element-id="417974"><p id="r-417973" data-claire-element-id="417973"><strong>Nombre normalisé</strong></p></td><td id="r-417976" data-claire-element-id="417976"><p id="r-417975" data-claire-element-id="417975">[7/F]F EF FF FF   FF FF FF FF<br/> …<br/>[0/8]0 10 00 00   00 00 00 00</p></td><td id="r-417978" data-claire-element-id="417978"><p id="r-417977" data-claire-element-id="417977">± 1,7976931348623157 ×10+308<br/> …<br/> ± 2,2250738585072014 ×10-308</p></td></tr><tr id="r-417986" data-claire-element-id="417986"><td id="r-417981" data-claire-element-id="417981"><p id="r-417980" data-claire-element-id="417980"><strong>Nombre dénormalisé</strong></p></td><td id="r-417983" data-claire-element-id="417983"><p id="r-417982" data-claire-element-id="417982">[0/8]0 0F FF FF   FF FF FF FF<br/> …<br/>[0/8]0 00 00 00   00 00 00 01</p></td><td id="r-417985" data-claire-element-id="417985"><p id="r-417984" data-claire-element-id="417984">± 2,2250738585072010 ×10-308<br/> …<br/> ± 5,0000000000000000 ×10-324</p></td></tr><tr id="r-417993" data-claire-element-id="417993"><td id="r-417988" data-claire-element-id="417988"><p id="r-417987" data-claire-element-id="417987"><strong>Zéro</strong></p></td><td id="r-417990" data-claire-element-id="417990"><p id="r-417989" data-claire-element-id="417989">[0/8]0 00 00 00   00 00 00 00</p></td><td id="r-417992" data-claire-element-id="417992"><p id="r-417991" data-claire-element-id="417991">± 0</p></td></tr></tbody></table><p id="r-417996" data-claire-element-id="417996">Notez que pour passer d'un nombre positif à son équivalent négatif, il suffit d'additionner 0x 8000 0000 à sa représentation en mémoire (ou 0x 8000 0000 0000 0000 s'il s'agit d'un <code data-claire-semantic="c">double</code>). Ceci nous servira plus tard. ;)</p><p id="r-417997" data-claire-element-id="417997">Courage, cette partie théorique n'est pas encore finie, et peut-être que vous trouvez ça barbant, mais ça nous servira pour la suite.</p><h2 id="r-nombres-denormalises" data-claire-element-id="418026">Nombres dénormalisés</h2><p id="r-417999" data-claire-element-id="417999">Nous allons maintenant nous attarder sur les nombres dénormalisés. C'est qu'ils sont traîtres, les bougres.</p><p id="r-418000" data-claire-element-id="418000"><strong>Un nombre dénormalisé est un nombre si petit (en valeur absolue) que l'on ne peut pas le représenter en mémoire en se basant sur son écriture scientifique.</strong> Par exemple, 0b 1011 ×2-133 (soit environ 1,0101905 ×10-39) a pour écriture scientifique 0b 1,011 ×2-130 ; cependant, on ne peut pas stocker l'exposant -130 dans un <code data-claire-semantic="c">float</code>.</p><p id="r-418001" data-claire-element-id="418001"><strong>On ruse donc en écrivant le nombre avec le plus petit exposant possible.</strong><em>Question :</em> quel est cet exposant (pour un <code data-claire-semantic="c">float</code>) ?<br/> Si vous avez répondu -127 (et je suis sûr que vous l'avez fait, si vous suivez encore ce cours), vous êtes tombés dans le piège. Mouahaha. :p</p><div id="r-418003" data-claire-element-id="418003" data-claire-semantic="question"><p id="r-418002" data-claire-element-id="418002">Mais pourtant, c'est bien l'exposant non-décalé minimal, celui qui sert pour représenter des nombres dénormalisés ?</p></div><p id="r-418004" data-claire-element-id="418004">Tout à fait. En fait, les gens de chez IEEE (qui sont très très intelligents, si si) ont décidés de compliquer la chose. Ils ont choisi que, bien que l'exposant non-décalé en mémoire soit -127 (pour un <code data-claire-semantic="c">float</code>), <strong>l'exposant réel d'un nombre dénormalisé serait -126</strong>, c'est-à-dire le même que pour les plus petits nombres normalisés !</p><p id="r-418005" data-claire-element-id="418005">Pourquoi cela ? Pour assurer une sorte de continuité avec les premiers nombres normalisés. Puisqu'ils ont le même exposant réel, les nombres dénormalisés et les premiers nombres normalisés sont à intervalles réguliers :</p><p id="r-418006" data-claire-element-id="418006"><cite>Citation : liste des nombres dénormalisés et premiers nombres normalisés (pour un float)</cite></p><blockquote id="r-418008" data-claire-element-id="418008"><p id="r-418007" data-claire-element-id="418007">0b 0,00000000000000000000000 ×2-126   // <strong>zéro</strong><br/>0b 0,00000000000000000000001 ×2-126   // 1er nombre <strong>dénormalisé</strong><br/>0b 0,00000000000000000000010 ×2-126   // nombre dénormalisé suivant<br/>    …<br/>0b 0,11111111111111111111110 ×2-126   // avant-dernier nombre dénormalisé<br/>0b 0,11111111111111111111111 ×2-126   // dernier nombre dénormalisé<br/>0b 1,00000000000000000000000 ×2-126   // 1er nombre <strong>normalisé</strong><br/>0b 1,00000000000000000000001 ×2-126   // nombre normalisé suivant<br/>    …<br/>0b 1,11111111111111111111110 ×2-126   // avant-dernier nombre normalisé de cet exposant<br/>0b 1,11111111111111111111111 ×2-126   // dernier nombre normalisé de cet exposant</p></blockquote><p id="r-418009" data-claire-element-id="418009">Revenons à nos moutons. Comme je le disais, on écrit donc le nombre avec le plus petit exposant possible, soit dans notre exemple 0b+ 0,0001011 ×2-126.<br/> On traduit ensuite ceci de façon similaire à ce qu'on a fait pour un nombre normalisé : suivez les couleurs !</p><figure id="r-418011" data-claire-element-id="418012"><img id="r-418010" data-claire-element-id="418010" src="medias/uploads.siteduzero.com_files_323001_324000_323151.png" alt="schéma : de l'écriture décimale à la représentation en mémoire d'un nombre flottant dénormalisé"/></figure><p id="r-418013" data-claire-element-id="418013">Vous comprenez maintenant pourquoi le bit implicite est à 0 pour un nombre dénormalisé.</p><p id="r-418014" data-claire-element-id="418014">Pour un <code data-claire-semantic="c">double</code>, l'exposant sera -1022 ; de manière générale, il s'agit de 1 - d\'ecalage.</p><div id="r-418016" data-claire-element-id="418016" data-claire-semantic="question"><p id="r-418015" data-claire-element-id="418015">Mais pourquoi avoir inventé les nombres dénormalisés ? o_O Il aurait été plus simple de décider qu'à l'exposant décalé nul correspondaient également des nombres habituels (dont l'exposant réel aurait bien été -127 et non -126).</p></div><p id="r-418017" data-claire-element-id="418017">C'est vrai, on peut cependant trouver plusieurs raisons :</p><ul id="r-418024" data-claire-element-id="418024"><li id="r-418019" data-claire-element-id="418019"><p id="r-418018" data-claire-element-id="418018">Historiquement, l'exposant minimal servait pour représenter zéro, quelle que soit la valeur de la mantisse ; les nombres dénormalisés ont été introduits en 1985 avec la première version de la norme IEEE 754.</p></li><li id="r-418021" data-claire-element-id="418021"><p id="r-418020" data-claire-element-id="418020">D'ailleurs, si l'on avait choisi des nombres normalisés pour « remplir » cette plage de valeurs, la représentation de zéro n'aurait plus été cohérente. En effet, on se serait retrouvé avec ±<em>zéro</em> = ± 1,00000000000000000000000 ×2-127 (le bit implicite valant 1).<br/> Cela dit, les nombres dénormalisés introduisent eux-même une incohérence, puisqu'il y a deux types de nombres qu'il faut interpréter différemment ; de plus, on aurait été tout à fait capable de gérer cette incohérence pour interpréter correctement zéro.</p></li><li id="r-418023" data-claire-element-id="418023"><p id="r-418022" data-claire-element-id="418022">Les nombres dénormalisés permettent de représenter des nombres bien plus petits (plus proches de zéro) que si l'on avait choisi des nombres normalisés. En effet, le plus petit nombre dénormalisé est ± 0b 0,00000000000000000000001 ×2-126, soit ±1 ×2-149 (-126-23 = -149) ; si l'on avait choisi des nombres normalisés, le plus petit aurait été ± 0b 1,00000000000000000000001 ×2-127.</p></li></ul><p id="r-418025" data-claire-element-id="418025">Cependant, un reproche qu'on pourrait faire aux nombres dénormalisés est qu'en plus de tout compliquer pour nous autres pauvres humains, ils perdent en précision au fur et à mesure qu'ils se rapprochent de zéro : c'est ce que nous allons voir dans la partie suivante.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c">Maîtrisez les nombres à virgule en C</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/utilisation-des-nombres-a-virgule-en-c">
Utilisation des nombres à virgule en C
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-le-codage-en-memoire-d-un-nombre-flottant">
IEEE 754 : le codage en mémoire d’un nombre flottant
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/un-peu-de-mathematiques-1">
Un peu de mathématiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-exceptions-arrondis">
IEEE 754 : Exceptions &amp; arrondis
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/comparer-des-nombres-flottants">
Comparer des nombres flottants
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/mais-qu-en-dit-la-norme-c">
Mais qu&#039;en dit la norme C ?
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/utilisation-des-nombres-a-virgule-en-c">
<span class="arrow"></span>
<span class="next">Utilisation des nombres à virgule en C</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/un-peu-de-mathematiques-1">
<span class="next">Un peu de mathématiques</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Unpeudemathmatiques"></a><h2>Un peu de mathématiques</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-le-codage-en-memoire-d-un-nombre-flottant">
<span class="arrow"></span>
<span class="next">IEEE 754 : le codage en mémoire d’un nombre flottant</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-exceptions-arrondis">
<span class="next">IEEE 754 : Exceptions &amp; arrondis</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-418028" data-claire-element-id="418028">Dans cette partie, nous allons continuer à approfondir les aspects théoriques. Elle va se révéler très mathématique. &gt;_</p><h2 id="r-retrouver-la-valeur-du-nombre-flottant" data-claire-element-id="418070">Retrouver la valeur du nombre flottant</h2><p id="r-418029" data-claire-element-id="418029">Non, restez ! Bon, si vraiment le mot « mathématiques » vous fait pousser des boutons, vous pouvez passer cette partie, mais elle est intéressante pour bien comprendre la conversion de la représentation en mémoire vers la valeur.</p><aside id="r-418031" data-claire-element-id="418031" data-claire-semantic="information"><p id="r-418030" data-claire-element-id="418030">Pour la suite, vous devrez être à l'aise avec le binaire car je ne détaillerai pas les calculs. Sinon, autant passer cette partie. De toute façon, les formules ne sont pas à savoir par cœur : elles sont là à titre informatif et vous devriez être capable de les retrouver.</p></aside><p id="r-418032" data-claire-element-id="418032">Pour la suite, on note :</p><ul id="r-418046" data-claire-element-id="418046"><li id="r-418034" data-claire-element-id="418034"><p id="r-418033" data-claire-element-id="418033">flottant la valeur du flottant représenté ;</p></li><li id="r-418036" data-claire-element-id="418036"><p id="r-418035" data-claire-element-id="418035">m et e le nombre de bits occupés par la mantisse et l'exposant (respectivement) ;</p></li><li id="r-418038" data-claire-element-id="418038"><p id="r-418037" data-claire-element-id="418037">mantisse la mantisse (plus précisément, sa représentation entière) ;</p></li><li id="r-418045" data-claire-element-id="418045"><p id="r-418039" data-claire-element-id="418039">exposant l'exposant non-décalé (en termes de puissances de 2) ; le décalage de l'exposant est d\'ecalage= 2^{e-1}-1, on en déduit les valeurs limites de l'exposant :</p><ul id="r-418044" data-claire-element-id="418044"><li id="r-418041" data-claire-element-id="418041"><p id="r-418040" data-claire-element-id="418040">la valeur minimale de l'exposant non-décalé, réservée aux zéros et nombres dénormalisés, est exposantMin=\quad 0 - d\'ecalage \quad= 1 - 2^{e-1} (mais l'exposant réel des dénormalisés est exposantMin+1) ;</p></li><li id="r-418043" data-claire-element-id="418043"><p id="r-418042" data-claire-element-id="418042">la valeur maximale de l'exposant non-décalé, réservée aux infinis et NaN, est exposantMax=\quad (2^e-1) - d\'ecalage \quad= 2^{e-1}.</p></li></ul></li></ul><p id="r-418047" data-claire-element-id="418047">Pour retrouver la partie significative de la notation scientifique, il suffit de faire 1+\frac{mantisse}{2^m} si le nombre est normalisé, ou 0+\frac{mantisse}{2^m} s'il est dénormalisé.</p><ul id="r-418052" data-claire-element-id="418052"><li id="r-418049" data-claire-element-id="418049"><p id="r-418048" data-claire-element-id="418048">1 ou 0 représente la partie entière du flottant (c'est-à-dire le bit implicite).</p></li><li id="r-418051" data-claire-element-id="418051"><p id="r-418050" data-claire-element-id="418050">La fraction qui suit représente la partie décimale (on a 0\le\frac{mantisse}{2^m}&lt;1 ).</p></li></ul><p id="r-418053" data-claire-element-id="418053">Ensuite, il suffit de multiplier par la puissance de 2 indiquée par l'exposant réel, et d'adapter le signe selon le bit de signe :</p><ul id="r-418058" data-claire-element-id="418058"><li id="r-418055" data-claire-element-id="418055"><p id="r-418054" data-claire-element-id="418054">flottant=\quad \pm\enspace (1+\frac{mantisse}{2^m}) imes2^{exposant} (normalisé) ;</p></li><li id="r-418057" data-claire-element-id="418057"><p id="r-418056" data-claire-element-id="418056">flottant=\quad \pm\enspace (0+\frac{mantisse}{2^m}) imes2^{exposantMin+1} (dénormalisé).</p></li></ul><p id="r-418059" data-claire-element-id="418059">Si l'on reprend les exemples de tout à l'heure…</p><h3 id="r-exemple-1-nombre-normalise" data-claire-element-id="418064">Exemple 1 : Nombre normalisé</h3><figure id="r-418061" data-claire-element-id="418062"><img id="r-418060" data-claire-element-id="418060" src="medias/uploads.siteduzero.com_files_322001_323000_322947.png" alt="schéma : de la représentation en mémoire à l'écriture décimale d'un nombre flottant normalisé"/></figure><p id="r-418063" data-claire-element-id="418063">\[\begin{aligned}flottant &amp;=\quad -\enspace (1 + \frac{ extit{0b} hinspace 10001000101100000000000}{2^{23}}) imes2^{11}\\ &amp;=\quad -\enspace (1 + \frac{4,478976 imes10^6}{2^{23}}) imes2^{11} \quad\quad=\enspace -3141{,}5\end{aligned}\]<br/> On retrouve bien -3141,5. :)</p><h3 id="r-exemple-2-nombre-denormalise" data-claire-element-id="418069">Exemple 2 : Nombre dénormalisé</h3><figure id="r-418066" data-claire-element-id="418067"><img id="r-418065" data-claire-element-id="418065" src="medias/uploads.siteduzero.com_files_323001_324000_323193.png" alt="schéma : de la représentation en mémoire à l'écriture décimale d'un nombre flottant dénormalisé"/></figure><p id="r-418068" data-claire-element-id="418068">\[\begin{aligned}flottant &amp;=\quad +\enspace (0 + \frac{ extit{0b} hinspace 00010110000000000000000}{2^{23}}) imes2^{-127+1}\\ &amp;=\quad +\enspace (0 + \frac{720896}{2^{23}}) imes2^{-126} \quad\quad\approx\enspace +\enspace 1{,}0101905 imes10^{-39}\end{aligned}\]<br/> Là aussi, on retrouve bien le nombre de départ.</p><h2 id="r-intervalle-entre-les-nombres-en-fonction-de-l-exposant" data-claire-element-id="418082">Intervalle entre les nombres en fonction de l'exposant</h2><p id="r-418071" data-claire-element-id="418071">Selon la norme IEEE 754, les nombres consécutifs de même exposant (qu'ils soient normalisés ou pas) sont « placés » à <strong>intervalle régulier</strong>. En effet, pour passer d'un nombre au nombre suivant, on ajoute toujours \delta=\quad 0{,}00000000000000000000001 imes2^{exposant} \enspace= \frac{1}{2^m} imes2^{exposant} \enspace= 2^{exposant-m}.</p><p id="r-418072" data-claire-element-id="418072">Cet intervalle double quand on passe d'un exposant à l'exposant supérieur. Quelques valeurs remarquables pour un <code data-claire-semantic="c">float</code> (ne les apprenez pas !) :</p><ul id="r-418081" data-claire-element-id="418081"><li id="r-418074" data-claire-element-id="418074"><p id="r-418073" data-claire-element-id="418073">2-126 - 23 = 2-149 ≈ 1,40 ×10-45 : écart entre les nombres dénormalisés et les premiers nombres normalisés (et valeur du tout premier nombre dénormalisé) ;</p></li><li id="r-418076" data-claire-element-id="418076"><p id="r-418075" data-claire-element-id="418075">20 - 23 ≈ 1,19 ×10-7 : écart entre les nombres normalisés compris entre 1 et 2 ;</p></li><li id="r-418078" data-claire-element-id="418078"><p id="r-418077" data-claire-element-id="418077">1 : écart entre les nombres normalisés d'exposant non-décalé 23 ;</p></li><li id="r-418080" data-claire-element-id="418080"><p id="r-418079" data-claire-element-id="418079">2127 - 23 ≈ 2,03 ×1031 : écart entre les plus grands nombres normalisés.</p></li></ul><h2 id="r-precision-et-chiffres-significatifs" data-claire-element-id="418102">Précision et chiffres significatifs</h2><p id="r-418083" data-claire-element-id="418083">Vous aurez remarqué une colonne « chiffres significatifs » dans le premier tableau. C'est ce dont on va parler ici.</p><p id="r-418084" data-claire-element-id="418084">Mais qu'est-ce qu'un <strong>chiffre significatif</strong> ? Le nombre de chiffres significatifs d'un nombre, c'est tout simplement le nombre de chiffres utilisés pour écrire ce nombre (dans une base numérique donnée). Par exemple, 43,1337 a 6 chiffres significatifs.</p><p id="r-418085" data-claire-element-id="418085">En physique et en chimie, on y voue une attention particulière. En effet, les mesures n'étant jamais exactes, on s'en sert pour <strong>indiquer le degré de <em>précision</em></strong> de la mesure (qui varie selon les instruments). En conséquence, pour un physicien, 42,1337 est différent de 42,13370 ; le second nombre est plus précis, car il indique quel est le 5e chiffre après la virgule tandis que le premier nombre s'arrête au 4e (le 5e chiffre pourrait être 0, 1, 2, 3, 4, on n’en sait pas plus).</p><p id="r-418086" data-claire-element-id="418086">On compte les chiffres significatifs à partir du premier chiffre de gauche différent de 0, ce qui signifie que 3,1416 et 003,1416 sont équivalents (ils ont tous les deux 5 chiffres significatifs).</p><p id="r-418087" data-claire-element-id="418087">Vous pouvez maintenant comprendre la colonne du tableau : elle indique le nombre de chiffres significatifs en base 10 que nous permet chaque format :</p><ul id="r-418092" data-claire-element-id="418092"><li id="r-418089" data-claire-element-id="418089"><p id="r-418088" data-claire-element-id="418088">le format 32 bits garantit <em>grosso modo</em><strong>7</strong> chiffres significatifs en base 10 ;</p></li><li id="r-418091" data-claire-element-id="418091"><p id="r-418090" data-claire-element-id="418090">le format 64 bits garantit <em>grosso modo</em><strong>16</strong> chiffres significatifs en base 10.</p></li></ul><p id="r-418093" data-claire-element-id="418093">Maintenant, <em>contrôle surprise :</em> combien de chiffres significatifs en base 2 permettent ces formats ? :diable: Mais si, vous pouvez tout à fait répondre, réfléchissez un peu.<br/> C'est tout simple : la mantisse représentant la partie significative du nombre, un nombre flottant a autant de chiffres significatifs en base 2 que sa mantisse occupe de bits.<br/> Hmm hmm. Vous êtes certain ? N'oubliez pas le bit implicite ! Il faut donc ajouter 1 à ce nombre. En vérité, <strong>un nombre normalisé a donc m+1 chiffres significatifs en binaire</strong>, soit 23+1=24 pour le format 32 bits, ou 52+1=53 pour le format 64 bits.<br/> On appelle souvent le nombre de chiffres significatifs en base 2 la <strong>précision</strong> tout court.</p><p id="r-418094" data-claire-element-id="418094">Mais ce n'est pas aussi simple ! Cette « formule » pour la précision n'est valable que pour les nombre normalisés. Voyez-vous pourquoi ?<br/> Rappelez-vous que pour les nombres dénormalisés, le bit implicite, c'est-à-dire la partie entière du nombre, est 0. Comme c'est le premier chiffre, on ne le compte pas dans les chiffres significatifs.</p><div id="r-418096" data-claire-element-id="418096" data-claire-semantic="question"><p id="r-418095" data-claire-element-id="418095">Ah bah alors, pour un nombre dénormalisé, la précision c'est juste le nombre de bits de la mantisse ?</p></div><p id="r-418097" data-claire-element-id="418097">Que nenni, jeune padawan. Un court schéma vaut mieux que de longues explications.</p><figure id="r-418099" data-claire-element-id="418100"><img id="r-418098" data-claire-element-id="418098" src="medias/uploads.siteduzero.com_files_323001_324000_323005.png" alt="schéma : précision (nombre de chiffres significatifs en base 2) d'un nombre flottant normalisé ou non"/></figure><p id="r-418101" data-claire-element-id="418101">Comme vous le voyez, <strong>plus un nombre dénormalisé est proche de zéro, moins il est précis</strong>.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c">Maîtrisez les nombres à virgule en C</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/utilisation-des-nombres-a-virgule-en-c">
Utilisation des nombres à virgule en C
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-le-codage-en-memoire-d-un-nombre-flottant">
IEEE 754 : le codage en mémoire d’un nombre flottant
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/un-peu-de-mathematiques-1">
Un peu de mathématiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-exceptions-arrondis">
IEEE 754 : Exceptions &amp; arrondis
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/comparer-des-nombres-flottants">
Comparer des nombres flottants
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/mais-qu-en-dit-la-norme-c">
Mais qu&#039;en dit la norme C ?
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-le-codage-en-memoire-d-un-nombre-flottant">
<span class="arrow"></span>
<span class="next">IEEE 754 : le codage en mémoire d’un nombre flottant</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-exceptions-arrondis">
<span class="next">IEEE 754 : Exceptions &amp; arrondis</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="IEEE754Exceptionsamparrondis"></a><h2>IEEE 754 : Exceptions &amp; arrondis</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/un-peu-de-mathematiques-1">
<span class="arrow"></span>
<span class="next">Un peu de mathématiques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/comparer-des-nombres-flottants">
<span class="next">Comparer des nombres flottants</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-418104" data-claire-element-id="418104">Bien. On vient de se farcir deux chapitres de théorie pure sur la représentation en mémoire d'un nombre à virgule flottante. Vous en avez marre ? Tant mieux, on change de sujet ! Bon, ça va rester théorique, mais un peu moins quand même.<br/> La norme IEEE 754 ne se limite pas à la représentation des flottants ; elle définit également des exceptions et des modes d'arrondis. Décortiquons tout ça.</p><h2 id="r-les-exceptions-5" data-claire-element-id="418119">Les exceptions</h2><p id="r-418105" data-claire-element-id="418105">Une <strong>exception</strong> est une sorte de « signal  qui est envoyé dans certains cas, afin de traiter les erreurs les cas particuliers qui, s'ils étaient ignorés, seraient des erreurs. Cette définition est en fait générale (le terme vous est peut-être familier si vous faites du C++).</p><p id="r-418106" data-claire-element-id="418106">C'est encore flou pour vous ? Ça ne fait rien, vous allez mieux comprendre avec cette liste.<br/> IEEE définit cinq exceptions :</p><ul id="r-418117" data-claire-element-id="418117"><li id="r-418108" data-claire-element-id="418108"><p id="r-418107" data-claire-element-id="418107"><strong><em>invalid operation</em> (opération invalide)</strong> : se produit lorsqu'une opération interdite est effectuée ; le résultat du calcul en question sera NaN ;</p></li><li id="r-418110" data-claire-element-id="418110"><p id="r-418109" data-claire-element-id="418109"><strong><em>division by zero</em> (division par zéro)</strong> : se produit lorsqu'on tente de diviser un nombre (non nul) par zéro ; le résultat sera ± \infty ;</p></li><li id="r-418112" data-claire-element-id="418112"><p id="r-418111" data-claire-element-id="418111"><em><strong>overflow</strong></em> : se produit lorsque le résultat d'un calcul est trop grand (en valeur absolue) pour être stocké ; on arrondit à ± \infty ;</p></li><li id="r-418114" data-claire-element-id="418114"><p id="r-418113" data-claire-element-id="418113"><em><strong>underflow</strong></em> : se produit lorsque le résultat d'un calcul est trop petit (en valeur absolue) pour être stocké ; on arrondit à zéro ;</p></li><li id="r-418116" data-claire-element-id="418116"><p id="r-418115" data-claire-element-id="418115"><em><strong>inexact</strong></em> : se produit lorsqu'on effectue un autre arrondi pour pouvoir stocker un nombre flottant (parce que le résultat a plus de chiffres significatifs qu'on peut en stocker).</p></li></ul><p id="r-418118" data-claire-element-id="418118">Et là, j'ai une transition de malââââde !…</p><h2 id="r-les-arrondis-1" data-claire-element-id="418161">Les arrondis</h2><p id="r-418120" data-claire-element-id="418120">Les nombres stockés en mémoire ayant un nombre fini de chiffres significatifs (essayez de stocker un nombre infini de chiffres…), <strong>les calculs peuvent mener à des arrondis</strong>. IEEE 754 définit quatre <strong>modes d'arrondis</strong> :</p><ul id="r-418129" data-claire-element-id="418129"><li id="r-418122" data-claire-element-id="418122"><p id="r-418121" data-claire-element-id="418121"><strong>au nombre le plus proche</strong> : c'est le comportement par défaut (si le nombre à arrondir tombe pile-poil entre deux, alors on arrondit à celui dont le dernier bit vaut 0) ;</p></li><li id="r-418124" data-claire-element-id="418124"><p id="r-418123" data-claire-element-id="418123"><strong>vers zéro</strong> ;</p></li><li id="r-418126" data-claire-element-id="418126"><p id="r-418125" data-claire-element-id="418125"><strong>vers +\infty</strong> ;</p></li><li id="r-418128" data-claire-element-id="418128"><p id="r-418127" data-claire-element-id="418127"><strong>vers -\infty</strong>.</p></li></ul><p id="r-418130" data-claire-element-id="418130">C'est là que ça devient intéressant (enfin ça l'était déjà avant, c'est une façon de parler, n'est-ce-pas). Les imprécisions s'accumulent au fil des calculs, et au final vous pouvez obtenir quelque chose d'incohérent !</p><p id="r-418131" data-claire-element-id="418131">Ces imprécisions se manifestent par exemple lorsqu'on manipule deux nombres dont les exposants sont très éloignés. Par exemple, <code data-claire-semantic="c">4.2e17 + 13.37</code> devrait donner <code data-claire-semantic="c">42000000000000001337</code> soit <code data-claire-semantic="c">4.2000000000000001337e17</code>, mais il y a plus de chiffres significatifs qu'on ne peut en stocker ; le nombre sera donc arrondi, et finalement il vaudra <code data-claire-semantic="c">4.2e17</code> comme si l'opération n'avait pas eu lieu !<br/> Certains opérateurs entraînent beaucoup d'arrondis, comme l'addition ou la soustraction. Au contraire, d'autres, tels la multiplication ou la division, sont beaucoup plus sûrs. L'exemple précédent devrait vous aider à comprendre pourquoi. ;)</p><p id="r-418132" data-claire-element-id="418132">Autre source de problèmes : comme vu précédemment, tous les nombres décimaux ne sont pas représentables de façon finie en binaire, et certains (comme <code data-claire-semantic="c">1.0/10.0</code> = <code data-claire-semantic="c">.1</code>) sont donc arrondis.</p><p id="r-418133" data-claire-element-id="418133">Enfin, et en conséquence de ce qui vient d'être dit :</p><p id="r-418134" data-claire-element-id="418134"><cite>Citation : Mewtow</cite></p><blockquote id="r-418136" data-claire-element-id="418136"><p id="r-418135" data-claire-element-id="418135">Les opérations avec les flottants ne sont pas associatives : l'ordre dans lequel on fait un calcul change le résultat. Par exemple, <code data-claire-semantic="c">1 - (.2 + .2 + .2 + .2 + .2)</code> aura un résultat différent de <code data-claire-semantic="c">(((((1-.2)-.2)-.2)-.2)-.2)</code>.</p></blockquote><p id="r-418137" data-claire-element-id="418137">Pas convaincus ? Vérifions ça !</p><pre id="r-418138" data-claire-element-id="418138"><code data-claire-semantic="c">#include &lt;stdio.h&gt;
int main(void) {
   printf(&quot;%g\n%g\n&quot;,  (1.0 - .2 - .2 - .2 - .2 - .2),
                       (1.0 - (.2 + .2 + .2 + .2 + .2))  );
   return 0;
}</code></pre><p id="r-418139" data-claire-element-id="418139">Compilé chez moi, j'obtiens ceci :</p><pre id="r-418140" data-claire-element-id="418140"><code data-claire-semantic="console">5.55112e-017
0</code></pre><p id="r-418141" data-claire-element-id="418141">Ça parle tout seul.</p><h3 id="r-remarque-hors-sujet-mais-importante" data-claire-element-id="418160">Remarque hors-sujet (mais importante)</h3><p id="r-418142" data-claire-element-id="418142">De façon plus générale, il faut rester vigilant lorsqu'on écrit des expressions impliquant des flottants, car des expressions <em>a priori</em> équivalentes, du point de vue d'un humain, se révèlent en fait différentes en pratique. &gt;_ L'exemple précédent l'illustre bien. D'autres cas parlants sont imaginables.</p><ul id="r-418158" data-claire-element-id="418158"><li id="r-418144" data-claire-element-id="418144"><p id="r-418143" data-claire-element-id="418143">Il y a pas mal de cas où ce qui change d'une expression à l'autre est le signe du zéro obtenu. Par exemple, <code data-claire-semantic="c">x-y</code> et <code data-claire-semantic="c">-(y-x)</code> ne sont pas équivalents car si les deux nombres sont égaux, alors la première expression donne <code data-claire-semantic="c">+0.0</code> mais la deuxième <code data-claire-semantic="c">-0.0</code>.</p></li><li id="r-418157" data-claire-element-id="418157"><p id="r-418145" data-claire-element-id="418145">Il y a aussi des cas où les expressions ne sont pas équivalentes si on considère les valeurs « spéciales » des nombres, à savoir zéro, l'infini ou NaN :</p><ul id="r-418156" data-claire-element-id="418156"><li id="r-418147" data-claire-element-id="418147"><p id="r-418146" data-claire-element-id="418146"><code data-claire-semantic="c">x-x</code> ne vaut pas <code data-claire-semantic="c">0.0</code> si <code data-claire-semantic="c">x</code> vaut l'infini ou NaN ;</p></li><li id="r-418149" data-claire-element-id="418149"><p id="r-418148" data-claire-element-id="418148"><code data-claire-semantic="c">0*x</code> ne vaut pas <code data-claire-semantic="c">0.0</code> si <code data-claire-semantic="c">x</code> vaut <code data-claire-semantic="c">-0.0</code>, l'infini ou NaN ;</p></li><li id="r-418151" data-claire-element-id="418151"><p id="r-418150" data-claire-element-id="418150"><code data-claire-semantic="c">x/x</code> ne vaut pas <code data-claire-semantic="c">1.0</code> si <code data-claire-semantic="c">x</code> vaut zéro, l'infini ou NaN ;</p></li><li id="r-418153" data-claire-element-id="418153"><p id="r-418152" data-claire-element-id="418152"><code data-claire-semantic="c">x==x</code> est faux si <code data-claire-semantic="c">x</code> vaut NaN ; :euh:</p></li><li id="r-418155" data-claire-element-id="418155"><p id="r-418154" data-claire-element-id="418154"><code data-claire-semantic="c">x!=x</code> est vrai si <code data-claire-semantic="c">x</code> vaut NaN.</p></li></ul></li></ul><p id="r-418159" data-claire-element-id="418159">Cette liste est tirée de la norme C99 (ISO/IEC 9899:TC3), que je vous invite à consulter si vous en voulez une plus complète (localisation dans le <a href="http://open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf">draft PDF</a> de la norme : <em>Annex F — F.8.2 Expression transformations &amp; F.8.3 Relational operators (p. 464-466)</em>).</p><h2 id="r-l-environnement-des-flottants-fenv-h" data-claire-element-id="418164">L'environnement des flottants : <code data-claire-semantic="c">&lt;fenv.h&gt;</code></h2><p id="r-418162" data-claire-element-id="418162">Cet ensemble de paramètres (les exceptions et le mode d'arrondi) forme ce qu'on appelle en informatique (c'est une définition générale) un <strong>environnement</strong>. C'est le cadre dans lequel on travaille.</p><p id="r-418163" data-claire-element-id="418163">Cet environnement pour les flottants est accessible avec le header standard (C99) <code data-claire-semantic="c">&lt;fenv.h&gt;</code>. Il permet de manipuler les exceptions (les surveiller, en lever, etc.) et les modes d'arrondis (savoir quel est le mode utilisé et en changer). Je ne détaillerai pas son utilisation. Si vous voulez en savoir plus, consultez (par exemple) <a href="http://en.wikipedia.org/wiki/Fenv.h">cette page Wikipédia</a> ou <a href="http://pubs.opengroup.org/onlinepubs/009604599/basedefs/fenv.h.html">cette page du site d'Open Group</a>.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c">Maîtrisez les nombres à virgule en C</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/utilisation-des-nombres-a-virgule-en-c">
Utilisation des nombres à virgule en C
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-le-codage-en-memoire-d-un-nombre-flottant">
IEEE 754 : le codage en mémoire d’un nombre flottant
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/un-peu-de-mathematiques-1">
Un peu de mathématiques
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-exceptions-arrondis">
IEEE 754 : Exceptions &amp; arrondis
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/comparer-des-nombres-flottants">
Comparer des nombres flottants
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/mais-qu-en-dit-la-norme-c">
Mais qu&#039;en dit la norme C ?
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/un-peu-de-mathematiques-1">
<span class="arrow"></span>
<span class="next">Un peu de mathématiques</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/comparer-des-nombres-flottants">
<span class="next">Comparer des nombres flottants</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Comparerdesnombresflottants"></a><h2>Comparer des nombres flottants</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-exceptions-arrondis">
<span class="arrow"></span>
<span class="next">IEEE 754 : Exceptions &amp; arrondis</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/mais-qu-en-dit-la-norme-c">
<span class="next">Mais qu&#039;en dit la norme C ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-l-infame-traitrise-de-l-operateur" data-claire-element-id="418182">L'infâme traîtrise de l'opérateur <code data-claire-semantic="c">==</code></h2><p id="r-418166" data-claire-element-id="418166">Bon. On a donc vu que l'utilisation des flottants en C est semée d'embûches : on risque des arrondis et des expressions « normalement » équivalentes ne le sont pas.<br/> Mais ce n'est pas tout ! Les comparaisons vont aussi vous donner du fil à retordre. :( En effet, <strong>l'opérateur de comparaison <code data-claire-semantic="c">==</code> renvoie vrai si ses deux opérandes sont EXACTEMENT égales</strong>, ou s'il compare un zéro positif et un zéro négatif. Or, avec les problèmes d'arrondis, une différence minuscule peut s'être glissée entre les deux nombres testés. Ainsi, <strong>vous risquez de vous retrouver avec des égalités qui devraient être vraies, mais qui sont fausses</strong> !</p><p id="r-418167" data-claire-element-id="418167">Cela peut faire planter lamentablement un programme (boucles infinies, instructions dans un bloc conditionnel jamais exécutées…), et la source du problème est difficilement identifiable pour un œil non averti.</p><p id="r-418168" data-claire-element-id="418168">Un petit exemple ? <code data-claire-semantic="c">4.2e17 == 4.2e17 + 13.37</code> renverra vrai (d'après l'exemple précédent).</p><p id="r-418169" data-claire-element-id="418169">Autre exemple :</p><pre id="r-418170" data-claire-element-id="418170"><code data-claire-semantic="c">int main(void) {
   float f=0;
   int i;
   
   for(i=0; i&lt;100; ++i)
      f+= .01;
   
   if(f==1)   printf(&quot;f==1\n&quot;);
   else       printf(&quot;f!=1,  f==%f&quot;, f);
   
   return 0;
}</code></pre><p id="r-418171" data-claire-element-id="418171">La sortie sera : <code data-claire-semantic="console">f!=1,  f==0.999999</code>.</p><p id="r-418172" data-claire-element-id="418172">Évidemment, ces exemples sont stupides, mais ils permettent de mieux saisir dans quels cas se pose ce problème.</p><p id="r-418173" data-claire-element-id="418173">Les utilisateurs de GCC seront intéressés de savoir qu'il existe une option <code data-claire-semantic="console">-Wfloat-equal</code> qui déclenche un <em>warning</em> dès que l'on utilise l'opérateur <code data-claire-semantic="c">==</code> sur des nombres flottants.</p><p id="r-418174" data-claire-element-id="418174"><cite>Citation : Vous</cite></p><blockquote id="r-418176" data-claire-element-id="418176"><p id="r-418175" data-claire-element-id="418175">Argghh…! mais c'est abominable !</p></blockquote><p id="r-418177" data-claire-element-id="418177">Hé oui, c'est horrible. Il est encore temps d'abandonner définitivement l'informatique et de vous mettre au patchwork.</p><p id="r-418178" data-claire-element-id="418178">Non attendez, revenez ! Bien sûr, il existe des astuces. Et heureusement !</p><aside id="r-418180" data-claire-element-id="418180" data-claire-semantic="information"><p id="r-418179" data-claire-element-id="418179">La suite est fortement inspirée de <a href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">cette page Internet</a> (en anglais). Elle est complète et détaillée et je vous invite à la lire, car je n'aborderai pas forcément tout ce qu'elle dit (mais y ajouterai quelques broutilles de mon cru).</p></aside><p id="r-418181" data-claire-element-id="418181">Alors, récapitulons : on cherche à comparer deux nombres à virgule flottante (<code data-claire-semantic="c">float</code> ou <code data-claire-semantic="c">double</code>) en tenant compte d'une marge d'erreur due aux arrondis ; on va pour cela écrire une fonction qui renverra un booléen (vrai ou faux, 1 ou 0), pour remplacer l'opérateur <code data-claire-semantic="c">==</code>.</p><h2 id="r-l-ecart-absolu-l-ecart-relatif" data-claire-element-id="418195">L'écart absolu &amp; l'écart relatif</h2><p id="r-418183" data-claire-element-id="418183">La première méthode consiste tout simplement à mesurer l'écart entre les deux nombres. On parle d'<strong>écart absolu</strong> (par opposition à l'écart relatif que nous verrons par la suite). Si cet écart est inférieur à une certaine valeur (souvent appelée <em>epsilon</em>, ce qui pour un mathématicien signifie « valeur très petite »), alors on considère que les deux nombres sont égaux.</p><pre id="r-418184" data-claire-element-id="418184"><code data-claire-semantic="c">#include &lt;math.h&gt;   // pour la fonction fabs, renvoyant la valeur absolue d'un flottant

#define  EPSILON  1e-8

/* ici pour des doubles, mais on fait la même chose pour des floats */
int doublesAreEqual(double a, double b) {
   return fabs(a-b) &lt;= EPSILON;
/* La fonction fabs renvoie la valeur absolue (c'est-à-dire positive) du nombre
   de type double passé en argument ; ses équivalents (C99) sont fabsf pour les
   float, et fabsl pour les long double (pensez donc à adapter votre code en
   conséquence pour comparer les autres types flottants). */
}</code></pre><p id="r-418185" data-claire-element-id="418185">Ici, <code data-claire-semantic="c">fabs</code> nous renvoie l'écart absolu entre a et b. Le reste est facile à comprendre. Simple, non ?</p><p id="r-418186" data-claire-element-id="418186">Oui, mais c'est encore loin d'être parfait : en effet, un écart de <code data-claire-semantic="c">1e-8</code> (soit <code data-claire-semantic="c">0.00000001</code>) peut s'avérer judicieux pour comparer des nombres compris entre 0,1 et 1 (par exemple, en fonction de la précision que vous souhaitez), mais trop petit pour des nombres entre 100 et 1000, ou trop grand pour des nombres entre 0,00001 et 0,0001 ; si vous comparez des nombres compris entre 0,00000001 et 0,0000001, vous avez même une marge d'erreur de 100% !<br/> N'employez donc cette méthode que si vous êtes sûr de l'ordre de grandeur des nombres à comparer, et choisissez un <em>epsilon</em> adapté.</p><p id="r-418187" data-claire-element-id="418187">Pour pallier à ce problème et faire une fonction plus générique, une solution serait de passer l'écart maximal en argument à la fonction et non de se baser sur une constante de préprocesseur ; ainsi, l'utilisateur pourrait fournir un écart adapté à l'ordre de grandeur des nombres qu'il veut comparer.<br/> Allons plus loin. On va employer l'<strong>écart relatif</strong>. Celui-ci ramène l'écart absolu dans les proportions des nombres comparés :</p><pre id="r-418188" data-claire-element-id="418188"><code data-claire-semantic="c">#include &lt;math.h&gt;

#define  EPSILON  1e-8

int doublesAreEqual(double a, double b) {
   if(a==b)   return 1;   // si a et b valent zéro  (explications plus bas)
   
   double absError= fabs(a-b);   // écart absolu
   a= fabs(a);   // on ne garde que les valeurs absolues pour la suite …
   b= fabs(b);   // … pour pouvoir calculer le nombre le plus grand en valeur absolue
   
   return  ( absError / (a&gt;b? a:b) )  &lt;=  EPSILON;
}</code></pre><p id="r-418189" data-claire-element-id="418189">On divise l'écart absolu par le plus grand des deux nombres en valeur absolue (signification du ternaire), pour avoir quelque chose d'adapté à l'ordre de grandeur des deux nombres.</p><p id="r-418190" data-claire-element-id="418190">La ligne commençant par <code data-claire-semantic="c">if(a==b)</code> vous paraît sans doute bizarre. Elle est là pour gérer le cas où a et b sont égaux à zéro. En effet, sans elle, on aurait une division par zéro qui vaudrait NaN, et la comparaison serait donc toujours fausse. On compare donc les deux nombres pour que la fonction renvoie vrai s'ils sont identiques et égaux à zéro (positif ou négatif).</p><aside id="r-418192" data-claire-element-id="418192" data-claire-semantic="information"><p id="r-418191" data-claire-element-id="418191"><em>Remarque :</em> Dans ce tutoriel, j'utilise le C99, et non le C90 enseigné dans le cours de M@teo21. Celui-ci autorise de déclarer des variables après des instructions. Si c'était juste pour ce détail, ce serait superflu, mais plus loin on en aura réellement besoin.</p></aside><p id="r-418193" data-claire-element-id="418193">Cependant, il subsiste un problème : dans le cas de deux nombres très proches de zéro, l'écart relatif sera très important (car on divise par un tout petit nombre) alors que ces deux nombres seront très proches… Pour y remédier, on réintroduit l'écart absolu : la fonction retournerait vrai si l'écart absolu ou l'écart relatif (au moins l'un des deux) est inférieur à une valeur donnée (qu'on passe en argument à la fonction). D'où le code définitif :</p><pre id="r-418194" data-claire-element-id="418194"><code data-claire-semantic="c">#include &lt;math.h&gt;

#define  EPSILON  1e-8

int doublesAreEqual(double a, double b, double maxAbs, double maxRel) {
   if(a==b)   return 1;
   
   double absError= fabs(a-b);
   a= fabs(a);
   b= fabs(b);
   
   return   absError &lt;= maxAbs   ||   ( absError / (a&gt;b? a:b) )  &lt;=  maxRel;
}</code></pre><h2 id="r-la-representation-en-memoire-convertie-en-entier" data-claire-element-id="418250">La représentation en mémoire convertie en entier</h2><p id="r-418196" data-claire-element-id="418196">Maintenant, vous avez du code à peu près potable et fonctionnel. Toutefois, il existe une autre manière de faire, plus pratique mais un peu plus <em>hard</em>. Accrochez-vous, ça va secouer. :pirate:</p><p id="r-418197" data-claire-element-id="418197">Imaginez qu'au lieu de se baser sur l'écart entre les deux nombres, on cherche à déterminer combien de nombres possibles les séparent ? Ainsi, on aimerait placer une marge d'erreur, non sur la valeur elle-même des nombres flottants, mais sur leur « éloignement », pour pouvoir dire par exemple : « <em>J'accepte les 5 nombres en dessous et les 5 nombres au dessus de la valeur machin</em> ».</p><p id="r-418198" data-claire-element-id="418198">Eh bien, grâce au format de l'IEEE, c'est possible !</p><aside id="r-418200" data-claire-element-id="418200" data-claire-semantic="warning"><p id="r-418199" data-claire-element-id="418199">Ici, on a donc impérativement besoin du format IEEE 754 ! L'astuce présentée est basée dessus. Si jamais ce n'est pas ce format que vous avez chez vous, vous ne pourrez sans doute pas la mettre en œuvre.<br/> Toutefois, je vous invite à lire quand même ce qui suit, cela pourra peut-être vous intéresser ; et en tous cas, jetez un œil au code complet (dernière sous-partie), car j’y présente des idées qui pourront vous intéresser même si vous utilisez l'écart absolu/relatif.</p></aside><p id="r-418201" data-claire-element-id="418201">Ce format garantit que « <em>si deux nombres du même type à virgule flottante sont consécutifs, alors leurs représentations entières le sont aussi (selon le bit de poids fort pour déterminer le signe, et non la règle du complément à 2).</em> »</p><p id="r-418202" data-claire-element-id="418202">Que signifie ce charabia ? Eh bien, prenons 2 nombres de type <code data-claire-semantic="c">float</code> codés sur 32 bits selon le format IEEE 754 (évidemment, cela s'applique aussi aux <code data-claire-semantic="c">double</code>) :</p><pre id="r-418203" data-claire-element-id="418203"><code data-claire-semantic="console">Valeur du float                       représentation en mémoire
                     binaire                                      hexadécimal    en base 10
+1.9999998           0   0111111 1   1111111 11111111 11111110    3F FF FF FE    1073741822
+1.9999999           0   0111111 1   1111111 11111111 11111111    3F FF FF FF    1073741823</code></pre><p id="r-418204" data-claire-element-id="418204">Ces 2 nombres sont « consécutifs », il ne peut pas y avoir d'autre nombre du même type dont la valeur serait comprise entre les 2. Or, que constate-t-on ? <strong>Leurs représentations en mémoire</strong>, <strong>si on les lit comme des nombres entiers</strong>, sont également consécutives !</p><p id="r-418205" data-claire-element-id="418205">Pour savoir si les deux nombres à comparer sont « voisins », il suffit donc de comparer leur représentation en mémoire convertie en nombre entier.</p><aside id="r-418207" data-claire-element-id="418207" data-claire-semantic="information"><p id="r-418206" data-claire-element-id="418206">Par la suite, je dirais (abusivement, certes) « représentation entière » plutôt que « représentation en mémoire lue comme un entier », c'est quand même plus court.</p></aside><div id="r-418209" data-claire-element-id="418209" data-claire-semantic="question"><p id="r-418208" data-claire-element-id="418208">Mais comment accéder à cette représentation entière ?</p></div><p id="r-418210" data-claire-element-id="418210">Ben, c'est simple, il suffit de faire <code data-claire-semantic="c">(int)monFloat</code> … Surtout pas ! En faisant ça, on convertit le nombre à virgule en nombre entier, et on obtient donc le nombre de départ arrondi à l'unité. Ça n'a rien à voir avec ce que l'on veut. La bonne formule est donc, tenez-vous bien :<br/><code data-claire-semantic="c"><strong>*(int*)&amp;monFloat</strong></code><br/> Je vous laisse méditer là-dessus. :p Ce n'est pas vraiment compliqué, quand on y pense. Quelques explications si vraiment vous bloquez :</p><div id="r-418219" data-claire-element-id="418219"><p id="r-418211" data-claire-element-id="418211">pour comprendre cette expression, il faut en fait la lire de droite à gauche :</p><ul id="r-418218" data-claire-element-id="418218"><li id="r-418213" data-claire-element-id="418213"><p id="r-418212" data-claire-element-id="418212"><code data-claire-semantic="c">&amp;monFloat</code> renvoie l'adresse de la variable de type float, donc un pointeur sur float (un <code data-claire-semantic="c">float*</code>) ;</p></li><li id="r-418215" data-claire-element-id="418215"><p id="r-418214" data-claire-element-id="418214"><code data-claire-semantic="c">(int*)</code> convertit ce pointeur sur float en un pointeur sur int ; ainsi, l'ordinateur considérera la variable pointée comme un int et non plus plus un float ;</p></li><li id="r-418217" data-claire-element-id="418217"><p id="r-418216" data-claire-element-id="418216">et hop ! le tour est joué, il ne nous reste plus qu'à déréférencer ce pointeur avec <code data-claire-semantic="c">*</code> pour accéder à la variable pointée, cette fois lue comme un entier (int) et non comme un flottant.</p></li></ul></div><p id="r-418220" data-claire-element-id="418220">Maintenant, du code avec ce que je viens de vous dire :</p><pre id="r-418221" data-claire-element-id="418221"><code data-claire-semantic="c">#include &lt;stdlib.h&gt;   // pour la fonction abs, renvoyant la valeur absolue d'un entier
#include &lt;stdint.h&gt;   /* header du C99, qui fournit des types entiers de taille fixe :
                         —  int32_t,  int64_t : entier signé de 32 ou 64 bits ;
                         — uint32_t, uint64_t : entier non-signé de 32 ou 64 bits. */

#define  INTREPOFFLOAT(f)   ( *(int32_t*)&amp;(f) )   // représentation entière d'un float (32 bits)
#define  INTREPOFDOUBLE(d)  ( *(int64_t*)&amp;(d) )   // représentation entière d'un double (64 bits)

#define  MAXULPS  5

/* ici pour des floats, mais on fait exactement pareil pour des doubles */
int floatsAreEqual(float a, float b) {
   if(a==b)   return 1;
   
   return abs( INTREPOFFLOAT(a) - INTREPOFFLOAT(b) )  &lt;=  MAXULPS;
/* attention à la fonction abs, qui prend un int en argument ; un int fait 16
   ou 32 bits : il peut donc être trop petit pour contenir les 32 bits de la
   représentation entière d'un float, et sera de toutes façons insuffisant
   pour les 64 bits de celle d'un double. Voyez la fonction labs qui prend un
   long int, ou llabs (C99) qui prend un long long int, ou mieux, écrivez vos
   propres fonctions de valeur absolue, pour 32 et 64 bits (avec les types de
   &lt;stdint.h&gt;) ; ainsi, vous n'aurez plus de problèmes de taille des types
   pouvant varier. Ici, je garde les fonctions standards par souci de clarté. */
}</code></pre><p id="r-418222" data-claire-element-id="418222">La constante <code data-claire-semantic="c">MAXULPS</code> (de ULP, « <em>Unit of Least Precision</em> », c'est-à-dire la valeur qui sépare deux flottants consécutifs) nous fournit notre marge d'erreur. Si l'écart entre les représentations entières est inférieur à <code data-claire-semantic="c">MAXULPS</code>, alors on considère que les nombres sont égaux. :)</p><p id="r-418223" data-claire-element-id="418223">Ici, la ligne commençant par <code data-claire-semantic="c">if(a==b)</code> est là pour gérer le cas où les deux nombres seraient +0.0 et -0.0. En effet, +0.0 et -0.0 ont des représentations entières très différentes, ce qui fait que la fonction retournerait faux sans ce test préalable.</p><p id="r-418224" data-claire-element-id="418224">En outre, remarquez qu'on utilise les types entiers définis dans le header standard <code data-claire-semantic="c">&lt;stdint.h&gt;</code> au lieu des types habituels (<code data-claire-semantic="c">int</code>, <code data-claire-semantic="c">long int</code>…). En effet, la taille de ces derniers dépend de l'implémentation et n'est donc pas connue, il serait donc dangereux (non portable) de s'appuyer dessus ; au contraire, la taille de <code data-claire-semantic="c">int32_t et int64_t</code> est connue et fixe.<br/> Ce header a été introduit avec C99, c'est pourquoi je vous ai dit qu'on allait devoir se baser sur cette version du langage C.</p><p id="r-418225" data-claire-element-id="418225">Un peu de maths pour vous aider à choisir votre marge d'erreur !</p><p id="r-418226" data-claire-element-id="418226">Une variation de \Delta mantisse dans la représentation entière de la mantisse codée sur m bits correspond à une variation de la valeur du flottant donnée par la formule suivante : \Delta flottant=\enspace \frac{\Delta mantisse}{2^m} imes 2^{exposant} \enspace= \Delta mantisse imes 2^{exposant-m} (où exposant est l'exposant réel). Cette formule provient directement de celle donnant l'intervalle entre les nombres consécutifs en fonction de l'exposant.</p><p id="r-418227" data-claire-element-id="418227">Pour un nombre flottant compris entre 1 et 2, une variation d'un ULP correspond donc à une variation de valeur du nombre flottant de \frac{1}{2^{23}} \approx 1{,}192 imes10^{-7} pour un <code data-claire-semantic="c">float</code> et \frac{1}{2^{52}} \approx 2{,}220 imes10^{-16} pour un <code data-claire-semantic="c">double</code>.</p><p id="r-418228" data-claire-element-id="418228">Si vous choisissez comme moi une marge de 5 ULP, alors votre marge de valeur (pour un nombre flottant compris entre 1 et 2) sera \frac{5}{2^{23}} \approx 5{,}960 imes10^{-7} pour un <code data-claire-semantic="c">float</code> et \frac{5}{2^{52}} \approx 1{,}110 imes10^{-15} pour un <code data-claire-semantic="c">double</code>.</p><p id="r-418229" data-claire-element-id="418229">Mais (hé oui, encore un « mais ») il reste encore un détail à régler, et à ce stade j'aimerais que vous leviez tous la main pour me le dire. Allez, un indice : ça concerne la parenthèse de la phrase en italique de tout à l'heure… :-° Ben oui, le signe ! Les flottants, selon la norme IEEE 754, sont signés selon le principe du bit de signe et non du complément à 2. Or, les entiers (du moins sur la grande majorité des ordinateurs aujourd'hui) sont stockés… selon la règle du complément à 2.</p><p id="r-418230" data-claire-element-id="418230">Un exemple pour bien voir (je ne vous met plus le binaire, vous êtes grands maintenant) :</p><pre id="r-418231" data-claire-element-id="418231"><code data-claire-semantic="console">Valeur du float              représentation en mémoire
                         hexadécimal    en base 10 selon le complément à 2
+4.2038954 e-45          00 00 00 03     3
+2.8025969 e-45          00 00 00 02     2
+1.4012985 e-45          00 00 00 01     1
+0.0000000               00 00 00 00     0
-0.0000000               80 00 00 00    -2147483648
-1.4012985 e-45          80 00 00 01    -2147483647
-2.8025969 e-45          80 00 00 02    -2147483646
-4.2038954 e-45          80 00 00 03    -2147483645</code></pre><p id="r-418232" data-claire-element-id="418232">Comme vous le voyez, le dernier nombre est inférieur à l'avant-dernier, et pourtant sa représentation entière (en <code data-claire-semantic="c">signed</code> comme en <code data-claire-semantic="c">unsigned</code>) est supérieure !<br/> En vérité, cela ne porte pas à conséquence si l'on compare deux nombres négatifs, car on ne s'intéresse qu'à l'écart entre les représentations entières, qui lui ne change pas ; le problème se pose lorsque l'on compare deux nombres de signes opposés.</p><p id="r-418233" data-claire-element-id="418233">Heureusement, il existe une solution. Il suffit de convertir les nombres négatifs selon la règle du bit de signe, en nombres négatifs selon la règle du complément à 2. Je vous laisse chercher ; aidez-vous de l'exemple ci-dessus…<br/> Trouvé ? Il suffit de garder la valeur telle quelle si le flottant est positif, ou s'il est négatif de soustraire <code data-claire-semantic="c">0x 80 00 00 00</code> à la représentation entière puis d'inverser le signe de cette représentation. Cela revient à faire l'opération suivante :<br/><code data-claire-semantic="c">représentation = 0x 8000 0000 - représentation ;</code><br/> Similairement, pour un <code data-claire-semantic="c">double</code> de 64 bits, on fera <code data-claire-semantic="c">représentation = 0x 8000 0000 0000 0000 - représentation</code>.</p><p id="r-418234" data-claire-element-id="418234">On obtient alors ceci :</p><pre id="r-418235" data-claire-element-id="418235"><code data-claire-semantic="console">Valeur du float              représentation transformée
                         hexadécimal    en base 10 selon le complément à 2
+4.2038954 e-45          00 00 00 03     3
+2.8025969 e-45          00 00 00 02     2
+1.4012985 e-45          00 00 00 01     1
+0.0000000               00 00 00 00     0
-0.0000000               00 00 00 00     0   *    (* = a été transformé)
-1.4012985 e-45          FF FF FF FF    -1   *
-2.8025969 e-45          FF FF FF FE    -2   *
-4.2038954 e-45          FF FF FF FD    -3   *</code></pre><p id="r-418236" data-claire-element-id="418236">Comme vous le voyez, les représentations entières sont maintenant cohérentes, on peut les comparer sans problème. Et même les deux zéros (positif/négatif) sont égaux !</p><p id="r-418237" data-claire-element-id="418237">Du code, du code !</p><pre id="r-418238" data-claire-element-id="418238"><code data-claire-semantic="c">#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

#define  INTREPOFFLOAT(f)   ( *(int32_t*)&amp;(f) )
#define  INTREPOFDOUBLE(d)  ( *(int64_t*)&amp;(d) )

#define  MAXULPS  5

int floatsAreEqual(float a, float b) {
   int32_t aInt= INTREPOFFLOAT(a);   // représentations entières
   int32_t bInt= INTREPOFFLOAT(b);
   
   if(aInt&lt;0)   aInt= 0x80000000 - aInt;   // ou 0x8000000000000000 pour des doubles
   if(bInt&lt;0)   bInt= 0x80000000 - bInt;
/* NOTE: on teste (aInt&lt;0) et non (a&lt;0). En effet, si a==-0.0 (zéro négatif),
   alors le test (a&lt;0) renverrait faux, et on garderait la représentation de
   -0.0, à savoir 0x80000000. La règle du complément à 2 garde l'avantage du
   bit de signe : si le bit de poids fort est à 1, alors le nombre entier est
   négatif, et réciproquement ; on peut donc utiliser le test sur l'entier et
   non sur le flottant pour savoir s'il faut « transformer » la représentation. */
   
   return abs( aInt - bInt )  &lt;=  MAXULPS;
}</code></pre><p id="r-418239" data-claire-element-id="418239">Attention à bien utiliser les types signés (<code data-claire-semantic="c">int32_t et int64_t</code>) et non les non signés (<code data-claire-semantic="c">uint32_t et uint64_t</code>).</p><p id="r-418240" data-claire-element-id="418240">Bon, ce n'est pas encore parfait, mais c'est très convenable. Quelques points améliorables :</p><ul id="r-418245" data-claire-element-id="418245"><li id="r-418242" data-claire-element-id="418242"><p id="r-418241" data-claire-element-id="418241">les infinis : comme vu précédemment, les infinis sont adjacents aux plus grands nombres en valeur absolue. Notre fonction pourrait par exemple nous dire qu'un nombre positif très très très grand et +\infty sont égaux, alors que ce n'est pas vrai (ne discutez pas, d'un point de vue mathématique c'est faux :lol: ) ;</p></li><li id="r-418244" data-claire-element-id="418244"><p id="r-418243" data-claire-element-id="418243">les NaN : de même, certains NaN pourraient être comparés comme égaux à l'infini ou à un nombre extrêmement grand en valeur absolue, voire à un autre NaN. Or, normalement, n'importe quelle comparaison avec un NaN (hormis <code data-claire-semantic="c">!=</code>) devrait valoir faux.</p></li></ul><p id="r-418246" data-claire-element-id="418246">Ces détails peuvent être corrigés avec des vérifications supplémentaires. À ce sujet, les <a href="http://www.man-linux-magique.net/man3/isinf.html">macros de test de nombres flottants (C99)</a> peuvent servir. En résumé (je vous invite à consulter le manuel avec le lien précédent) :</p><p id="r-418247" data-claire-element-id="418247"><cite>Citation : Le manuel : fpclassify, isfinite, isnormal, isnan, isinf</cite></p><blockquote id="r-418249" data-claire-element-id="418249"><p id="r-418248" data-claire-element-id="418248">Depuis le C99, le header <code data-claire-semantic="c">&lt;math.h&gt;</code> définit les macros <code data-claire-semantic="c">isfinite</code>, <code data-claire-semantic="c">isnormal</code>, <code data-claire-semantic="c">isnan</code> et <code data-claire-semantic="c">isinf</code> ; elles prennent toutes un nombre flottant en argument (peu importe son type), et renvoient un booléen indiquant respectivement si le nombre est fini, normalisé, NaN ou infini (le retour de <code data-claire-semantic="c">isinf</code> n'est pas forcément 1 ou 0).<br/> La macro <code data-claire-semantic="c">fpclassify</code> est également définie. On l'utilise comme les autres, et sa valeur de retour indique le type du nombre flottant (<code data-claire-semantic="c">FP_ZERO</code>, <code data-claire-semantic="c">FP_SUBNORMAL</code>, <code data-claire-semantic="c">FP_NORMAL</code>, <code data-claire-semantic="c">FP_INFINITE</code>, <code data-claire-semantic="c">FP_NAN</code>).</p></blockquote><h2 id="r-code-complet-2" data-claire-element-id="418272">Code complet</h2><p id="r-418251" data-claire-element-id="418251">Je vous propose finalement un code complet.</p><p id="r-418252" data-claire-element-id="418252">J'y ai introduit une fonction <code data-claire-semantic="c">cmpFloats</code> (ou <code data-claire-semantic="c">cmpDoubles</code>) de mon cru qui permet une comparaison plus générale : en effet, à la manière de <code data-claire-semantic="c">strcmp</code>, elle renvoie -1 si a&gt;b, 0 si a==b ou 1 si a&lt;b ; elle renvoie par ailleurs -2 si l'un des deux nombres au moins est NaN.<br/> Ainsi, il devient plus facile de tester les deux nombres (j'ai de plus écrit des macros simples pour faciliter les comparaisons). En effet, avant, pour tester par exemple a&lt;b (strictement inférieur), il fallait faire <code data-claire-semantic="c">if(a&lt;b &amp;&amp; !floatsAreEqual(a,b))</code>, ce qui était plus lourd à écrire.</p><h3 id="r-header" data-claire-element-id="418266">Header</h3><div id="r-418265" data-claire-element-id="418265"><pre id="r-418253" data-claire-element-id="418253"><code data-claire-semantic="c">#ifndef INCLUDE_CMPFLOATS_H
#define INCLUDE_CMPFLOATS_H


#include &lt;stdint.h&gt;
#include &lt;math.h&gt;   /* pour les macros de test des nombres
                       flottants ( isnan() et isinf() ) */


/* représentation entière du nombre en virgule flottante */
#define  INTREPOFFLOAT(f)   ( *(int32_t*)&amp;(f) )
#define  INTREPOFDOUBLE(d)  ( *(int64_t*)&amp;(d) )

/* marge maximale séparant deux nombres flottants considérés comme égaux,
   en termes d'ULP (« Unit of Least Precision ») */
#define  MAXULPSFLOAT   5
#define  MAXULPSDOUBLE  5


/* renvoie vrai (1) si les 2 nombres sont égaux, faux (0) sinon */
int floatsAreEqual(float a, float b);
int doublesAreEqual(double a, double b);


/* renvoie  -1 si a&gt;b,  0 si a==b,  1 si a&lt;b,  ou -2 si a ou b est NaN */
int cmpFloats(float a, float b);
int cmpDoubles(double a, double b);

/* macros booléennes (à utiliser dans des tests simples) */
#define  CMPFLOATS_EQUAL(a,b)     (cmpFloats((a),(b))==0)      // =&gt;  a==b
#define  CMPFLOATS_UNEQUAL(a,b)   (cmpFloats((a),(b))!=0)      // =&gt;  a!=b
#define  CMPFLOATS_GT(a,b)        (cmpFloats((a),(b))==-1)     // =&gt;  a&gt;b
#define  CMPFLOATS_LT(a,b)        (cmpFloats((a),(b))==1)      // =&gt;  a&lt;b
//#define  CMPFLOATS_GTEQUAL(a,b)   (cmpFloats((a),(b))!=1)      // =&gt;  a&gt;=b
//#define  CMPFLOATS_LTEQUAL(a,b)   (cmpFloats((a),(b))!=-1)     // =&gt;  a&lt;=b
#define  CMPFLOATS_GTEQUAL(a,b)   ((cmpFloats((a),(b))-1)&amp;2)   // =&gt;  a&gt;=b
#define  CMPFLOATS_LTEQUAL(a,b)   (cmpFloats((a),(b))&gt;=0)      // =&gt;  a&lt;=b
#define  CMPFLOATS_NAN(a,b)       (cmpFloats((a),(b))==-2)     // =&gt;  a==NaN || b==NaN

#define  CMPDOUBLES_EQUAL(a,b)     (cmpDoubles((a),(b))==0)    // =&gt;  a==b
#define  CMPDOUBLES_UNEQUAL(a,b)   (cmpDoubles((a),(b))!=0)    // =&gt;  a!=b
#define  CMPDOUBLES_GT(a,b)        (cmpDoubles((a),(b))==-1)   // =&gt;  a&gt;b
#define  CMPDOUBLES_LT(a,b)        (cmpDoubles((a),(b))==1)    // =&gt;  a&lt;b
//#define  CMPDOUBLES_GTEQUAL(a,b)   (cmpDoubles((a),(b))!=1)    // =&gt;  a&gt;=b
//#define  CMPDOUBLES_LTEQUAL(a,b)   (cmpDoubles((a),(b))!=-1)   // =&gt;  a&lt;=b
#define  CMPDOUBLES_GTEQUAL(a,b)   ((cmpDoubles((a),(b))-1)&amp;2) // =&gt;  a&gt;=b
#define  CMPDOUBLES_LTEQUAL(a,b)   (cmpDoubles((a),(b))&gt;=0)    // =&gt;  a&lt;=b
#define  CMPDOUBLES_NAN(a,b)       (cmpDoubles((a),(b))==-2)   // =&gt;  a==NaN || b==NaN


#endif  //INCLUDE_CMPFLOATS_H</code></pre><p id="r-418254" data-claire-element-id="418254">Remarquez que j'ai mis des macros en commentaires (correspondant à <code data-claire-semantic="c">&lt;=</code> et <code data-claire-semantic="c">&gt;=</code>), qui on été remplacées par d'autres. En effet, ces macros ne sont plus valables si <code data-claire-semantic="c">cmp…</code> renvoie -2 (qui est le code pour NaN).</p><aside id="r-418256" data-claire-element-id="418256" data-claire-semantic="information"><p id="r-418255" data-claire-element-id="418255">Les macros <code data-claire-semantic="c">CMP…_GTEQUAL</code> de remplacement sont très bizarres. En fait, c'est une astuce que j'ai trouvé pour éviter quelque chose du type <code data-claire-semantic="c">(cmpFloats((a),(b))==-1 || cmpFloats((a),(b))==0)</code>, ce qui est dangereux car a et b sont potentiellement évalués 2 fois, et non optimisé car on appelle 2 fois la fonction <code data-claire-semantic="c">cmp…</code> .<br/> En fait, les seules macros qui renverront vrai en cas de NaN seront <code data-claire-semantic="c">CMP…_NAN</code> et <code data-claire-semantic="c">CMP…_UNEQUAL</code>.</p></aside><p id="r-418257" data-claire-element-id="418257">L'utilisation de ces macros est conseillée dans le cas d'un test « simple », c'est-à-dire avec un seul test ; par exemple :</p><pre id="r-418258" data-claire-element-id="418258"><code data-claire-semantic="c">instructions1;
if(CMPFLOATS_GT(a,b)) { // a&gt;b
   instructions2;
}
instructions3;</code></pre><p id="r-418259" data-claire-element-id="418259">En revanche, il vaut mieux éviter de les enchaîner pour traiter différentes possibilités (si a&lt;b, faire machin, si a&gt;b, faire truc...) le <code data-claire-semantic="c">else</code> est aussi à éviter (car il engloberait aussi le cas de NaN, ce qui dans la plupart des cas n'est pas voulu) :</p><pre id="r-418260" data-claire-element-id="418260"><code data-claire-semantic="c">instructions1;
if(CMPFLOATS_GT(a,b)) { // a&gt;b
   instructions2;
}
else if(CMPFLOATS_LT(a,b)) { // a&lt;b
   /*  /!\  on appelle la fonction cmpFloats 2 fois  */
   instructions2b;
}
else // a==b
   instructions2t;   /*  /!\  ce code est aussi exécuté dans le cas de NaN !  */
}
instructions3;</code></pre><p id="r-418261" data-claire-element-id="418261">Il vaut mieux utiliser un <code data-claire-semantic="c">switch</code> dans ce cas, qui n'appelle la fonction qu'une seule fois tout en permettant un contrôle précis :</p><pre id="r-418262" data-claire-element-id="418262"><code data-claire-semantic="c">instructions1;
switch(cmpFloats(a,b)) {
 case -1: // a&gt;b
   instructions2;
   break;
 case  0: // a==b
   instructions2t;
   break;
 case  1: // a&lt;b
   instructions2b;
   break;
 default: break; // NaN
}
instructions3;</code></pre><p id="r-418263" data-claire-element-id="418263">Autre exemple pour bien saisir l'utilisation du <code data-claire-semantic="c">switch</code> :</p><pre id="r-418264" data-claire-element-id="418264"><code data-claire-semantic="c">instructions1;
switch(cmpFloats(a,b)) {
 case -1: // a&gt;b
 case  0: // a==b
   instructions2;   // ce code est donc exécuté si a&gt;=b
   break;
 case  1: // a&lt;b
   instructions2b;
   break;
 default: break; // NaN
}
instructions3;</code></pre></div><h3 id="r-fichier-source" data-claire-element-id="418271">Fichier source</h3><div id="r-418268" data-claire-element-id="418268"><pre id="r-418267" data-claire-element-id="418267"><code data-claire-semantic="c">#include &quot;cmpfloats.h&quot;




/* valeur absolue d'un entier de 32 ou 64 bits */
uint32_t abs32(int32_t x) {   return x&lt;0? -x : x;   }
uint64_t abs64(int64_t x) {   return x&lt;0? -x : x;   }




int floatsAreEqual(float a, float b) {
   
   /* vérification pour NaN : si l'un des deux nombres est NaN, alors on
      retourne toujours faux */
   if(isnan(a) || isnan(b))
      return 0;
   
   /* vérification pour les infinis : si l'un des deux nombres est infini,
      alors on ne retourne vrai que si les deux nombres sont strictement
      égaux (tous les deux +inf ou -inf) */
   if(isinf(a) || isinf(b))
      return a==b;
   
   int32_t aInt= INTREPOFFLOAT(a);
   int32_t bInt= INTREPOFFLOAT(b);
   if(aInt&lt;0)   aInt= 0x80000000 - aInt;
   if(bInt&lt;0)   bInt= 0x80000000 - bInt;
   return abs32( aInt - bInt )  &lt;=  MAXULPSFLOAT;
}

int doublesAreEqual(double a, double b) {
   if(isnan(a) || isnan(b))
      return 0;
   
   if(isinf(a) || isinf(b))
      return a==b;
   
   int64_t aInt= INTREPOFDOUBLE(a);
   int64_t bInt= INTREPOFDOUBLE(b);
   if(aInt&lt;0)   aInt= 0x8000000000000000LL - aInt;
   if(bInt&lt;0)   bInt= 0x8000000000000000LL - bInt;
   return abs64( aInt - bInt )  &lt;=  MAXULPSDOUBLE;
}




int cmpFloats(float a, float b) {
   if(isnan(a) || isnan(b))
      return -2;   // -2 si on a au moins un NaN
   
   if(isinf(a) || isinf(b))
      return (a&lt;b)? -1 : (a&gt;b)? 1 : 0;   // gestion des infinis similaire à ci-dessous
   
   int32_t aInt= INTREPOFFLOAT(a);
   int32_t bInt= INTREPOFFLOAT(b);
   if(aInt&lt;0)   aInt= 0x80000000 - aInt;
   if(bInt&lt;0)   bInt= 0x80000000 - bInt;
   return (abs32(aInt-bInt) &lt;= MAXULPSFLOAT)?  0   // 0 si les nombres sont égaux
                               : (aInt&lt;bInt)?  1   // 1 si a&lt;b
                               :              -1;  // -1 si a&gt;b
}

int cmpDoubles(double a, double b) {
   if(isnan(a) || isnan(b))
      return -2;
   
   if(isinf(a) || isinf(b))
      return (a&lt;b)? -1 : (a&gt;b)? 1 : 0;
   
   int64_t aInt= INTREPOFDOUBLE(a);
   int64_t bInt= INTREPOFDOUBLE(b);
   if(aInt&lt;0)   aInt= 0x8000000000000000LL - aInt;
   if(bInt&lt;0)   bInt= 0x8000000000000000LL - bInt;
   return (abs64(aInt-bInt) &lt;= MAXULPSDOUBLE)?  0
                                : (aInt&lt;bInt)?  1
                                :              -1;
}</code></pre></div><p id="r-418269" data-claire-element-id="418269">Ce code est à compiler en C99.</p><p id="r-418270" data-claire-element-id="418270">Si vous programmez en C++, pourquoi ne pas surcharger les opérateurs de comparaison ? Cela vous simplifiera la vie (toutefois, vous risquerez alors, à la longue, d'oublier que vous avez fait quelque chose pour comparer tranquillement des flottants, et un jour ça ne marchera plus car vous n'aurez plus inclus votre petit header magique.) :-°</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c">Maîtrisez les nombres à virgule en C</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/utilisation-des-nombres-a-virgule-en-c">
Utilisation des nombres à virgule en C
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-le-codage-en-memoire-d-un-nombre-flottant">
IEEE 754 : le codage en mémoire d’un nombre flottant
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/un-peu-de-mathematiques-1">
Un peu de mathématiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-exceptions-arrondis">
IEEE 754 : Exceptions &amp; arrondis
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/comparer-des-nombres-flottants">
Comparer des nombres flottants
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/mais-qu-en-dit-la-norme-c">
Mais qu&#039;en dit la norme C ?
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-exceptions-arrondis">
<span class="arrow"></span>
<span class="next">IEEE 754 : Exceptions &amp; arrondis</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/mais-qu-en-dit-la-norme-c">
<span class="next">Mais qu&#039;en dit la norme C ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Maisqu039enditlanormeC"></a><h2>Mais qu&#039;en dit la norme C ?</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/comparer-des-nombres-flottants">
<span class="arrow"></span>
<span class="next">Comparer des nombres flottants</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-418274" data-claire-element-id="418274"><cite>Citation : Le Zéro harassé</cite></p><blockquote id="r-418276" data-claire-element-id="418276"><p id="r-418275" data-claire-element-id="418275">Oh non ! Encore de la théorie !</p></blockquote><p id="r-418277" data-claire-element-id="418277">Rassurez-vous, si vous êtes fatigués, vous pouvez passer cette partie. Elle se destine aux petits curieux qui voudraient aller plus loin pour savoir plus précisément quelle relation entretient IEEE 754 vis à vis de la norme C, et comment déterminer si le compilateur suit bien les formats IEEE 754 ou pas. Car en C, il y a foule de gourous barbus qui se cramponnent à la norme comme une huître à son rocher, la citent comme un texte sacré, et viennent hurler à l’hérésie au moindre bout de code non « portable ». Et ils ont bien raison.</p><h2 id="r-ieee-754-et-la-norme-c" data-claire-element-id="418309">IEEE 754 et la norme C</h2><p id="r-418278" data-claire-element-id="418278">La norme C90 était très floue sur ce sujet, et n'imposait ni ne privilégiait aucun format pour les nombres à virgule flottante. Le C99 a changé cela. En effet, la norme C99 (alias ISO/IEC 9899:TC3, téléchargeable <a href="http://open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf">ici</a> en PDF) introduit le support de la norme IEEE 754.</p><p id="r-418279" data-claire-element-id="418279">Voici un extrait le montrant (issu de la liste des changements majeurs depuis le C90) :</p><p id="r-418280" data-claire-element-id="418280"><cite>Citation : ISO/IEC 9899:TC3 — Foreword (§5, p. xi-xii)</cite></p><blockquote id="r-418282" data-claire-element-id="418282"><p id="r-418281" data-claire-element-id="418281">This second edition cancels and replaces the first edition, ISO/IEC 9899:1990 […]. Major changes from the previous edition include:<br/> […]<br/> — IEC 60559 (also known as IEC 559 or IEEE arithmetic) support<br/> […]</p></blockquote><div id="r-418284" data-claire-element-id="418284" data-claire-semantic="question"><p id="r-418283" data-claire-element-id="418283">Quoi ? C'est quoi IEC 60559 ? Encore une nouvelle norme au nom tordu !</p></div><p id="r-418285" data-claire-element-id="418285">Oulala, pas de panique ! IEC 60559, c'est juste un autre nom de IEEE 754.</p><p id="r-418286" data-claire-element-id="418286">Cette norme est donc <strong>supportée par le langage C depuis sa version C99</strong>. Attention ! Supporté ne veut pas dire imposé. Les compilateurs ne sont pas obligés d'adopter les formats IEEE 754. C'est juste que s'ils le font, ils doivent suivre les règles de support spécifiées par la norme C99.</p><p id="r-418287" data-claire-element-id="418287">Ce passage le montre clairement :</p><p id="r-418288" data-claire-element-id="418288"><cite>Citation : ISO/IEC 9899:TC3 — 6.2.6: Representation of types — General (§1, p.37)</cite></p><blockquote id="r-418290" data-claire-element-id="418290"><p id="r-418289" data-claire-element-id="418289">The representations of all types are unspecified except as stated in this subclause. […]</p></blockquote><p id="r-418291" data-claire-element-id="418291">Cela signifie que la représentation de n'importe quel type (et pas seulement les flottants) est inconnue ; elle reste aux choix du compilateur.</p><p id="r-418292" data-claire-element-id="418292">Certains compilateurs peuvent supporter plusieurs formats ; dans ce cas, vous devrez spécifier lequel utiliser avec des arguments (sauf si vous voulez garder le format par défaut). GCC, pour sa part, implémente IEEE 754 par défaut, ses utilisateurs peuvent donc dormir sur leurs deux oreilles. :)</p><div id="r-418294" data-claire-element-id="418294" data-claire-semantic="question"><p id="r-418293" data-claire-element-id="418293">Mais quelles sont les règles de support de IEEE 754 selon le C99 ?</p></div><p id="r-418295" data-claire-element-id="418295">La norme C99 comporte une annexe (l'annexe F) dédiée aux nombres flottants, où se trouve la réponse à cette question. En voici le début :</p><p id="r-418296" data-claire-element-id="418296"><cite>Citation : ISO/IEC 9899:TC3 — Annex F (normative): IEC 60559 floating-point arithmetic (p.444)</cite></p><blockquote id="r-418302" data-claire-element-id="418302"><h3 id="r-f-1-introduction" data-claire-element-id="418298">F.1 Introduction</h3><p id="r-418297" data-claire-element-id="418297">This annex specifies C language support for the IEC 60559 floating-point standard. […] An implementation that defines <code data-claire-semantic="c">__STDC_IEC_559__</code> shall conform to the specifications in this annex. […]</p><h3 id="r-f-2-types" data-claire-element-id="418301">F.2 Types</h3><p id="r-418299" data-claire-element-id="418299">The C floating types match the IEC 60559 formats as follows:<br/> — The <code data-claire-semantic="c">float</code> type matches the IEC 60559 single format.<br/> — The <code data-claire-semantic="c">double</code> type matches the IEC 60559 double format.<br/> — The <code data-claire-semantic="c">long double</code> type matches an IEC 60559 extended format, else a non-IEC 60559 extended format, else the IEC 60559 double format.<br/> Any non-IEC 60559 extended format used for the <code data-claire-semantic="c">long double</code> type shall have more precision than IEC 60559 double and at least the range of IEC 60559 <code data-claire-semantic="c">double</code>.<br/><strong>Recommended practice</strong><br/> The <code data-claire-semantic="c">long double</code> type should match an IEC 60559 extended format.</p><p id="r-418300" data-claire-element-id="418300">[…]</p></blockquote><p id="r-418303" data-claire-element-id="418303">This annex specifies C language support for the IEC 60559 floating-point standard. […] An implementation that defines <code data-claire-semantic="c">__STDC_IEC_559__</code> shall conform to the specifications in this annex. […]</p><h3 id="r-f-2-types-1" data-claire-element-id="418306">F.2 Types</h3><p id="r-418304" data-claire-element-id="418304">The C floating types match the IEC 60559 formats as follows:<br/> — The <code data-claire-semantic="c">float</code> type matches the IEC 60559 single format.<br/> — The <code data-claire-semantic="c">double</code> type matches the IEC 60559 double format.<br/> — The <code data-claire-semantic="c">long double</code> type matches an IEC 60559 extended format, else a non-IEC 60559 extended format, else the IEC 60559 double format.<br/> Any non-IEC 60559 extended format used for the <code data-claire-semantic="c">long double</code> type shall have more precision than IEC 60559 double and at least the range of IEC 60559 <code data-claire-semantic="c">double</code>.<br/><strong>Recommended practice</strong><br/> The <code data-claire-semantic="c">long double</code> type should match an IEC 60559 extended format.</p><p id="r-418305" data-claire-element-id="418305">[…]</p><p id="r-418307" data-claire-element-id="418307">The C floating types match the IEC 60559 formats as follows:<br/> — The <code data-claire-semantic="c">float</code> type matches the IEC 60559 single format.<br/> — The <code data-claire-semantic="c">double</code> type matches the IEC 60559 double format.<br/> — The <code data-claire-semantic="c">long double</code> type matches an IEC 60559 extended format, else a non-IEC 60559 extended format, else the IEC 60559 double format.<br/> Any non-IEC 60559 extended format used for the <code data-claire-semantic="c">long double</code> type shall have more precision than IEC 60559 double and at least the range of IEC 60559 <code data-claire-semantic="c">double</code>.<br/><strong>Recommended practice</strong><br/> The <code data-claire-semantic="c">long double</code> type should match an IEC 60559 extended format.</p><p id="r-418308" data-claire-element-id="418308">[…]</p><p id="r-418310" data-claire-element-id="418310">La deuxième partie dit que le type <code data-claire-semantic="c">float</code> du langage C doit correspondre au format simple précision (32 bits) de IEC 60559 (alias IEEE 754), etc., etc.<br/> Il est aussi question du type <code data-claire-semantic="c">long double</code>, dont j'ai peu parlé dans ce tutoriel ; sachez qu'en C, son format est moins bien défini, mais qu'il correspond souvent au format de double précision étendue de IEEE 754 (dont je n'ai pas parlé non plus), ou alors au format de double précision tout court (comme un <code data-claire-semantic="c">double</code>).</p><p id="r-418311" data-claire-element-id="418311">Je ne parlerai pas de la suite de cette annexe, vous pouvez la lire si vous voulez (vous êtes grands). Elle décrit notamment le comportement des opérations sur les flottants.</p><p id="r-418312" data-claire-element-id="418312">Enfin, sachez que :</p><p id="r-418313" data-claire-element-id="418313"><cite>Citation : Taurre</cite></p><blockquote id="r-418315" data-claire-element-id="418315"><p id="r-418314" data-claire-element-id="418314">un système peut visiblement encoder les nombres flottants suivant le format défini par la norme IEEE 754, sans pour autant remplir toutes les conditions de l'annexe F de la norme C99 (<a href="http://bytes.com/topic/c/answers/770825-ieee754-fp">cf ce sujet</a>).</p></blockquote><p id="r-418316" data-claire-element-id="418316">Les conditions en questions sont surtout des détails du comportement des calculs. Dans le cadre de ce tutoriel, qui s'est surtout focalisé sur les formats de représentation des flottants, ça ne devrait pas poser trop de problèmes.</p><p id="r-418317" data-claire-element-id="418317">Le non-respect partiel de la norme IEEE 754 peut aussi être le fait d'options du compilateur. Par exemple, l'option d'optimisation <code data-claire-semantic="console">-ffast-math</code> de GCC améliore les performances en accélérant les calculs sur les nombres flottants, mais enfreint certaines règles de IEEE 754.</p><p id="r-418318" data-claire-element-id="418318">Je reviens sur l'introduction, elle contient quelque chose d'intéressant. Il est dit que si la macro <code data-claire-semantic="c">__STDC_IEC_559__</code> est définie, alors c'est le format IEEE 754 qui est utilisé. Cela peut vous être utile pour faire des tests ou adapter votre code. ;) <br/> Cependant, le contraire n'est pas vrai ! Vous pouvez parfaitement avoir une implémentation qui suit IEEE 754 mais qui ne définit pas cette constante. Cela semble être le cas de GCC sous Windows (portage MinGW par exemple), car GCC laisse cette définition aux headers du système ; or, ceux de Windows ne définissent pas <code data-claire-semantic="c">__STDC_IEC_559__</code>, en partie parce qu'il y aurait un risque d'incompatibilité entre GCC et la bibliothèque C de Windows.</p><h2 id="r-en-pratique-savoir-si-l-implementation-utilise-ieee-754" data-claire-element-id="418354">En pratique : savoir si l'implémentation utilise IEEE 754</h2><p id="r-418319" data-claire-element-id="418319">Puisqu'on ne peut pas compter sur la constante <code data-claire-semantic="c">__STDC_IEC_559__</code> pour nous renseigner, il faut trouver un autre moyen de déterminer si oui ou non on travaille avec IEEE 754.</p><p id="r-418320" data-claire-element-id="418320">Pour cela, le meilleur moyen reste de se renseigner auprès de votre compilateur favori et/ou de votre plateforme cible.</p><p id="r-418321" data-claire-element-id="418321">Toutefois, si vous tenez vraiment à faire cette vérification avec du code, je peux vous offrir des pistes…</p><ul id="r-418328" data-claire-element-id="418328"><li id="r-418324" data-claire-element-id="418324"><p id="r-418322" data-claire-element-id="418322">dynamiquement (c'est-à-dire au moment de l'exécution de votre programme) : Vous pouvez par exemple déclarer un certain nombre de variables de type à virgule flottante, puis vérifier que leur représentation mémoire correspond à celle attendue en se basant sur IEEE 754. Il faudrait effectuer cette série de tests pour les différents types de nombres (zéros, dénormalisés, normalisés, infinis, NaN).<br/> Un tel code ne serait pas infaillible (on peut très bien imaginer des formats ressemblant à IEEE 754, qui passeraient avec succès tous les tests) mais il permet d'éliminer certains formats.</p><p id="r-418323" data-claire-element-id="418323">L'inconvénient est que du code inutile est intégré à l'exécutable, et que l'on perd du temps à chaque exécution du programme lorsqu'on effectue ces vérifications. À éviter en pratique, donc.<br/> D'un point de vue technique, cela reste cependant un bon exercice. :ange:</p></li><li id="r-418327" data-claire-element-id="418327"><p id="r-418325" data-claire-element-id="418325">statiquement (c'est-à-dire lors de la compilation) : Pour cela, il faut vous appuyer sur votre ami le préprocesseur. Sans détailler, vous pouvez tester la valeur des macros définies dans le header <a href="http://www.gnu.org/s/hello/manual/libc/Floating-Type-Macros.html">&lt;float.h&gt;</a> du C99 ; celles-ci caractérisent l'implémentation des nombres flottants : précision, exposants minimum et maximum, valeurs minimales et maximales… Tout cela en 3 variantes pour chacun des 3 types à virgule flottante du C.</p><p id="r-418326" data-claire-element-id="418326">Cette approche présente l'avantage de ne garder que le code nécessaire lors de la compilation et de ne pas faire cette vérification à l'exécution.<br/> Mais avouez que c'est fichtrement moins rigolo.</p></li></ul><p id="r-418329" data-claire-element-id="418329">L'avantage est que le bon fonctionnement du code serait indépendant du compilateur utilisé, facilitant ainsi les échanges de code.</p><p id="r-418330" data-claire-element-id="418330">Notez toutefois que les propositions ci-dessus vérifient la représentation en mémoire, mais pas les différentes opérations sur les flottants.</p><p id="r-418331" data-claire-element-id="418331">Voilà, ce cours touche à sa fin ! Il a été très théorique, j'espère que vous avez digéré.<br/> Vous savez maintenant comment vous servir des nombres à virgule en C, et comment ils fonctionnent sous le capot. On a aussi vu les difficultés de leur utilisation, et comment les contourner.</p><p id="r-418332" data-claire-element-id="418332">J'espère que vous avez apprécié le voyage, et bon code ! Faites-nous de beaux programmes mathématiques, je compte sur vous. :D</p><p id="r-418333" data-claire-element-id="418333">Si vous voulez aller encore plus loin, je ne peux que vous conseiller de lire <a href="http://www.siteduzero.com/tutoriel-3-528426.html">ce tutoriel</a> qui décrit comment sont gérés les nombres flottants au niveau matériel (le processeur).</p><p id="r-418334" data-claire-element-id="418334">Sources :</p><ul id="r-418343" data-claire-element-id="418343"><li id="r-418336" data-claire-element-id="418336"><p id="r-418335" data-claire-element-id="418335">articles de Wikipédia : <a href="http://fr.wikipedia.org/wiki/Virgule_flottante">virgule flottante</a>, <a href="http://fr.wikipedia.org/wiki/IEEE_754">IEEE 754</a> (n'hésitez pas à aller sur les articles anglais qui sont bien plus complets) ;</p></li><li id="r-418338" data-claire-element-id="418338"><p id="r-418337" data-claire-element-id="418337">wikilivre (actuellement en rédaction) : <a href="http://fr.wikibooks.org/wiki/Arithmétique_flottante">Arithmétique flottante</a> ;</p></li><li id="r-418340" data-claire-element-id="418340"><p id="r-418339" data-claire-element-id="418339">page présentant l'astuce pour comparer des flottants : <em><a href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">Comparing floating point numbers</a></em> par Bruce Dawson (en) ;</p></li><li id="r-418342" data-claire-element-id="418342"><p id="r-418341" data-claire-element-id="418341">la norme C99 ! ou plutôt son draft (n1256), disponible <a href="http://open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf">ici</a> en PDF (en).</p></li></ul><p id="r-418344" data-claire-element-id="418344">Liens additionnels :</p><ul id="r-418351" data-claire-element-id="418351"><li id="r-418346" data-claire-element-id="418346"><p id="r-418345" data-claire-element-id="418345">page de manuel de <code data-claire-semantic="c">isinf</code>, <code data-claire-semantic="c">isnan</code>, etc. : <a href="http://www.man-linux-magique.net/man3/isinf.html">macros de classification en virgule flottante</a> ;</p></li><li id="r-418348" data-claire-element-id="418348"><p id="r-418347" data-claire-element-id="418347">pages du manuel de la lib GNU C concernant les flottants (concepts, constantes fournies par <code data-claire-semantic="c">&lt;float.h&gt;</code>, exemple pour IEEE 754) : <em><a href="http://www.gnu.org/s/hello/manual/libc/Floating-Type-Macros.html">floating type macros</a></em>(en) ;</p></li><li id="r-418350" data-claire-element-id="418350"><p id="r-418349" data-claire-element-id="418349"><strong>site très pratique permettant de calculer la représentation en mémoire d'un nombre à virgule et l'inverse, pour les deux formats principaux de IEEE 754 (32 et 64 bits) : <em><a href="http://babbage.cs.qc.edu/IEEE-754/">IEEE-754 Analysis</a></em></strong>(en).</p></li></ul><aside id="r-418353" data-claire-element-id="418353" data-claire-semantic="information"><p id="r-418352" data-claire-element-id="418352">Je tiens à remercier tous ceux qui ont participé à <a href="http://www.siteduzero.com/forum-83-663077-p1-les-nombres-a-virgule-flottante-du-point-de-vue-de-la-norme.html">cette discussion</a> sur le forum, et en particulier <strong>Taurre</strong> (ainsi que <strong>yoch</strong>) ; ils m'ont beaucoup aidé pour la dernière partie de ce cours, consacrée à la norme C.<br/> Un grand merci également au bêta-testeurs pour leur précieuse assistance et le temps qu'ils ont consacré à ce tutoriel : je citerai surtout <strong>mewtow</strong>, <strong>Adroneus</strong> et <strong>yoch</strong> (sans oublier <strong>programLyrique</strong> et <strong>Duarna</strong>).</p></aside>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c">Maîtrisez les nombres à virgule en C</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/utilisation-des-nombres-a-virgule-en-c">
Utilisation des nombres à virgule en C
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-le-codage-en-memoire-d-un-nombre-flottant">
IEEE 754 : le codage en mémoire d’un nombre flottant
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/un-peu-de-mathematiques-1">
Un peu de mathématiques
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/ieee-754-exceptions-arrondis">
IEEE 754 : Exceptions &amp; arrondis
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/comparer-des-nombres-flottants">
Comparer des nombres flottants
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/mais-qu-en-dit-la-norme-c">
Mais qu&#039;en dit la norme C ?
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-nombres-a-virgule-en-c/comparer-des-nombres-flottants">
<span class="arrow"></span>
<span class="next">Comparer des nombres flottants</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/maitrisez-les-nombres-a-virgule-en-c.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Oct 2013 20:34:19 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/maitrisez-les-nombres-a-virgule-en-c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 03:52:51 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/maitrisez-les-bases-de-donnees-avec-qtsql.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 11:05:30 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/maitrisez-les-bases-de-donnees-avec-qtsql.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:47:25 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Maîtrisez les bases de données avec QtSQL</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/maitrisez-les-bases-de-donnees-avec-qtsql.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Maîtrisez les bases de données avec QtSQL</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#MatrisezlesbasesdedonnesavecQtSQL">Maîtrisez les bases de données avec QtSQL</a><br/><a href="#Prparationavantcodage">Préparation avant codage</a><br/><a href="#QtSeconnecterfairedesrequtesetlestraiter">[Qt] Se connecter, faire des requêtes, et les traiter</a><br/></div>
<a name="MatrisezlesbasesdedonnesavecQtSQL"></a><h2>Maîtrisez les bases de données avec QtSQL</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-bases-de-donnees-avec-qtsql/preparation-avant-codage">
<span class="next">Préparation avant codage</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-530827" data-claire-element-id="530827">Dans ce tutoriel, nous allons voir ensemble l'utilisation des bases de données dans un projet Qt.</p><p id="r-530828" data-claire-element-id="530828">Pour suivre ce tutoriel, il est donc nécessaire d'avoir des bases en C++, de connaître un minimum le framework Qt, de savoir utiliser un S.G.B.D., et d'avoir des bases en SQL.<br/> Si ce n'est pas le cas, vous pouvez lire le <a href="http://www.siteduzero.com/tutoriel-3-11406-apprenez-a-programmer-en-c.html">tutoriel de C++</a> en totalité, ainsi que <a href="http://www.siteduzero.com/tutoriel-3-14668-un-site-dynamique-avec-php.html#part_14671">la partie 3 du tutoriel de PHP</a> qui sont présents sur ce site.</p>
</div><a name="Prparationavantcodage"></a><h2>Préparation avant codage</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-bases-de-donnees-avec-qtsql/qt-se-connecter-faire-des-requetes-et-les-traiter">
<span class="next">[Qt] Se connecter, faire des requêtes, et les traiter</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-obtenir-une-base-de-donnees" data-claire-element-id="530832">Obtenir une Base de Données</h2><p id="r-530829" data-claire-element-id="530829">Pour commencer à utiliser une BDD, il faut bien en avoir une, non ? :) <br/> Si vous en possédez une, vous pouvez passer votre chemin, et aller directement à la partie suivante.</p><p id="r-530830" data-claire-element-id="530830">Tout d'abord, si vous voulez juste tester pour voir comment cela marche, et seulement sur votre PC, le plus simple est directement d'en installer une chez vous. Le SGBD que j'utiliserai dans le tutoriel est MySQL, vous pouvez l'installer en le téléchargeant sur <a href="http://www.mysql.fr/downloads/mysql/">le site officiel</a> et en l'installant. Si vous êtes sous GNU/Linux, il se trouve à coup sûr dans vos dépôts.<br/> Attention ! Il vous faut aussi installer la librairie côté client du SGBD choisi !</p><p id="r-530831" data-claire-element-id="530831">C'est bon ? vous avez tout ?<br/> C'est parti pour l'aventure ! :D</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-bases-de-donnees-avec-qtsql">Maîtrisez les bases de données avec QtSQL</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-bases-de-donnees-avec-qtsql/preparation-avant-codage">
Préparation avant codage
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-bases-de-donnees-avec-qtsql/qt-se-connecter-faire-des-requetes-et-les-traiter">
[Qt] Se connecter, faire des requêtes, et les traiter
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-bases-de-donnees-avec-qtsql/qt-se-connecter-faire-des-requetes-et-les-traiter">
<span class="next">[Qt] Se connecter, faire des requêtes, et les traiter</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="QtSeconnecterfairedesrequtesetlestraiter"></a><h2>[Qt] Se connecter, faire des requêtes, et les traiter</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-bases-de-donnees-avec-qtsql/preparation-avant-codage">
<span class="arrow"></span>
<span class="next">Préparation avant codage</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-530834" data-claire-element-id="530834">Dans cette partie, nous allons apprendre à nous servir de toutes ces magnifiques choses, ne perdons donc pas de temps, allons-y.</p><p id="r-530835" data-claire-element-id="530835">Voici donc le code de base que je vous propose pour commencer à étudier le module QtSql. :)</p><pre id="r-530836" data-claire-element-id="530836"><code data-claire-semantic="cpp">#include &lt;QCoreApplication&gt;
#include &lt;QtSql&gt;
#include &lt;iostream&gt;

#define q2c(string) string.toStdString()

int main(int countArg, char **listArg)
{
    QCoreApplication app(countArg, listArg);
    std::cout &lt;&lt; std::flush;
    return app.exec();
}</code></pre><p id="r-530837" data-claire-element-id="530837">Voici ce qui est à noter dans le code :</p><ul id="r-530844" data-claire-element-id="530844"><li id="r-530839" data-claire-element-id="530839"><p id="r-530838" data-claire-element-id="530838">Peut-être l'avez-vous remarqué avec « QCoreApplication », mais je n'utiliserai pas d'interface graphique pour faire ce code ;</p></li><li id="r-530841" data-claire-element-id="530841"><p id="r-530840" data-claire-element-id="530840">La macro-définition q2c est simplement faite pour faciliter la conversion de QString vers std::string ; :)</p></li><li id="r-530843" data-claire-element-id="530843"><p id="r-530842" data-claire-element-id="530842">Quand l'on écrit directement avec std::cout, le texte ne sera pas dans la console, pour cela, il faut utiliser std::flush pour forcer l'affichage.</p></li></ul><p id="r-530845" data-claire-element-id="530845">Étant donné que nous n'utilisons pas de GUI (il vous faudrait plus de temps à modifier l'ancien qu'à écrire le nouveau ^^ ), ne générez pas votre .pro avec <code data-claire-semantic="console">qmake -project</code>, utilisez celui-ci :</p><pre id="r-530846" data-claire-element-id="530846"><code>QT       += sql # On rajoute SQL
QT       -= gui # On enlève la GUI
TARGET = test # La cible de compilation, le résultat
CONFIG   += console # On rajoute la console
TEMPLATE = app # On veut une application, oui
SOURCES += main.cpp # La liste des fichiers de source</code></pre><p id="r-530847" data-claire-element-id="530847">Et si vous compilez puis exécutez... vous tomberez sur une console vide. Et c'est normal, nous n'avons rien codé, pour l'instant ! :D</p><h2 id="r-connexion-a-la-bdd-1" data-claire-element-id="530857">Connexion à la BDD</h2><p id="r-530848" data-claire-element-id="530848">Pour commencer, il faut faire la connexion. Pour ce faire, on va créer un objet de la classe QSqlDatabase.<br/> Comme valeur, on va lui assigner le retour de la méthode statique addDatabase() qui reçoit en paramètre sous forme de chaîne de caractères l'une des valeurs du tableau se trouvant <a href="http://doc.trolltech.com/latest/qsqldatabase.html#QSqlDatabase-3">dans la documentation</a>.<br/> Dans ce tutoriel, étant donné que je prendrai en exemple une base de données MySQL, nous prendrons la valeur QMYSQL.</p><p id="r-530849" data-claire-element-id="530849">Pour résumer ce que je viens de dire, rajoutez ceci dans le code :</p><pre id="r-530850" data-claire-element-id="530850"><code data-claire-semantic="cpp">QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);</code></pre><p id="r-530851" data-claire-element-id="530851">Maintenant, nous allons préciser l'hôte, le nom d'utilisateur, le mot de passe, et la base de données que l'on utilisera. Pour ce faire, on utilisera respectivement les méthodes setHostName(), setUserName(), setPassword() et setDatabaseName(), qui prennent chacunes un QString renseignant l'information que l'on modifie.<br/> Pour continuer, nous allons utiliser open(), qui ouvre la connexion, et renvoie un booléen : true si la connexion a réussie, false si elle a échouée. Nous l'utiliserons donc dans une condition.<br/> Pour fermer la base de données, on utilisera la méthode close().</p><p id="r-530852" data-claire-element-id="530852">Si je résume, encore une fois, voici notre code :</p><pre id="r-530853" data-claire-element-id="530853"><code data-claire-semantic="cpp">QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);
db.setHostName(&quot;localhost&quot;);
db.setUserName(&quot;root&quot;);
db.setPassword(&quot;&quot;);
db.setDatabaseName(&quot;tuto&quot;);
if(db.open())
{
    std::cout &lt;&lt; &quot;Vous êtes maintenant connecté à &quot; &lt;&lt; q2c(db.hostName()) &lt;&lt; std::endl;
    db.close();
}
else
{
    std::cout &lt;&lt; &quot;La connexion a échouée, désolé&quot; &lt;&lt; std::endl;
}</code></pre><p id="r-530854" data-claire-element-id="530854">Vous pouvez donc déjà tester la connexion en utilisant le code ci-dessus.<br/> Ça marche ? Oui ? Parfait. :)</p><p id="r-530855" data-claire-element-id="530855">Si ce n'est pas le cas, vérifiez que les identifiants sont corrects ou que vous êtes, dans le cas d'un serveur externe, autorisés à accéder à la BDD. Pensez aussi à placer les DLL de l'API de votre SGBD ainsi que ceux de QtSQL.<br/> Remarque : La méthode QSqlDatabase::lastError retourne un objet de type QSqlError, et dedans, il y a une méthode text() qui explique la source du problème !<br/> Vous pouvez donc le connaître ainsi :</p><pre id="r-530856" data-claire-element-id="530856"><code data-claire-semantic="cpp">//...
else
{
    std::cout &lt;&lt; &quot;La connexion a échouée, désolé :(&quot; &lt;&lt; std::endl &lt;&lt; q2c(db.lastError().text()) &lt;&lt; std::endl;
}</code></pre><h2 id="r-effectuer-une-requete" data-claire-element-id="530862">Effectuer une requête</h2><p id="r-530858" data-claire-element-id="530858">Tout d'abord, sachez qu'une requête est représentée par la classe QSqlQuery. Elle peut prendre un paramètre au constructeur, ou aucun (ce que je vous conseille, pour n'utiliser qu'un objet de la classe QSqlQuery et ne pas en recréer à chaque requête).</p><p id="r-530859" data-claire-element-id="530859">Vous créez un objet QSqlQuery, et pour faire une requête, il vous suffira d'utiliser la méthode exec(), en lui passant la requête en paramètre.<br/> Sachez qu'exec() retourne un booléen : true si la requête a réussie, false si elle a échouée. Si c'est une requête qui n'attend pas de réponse (dans le cas de la requête UPDATE, par exemple), cela suffit. Si par contre elle attend une réponse (dans le cas de SELECT, par exemple), on utilisera cette méthode d'une façon un peu différente que nous verrons dans le paragraphe suivant.<br/> En cas d'erreur de la requête, QSqlQuery::lastError() vous retournera un objet de type QSqlError.<br/> Il vous suffira d'utiliser QSqlError::text() pour l'avoir dans un QString, et pouvoir l'afficher !</p><p id="r-530860" data-claire-element-id="530860">Par exemple, imaginez que vous avez une table config, contenant deux champs : type et contenu. <em>type</em> serait la configuration que l'on fait (titre, taille, ...) et <em>contenu</em> serait la valeur de la configuration (&quot;Mon super programme&quot;, &quot;165x253&quot;, ...).<br/> Vous voudriez modifier le titre, pour le changer en « Mon programme avec BDD v2.0 ». Voici comment vous devrez faire :</p><pre id="r-530861" data-claire-element-id="530861"><code data-claire-semantic="cpp">QSqlQuery query;
if(query.exec(&quot;UPDATE `config` SET `contenu`='Mon programme avec BDD v2.0' WHERE `type`='titre'&quot;))
{
    std::cout &lt;&lt; &quot;Le titre a bien été changé ! :)&quot; &lt;&lt; std::endl;
}
else
{
    std::cout &lt;&lt; &quot;Une erreur s'est produite. :(&quot; &lt;&lt; std::endl &lt;&lt; q2c(query.lastError().text()) &lt;&lt; std::endl;
}</code></pre><h2 id="r-recuperer-les-donnees-2" data-claire-element-id="530876">Récupérer les données</h2><p id="r-530863" data-claire-element-id="530863">Donc, comme je viens de le dire, dans le cas d'une requête attendant une réponse, tel que SELECT, on utilisera, combinée à la méthode exec(), la méthode next() qui retourne la valeur suivante de la requête. Tant qu'il reste des lignes dans la réponse, next() retournera true, et modifiera la ligne actuelle dans notre objet.<br/> Pour accéder à une colonne de la ligne, il vous faudra passer par son ID (le numéro qui donne son ordre dans la liste, le premier étant 0), avec QSqlQuery::value(), vous avez plusieurs solutions :</p><ul id="r-530868" data-claire-element-id="530868"><li id="r-530865" data-claire-element-id="530865"><p id="r-530864" data-claire-element-id="530864">Vous savez que la requête ne retournera qu'une colonne, dans ce cas, vous utiliserez le premier ID possible (0) ;</p></li><li id="r-530867" data-claire-element-id="530867"><p id="r-530866" data-claire-element-id="530866">Vous connaissez le nom du champ, vous allez utiliser QSqlRecord::indexOf() qui prend en paramètre le nom du champ dans un QString ;</p></li></ul><p id="r-530869" data-claire-element-id="530869">Maintenant, je veux afficher les valeurs de tous les champs, et récupérer leurs noms : en passant son ID à la fonction QSqlRecord::fieldname(), on peut récupérer son nom.<br/> Si on veut récupérer la totalité des colonnes, il suffit de faire une boucle « tant que x est plus petit que QSqlRecord::count() ». x sera l'ID de la colonne.</p><div id="r-530871" data-claire-element-id="530871" data-claire-semantic="question"><p id="r-530870" data-claire-element-id="530870">Attends une minute, mon bonhomme ! C'est quoi, cette classe QSqlRecord ? Je dois faire un objet ?</p></div><p id="r-530872" data-claire-element-id="530872">Non, il y a plus simple !<br/> La méthode QSqlQuery::record() retournera l'objet QSqlRecord à utiliser !<br/> Vous pourrez donc faire : <code data-claire-semantic="cpp">query.record().indexOf(&quot;colonne1&quot;);</code></p><p id="r-530873" data-claire-element-id="530873">Par exemple, pour afficher le contenu de notre table « config », cela suffira :</p><pre id="r-530874" data-claire-element-id="530874"><code data-claire-semantic="cpp">QSqlQuery query;
if(query.exec(&quot;SELECT * FROM config&quot;))
{
    while(query.next())
    {
        std::cout &lt;&lt; &quot;    Nouvelle entrée&quot; &lt;&lt; std::endl;
        for(int x=0; x &lt; query.record().count(); ++x)
        {
            std::cout &lt;&lt; &quot;        &quot; &lt;&lt; q2c(query.record().fieldName(x)) &lt;&lt; &quot; = &quot; &lt;&lt; q2c(query.value(x)) &lt;&lt; std::endl;
        }
    }
}</code></pre><p id="r-530875" data-claire-element-id="530875">Qui a dit que les BDD avec Qt, c'était dur ? :D</p><h2 id="r-les-requetes-preparees-5" data-claire-element-id="530909">Les requêtes préparées</h2><p id="r-530877" data-claire-element-id="530877">Tout d'abord, qu'est-ce-qu'une requête préparée ? C'est une requête comme une autre, sauf qu'au lieu de mettre directement les valeurs, on va mettre des marqueurs (<strong>?</strong> ou un marqueur nominatif), et les remplacer plus tard.<br/> Ainsi, la requête sera réutilisable pour différentes valeurs.</p><p id="r-530878" data-claire-element-id="530878">Pour en créer une, on utilise toujours l'objet QSqlQuery. Sauf que nous n'écrirons pas la requête dans la méthode QSqlQuery::exec(), mais dans la méthode QSqlQuery::prepare().<br/> Pour remplacer un marqueur, il y a deux possibilités :</p><ul id="r-530883" data-claire-element-id="530883"><li id="r-530880" data-claire-element-id="530880"><p id="r-530879" data-claire-element-id="530879">C'est un marqueur nominatif, on va utiliser la méthode QSqlQuery::bindValue en mettant le nom du marqueur puis la valeur ;</p></li><li id="r-530882" data-claire-element-id="530882"><p id="r-530881" data-claire-element-id="530881">C'est un point d'interrogation, on utilisera QSqlQuery::addBindValue() en passant la valeur : il faudra l'utiliser dans l'ordre des <strong>?</strong> !</p></li></ul><p id="r-530884" data-claire-element-id="530884">Si je résume :</p><pre id="r-530885" data-claire-element-id="530885"><code data-claire-semantic="cpp">QSqlQuery q;
//Marqueurs ?
q.prepare(&quot;UPDATE matable SET monchamp=?, monchamp2=?&quot;);
q.addBindValue(&quot;Coucou&quot;);
q.addBindValue(42);

//Marqueurs nominatifs
q.prepare(&quot;UPDATE matable SET monchamp=:premierevaleur, monchamp2=:deuxiemevaleur&quot;);
q.bindValue(&quot;:premierevaleur&quot;, &quot;Coucou&quot;);
q.bindValue(&quot;:deuxiemevaleur&quot;, 42);</code></pre><p id="r-530886" data-claire-element-id="530886">À noter que les marqueurs nominatifs commencent par le caractère <strong>:</strong> (<strong>Doubles-points</strong>).</p><p id="r-530887" data-claire-element-id="530887">Vous avez aussi une deuxième possibilité :<br/> On veut executer cette même requête plusieurs fois. On va utiliser QSqlQuery::addBindValue() pour les deux types de marqueurs, sauf que l'on passera un QVariantList en paramètre.<br/> Attention ! Un QVariantList passé correspond aux valeurs d'un marqueur dans les différentes requêtes, et non aux valeurs des marqueurs dans chacunes des requêtes !<br/> Mais un exemple vaut mieux qu'un avertissement, voici celui de la documentation :</p><pre id="r-530888" data-claire-element-id="530888"><code data-claire-semantic="cpp">QSqlQuery q;
q.prepare(&quot;insert into myTable values (?, ?)&quot;);

QVariantList ints;
ints &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4;
q.addBindValue(ints);

QVariantList names;
names &lt;&lt; &quot;Harald&quot; &lt;&lt; &quot;Boris&quot; &lt;&lt; &quot;Trond&quot; &lt;&lt; QVariant(QVariant::String);
q.addBindValue(names);</code></pre><div id="r-530890" data-claire-element-id="530890" data-claire-semantic="question"><p id="r-530889" data-claire-element-id="530889">Bonhomme, c'est bien beau tout ça, mais ça m'aide pas à exécuter une requête ! J'utilise exec() tout seul ?</p></div><p id="r-530891" data-claire-element-id="530891">Et bien, c'est presque la solution ! Il va falloir utiliser QSqlQuery::execBatch(). :)</p><p id="r-530892" data-claire-element-id="530892">Pour compléter le code ci-dessus, voici comment on exécuterai la requête :</p><pre id="r-530893" data-claire-element-id="530893"><code data-claire-semantic="cpp">QSqlQuery q;
q.prepare(&quot;insert into myTable values (?, ?)&quot;);

QVariantList ints;
ints &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4;
q.addBindValue(ints);

QVariantList names;
names &lt;&lt; &quot;Harald&quot; &lt;&lt; &quot;Boris&quot; &lt;&lt; &quot;Trond&quot; &lt;&lt; QVariant(QVariant::String);
q.addBindValue(names);

if (q.execBatch())
{
    std::cout &lt;&lt; &quot;Ça marche ! :)&quot; &lt;&lt; std::endl;
}
else
{
    std::cout &lt;&lt; &quot;Ça marche pas ! :(&quot; &lt;&lt; std::endl;
}</code></pre><p id="r-530894" data-claire-element-id="530894">Pour le reste (gestion des erreurs, récupération des données), le fonctionnement est le même.</p><p id="r-530895" data-claire-element-id="530895">Il y a tant de choses que j'aurais pu rajouter dans ce tutoriel, tant de choses à apprendre, tant d'astuces à utiliser, tant de choses qui fait que ce tutoriel n'est pas complet.<br/> Par contre, la documentation, elle, est très complète, n'hésitez pas à regarder dedans !</p><ul id="r-530908" data-claire-element-id="530908"><li id="r-530897" data-claire-element-id="530897"><p id="r-530896" data-claire-element-id="530896"><a href="http://doc.trolltech.com/latest">Documentation de Qt</a> ;</p></li><li id="r-530899" data-claire-element-id="530899"><p id="r-530898" data-claire-element-id="530898"><a href="http://doc.trolltech.com/latest/qtsql.html">Documentation du module QtSql</a> ;</p></li><li id="r-530901" data-claire-element-id="530901"><p id="r-530900" data-claire-element-id="530900"><a href="http://doc.trolltech.com/latest/qsqldatabase.html">Documentation de la classe QSqlDatabase</a> ;</p></li><li id="r-530903" data-claire-element-id="530903"><p id="r-530902" data-claire-element-id="530902"><a href="http://doc.trolltech.com/latest/qsqlquery.html">Documentation de la classe QSqlQuery</a> ;</p></li><li id="r-530905" data-claire-element-id="530905"><p id="r-530904" data-claire-element-id="530904"><a href="http://doc.trolltech.com/latest/qsqlrecord.html">Documentation de la classe QSqlRecord</a> ;</p></li><li id="r-530907" data-claire-element-id="530907"><p id="r-530906" data-claire-element-id="530906"><a href="http://doc.trolltech.com/latest/qsqlerror.html">Documentation de la classe QSqlError</a>.</p></li></ul>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-bases-de-donnees-avec-qtsql">Maîtrisez les bases de données avec QtSQL</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-bases-de-donnees-avec-qtsql/preparation-avant-codage">
Préparation avant codage
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-bases-de-donnees-avec-qtsql/qt-se-connecter-faire-des-requetes-et-les-traiter">
[Qt] Se connecter, faire des requêtes, et les traiter
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/maitrisez-les-bases-de-donnees-avec-qtsql/preparation-avant-codage">
<span class="arrow"></span>
<span class="next">Préparation avant codage</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/maitrisez-les-bases-de-donnees-avec-qtsql.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 11:05:30 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/maitrisez-les-bases-de-donnees-avec-qtsql.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:47:25 GMT -->
</html>
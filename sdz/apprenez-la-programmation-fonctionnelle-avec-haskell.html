<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/apprenez-la-programmation-fonctionnelle-avec-haskell.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Oct 2013 20:01:20 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/apprenez-la-programmation-fonctionnelle-avec-haskell.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 03:44:58 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Apprenez la programmation fonctionnelle avec Haskell</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Apprenez la programmation fonctionnelle avec Haskell</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#ApprenezlaprogrammationfonctionnelleavecHaskell">Apprenez la programmation fonctionnelle avec Haskell</a><br/><a href="#HaskellC039estquoi">Haskell ? C&#039;est quoi ?</a><br/><a href="#PourquoiapprendreHaskell">Pourquoi apprendre Haskell ?</a><br/><a href="#Qu039est-cequ039onpeutfaireenHaskell">Qu&#039;est-ce qu&#039;on peut faire en Haskell ?</a><br/><a href="#Tlchargezetinstallezuncompilateur">Téléchargez et installez un compilateur</a><br/><a href="#Dcouvrezlelangageavecghci">Découvrez le langage avec ghci</a><br/><a href="#Unecalculatrice">Une calculatrice</a><br/><a href="#Utiliserdesfonctions">Utiliser des fonctions</a><br/><a href="#Listeschanesdecaractres">Listes, chaînes de caractères</a><br/><a href="#Dfinirdesfonctions">Définir des fonctions</a><br/><a href="#Dclarationsdansunfichier">Déclarations dans un fichier</a><br/><a href="#Conditionsetfiltragedemotif">Conditions et filtrage de motif</a><br/><a href="#Plusdefiltragedemotif">Plus de filtrage de motif</a><br/><a href="#Typesetclassesdetypes">Types et classes de types</a><br/><a href="#Typessimples">Types simples</a><br/><a href="#Polymorphismeetclassesdetypes">Polymorphisme et classes de types</a><br/><a href="#Rcursivit">Récursivité</a><br/><a href="#C039estquoi">C&#039;est quoi ?</a><br/><a href="#Filtragedemotifetrcursivit">Filtrage de motif et récursivité</a><br/><a href="#Programmationfonctionnelle">Programmation fonctionnelle</a><br/><a href="#Exemplelafonctionmap">Exemple : la fonction map</a><br/><a href="#Fonctionssurleslistes">Fonctions sur les listes</a><br/><a href="#Composerdesfonctions">Composer des fonctions</a><br/><a href="#Crezvosproprestypes">Créez vos propres types</a><br/><a href="#Dclareruntype">Déclarer un type</a><br/><a href="#Desinstancesdeclassesdetypes">Des instances de classes de types</a><br/><a href="#ModulesIOetcompilation">Modules, IO et compilation</a><br/><a href="#Crerdesmodules">Créer des modules</a><br/><a href="#Entresetsorties">Entrées et sorties</a><br/><a href="#Plusdefonctionscompilation">Plus de fonctions, compilation</a><br/><a href="#Programmezavecdeseffets">Programmez avec des effets</a><br/><a href="#Lesfoncteurs">Les foncteurs</a><br/><a href="#Appliquezdesfonctionslesfoncteursapplicatifs">Appliquez des fonctions : les foncteurs applicatifs</a><br/></div>
<a name="ApprenezlaprogrammationfonctionnelleavecHaskell"></a><h2>Apprenez la programmation fonctionnelle avec Haskell</h2><div class="content" role="article">
<p id="r-420436" data-claire-element-id="420436">Ce tuto a pour but de vous apprendre à programmer en Haskell, un langage fonctionnel pur, avec un modèle d'évaluation paresseuse par défaut, typé statiquement (avec de l'inférence de types).<br/> Si vous ne savez pas ce qu'est Haskell, ou pourquoi apprendre à programmer dans ce langage, je vous conseille de passer directement au premier chapitre, qui répond à toutes ces questions.<br/> Pour pouvoir suivre ce tuto, il n'est pas nécessaire d'avoir un niveau exceptionnel en programmation (même si ça ne peut qu'aider), mais il est conseillé de savoir faire un peu plus qu'un Hello World dans un autre langage (au niveau des connaissances, la partie I du cours de C sur le site du zéro devrait vous suffire).<br/> Ne soyez pas effrayés par les chapitres qui peuvent parfois paraître un peu long, il est parfaitement possible de les lire en plusieurs fois.</p><p id="r-420437" data-claire-element-id="420437">Si vous avez des remarques, n'hésitez pas à laisser des commentaires, ils seront pris en compte pour la version suivante.</p>
</div>
<div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1358423835269-0" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1358423835269-0');
        });
    }
    </script>
</div><a name="HaskellC039estquoi"></a><h2>Haskell ? C&#039;est quoi ?</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
<span class="next">Pourquoi apprendre Haskell ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-420438" data-claire-element-id="420438">Ce premier chapitre s'attaque à deux questions importantes.</p><p id="r-420439" data-claire-element-id="420439">Dans la première partie, vous verrez pourquoi vous devriez apprendre à programmer en Haskell. Cette partie introduit beaucoup de concepts pas forcément simples à expliquer et que vous ne comprendrez peut-être pas du premier coup. Ce n'est pas grave : ils seront réexpliqués au fur et à mesure du tutoriel. La deuxième partie va vous donner quelques exemples de programmes codés en Haskell.<br/> Ensuite, il vous faut quelques outils pour programmer en Haskell : c'est le sujet de la troisième partie.</p>
</div><a name="PourquoiapprendreHaskell"></a><h2>Pourquoi apprendre Haskell ?</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">
<span class="arrow"></span>
<span class="next">Haskell ? C&#039;est quoi ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
<span class="next">Qu&#039;est-ce qu&#039;on peut faire en Haskell ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-pourquoi-apprendre-haskell" data-claire-element-id="420446">Pourquoi apprendre Haskell ?</h4><p id="r-420440" data-claire-element-id="420440">Haskell est un langage différent des autres : voici quelques-unes de ses particularités.</p><p id="r-420441" data-claire-element-id="420441">Haskell est un langage <strong>statiquement typé</strong> : les types sont déterminés à la compilation, et le compilateur détecte les erreurs de type. Si vous additionnez une chaîne de caractères et un entier, le compilateur refusera de continuer. Plutôt que d'avoir à écrire les types de chaque variable, Haskell utilise l'<strong>inférence de types</strong> : le compilateur détermine tout seul le type des fonctions, variables et arguments. Cela permet de profiter de la sécurité donnée par le typage statique sans avoir à se fatiguer à écrire des types partout (il est quand même conseillé d'en indiquer quelques-uns, puisqu'ils peuvent aider à comprendre le code). Le système de types du langage est plutôt puissant : on peut s'en servir pour garantir certaines propriétés, par exemple qu'un programme ne renverra jamais d'informations secrètes au monde extérieur.</p><p id="r-420442" data-claire-element-id="420442">C'est un langage <strong>fonctionnel</strong> : les fonctions sont des valeurs comme les autres, qu'on peut prendre en arguments, renvoyer ou appliquer partiellement. Plutôt que de penser un programme comme une suite d'instructions à appliquer les unes à la suite des autres, on essaye de l'exprimer comme des transformations à appliquer aux données en entrées. On peut créer des transformations plus complexes en appliquant une fonction à une autre fonction.</p><p id="r-420443" data-claire-element-id="420443">Les fonctions sont toutes <strong>pures</strong> : elles ne peuvent pas modifier l'environnement extérieur à la fonction, et doivent toujours renvoyer le même résultat si on leur donne les mêmes arguments. Les variables ne sont pas modifiables, ce qui fait qu'on ne peut pas programmer de manière impérative, avec des boucles dans lesquelles on modifie des variables. Cela n'empêche pas de faire des programmes utiles, mais force juste à les exprimer différemment. Les fonctions qui interagissent avec le monde extérieur ont un type spécial, ce qui fait qu'on ne peut pas les utiliser à la place d'une fonction pure.</p><p id="r-420444" data-claire-element-id="420444">Enfin, c'est un langage <strong>paresseux</strong> : les calculs ne sont effectués que lorsque leur résultat est nécessaire. Cela permet dans certains cas d'exprimer des programmes de façon beaucoup plus simple, par exemple quand on ne sait pas jusqu'où on devrait normalement évaluer les données. Cela permet aussi de créer des fonctions plus génériques, où on n'a pas à se soucier de calculer des résultats non nécessaires à l'opération qu'on veut réellement effectuer : si la fonction est suffisamment paresseuse, ils ne seront pas calculés du tout. On peut manipuler de cette façon des structures de données infinies de la même façon qu'on manipulerait des structures de données finies.</p><p id="r-420445" data-claire-element-id="420445">Tout cela fait de Haskell un langage <strong>intéressant</strong> et <strong>amusant</strong> à apprendre : il est différent de ce que vous avez pu voir jusqu'ici, donc vous allez apprendre beaucoup de choses nouvelles, que, même si vous ne programmez pas tous les jours en Haskell, vous pourrez utiliser pour mieux programmer dans votre langage préféré. D'ailleurs, certains langages intègrent maintenant des concepts empruntés à la programmation fonctionnelle.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">
<span class="arrow"></span>
<span class="next">Haskell ? C&#039;est quoi ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
<span class="next">Qu&#039;est-ce qu&#039;on peut faire en Haskell ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Qu039est-cequ039onpeutfaireenHaskell"></a><h2>Qu&#039;est-ce qu&#039;on peut faire en Haskell ?</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
<span class="arrow"></span>
<span class="next">Pourquoi apprendre Haskell ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
<span class="next">Téléchargez et installez un compilateur</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-qu-est-ce-qu-on-peut-faire-en-haskell" data-claire-element-id="420473">Qu'est-ce qu'on peut faire en Haskell ?</h4><p id="r-420447" data-claire-element-id="420447">Vous vous demandez maintenant après cette présentation quel genre de programmes on peut faire en Haskell. En fait, on peut à peu près faire tout ce qu'on peut faire dans un autre langage, mais ce chapitre va vous montrer quelques exemples.</p><h5 id="r-jeux-et-interface-graphique" data-claire-element-id="420458">Jeux et interface graphique</h5><h6 id="r-frag-un-fps-en-3d" data-claire-element-id="420452">Frag, un FPS en 3D</h6><p id="r-420448" data-claire-element-id="420448">En Haskell, on peut faire des jeux vidéo (même si, comme dans tous les langages, ça peut devenir compliqué) : Frag est un jeu de tir à la première personne en 3D, utilisant OpenGL pour les graphismes, capable de charger des niveaux au format Quake3. Pour plus de détails, vous pouvez lire la page dédiée sur le wiki haskell : <a href="http://www.haskell.org/haskellwiki/Frag">Frag</a>. Voilà une capture d'écran :</p><figure id="r-420450" data-claire-element-id="420451"><img id="r-420449" data-claire-element-id="420449" src="medias/uploads.siteduzero.com_files_199001_200000_199380.png" alt="Image utilisateur"/></figure><h6 id="r-xmonad-un-gestionnaire-de-fenetres" data-claire-element-id="420457">xmonad, un gestionnaire de fenêtres</h6><p id="r-420453" data-claire-element-id="420456"><a href="http://xmonad.org/">xmonad</a> est un gestionnaire de fenêtre (ou WM) X11 (donc pour Linux et autres). C'est un programme qui se charge de placer les fenêtres au bon endroit à l'écran. Cependant, xmonad à la particularité d'être un <em>tiling wm</em> : par défaut, il organise les fenêtres de telle façon qu'elles occupent tout l'espace de l'écran et ne se recouvrent pas (cependant, certains modes permettent d'arranger les fenêtres différemment). Il est très léger, mais très configurable : le fichier de configuration est écrit en haskell. Il est aussi extensible, avec de nombreux modes de placement des fenêtres, et gère les écrans multiples.<a href="medias/uploads.siteduzero.com_files_199001_200000_199384.jpg"><img id="r-420454" data-claire-element-id="420453" src="medias/uploads.siteduzero.com_thb_199001_200000_199384.jpg" alt="Image utilisateur"/></a><a href="medias/uploads.siteduzero.com_files_199001_200000_199386.png"><img id="r-420455" data-claire-element-id="420454" src="medias/uploads.siteduzero.com_thb_199001_200000_199386.png" alt="Image utilisateur"/></a><a href="medias/uploads.siteduzero.com_files_199001_200000_199383.png"><img id="r-420456" data-claire-element-id="420455" src="medias/uploads.siteduzero.com_thb_199001_200000_199383.png" alt="Image utilisateur"/></a></p><h5 id="r-outils-pour-developpeurs" data-claire-element-id="420460">Outils pour développeurs</h5><p id="r-420459" data-claire-element-id="420459">GHC, le principal compilateur Haskell, est écrit en Haskell, mais c'est aussi le cas de la plupart des autres compilateurs pour Haskell. <a href="http://en.wikipedia.org/wiki/Pugs">Pugs</a>, un interpréteur et compilateur pour Perl 6, a aussi été codé en Haskell.<br/><a href="http://darcs.net/">darcs</a>, un logiciel de gestion de version distribué, est aussi codé en haskell.</p><h5 id="r-et-plus-encore" data-claire-element-id="420472">Et plus encore !</h5><h6 id="r-plein-d-autres-choses" data-claire-element-id="420469">Plein d'autres choses</h6><p id="r-420461" data-claire-element-id="420461">Il aussi possible de faire beaucoup d'autres choses, parmi lesquelles :</p><ul id="r-420468" data-claire-element-id="420468"><li id="r-420463" data-claire-element-id="420463"><p id="r-420462" data-claire-element-id="420462"><a href="http://www.haskell.org/haskellwiki/Lambdabot">lambdabot</a>, un bot irc utilisé sur le <a href="http://www.haskell.org/haskellwiki/IRC_channel">canal irc #haskell</a></p></li><li id="r-420465" data-claire-element-id="420465"><p id="r-420464" data-claire-element-id="420464"><a href="http://www.haskell.org/haskellwiki/Yi">Yi</a>, un éditeur de texte</p></li><li id="r-420467" data-claire-element-id="420467"><p id="r-420466" data-claire-element-id="420466"><a href="http://www.haskell.org/haskellwiki/Leksah">leksah</a>, IDE en Haskell</p></li></ul><h6 id="r-de-nombreuses-bibliotheques" data-claire-element-id="420471">De nombreuses bibliothèques</h6><p id="r-420470" data-claire-element-id="420470">Il y a aussi de nombreuses bibliothèques en Haskell, qui permettent de ne pas avoir à réinventer la roue pour coder quelque chose de simple et de faire beaucoup de choses : des applications web, de la musique, du traitement d'images, manipuler du XML, de la cryptographie, des mathématiques et beaucoup d'autres choses.<br/> Vous pouvez voir une liste de bibliothèques et d'applications disponibles en Haskell sur <a href="http://hackage.haskell.org/packages/archive/pkg-list.html">hackage</a>.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
<span class="arrow"></span>
<span class="next">Pourquoi apprendre Haskell ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
<span class="next">Téléchargez et installez un compilateur</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Tlchargezetinstallezuncompilateur"></a><h2>Téléchargez et installez un compilateur</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
<span class="arrow"></span>
<span class="next">Qu&#039;est-ce qu&#039;on peut faire en Haskell ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">
<span class="next">Découvrez le langage avec ghci</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-telechargez-et-installez-un-compilateur" data-claire-element-id="420482">Téléchargez et installez un compilateur</h4><h5 id="r-choix-d-un-compilateur" data-claire-element-id="420475">Choix d'un compilateur</h5><p id="r-420474" data-claire-element-id="420474">Il existe de nombreux interpréteurs et compilateurs pour Haskell. Vous pouvez trouver une liste (pas forcément complète) sur <a href="http://www.haskell.org/haskellwiki/Implementations">la page Implementations du wiki Haskell</a>.<br/> Ce tutoriel vous apprendra à vous servir de GHC : c'est un compilateur qui produit du code rapide, et qui supporte un grand nombre d'extensions au langage. Si vous souhaitez vous renseigner sur GHC, lire la documentation, voir si de nouvelles versions sont sorties ou comment le compilateur évolue, rendez-vous sur <a href="http://haskell.org/ghc/">le site officiel de GHC</a>. <br/> Pour permettre d'installer plus facilement GHC et un certain nombre de bibliothèques et d'outils utiles, un paquet unique, appelé <a href="http://hackage.haskell.org/platform/">Haskell Platform</a> a été créé.</p><h5 id="r-installation-53" data-claire-element-id="420481">Installation</h5><h6 id="r-sous-windows-et-mac-os-x" data-claire-element-id="420477">Sous Windows et Mac OS X</h6><p id="r-420476" data-claire-element-id="420476">Sous Windows et Mac OS X, l'installation est simple : allez sur le site de <a href="http://hackage.haskell.org/platform/">Haskell Platform</a>, téléchargez l'installateur pour votre système et lancez-le. Voilà, vous êtes prêts pour la suite de ce tuto.</p><h6 id="r-sous-linux-et-autres-systemes-unix" data-claire-element-id="420480">Sous Linux et autres systèmes Unix</h6><p id="r-420478" data-claire-element-id="420478">Rendez-vous sur le site de <a href="http://hackage.haskell.org/platform/">Haskell Platform</a>. Si vous avez de la chance, votre distribution fournit un paquet pour la plateforme. Cliquez donc sur le lien correspondant à votre distribution pour suivre les instructions d'installation.<br/> Si votre distribution ne fournit pas de paquet, vous devrez installer la plateforme vous-même. Pour cela, commencez par installer la dernière version de GHC (le mieux est d'utiliser les paquets de votre distribution, la compilation de GHC est assez longue), puis téléchargez le tarball des sources de Haskell Platform sur la même page et suivez les instructions.</p><p id="r-420479" data-claire-element-id="420479">Maintenant que vous avez installé les outils nécessaires pour programmer, on peut commencer. Dans le chapitre suivant, vous allez commencer à écrire du code !</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
<span class="arrow"></span>
<span class="next">Qu&#039;est-ce qu&#039;on peut faire en Haskell ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">
<span class="next">Découvrez le langage avec ghci</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Dcouvrezlelangageavecghci"></a><h2>Découvrez le langage avec ghci</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
<span class="arrow"></span>
<span class="next">Téléchargez et installez un compilateur</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
<span class="next">Une calculatrice</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-420484" data-claire-element-id="420484">Dans ce chapitre, vous allez découvrir les bases de la syntaxe du langage. <br/> Pour ce faire, nous utiliserons le mode interactif de GHC, ghci.</p><p id="r-420485" data-claire-element-id="420485">Pour lancer ghci, ouvrez une console et tapez &quot;ghci&quot;.<br/> Vous devriez voir apparaître un message qui ressemble à celui-ci :</p><pre id="r-420486" data-claire-element-id="420486"><code data-claire-semantic="console">GHCi, version 6.10.2: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer ... linking ... done.
Loading package base ... linking ... done.
Prelude&gt;</code></pre>
</div><a name="Unecalculatrice"></a><h2>Une calculatrice</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">
<span class="arrow"></span>
<span class="next">Découvrez le langage avec ghci</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
<span class="next">Utiliser des fonctions</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-une-calculatrice" data-claire-element-id="420536">Une calculatrice</h4><h5 id="r-premiers-calculs" data-claire-element-id="420508">Premiers calculs</h5><p id="r-420487" data-claire-element-id="420487">La ligne se terminant par &gt; (ici <code data-claire-semantic="console">Prelude&gt;</code>) signale que ghci attend une instruction.</p><h6 id="r-operations-de-base-3" data-claire-element-id="420496">Opérations de base</h6><p id="r-420488" data-claire-element-id="420488">Tapez alors votre première <em>expression</em> :</p><pre id="r-420489" data-claire-element-id="420489"><code data-claire-semantic="console">Prelude&gt; 3 + 5
8</code></pre><p id="r-420490" data-claire-element-id="420490">ghci a <em>évalué</em> l'expression, et affiche son résultat</p><p id="r-420491" data-claire-element-id="420491">Vous pouvez essayer d'autres expressions avec des entiers, ou des nombres à virgule :</p><pre id="r-420492" data-claire-element-id="420492"><code data-claire-semantic="console">Prelude&gt; 12*30
360
Prelude&gt; 1
1
Prelude&gt; 12-3
9
Prelude&gt; 2^12
4096
Prelude&gt; 4/2
2.0</code></pre><p id="r-420493" data-claire-element-id="420493">Le symbole ^ permet d'élever un nombre à une puissance entière. Utilisez ** pour une puissance non-entière.</p><p id="r-420494" data-claire-element-id="420494">Les priorités normales des opérations mathématiques sont respectées. On peut aussi mettre des parenthèses :</p><pre id="r-420495" data-claire-element-id="420495"><code data-claire-semantic="console">Prelude&gt; 3+2*5+7
20
Prelude&gt; (3+2)*(5+7)
60</code></pre><h6 id="r-nombres-negatifs-nombres-reels-et-grands-nombres" data-claire-element-id="420507">Nombres négatifs, nombres réels, et grands nombres</h6><p id="r-420497" data-claire-element-id="420497">Les nombres à virgule se notent avec un . :</p><pre id="r-420498" data-claire-element-id="420498"><code data-claire-semantic="console">Prelude&gt;3.7 * 4.4
16.28
Prelude&gt; 1/2
0.5</code></pre><p id="r-420499" data-claire-element-id="420499">On note les nombres négatifs en mettant un - devant. Cependant, il y a quelques subtilités.</p><pre id="r-420500" data-claire-element-id="420500"><code data-claire-semantic="console">Prelude&gt; -3
-3
Prelude&gt; -3 + 4
1
Prelude&gt; 4 + -3
&lt;interactive&gt;:1:0:
    Precedence parsing error
        cannot mix `+' [infixl 6] and prefix `-' [infixl 6] in the same infix expression</code></pre><p id="r-420501" data-claire-element-id="420501">Le problème, c'est que - peut aussi servir pour faire des soustractions, et dans un cas comme ça, ghci n'arrive pas à déterminer si - est utilisé pour noter un nombre négatif ou pour noter une soustraction. La solution, c'est de mettre -3 entre parenthèses, comme ceci :</p><pre id="r-420502" data-claire-element-id="420502"><code data-claire-semantic="console">Prelude&gt; 4 + (-3)
1</code></pre><p id="r-420503" data-claire-element-id="420503">Ces parenthèses seront obligatoires dans la plupart des cas, si vous obtenez des erreurs bizarres, c'est peut-être que vous les avez oubliées.</p><p id="r-420504" data-claire-element-id="420504">Et finalement, une fonctionnalité intéressante : Haskell supporte les entiers aussi grands que l'on veut. On peut donc écrire quelque chose comme :</p><pre id="r-420505" data-claire-element-id="420505"><code data-claire-semantic="console">Prelude&gt; 2^4096
10443888814131525[...]4190336</code></pre><p id="r-420506" data-claire-element-id="420506">J'ai coupé les chiffres du résultat, mais vous pouvez essayer ça chez vous.</p><h5 id="r-des-noms-pour-les-resultats-intermediaires" data-claire-element-id="420535">Des noms pour les résultats intermédiaires</h5><h6 id="r-motivation-eviter-les-repetitions" data-claire-element-id="420519">Motivation : éviter les répétitions</h6><p id="r-420509" data-claire-element-id="420509">On va maintenant calculer le périmètre d'un cercle. Pour ceux qui ne le savent pas, il est égal à 2{\pi}r, où r est le rayon du cercle.<br/> Et \pi vaut environ 3.141592653589793.<br/> On va donc calculer le périmètre pour un cercle de rayon r égal à 1.</p><pre id="r-420510" data-claire-element-id="420510"><code data-claire-semantic="console">Prelude&gt; 2 * 3.141592653589793 * 1
6.283185307179586</code></pre><p id="r-420511" data-claire-element-id="420511">Puis on va recommencer pour des cercles de rayons 2,3,4,5,...</p><pre id="r-420512" data-claire-element-id="420512"><code data-claire-semantic="console">Prelude&gt; 2 * 3.141592653589793 * 2
12.566370614359172
Prelude&gt; 2 * 3.141592653589793 * 3
18.84955592153876</code></pre><p id="r-420513" data-claire-element-id="420513">Et ainsi de suite. Mais l'ordinateur n'est pas une simple calculatrice et on peut faire bien mieux. De plus, les programmeurs détestent la répétition, pour tout un tas de raisons (dont la paresse).<br/> Ici, ce qu'on n'arrête pas de répéter, c'est la valeur de \pi. Il faudrait donc un moyen de dire «à chaque fois que je dis pi, remplace par 3.141592653589793».</p><p id="r-420514" data-claire-element-id="420514">Pour cela on va utiliser ce qu'on appelle des variables.<br/> Dans ghci, on les déclare comme ceci : <code data-claire-semantic="haskell">let nom = valeur </code>. Ensuite, pour l'utiliser, il suffit d'écrire son nom, et il sera remplacé par sa valeur.</p><p id="r-420515" data-claire-element-id="420515">Par exemple :</p><pre id="r-420516" data-claire-element-id="420516"><code data-claire-semantic="console">Prelude&gt; let pi = 3.141592653589793
Prelude&gt; 2 * pi * 1
6.283185307179586
Prelude&gt; 2 * 3.141592653589793 *1
6.283185307179586</code></pre><p id="r-420517" data-claire-element-id="420517">On retrouve bien le même résultat.</p><p id="r-420518" data-claire-element-id="420518">Les noms de variables sont sensibles à la casse : valeurpi et valeurPi sont des variables différentes. Un nom de variable doit commencer par une lettre minuscule.</p><h6 id="r-ne-pas-repeter-les-calculs" data-claire-element-id="420526">Ne pas répéter les calculs</h6><p id="r-420520" data-claire-element-id="420520">L'autre intérêt des variables, c'est de ne pas avoir à répéter les calculs.<br/> Imaginons que j'ai un nombre x, et que je veux calculer x(x+1).</p><pre id="r-420521" data-claire-element-id="420521"><code data-claire-semantic="console">Prelude&gt; 3 * (3 + 1)
12</code></pre><p id="r-420522" data-claire-element-id="420522">Maintenant, on prend x = 2\pi.</p><pre id="r-420523" data-claire-element-id="420523"><code data-claire-semantic="console">Prelude&gt; (2*pi)*((2*pi)+1
45.76160291153702</code></pre><p id="r-420524" data-claire-element-id="420524">En regardant cette ligne, on se rend compte que <code data-claire-semantic="haskell">2*pi </code> est calculé deux fois. Évidemment, ce n'est pas un calcul très long. Mais si on faisait la même chose avec un calcul qui prend 2 heures, vous seriez contents de ne pas devoir attendre 2 heures de trop.<br/> La solution est de déclarer une variable : le compilateur pourrait simplement remplacer le nom d'une variable par son expression (le calcul qui donne la valeur de la variable), mais on se rend compte que ce n'est pas le plus efficace si la variable est utilisée plusieurs fois : il faudrait refaire le calcul à chaque utilisation. C'est pourquoi il fait en sorte que la valeur de la variable ne soit calculée qu'une seule fois.<br/> Ce code donne le même résultat, mais évite les calculs superflus :</p><pre id="r-420525" data-claire-element-id="420525"><code data-claire-semantic="console">Prelude&gt; let x = 2*pi
Prelude&gt; x*(x+1)
45.76160291153702</code></pre><h6 id="r-don-t-panic" data-claire-element-id="420534">Don't panic</h6><p id="r-420527" data-claire-element-id="420527">Si vous êtes arrivés jusqu'ici, vous avez peut-être essayé un code comme celui-ci:</p><pre id="r-420528" data-claire-element-id="420528"><code data-claire-semantic="console">Prelude&gt; let r=5
Prelude&gt; 2*pi*r
&lt;interactive&gt;:1:5:
    Couldn't match expected type `Double'
           against inferred type `Integer'
    In the second argument of `(*)', namely `r'
    In the expression: 2 * pi * r
    In the definition of `it': it = 2 * pi * r</code></pre><p id="r-420529" data-claire-element-id="420529">Ou celui-ci si vous utilisez la définition de pi intégrée au Prelude :</p><pre id="r-420530" data-claire-element-id="420530"><code data-claire-semantic="console">Prelude&gt; let r=5
Prelude&gt; 2*pi*r
&lt;interactive&gt;:1:2:
    No instance for (Floating Integer)
      arising from a use of `pi' at &lt;interactive&gt;:1:2-3
    Possible fix: add an instance declaration for (Floating Integer)
    In the second argument of `(*)', namely `pi'
    In the first argument of `(*)', namely `2 * pi'
    In the expression: 2 * pi * r</code></pre><p id="r-420531" data-claire-element-id="420531">Ces deux messages effrayants (toutes les erreurs de ghc sont comme ça, il faudra vous y habituer) indiquent une erreur de type. Pourtant, vous multipliez un nombre par un nombre, et si vous remplacez les variables par leur valeur, vous n'obtenez pas d'erreur. Quel est le problème alors ?<br/> Il vient de l'interaction entre une limitation du langage introduite pour des raisons de performances et ghci. En gros, quand on entre un nombre, ghc peut le comprendre comme un nombre décimal ou un nombre entier. Quand on entre une expression comme <code data-claire-semantic="haskell">pi * 5 </code>, ghci comprend que 5 doit être vu comme un nombre décimal, mais quand on écrit <code data-claire-semantic="haskell">let r = 5 </code>, le compilateur ne sait pas encore comment r va être utilisé, et décide donc par défaut que r sera un entier. Le problème est qu'on ne peut multiplier que des nombres du même type, et qu'il n'y a pas de conversions implicite entre les types de nombres. On peut régler le problème en forçant r à être un nombre décimal :</p><pre id="r-420532" data-claire-element-id="420532"><code data-claire-semantic="console">Prelude&gt; let r=5.0</code></pre><p id="r-420533" data-claire-element-id="420533">Le problème est légèrement plus compliqué, comme vous le verrez dans le chapitre sur les types.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">
<span class="arrow"></span>
<span class="next">Découvrez le langage avec ghci</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
<span class="next">Utiliser des fonctions</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Utiliserdesfonctions"></a><h2>Utiliser des fonctions</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
<span class="arrow"></span>
<span class="next">Une calculatrice</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
<span class="next">Listes, chaînes de caractères</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-utiliser-des-fonctions" data-claire-element-id="420546">Utiliser des fonctions</h4><h5 id="r-appeler-une-fonction-5" data-claire-element-id="420542">Appeler une fonction</h5><h6 id="r-un-exemple-14" data-claire-element-id="420539">Un exemple</h6><p id="r-420537" data-claire-element-id="420537">Pour prendre la valeur absolue d'un nombre, il n'y a pas d'opérateur. Par contre, dans le Prelude (c'est le module chargé par défaut en Haskell, qui contient les fonctions et les types de base), il y a une fonction abs qui prend un argument et renvoie sa valeur absolue. Pour appeler une fonction à un argument, il suffit d'écrire le nom de la fonction, puis l'argument, le tout séparé par un espace.<br/> Par exemple, <code data-claire-semantic="haskell">abs 5 </code> donne 5, <code data-claire-semantic="haskell">abs (-5) </code> donne 5, et <code data-claire-semantic="haskell">abs (1-3) </code> donne 2. <br/>max est une fonction à deux arguments qui renvoie le plus grand de ses deux arguments (min renvoie le plus petit). On l'appelle comme ceci : <code data-claire-semantic="haskell">max 5 3 </code> donne 5.<br/> La syntaxe générale pour appeler une fonction est la suivante : <code data-claire-semantic="haskell">fonction argument_1 argument_2 ... argument_n </code>.</p><p id="r-420538" data-claire-element-id="420538">Une expression comme <code data-claire-semantic="haskell">abs 15 + 1 </code> est interprétée comme <code data-claire-semantic="haskell">(abs 15) + 1 </code>. Si vous voulez calculer <code data-claire-semantic="haskell">abs 16 </code>, il faut mettre des parenthèses autour de l'argument, comme ceci : <code data-claire-semantic="haskell">abs (15 + 1) </code> (cela se produit avec tous les opérateurs).</p><h6 id="r-les-operateurs-sont-aussi-des-fonctions-et-inversement" data-claire-element-id="420541">Les opérateurs sont aussi des fonctions (et inversement)</h6><p id="r-420540" data-claire-element-id="420540">La fonction mod permet de trouver le reste de la division euclidienne d'un entier par un autre. Par exemple, <code data-claire-semantic="haskell">mod 42 5 </code> donne 2. On pourra préférer une notation <em>infixe</em>, comme 42 mod 5. Cependant, si on fait ça, le compilateur va penser qu'on veut appliquer la fonction 42 à mod et 5, et comme 42 n'est pas une fonction mais un nombre, ça ne va pas marcher. Mais le langage fournit un mécanisme pour régler ce problème : pour utiliser une fonction en notation infixe (comme un opérateur), il suffit d'entourer son nom avec des accents graves (`, AltGr+7 sur un clavier azerty). Le code suivant donne bien ce que l'on cherche : <code data-claire-semantic="haskell">42 `mod` 5 </code>. Une autre fonction que vous aimeriez peut-être utiliser en notation infixe est la fonction div, qui donne le quotient de la division euclidienne.<br/> Si les fonctions sont des opérateurs, les opérateurs sont aussi... des fonctions ! En effet, pour utiliser un opérateur en position <em>préfixe</em>, il suffit d'entourer son nom avec des parenthèses. Par exemple, ces deux codes sont équivalents : <code data-claire-semantic="haskell">1 + 2 </code> et <code data-claire-semantic="haskell">(+) 1 2 </code>. Les opérateurs ne sont donc pas des objets à part, impossibles à manipuler et à transformer, mais bien des fonctions comme les autres. On peut donc en définir (vous verrez comment au prochain chapitre), et les manipuler exactement de la même manière que les fonctions, ce qui nous facilitera grandement la vie quand nous utiliserons des fonctions d'ordre supérieur, qui prennent d'autres fonctions comme arguments.</p><h5 id="r-paires" data-claire-element-id="420545">Paires</h5><p id="r-420543" data-claire-element-id="420543">Les paires sont une façon de stocker deux valeurs en même temps. Il n'y a pas grand-chose à savoir : pour noter les paires, on écrit entre parenthèses les deux valeurs séparées par une virgule, comme ceci : <code data-claire-semantic="haskell">(5,12) </code>. Les deux éléments de la paire peuvent être de types différents. Ils peuvent même être des paires ! Par exemple, <code data-claire-semantic="haskell">(5,(6,7)) </code> est aussi une paire, dont le premier élément est 5 et dont le second élément est une paire.<br/> Les fonctions fst et snd permettent d'obtenir respectivement les premiers et deuxièmes éléments d'une paire. Un exemple :</p><pre id="r-420544" data-claire-element-id="420544"><code data-claire-semantic="console">Prelude&gt; let paire = (5,(6,7))
Prelude&gt; snd paire
(6,7)
Prelude&gt; fst (snd paire) + snd (snd paire)
13</code></pre>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
<span class="arrow"></span>
<span class="next">Une calculatrice</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
<span class="next">Listes, chaînes de caractères</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Listeschanesdecaractres"></a><h2>Listes, chaînes de caractères</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
<span class="arrow"></span>
<span class="next">Utiliser des fonctions</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">
<span class="next">Définir des fonctions</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-listes-chaines-de-caracteres" data-claire-element-id="420596">Listes, chaînes de caractères</h4><h5 id="r-listes-3" data-claire-element-id="420586">Listes</h5><p id="r-420547" data-claire-element-id="420547">Les listes permettent de stocker un certain nombre d'éléments du même type. Par exemple, <code data-claire-semantic="haskell">[1,2,3,4,5] </code> est une liste. Comme vous le voyez, les listes sont notées entre crochets, et les éléments sont séparés par des virgules. Par contre, <code data-claire-semantic="haskell">[1,2,(3,4)] </code> n'est pas une liste valide parce que les éléments n'ont pas le même type. Un cas particulier de liste est <code data-claire-semantic="haskell">[] </code>, qui représente la liste vide.</p><h6 id="r-operations-sur-les-listes" data-claire-element-id="420568">Opérations sur les listes</h6><p id="r-420548" data-claire-element-id="420548">Il existe beaucoup de fonctions pour manipuler les listes et toutes les présenter serait beaucoup trop long. Je ne montrerai que les plus importantes.<br/> Pour prendre deux listes et les mettre bout à bout, on utilise l'opérateur de concaténation ++ :</p><pre id="r-420549" data-claire-element-id="420549"><code data-claire-semantic="console">Prelude&gt; [1,2,3] ++ [4,5,6]
[1,2,3,4,5,6]
Prelude&gt; [1,2] ++ [(3,4)]
&lt;interactive&gt;:1:5:
    Couldn't match expected type `Integer'
           against inferred type `(Integer, Integer)'
      Expected type: [Integer]
      Inferred type: [(Integer, Integer)]
    In the second argument of `(++)', namely `b'
    In the expression: a ++ b</code></pre><p id="r-420550" data-claire-element-id="420550">On obtient une erreur dans le deuxième cas, puisque la liste obtenue aurait des éléments de types différents. Attention, ++ n'est pas très efficace : plus la première liste est longue, plus ++ prend de temps. Cela prend beaucoup de temps de rajouter un élément à la fin d'une longue liste. Au contraire, si on ajoute un élément au début de la liste, quelle que soit la liste, l'opération est instantanée. On pourrait écrire <code data-claire-semantic="haskell">[0]++[1,2,3] </code>, mais il existe un opérateur exprès pour ça : :. Cet opérateur, parfois appelé <em>cons</em> permet d'ajouter un élément au début de la liste. C'est l'opération de base permettant de construire une liste, toutes les autres opérations qui créent une liste l'utilisent. cons ne copie pas la liste devant laquelle on rajoute un élément, mais puisqu'on ne peut pas la modifier, vous ne vous en rendrez pas compte. Cependant, c'est ça qui lui permet d'être si rapide.</p><pre id="r-420551" data-claire-element-id="420551"><code data-claire-semantic="console">Prelude&gt; 0:[1,2,3]
[0,1,2,3]
Prelude&gt; 0:1:2:3:[]
[0,1,2,3]</code></pre><p id="r-420552" data-claire-element-id="420552">Le deuxième exemple montre que l'on peut toujours écrire une liste à partir de : et de la liste vide. D'ailleurs, noter une liste entre crochets, comme <code data-claire-semantic="haskell">[1,2,3] </code>, est seulement un raccourci pour cette notation.</p><p id="r-420553" data-claire-element-id="420553">head et tail sont les opérations inverses de cons : head donne le premier élément d'une liste, et tail la liste à laquelle on a retiré ce premier élément. Comme cons, ces opérations sont instantanées et ne demandent pas de copier la liste.</p><pre id="r-420554" data-claire-element-id="420554"><code data-claire-semantic="console">Prelude&gt; let xs = [0,1,2,3]
Prelude&gt; head xs
0
Prelude&gt; tail xs
[1,2,3]
Prelude&gt; head xs:tail xs
[0,1,2,3]
Prelude&gt; head []
*** Exception: Prelude.head: empty list
Prelude&gt; tail []
*** Exception: Prelude.tail: empty list</code></pre><p id="r-420555" data-claire-element-id="420555">Comme vous le voyez, head et tail renvoient une erreur quand la liste est vide, puisqu'une liste vide n'a pas de premier élément.</p><p id="r-420556" data-claire-element-id="420556">Si on veut prendre un élément particulier d'une liste, on peut utiliser l'opérateur !!. <code data-claire-semantic="haskell">liste !! n </code> donne l'élément de rang n de la liste (les éléments sont numérotés à partir de 0). Si la liste n'a pas d'élément de rang n, on obtient une erreur.</p><pre id="r-420557" data-claire-element-id="420557"><code data-claire-semantic="console">Prelude&gt; [1,2,3] !! 0
1
Prelude&gt; [1,2,3] !! 3
*** Exception: Prelude.(!!): index too large</code></pre><p id="r-420558" data-claire-element-id="420558">Les fonctions take et drop permettent respectivement de prendre les n premiers éléments de la liste, et la liste à laquelle on a enlevé les n premiers éléments. Ces fonctions ne renvoient pas d'erreur quand n est trop grand.</p><pre id="r-420559" data-claire-element-id="420559"><code data-claire-semantic="console">Prelude&gt; let xs =  [1,2,3,4,5]
Prelude&gt; take 2 xs
[1,2]
Prelude&gt; drop 2 xs
[3,4,5]
Prelude&gt; take 100 xs
[1,2,3,4,5]
Prelude&gt; drop 100 xs
[]</code></pre><p id="r-420560" data-claire-element-id="420560">La fonction elem permet de tester si un élément est dans une liste ou non. Elle renvoie True si c'est le cas, False sinon. On l'utilise souvent en notation infixe.</p><pre id="r-420561" data-claire-element-id="420561"><code data-claire-semantic="console">Prelude&gt; 1 `elem` [0,1,2]
True
Prelude&gt; 42 `elem` [1,3,3,7]
False</code></pre><p id="r-420562" data-claire-element-id="420562">Avec reverse, il est possible de renverser l'ordre d'une liste.</p><pre id="r-420563" data-claire-element-id="420563"><code data-claire-semantic="console">Prelude&gt; reverse [1,2,3]
[3,2,1]</code></pre><p id="r-420564" data-claire-element-id="420564">length renvoie la longueur d'une liste. Les fonctions minimum et maximum renvoient, sans surprise, le minimum et le maximum des éléments d'une liste (à condition qu'on puisse les ordonner). Enfin sum et product renvoient respectivement la somme et le produit des éléments d'une liste de nombres. Quelques exemples :</p><pre id="r-420565" data-claire-element-id="420565"><code data-claire-semantic="console">Prelude&gt; let liste = [1,42,47,85,62,31,12,93]
Prelude&gt; length liste
8
Prelude&gt; length []
0
Prelude&gt; maximum liste
93
Prelude&gt; minimum liste
1
Prelude&gt; sum liste
373
Prelude&gt; product liste
359901496080</code></pre><p id="r-420566" data-claire-element-id="420566">Il est aussi possible de créer des listes de listes. Les listes peuvent avoir des longueurs différentes, mais doivent toutes contenir des éléments du même type. Par exemple, <code data-claire-semantic="haskell">[[],[]] </code> est une liste de liste valide, mais <code data-claire-semantic="haskell">[[5,6],[[]]] </code> ne marche pas : le premier élément est une liste d'entiers et le deuxième est une liste de listes. On peut transformer une liste de listes en liste tout court avec la fonction concat :</p><pre id="r-420567" data-claire-element-id="420567"><code data-claire-semantic="console">Prelude&gt; concat [[1,2,3],[4,5,6],[7,8,9]]
[1,2,3,4,5,6,7,8,9]</code></pre><h6 id="r-noter-une-sequence" data-claire-element-id="420577">Noter une séquence</h6><p id="r-420569" data-claire-element-id="420569">Dans les exemples précédents, toutes les listes de nombres ont été entrées à la main. Mais si on voulait la liste des nombres de 1 à 100 ? On pourrait les entrer à la main, mais ce serait bien trop long. Heureusement, Haskell offre une syntaxe spéciale pour les suites arithmétiques.<br/> Pour afficher tous les entiers entre deux entiers donnés, il suffit d'écrire entre crochets le premier nombre, puis le dernier nombre et de mettre deux points entre les deux.</p><pre id="r-420570" data-claire-element-id="420570"><code data-claire-semantic="console">Prelude&gt; [0..10]
[0,1,2,3,4,5,6,7,8,9,10]
Prelude&gt; let n = 42
Prelude [n..n+5]
[42,43,44,45,46,47]</code></pre><p id="r-420571" data-claire-element-id="420571">On peut écrire n'importe quelle suite arithmétique en donnant les deux premiers nombres, puis le dernier. On peut aussi utiliser cette notation quand on veut que les nombres soient dans l'ordre décroissant :</p><pre id="r-420572" data-claire-element-id="420572"><code data-claire-semantic="console">Prelude&gt;[0,2..10]
[0,2,4,6,8,10]
Prelude&gt; [10..0]
[]
Prelude&gt; [10,9..0]
[10,9,8,7,6,5,4,3,2,1,0]</code></pre><p id="r-420573" data-claire-element-id="420573">Cependant, cela ne marche qu'avec les suites arithmétiques. Il y a aussi quelques problèmes avec les nombres à virgules, donc il vaut mieux éviter de les utiliser avec cette notation. Ces problèmes ne sont pas causés par le langage en lui-même, mais par la façon dont les nombres à virgule sont représentés en mémoire. Par exemple :</p><pre id="r-420574" data-claire-element-id="420574"><code data-claire-semantic="console">Prelude&gt; [0.1,0.3..1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]</code></pre><p id="r-420575" data-claire-element-id="420575">On peut bien sûr combiner cette notation avec toutes les fonctions sur les listes. Par exemple, pour calculer 20! (le produit de tous les nombres de 1 à 20), il suffit d'utiliser product :</p><pre id="r-420576" data-claire-element-id="420576"><code data-claire-semantic="console">Prelude&gt; product [1..20]
2432902008176640000</code></pre><h6 id="r-des-listes-infinies" data-claire-element-id="420585">Des listes infinies</h6><p id="r-420578" data-claire-element-id="420578">Que se passe-t-il si on écrit <code data-claire-semantic="haskell">[1..] </code> ? Si on essaye, on obtient</p><pre id="r-420579" data-claire-element-id="420579"><code data-claire-semantic="console">Prelude&gt; [1..]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,Interrupted.</code></pre><p id="r-420580" data-claire-element-id="420580">J'ai appuyé sur Ctrl-C pour l'arrêter, sinon il allait remplir mon écran de chiffres, mais si je l'avais laissé tourner, il aurait affiché la liste des tous les nombres à partir de 1. On peut donc obtenir des listes infinies en Haskell. On peut les manipuler presque comme des listes normales : on peut prendre certains de leurs éléments, ajouter un élément devant, ... En général, on prend la précaution de mettre quelque chose comme <code data-claire-semantic="haskell">take 10 </code> avant d'afficher la liste pour éviter les catastrophes.</p><pre id="r-420581" data-claire-element-id="420581"><code data-claire-semantic="console">Prelude&gt; take 10 [1..]
[1,2,3,4,5,6,7,8,9,10]
Prelude&gt; take 10 (0:[1..])
[0,1,2,3,4,5,6,7,8,9]</code></pre><p id="r-420582" data-claire-element-id="420582">Si on peut faire des listes infinies, c'est grâce à l'évaluation paresseuse : un élément de la liste n'est calculé que lorsqu'il est réellement demandé. Cependant, certaines fonctions comme reverse, minimum et maximum, sum et product ne se terminent pas sur les listes infinies, car elles ont besoin de lire la liste en entier pour pouvoir répondre.</p><p id="r-420583" data-claire-element-id="420583">Quelques autres fonctions permettent de manipuler les listes infinies : cycle répète une liste une infinité de fois, repeat répète seulement un élément. La fonction replicate fait la même chose que repeat, sauf qu'elle prend un argument qui indique combien de fois l'élément doit être répété.</p><pre id="r-420584" data-claire-element-id="420584"><code data-claire-semantic="console">Prelude&gt; take 20 (cycle [0..2])
[0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1]
Prelude&gt; take 20 (repeat 0)
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Prelude&gt; replicate 5 0
[0,0,0,0,0]</code></pre><h5 id="r-chaines-de-caracteres-3" data-claire-element-id="420595">Chaînes de caractères</h5><h6 id="r-notation-1" data-claire-element-id="420588">Notation</h6><p id="r-420587" data-claire-element-id="420587">On note une chaîne de caractères entre guillemets doubles. Par exemple, <code data-claire-semantic="haskell">&quot;Hello World&quot; </code> (essayez d'entrer ça dans ghci). Pour échapper les caractères gênants (comme &quot; et \), on utilise un \. Exemple : <code data-claire-semantic="haskell">&quot;Plein de \&quot; et de \\&quot; </code>.</p><h6 id="r-ce-sont-des-listes" data-claire-element-id="420594">Ce sont des listes !</h6><p id="r-420589" data-claire-element-id="420589">En réalité, les chaînes de caractères sont juste des listes de caractères. Un caractère se note entre apostrophes, par exemple <code data-claire-semantic="haskell">'a' </code>. On peut aussi utiliser des séquences d'échappement quand on note des caractères : <code data-claire-semantic="haskell">' ' </code> représente un retour à la ligne.<br/> Cela veut dire que l'on peut utiliser toutes les opérations disponibles sur les listes sur des chaînes de caractères :</p><pre id="r-420590" data-claire-element-id="420590"><code data-claire-semantic="console">Prelude&gt; 'a':&quot;bcd&quot;
&quot;abcd&quot;
Prelude&gt; &quot;Hello &quot; ++ &quot;World&quot;
&quot;Hello World&quot;
Prelude&gt; reverse &quot;Hello World&quot;
&quot;dlroW olleH&quot;
Prelude&gt; 'a' `elem` &quot;Hello World&quot;
False</code></pre><p id="r-420591" data-claire-element-id="420591">On peut aussi noter des suites de caractères de la même façon que des suites de nombres :</p><pre id="r-420592" data-claire-element-id="420592"><code data-claire-semantic="console">Prelude&gt; ['a'..'z']
&quot;abcdefghijklmnopqrstuvwxyz&quot;
Prelude&gt; ['a','c'..'z']
&quot;acegikmoqsuwy&quot;
Prelude&gt; ['z','y'..'a']
&quot;zyxwvutsrqponmlkjihgfedcba&quot;</code></pre><p id="r-420593" data-claire-element-id="420593">Dans le prochain chapitre, vous allez apprendre à définir des fonctions et comment écrire du code dans un fichier pour l'utiliser dans ghci. Vous verrez aussi beaucoup de points de syntaxe qui n'ont pas été abordés dans ce chapitre.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
<span class="arrow"></span>
<span class="next">Utiliser des fonctions</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">
<span class="next">Définir des fonctions</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Dfinirdesfonctions"></a><h2>Définir des fonctions</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
<span class="arrow"></span>
<span class="next">Listes, chaînes de caractères</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
<span class="next">Déclarations dans un fichier</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-420598" data-claire-element-id="420598">Dans ce chapitre, vous n'allez plus uniquement utiliser ghci : la première partie va vous montrer comment écrire du code dans un fichier, et le charger dans ghci pour tester les fonctions définies dedans. Dans les deux parties suivantes, vous allez découvrir comment utiliser les conditions, mais aussi une technique très utilisée en Haskell : le filtrage de motif.</p>
</div><a name="Dclarationsdansunfichier"></a><h2>Déclarations dans un fichier</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">
<span class="arrow"></span>
<span class="next">Définir des fonctions</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
<span class="next">Conditions et filtrage de motif</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-declarations-dans-un-fichier" data-claire-element-id="420640">Déclarations dans un fichier</h4><h5 id="r-variables-dans-un-fichier-et-chargement" data-claire-element-id="420608">Variables dans un fichier et chargement</h5><p id="r-420599" data-claire-element-id="420599">Créez un fichier nommé declaration.hs avec pour contenu :</p><pre id="r-420600" data-claire-element-id="420600"><code data-claire-semantic="haskell">reponse = 42</code></pre><p id="r-420601" data-claire-element-id="420601">On va maintenant le charger. Pour cela, ouvrez une console, naviguez jusqu'au répertoire où se trouve votre fichier et lancez ghci.</p><pre id="r-420602" data-claire-element-id="420602"><code data-claire-semantic="console">Prelude&gt;:l declaration.hs
[1 of 1] Compiling Main             ( declaration.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; reponse
42</code></pre><p id="r-420603" data-claire-element-id="420603">On a chargé le fichier avec la commande <code data-claire-semantic="console">:l</code>. ghci indique qu'il a réussi à charger le fichier. Maintenant, la variable reponse vaut 42.<br/> Vous l'aurez compris, on déclare une variable comme ceci : <code data-claire-semantic="haskell">nomVariable = valeur </code><br/> Comme quand on définit des variables dans ghci, on peut réutiliser le résultat des calculs précédents.</p><pre id="r-420604" data-claire-element-id="420604"><code data-claire-semantic="haskell">foo = 42
foo = 1337</code></pre><p id="r-420605" data-claire-element-id="420605">Si on définit deux fois une variable, le compilateur se plaint :</p><pre id="r-420606" data-claire-element-id="420606"><code data-claire-semantic="console">Prelude&gt; :l multi.hs
[1 of 1] Compiling Main             ( multi.hs, interpreted )

multi.hs:2:0:
    Multiple declarations of `Main.foo'
    Declared at: multi.hs:1:0
                 multi.hs:2:0
Failed, modules loaded: none.</code></pre><p id="r-420607" data-claire-element-id="420607">ghci indique ici qu'il n'a pas pu charger le fichier car foo est défini deux fois: à la ligne 1 et à la ligne 2.</p><h5 id="r-definir-des-fonctions-simples" data-claire-element-id="420639">Définir des fonctions simples</h5><p id="r-420609" data-claire-element-id="420609">On peut aussi déclarer des fonctions.</p><p id="r-420610" data-claire-element-id="420610">Un exemple vaut mieux qu'un long discours :</p><pre id="r-420611" data-claire-element-id="420611"><code data-claire-semantic="haskell">perimetreCercle r = 2 * pi * r</code></pre><p id="r-420612" data-claire-element-id="420612">Cette ligne de code définit une fonction perimetreCercle, qui prend un argument r, et renvoie <code data-claire-semantic="haskell">2*pi*r </code>.</p><p id="r-420613" data-claire-element-id="420613">Vous pouvez charger ce fichier dans ghci pour tester la fonction :</p><pre id="r-420614" data-claire-element-id="420614"><code data-claire-semantic="console">Prelude&gt; :l fonction
Prelude&gt; perimetreCercle 5
31.41592653589793
Prelude&gt; 2*pi*5
31.41592653589793</code></pre><p id="r-420615" data-claire-element-id="420615">Pour appeler la fonction, on utilise la même syntaxe que pour les fonctions prédéfinies.<br/> Ce qui se passe, c'est que le corps de la fonction est exécuté, avec dans la variable r qui correspond à l'argument la valeur de l'argument donnée quand on appelle la fonction. C'est pour ça que, à la place de <code data-claire-semantic="haskell">perimetreCercle 5 </code>, on aurait très bien pu écrire <code data-claire-semantic="haskell">2*pi*5 </code>.</p><p id="r-420616" data-claire-element-id="420616">Si vous avez déjà programmé dans un langage comme le C, vous remarquerez que la définition d'une fonction en Haskell ressemble plus à la définition d'une fonction en maths qu'à la définition d'une fonction en C.<br/>f(x)=2*\pi*x</p><pre id="r-420617" data-claire-element-id="420617"><code data-claire-semantic="c">double perimetreCercle(double r) {
    return 2*pi*r;
}</code></pre><p id="r-420618" data-claire-element-id="420618">À part les indications de type, la différence principale, c'est qu'une fonction C est une suite d'instructions, alors qu'une fonction Haskell est une expression (un calcul, un appel de fonction, ...), et donc qu'il n'y a pas d'équivalent de return.<br/> D'ailleurs, en Haskell, mettre plusieurs instructions dans une fonction n'aurait aucun sens, puisque les instructions d'avant n'auraient aucune influence sur l'exécution du programme (le seul moyen d'influencer l'exécution du programme serait par des effets de bords, comme la modification d'une variable globale, mais ceux-ci sont interdits en Haskell).</p><p id="r-420619" data-claire-element-id="420619">On peut aussi définir des fonctions prenant plusieurs arguments :</p><pre id="r-420620" data-claire-element-id="420620"><code data-claire-semantic="haskell">perimetreRectangle longueur largeur = 2.0*(longueur+largeur)</code></pre><p id="r-420621" data-claire-element-id="420621">Cette fonction calcule le périmètre d'un rectangle : vous pouvez la tester dans ghci.<br/> On peut aussi réutiliser les fonctions déjà définies. Par exemple, sachant qu'un carré est un rectangle dont les côtés ont même longueur, comment calculeriez-vous le prérimètre d'un carré ?</p><div id="r-420624" data-claire-element-id="420624"><pre id="r-420622" data-claire-element-id="420622"><code data-claire-semantic="haskell">perimetreRectangle longueur largeur = 2.0*(longueur+largeur)
perimetreCarre cote = perimetreRectangle cote cote</code></pre><p id="r-420623" data-claire-element-id="420623">On définit le périmètre d'un carré de côté c comme le périmètre d'un rectangle de longueur c et de largeur c.</p></div><aside id="r-420626" data-claire-element-id="420626" data-claire-semantic="information"><p id="r-420625" data-claire-element-id="420625">Pour recharger un fichier après l'avoir modifié, dans ghci, utilisez la commande <code data-claire-semantic="console">:r</code></p></aside><p id="r-420627" data-claire-element-id="420627">Maintenant, que se passerait-il si on chargeait ce code, où l'ordre des définitions est inversé ?</p><pre id="r-420628" data-claire-element-id="420628"><code data-claire-semantic="haskell">perimetreCarre cote = perimetreRectangle cote cote
perimetreRectangle longueur largeur = 2.0*(longueur+largeur)</code></pre><p id="r-420629" data-claire-element-id="420629">La réponse est : rien. Le compilateur est capable de comprendre les définitions, même si elles font référence à des fonctions définies plus tard dans le fichier. On peut d'ailleurs faire la même expérience avec des variables qui dépendent l'une de l'autre.</p><h6 id="r-commentaires-8" data-claire-element-id="420638">Commentaires</h6><p id="r-420630" data-claire-element-id="420630">Il est souvent utile de commenter son code, pour le rendre plus compréhensible. Deux types de commentaires sont disponibles en Haskell :</p><ul id="r-420637" data-claire-element-id="420637"><li id="r-420633" data-claire-element-id="420633"><p id="r-420631" data-claire-element-id="420631">Les commentaires sur une ligne. Ils commencent par -- et le commentaire continue jusqu'à la fin de la ligne.</p><pre id="r-420632" data-claire-element-id="420632"><code data-claire-semantic="haskell">reponse = 42 -- commentaire à propos de cette déclaration</code></pre></li><li id="r-420636" data-claire-element-id="420636"><p id="r-420634" data-claire-element-id="420634">Les commentaires sur plusieurs lignes. Ils commencent par {- et se terminent par -}. Ils peuvent même être imbriqués :</p><pre id="r-420635" data-claire-element-id="420635"><code data-claire-semantic="haskell">{-
Un commentaire sur plusieurs lignes
-}

variable = &quot;test&quot;

{-
un commentaire {- imbriqué. -} le commentaire continue -}
message = &quot;ceci n'est pas dans un commentaire&quot;</code></pre></li></ul>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">
<span class="arrow"></span>
<span class="next">Définir des fonctions</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
<span class="next">Conditions et filtrage de motif</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Conditionsetfiltragedemotif"></a><h2>Conditions et filtrage de motif</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
<span class="arrow"></span>
<span class="next">Déclarations dans un fichier</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
<span class="next">Plus de filtrage de motif</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-conditions-et-filtrage-de-motif" data-claire-element-id="420787">Conditions et filtrage de motif</h4><p id="r-420641" data-claire-element-id="420641">Cette deuxième partie va vous apprendre à définir des fonctions un peu plus intéressantes.</p><h5 id="r-if-then-else" data-claire-element-id="420720">if/then/else</h5><p id="r-420642" data-claire-element-id="420642">Une construction utile est if. if renvoie le résultat d'une expression ou d'une autre suivant qu'une condition est vraie ou fausse.<br/> Elle s'écrit comme ceci : <code data-claire-semantic="haskell">if condition then expression 1 else expression 2 </code>.</p><p id="r-420643" data-claire-element-id="420643">condition est une expression qui donne un booléen, c'est-à-dire vrai ou faux.<br/> Si la condition vaut True, expression 1 est renvoyée, sinon expression 2 est renvoyée. En pratique, seule l'expression renvoyée est calculée.</p><p id="r-420644" data-claire-element-id="420644">Pour utiliser if, il est donc essentiel de savoir manipuler les booléens. Un booléen a deux valeurs possibles : True (vrai) et False (faux). Les noms sont sensibles à la casse, donc n'oubliez pas la majuscule.</p><h6 id="r-operateurs-de-comparaison-3" data-claire-element-id="420689">Opérateurs de comparaison</h6><p id="r-420645" data-claire-element-id="420645">Dans une condition, ce qui nous intéressera en général, c'est de comparer des objets. Pour cela, il existe des opérateurs de comparaison, qui prennent deux arguments et renvoient un booléen :</p><table id="r-420682" data-claire-element-id="420682"><tbody id="r-420681" data-claire-element-id="420681"><tr id="r-420650" data-claire-element-id="420650"><td id="r-420647" data-claire-element-id="420647"><p id="r-420646" data-claire-element-id="420646">Opérateur</p></td><td id="r-420649" data-claire-element-id="420649"><p id="r-420648" data-claire-element-id="420648">Renvoie True si...</p></td></tr><tr id="r-420655" data-claire-element-id="420655"><td id="r-420652" data-claire-element-id="420652"><p id="r-420651" data-claire-element-id="420651">==</p></td><td id="r-420654" data-claire-element-id="420654"><p id="r-420653" data-claire-element-id="420653">les deux arguments sont égaux</p></td></tr><tr id="r-420660" data-claire-element-id="420660"><td id="r-420657" data-claire-element-id="420657"><p id="r-420656" data-claire-element-id="420656"><strong>/=</strong></p></td><td id="r-420659" data-claire-element-id="420659"><p id="r-420658" data-claire-element-id="420658">les deux arguments sont différents</p></td></tr><tr id="r-420665" data-claire-element-id="420665"><td id="r-420662" data-claire-element-id="420662"><p id="r-420661" data-claire-element-id="420661">&lt;</p></td><td id="r-420664" data-claire-element-id="420664"><p id="r-420663" data-claire-element-id="420663">le premier argument est inférieur au deuxième</p></td></tr><tr id="r-420670" data-claire-element-id="420670"><td id="r-420667" data-claire-element-id="420667"><p id="r-420666" data-claire-element-id="420666">&gt;</p></td><td id="r-420669" data-claire-element-id="420669"><p id="r-420668" data-claire-element-id="420668">le premier argument est supérieur au deuxième</p></td></tr><tr id="r-420675" data-claire-element-id="420675"><td id="r-420672" data-claire-element-id="420672"><p id="r-420671" data-claire-element-id="420671">&lt;=</p></td><td id="r-420674" data-claire-element-id="420674"><p id="r-420673" data-claire-element-id="420673">le premier argument est inférieur ou égal au deuxième</p></td></tr><tr id="r-420680" data-claire-element-id="420680"><td id="r-420677" data-claire-element-id="420677"><p id="r-420676" data-claire-element-id="420676">&gt;=</p></td><td id="r-420679" data-claire-element-id="420679"><p id="r-420678" data-claire-element-id="420678">le premier argument est supérieur ou égal au deuxième</p></td></tr></tbody></table><p id="r-420683" data-claire-element-id="420683">La ligne la plus importante à retenir est celle en gras : on écrit /=, et non pas !=.</p><aside id="r-420685" data-claire-element-id="420685" data-claire-semantic="information"><p id="r-420684" data-claire-element-id="420684">Certaines choses ne sont pas comparables, par exemple les fonctions. On ne peut comparer des paires que si elles sont composées d'éléments comparables.</p></aside><p id="r-420686" data-claire-element-id="420686">Testons ces opérations sur quelques valeurs :</p><pre id="r-420687" data-claire-element-id="420687"><code data-claire-semantic="console">Prelude&gt; 42 == 1337
False
Prelude&gt; 4 &lt; 5
True
Prelude&gt; (2*7+6) &gt;= (7*7-23)
False
Prelude&gt; (1,7,3) == (4,2)
&lt;interactive&gt;:1:11:
    Couldn't match expected type `(t, t1, t2)'
           against inferred type `(t3, t4)'
    In the second argument of `(==)', namely `(4, 2)'
    In the expression: (1, 7, 3) == (4, 2)
    In the definition of `it': it = (1, 7, 3) == (4, 2)</code></pre><p id="r-420688" data-claire-element-id="420688">Comme vous le voyez, on ne peut comparer (même pour l'égalité) que des valeurs du même type.</p><h6 id="r-combiner-des-booleens" data-claire-element-id="420701">Combiner des booléens</h6><p id="r-420690" data-claire-element-id="420690">Quand ces conditions ne sont pas suffisantes, on peut les combiner. Pour cela, on dispose de trois fonctions déjà définies.<br/> La fonction not prend un argument et l'inverse simplement : <code data-claire-semantic="haskell">not False </code> donne True et <code data-claire-semantic="haskell">not True </code> donne False.</p><p id="r-420691" data-claire-element-id="420691">Si on veut que deux conditions soient vraies, on peut utiliser l'opérateur <strong>et</strong>, noté &amp;&amp;. Cet opérateur ne renvoie True que si ses deux arguments sont égaux à True. Par exemple, <code data-claire-semantic="haskell">True &amp;&amp; False </code> donne False, et <code data-claire-semantic="haskell">True &amp;&amp; True </code> donne True.</p><p id="r-420692" data-claire-element-id="420692">Enfin, l'opérateur || (<strong>ou</strong>) permet de tester si au moins une des deux conditions est vraie. Donc, <code data-claire-semantic="haskell">False || False </code> renvoie False, et <code data-claire-semantic="haskell">True || False </code> renvoie True.</p><p id="r-420693" data-claire-element-id="420693">Pour montrer comment fonctionnent ces trois fonctions, on va coder un exemple qui utilise les trois. Le but est de code une fonction &quot;ou exclusif&quot; (ou xor) qui prend deux arguments et renvoie True si un seul de ses arguments vaut True, False sinon.<br/> Vous pouvez essayer de trouver comment le faire vous-même. Si vous ne trouvez pas (ou si vous voulez vérifier votre solution), regardez la solution.</p><div id="r-420696" data-claire-element-id="420696"><div id="r-420695" data-claire-element-id="420695"><p id="r-420694" data-claire-element-id="420694">On va appeler les deux arguments x et y. On se rend compte que <code data-claire-semantic="haskell">xor x y </code> vaut True seulement si deux conditions sont respectées : x ou y doit valoir True (donc <code data-claire-semantic="haskell">x || y </code> doit donner True). De plus, x et y ne doivent pas être tous les deux vrais : <code data-claire-semantic="haskell">x &amp;&amp; y </code> doit donner False, donc <code data-claire-semantic="haskell">not (x &amp;&amp; y) </code> doit donner True.<br/> Finalement, on aboutit à ceci :<br/><code data-claire-semantic="haskell">xor x y = (x || y) &amp;&amp; not (x &amp;&amp; y)</code></p></div></div><aside id="r-420700" data-claire-element-id="420700" data-claire-semantic="information"><p id="r-420697" data-claire-element-id="420697"><strong>Définir des opérateurs:</strong><br/> Appeller une fonction xor dans le code n'est pas toujours très pratique : ça demande plus de parenthèses et on voit moins facilement le sens du code. On pourrait écrire <code data-claire-semantic="haskell">`xor` </code> à la place, mais ça fait quelques caractères en plus. L'autre solution est de définir un opérateur.<br/> Ici, on définit l'opérateur <code data-claire-semantic="haskell">|&amp; </code>, qui fait la même chose que la fonction xor.</p><pre id="r-420698" data-claire-element-id="420698"><code data-claire-semantic="haskell">a |&amp; b = (a || b) &amp;&amp; not (a &amp;&amp; b)
test = True |&amp; False</code></pre><p id="r-420699" data-claire-element-id="420699">Pour définir un opérateur, il faut donc faire comme pour une déclaration de fonction, mais écrire le nom de l'opérateur au milieu des deux arguments.<br/> Le nom d'un opérateur ne doit pas comprendre de lettres ou de chiffres, et ne peux pas commencer par : (deux points). Si vous avez un doute sur la validité d'un nom, le mieux est de tester.</p></aside><h6 id="r-utiliser-if" data-claire-element-id="420719">Utiliser if</h6><p id="r-420702" data-claire-element-id="420702">Vous pouvez tester if dans ghci :</p><pre id="r-420703" data-claire-element-id="420703"><code data-claire-semantic="console">Prelude&gt; let x = 7
Prelude&gt; if x &gt; 5 then 42 else 0
42
Prelude&gt; let x = 2
Prelude&gt; if x &gt; 5 then 42 else 0
0</code></pre><aside id="r-420705" data-claire-element-id="420705" data-claire-semantic="information"><p id="r-420704" data-claire-element-id="420704">La partie else est obligatoire. Si vous avez fait du C ou du php, if ressemble beaucoup à l'opérateur ternaire (qui revoie une valeur)</p></aside><aside id="r-420707" data-claire-element-id="420707" data-claire-semantic="warning"><p id="r-420706" data-claire-element-id="420706">Les deux branches doivent renvoyer des valeurs du même type, sinon ça ne compilera pas !</p></aside><p id="r-420708" data-claire-element-id="420708">Maintenant, une astuce utile. Prenons les fonctions suivantes</p><pre id="r-420709" data-claire-element-id="420709"><code data-claire-semantic="haskell">nul x = if x == 0 then True else False
nonNul x = if x == 0 then False else True</code></pre><p id="r-420710" data-claire-element-id="420710">On peut faire plus court : quand notre if renvoie des booléens, on peut enlever le if, comme ceci :</p><pre id="r-420711" data-claire-element-id="420711"><code data-claire-semantic="haskell">nul x = x == 0
nonNul x = not (x==0)</code></pre><p id="r-420712" data-claire-element-id="420712">On va utiliser if pour écrire une fonction qui prend un entier et renvoie <code data-claire-semantic="haskell">&quot;Negatif&quot; </code> s'il est strictement inférieur à 0, <code data-claire-semantic="haskell">&quot;Positif&quot; </code> sinon.</p><pre id="r-420713" data-claire-element-id="420713"><code data-claire-semantic="haskell">signe x = if x &gt;= 0 then &quot;Positif&quot; else &quot;Negatif&quot;</code></pre><p id="r-420714" data-claire-element-id="420714">On pourrait écrire ce code sur plusieurs lignes :</p><pre id="r-420715" data-claire-element-id="420715"><code data-claire-semantic="haskell">signe x = if x &gt;= 0
          then &quot;Positif&quot;
          else &quot;Negatif&quot;</code></pre><p id="r-420716" data-claire-element-id="420716">Mais on ne peut pas écrire ça :</p><pre id="r-420717" data-claire-element-id="420717"><code data-claire-semantic="haskell">signe x = if x &gt;= 0
then &quot;Positif&quot;
else &quot;Negatif&quot;</code></pre><p id="r-420718" data-claire-element-id="420718">En effet, l'indentation est importante en Haskell : ce qui est à l'intérieur de la fonction doit être plus indenté que le début de la déclaration de la fonction.</p><h5 id="r-filtrage-de-motif" data-claire-element-id="420752">Filtrage de motif</h5><h6 id="r-case-of" data-claire-element-id="420737">case of</h6><p id="r-420721" data-claire-element-id="420721">L'autre structure conditionnelle importante est <strong>case of</strong>.<br/> Observons là sur un exemple simple :</p><pre id="r-420722" data-claire-element-id="420722"><code data-claire-semantic="haskell">enLettres x = case x of
                  0 -&gt; &quot;Zero&quot;
                  1 -&gt; &quot;Un&quot;
                  2 -&gt; &quot;Deux&quot;
                  _ -&gt; &quot;Trop grand!&quot;</code></pre><p id="r-420723" data-claire-element-id="420723">Cette construction peut vous faire penser à un switch en C. <br/> On écrit <code data-claire-semantic="haskell">case variable of </code>, et en dessous une série de motifs ainsi que ce qu'il faut renvoyer quand variable correspond à un de ces motifs. Donc x est comparé aux motifs dans l'ordre, et on obtient le résultat de l'expression associée au premier motif qui correspond. Si aucun motif ne correspond, on obtient une erreur.<br/> Dans cet exemple, on a deux types de motifs : une valeur (0, 1, 2) et _ qui est un motif qui correspond à n'importe quelle valeur.</p><pre id="r-420724" data-claire-element-id="420724"><code data-claire-semantic="haskell">enLettres x = case x of
                  _ -&gt; &quot;Trop grand!&quot;
                  0 -&gt; &quot;Zero&quot;
                  1 -&gt; &quot;Un&quot;
                  2 -&gt; &quot;Deux&quot;</code></pre><p id="r-420725" data-claire-element-id="420725">Puisque les motifs sont testés dans l'ordre, si on changeait l'ordre des motifs, on obtiendrait des résultats différents. Ici, enLettres renverra toujours <code data-claire-semantic="haskell">&quot;Trop grand!&quot; </code>.</p><p id="r-420726" data-claire-element-id="420726">On peut aussi écrire des motifs plus compliqués :</p><pre id="r-420727" data-claire-element-id="420727"><code data-claire-semantic="haskell">ouEstZero x = case x of
                  (0,0) -&gt; &quot;Gauche et droite&quot;
                  (0,_) -&gt; &quot;Gauche&quot;
                  (_,0) -&gt; &quot;Droite&quot;
                  _ -&gt; &quot;Nul part&quot;</code></pre><p id="r-420728" data-claire-element-id="420728">Ici, on voit une nouvelle façon de construire des motifs : on peut utiliser _ à l'intérieur de structures plus compliquées, pour dire qu'on ne se soucie pas d'une partie de cette structure. Donc le motif <code data-claire-semantic="haskell">(0,_) </code> correspond à toutes les paires donc le premier élément est 0.</p><p id="r-420729" data-claire-element-id="420729">On peut aussi utiliser le filtrage de motif pour décomposer une paire.</p><pre id="r-420730" data-claire-element-id="420730"><code data-claire-semantic="haskell">sommePaire t = case t of
                   (x,y) -&gt; x+y</code></pre><p id="r-420731" data-claire-element-id="420731">Quand on met un nom de variable dans un motif, cela ne signifie pas que cette partie du motif doit être égale à la variable. Un nom de variable se comporte plutôt comme un _, c'est-à-dire qu'il correspond à tout, mais en plus, dans l'expression à droite du motif, cette variable vaudra ce qu'il y avait à sa place dans le motif.<br/> Par exemple, si on filtre la valeur <code data-claire-semantic="haskell">(0,7) </code> avec le motif et le résultat <code data-claire-semantic="haskell">(0,x) -&gt; x+1 </code>, on aura <code data-claire-semantic="haskell">x=7 </code> donc on obtiendra 8.</p><p id="r-420732" data-claire-element-id="420732">On peut combiner toutes ces idées pour créer des fonctions plus compliquées. Cette fonction renvoie le premier élément non nul d'une paire, ou 0.</p><pre id="r-420733" data-claire-element-id="420733"><code data-claire-semantic="haskell">premierNonNul t = case t of
                      (0,0) -&gt; 0
                      (0,y) -&gt; y
                      (x,0) -&gt; x
                      (x,y) -&gt; x</code></pre><p id="r-420734" data-claire-element-id="420734">On remarque que certains motifs se recoupent.<br/> Par exemple, les cas (0,0) -&gt; 0 et (0,y) -&gt; y peuvent se réécrire avec un seul motif (0,y) -&gt; y<br/> De même, on peut remplacer les cas (x,0) -&gt; x et (x,y) -&gt; x par un seul cas, (x,_) -&gt; x<br/> On obtient un code avec seulement deux cas :</p><pre id="r-420735" data-claire-element-id="420735"><code data-claire-semantic="haskell">premierNonNul t = case t of
                      (0,y) -&gt; y
                      (x,_) -&gt; x</code></pre><p id="r-420736" data-claire-element-id="420736">On ne peut pas mettre deux fois la même variable dans un motif (donc il est impossible de faire un motif <code data-claire-semantic="haskell">(x,x) </code>). Dans chaque cas, les valeurs renvoyées doivent être du même type.</p><h6 id="r-style-declaratif" data-claire-element-id="420746">Style déclaratif</h6><p id="r-420738" data-claire-element-id="420738">Le filtrage de motif est un outil puissant, et on se rend compte qu'on fait très souvent un filtrage sur les arguments de la fonction.<br/> Quand on doit prendre en compte la valeur de plusieurs arguments, le filtrage finit par donner des choses assez peu claires. Ici, on prend comme exemple une version de premierNonNul qui prend deux arguments au lieu de prendre une paire de nombres :</p><pre id="r-420739" data-claire-element-id="420739"><code data-claire-semantic="haskell">premierNonNul x y = case (x,y) of
                      (0,y) -&gt; y
                      (x,_) -&gt; x</code></pre><p id="r-420740" data-claire-element-id="420740">On doit construire une paire avec les deux arguments, ce qui finit par donner des codes pas très naturels.</p><pre id="r-420741" data-claire-element-id="420741"><code data-claire-semantic="haskell">premierNonNul 0 y = y
premierNonNul x _ = x</code></pre><p id="r-420742" data-claire-element-id="420742">On préfère en général écrire le filtrage de cette façon, quand c'est possible.</p><p id="r-420743" data-claire-element-id="420743">Il est aussi possible de remplacer dans certains cas if par des gardes :</p><pre id="r-420744" data-claire-element-id="420744"><code data-claire-semantic="haskell">signePremier (x,_)
    | x &gt; 0 = &quot;Positif&quot;
    | x &lt; 0 = &quot;Negatif&quot;
    | otherwise = &quot;Nul&quot;</code></pre><p id="r-420745" data-claire-element-id="420745">Les gardes permettent d'exécuter du code différent suivant des conditions : si le motif correspond, l'expression correspondant à la première garde qui renvoie True est exécutée. La garde otherwise permet de prendre en compte tous les cas pas encore traités (en réalité, otherwise est une constante qui vaut True). Il ne faut pas mettre de signe égal entre le motif et les gardes, sous peine de récolter une erreur de syntaxe.</p><h6 id="r-n-uplets" data-claire-element-id="420751">n-uplets</h6><p id="r-420747" data-claire-element-id="420747">Vous avez déjà vu les paires. Mais en fait, ce ne sont qu'un exemple d'un type de données plus général : les n-uplets. Les paires sont des n-uplets à 2 éléments, mais on peut écrire des n-uplets avec plus d'éléments.<br/> Par exemple <code>(1,2,3,True)</code>. On utilise la même notation pour le filtrage de motif sur les n-uplets que pour les paires.<br/> Cependant, <code data-claire-semantic="haskell">fst (1,2,3,True) </code> donne une erreur de type : les fonctions sur les n-uplets ne fonctionnent que pour des n-uplets de taille fixée. Mais vous pouvez, comme exercice, coder les fonctions fst3, snd3 et thr3 qui permettent d'obtenir respectivement le premier, deuxième et troisième élément d'un triplet en utilisant le filtrage de motif.<br/> Solution :</p><div id="r-420749" data-claire-element-id="420749"><pre id="r-420748" data-claire-element-id="420748"><code data-claire-semantic="haskell">fst3 (a,_,_) = a
snd3 (_,b,_) = b
thr3 (_,_,c) = c</code></pre></div><p id="r-420750" data-claire-element-id="420750">Si vous lisez des articles en anglais sur Haskell, les n-uplets sont appelés <em>tuples</em>.</p><h5 id="r-definir-des-valeurs-intermediaires" data-claire-element-id="420764">Définir des valeurs intermédiaires</h5><p id="r-420753" data-claire-element-id="420753">Parfois il peut être utile dans une fonction de définir des valeurs intermédiaires.<br/> Par exemple, on veut créer une fonction qui donne le nombre de racines réelles d'un polynôme du second degré (de la forme ax^2+bx+c). On sait que le discriminant est donné par \Delta=b^2-4ac, et que s'il est positif, il y a deux racines réelles, s'il est nul, il y en a une, et s'il est négatif, il n'y en a pas.<br/> Donc on peut penser notre fonction comme ceci : on calcule d'abord le discriminant, puis on regarde son signe pour donner le nombre de racines. <br/> Pour faire cela, on a besoin de définir une variable locale à notre fonction. Il y a deux façons de faire ça.</p><h6 id="r-let-in" data-claire-element-id="420756">let ... in ...</h6><p id="r-420754" data-claire-element-id="420754">La première méthode est d'utiliser <code data-claire-semantic="haskell">let </code>. On l'utilise ainsi : <code data-claire-semantic="haskell">let variable = valeur in expression </code>.<br/> Par exemple, on pourrait coder notre fonction nombreDeRacines ainsi :</p><pre id="r-420755" data-claire-element-id="420755"><code data-claire-semantic="haskell">nombreDeRacines a b c = let delta = b^2 - 4*a*c in
                        if delta &gt; 0 then 2
                        else if delta == 0 then 1
                        else 0</code></pre><h6 id="r-where-1" data-claire-element-id="420763">where</h6><p id="r-420757" data-claire-element-id="420757">On peut aussi déclarer une variable locale avec <code data-claire-semantic="haskell">where </code>.<br/> Par exemple :</p><pre id="r-420758" data-claire-element-id="420758"><code data-claire-semantic="haskell">nombreDeRacines' a b c = if delta &gt; 0 then 2
                         else if delta == 0 then 1
                         else 0
    where delta = b^2 - 4*a*c</code></pre><p id="r-420759" data-claire-element-id="420759">On peut aussi déclarer plusieurs variables avec un seul where, comme dans cet exemple qui ne fait rien d'utile :</p><pre id="r-420760" data-claire-element-id="420760"><code data-claire-semantic="haskell">diffSommeProd a b = produit - somme
    where produit = a*b
          somme = a+b</code></pre><aside id="r-420762" data-claire-element-id="420762" data-claire-semantic="warning"><p id="r-420761" data-claire-element-id="420761">where est sensible à l'indentation ! Il doit toujours être plus indenté que le début de la déclaration de la fonction.</p></aside><h5 id="r-un-peu-d-exercice" data-claire-element-id="420786">Un peu d'exercice ?</h5><p id="r-420765" data-claire-element-id="420765">Il est temps de mettre en pratique ce que vous avez appris. Ces exercices ne sont pas corrigés, mais vous pouvez tester votre code : s'il marche, c'est bon signe. Une bonne habitude à prendre est d'essayer toujours de trouver les cas qui font que le code ne marche pas.</p><ol id="r-420785" data-claire-element-id="420785"><li id="r-420767" data-claire-element-id="420767"><p id="r-420766" data-claire-element-id="420766">Des fonctions myMin et myMax qui prennent chacune deux arguments et renvoient respectivement le minimum et le maximum des deux arguments</p></li><li id="r-420769" data-claire-element-id="420769"><p id="r-420768" data-claire-element-id="420768">À partir de ces fonctions, codez une fonction qui donne le minimum ou le maximum de 4 nombres</p></li><li id="r-420772" data-claire-element-id="420772"><p id="r-420770" data-claire-element-id="420770">En utilisant myMin et myMax, codez une fonction bornerDans qui prend trois arguments et renvoie le troisième argument s'il est dans l'intervalle formé par les deux premiers, ou renvoie la borne de l'intervalle la plus proche.<br/> Exemples:</p><pre id="r-420771" data-claire-element-id="420771"><code data-claire-semantic="haskell">bornerDans 5 7 6 = 6 -- dans l'intervalle
bornerDans 5 7 4 = 5 -- trop petit
bornerDans 5 7 9 = 7 -- trop grand</code></pre></li><li id="r-420774" data-claire-element-id="420774"><p id="r-420773" data-claire-element-id="420773">Codez une fonction qui prend trois arguments et dit si le troisième argument est dans l'intervalle fermé formé par les deux premiers arguments (on considèrera que le premier argument est inférieur ou égal au deuxième)</p></li><li id="r-420776" data-claire-element-id="420776"><p id="r-420775" data-claire-element-id="420775">En n'utilisant qu'une seule comparaison, codez une fonction qui prend une paire de nombre et renvoie cette paire triée</p></li><li id="r-420778" data-claire-element-id="420778"><p id="r-420777" data-claire-element-id="420777">Codez une fonction qui prend deux vecteurs représentés par des paires de nombres, et donne la somme de ces deux vecteurs</p></li><li id="r-420780" data-claire-element-id="420780"><p id="r-420779" data-claire-element-id="420779">Codez une fonction qui prend un vecteur et renvoie sa norme</p></li><li id="r-420782" data-claire-element-id="420782"><p id="r-420781" data-claire-element-id="420781">Codez une fonction qui prend un nombre et un vecteur, et renvoie le produit du vecteur par ce nombre</p></li><li id="r-420784" data-claire-element-id="420784"><p id="r-420783" data-claire-element-id="420783">Codez une fonction qui prend deux vecteurs et renvoie le produit scalaire de ces deux vecteurs</p></li></ol>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
<span class="arrow"></span>
<span class="next">Déclarations dans un fichier</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
<span class="next">Plus de filtrage de motif</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Plusdefiltragedemotif"></a><h2>Plus de filtrage de motif</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
<span class="arrow"></span>
<span class="next">Conditions et filtrage de motif</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">
<span class="next">Types et classes de types</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-plus-de-filtrage-de-motif" data-claire-element-id="420843">Plus de filtrage de motif</h4><p id="r-420788" data-claire-element-id="420788">Pour l'instant, vous n'avez vu que deux applications du filtrage de motif : soit vous prenez plusieurs valeurs d'un type pour lequel il n'y a qu'un seul choix (par exemple un couple d'entiers ne peut pas être autre chose qu'un couple), soit vous distinguez les valeurs d'un type qui peut en prendre plusieurs (par exemple, True ou False pour les booléens). Mais en fait, le filtrage de motifs permet de faire les deux choses à la fois.</p><h5 id="r-manipuler-des-listes" data-claire-element-id="420804">Manipuler des listes</h5><p id="r-420789" data-claire-element-id="420789">Vous avez vu au chapitre précédent que toutes les listes pouvaient être construites à l'aide de la liste vide <strong>[]</strong> et de l'opérateur <strong>:</strong> qui combine un élément et une liste pour former une nouvelle liste avec l'élément ajouté en premier. C'est pratique pour construire des listes, mais on peut aussi s'en servir pour les détruire, c'est à dire examiner ce qu'il y a à l'intérieur, par du filtrage de motif.</p><p id="r-420790" data-claire-element-id="420790">Par exemple, si on veut créer une fonction qui renvoie 0 si la liste vide, son premier élément sinon, on peut la coder en utilisant un filtrage (puisqu'elle ne peut renvoyer qu'un type, cette fonction ne marche qu'avec des listes de nombres) :</p><pre id="r-420791" data-claire-element-id="420791"><code data-claire-semantic="haskell">-- Version sans filtrage
premier l = if null l then 0 else head l

-- Version avec filtrage
premier' l = case l of
    [] -&gt; 0
    x:_ -&gt; x

-- Ou même :
premier'' [] = 0
premier'' (x:_) = x</code></pre><p id="r-420792" data-claire-element-id="420792">Dans les deux versions avec filtrage, on distingue les deux formes possibles pour la liste donnée en argument. Les parenthèses sont nécessaires dans la deuxième version avec filtrage, comme pour l'application de fonction : <code data-claire-semantic="haskell">premier'' x:_ </code> serait compris comme <code data-claire-semantic="haskell">(premier'' x):_ </code>.</p><p id="r-420793" data-claire-element-id="420793">On peut aussi profiter d'une syntaxe spéciale pour créer un motif qui correspond à une liste de longueur connue, par exemple dans ce code qui additionne les deux premiers éléments d'une liste :</p><pre id="r-420794" data-claire-element-id="420794"><code data-claire-semantic="haskell">addition [] = 0
addition [x] = x
addition (x:y:_) = x + y</code></pre><p id="r-420795" data-claire-element-id="420795">De cette façon, on peut recoder quelques fonctions sur les listes, par exemple la fonction <code data-claire-semantic="haskell">head </code> qui retourne le premier élément d'une liste (mais vous pourriez aussi code <code data-claire-semantic="haskell">tail </code> ou <code data-claire-semantic="haskell">null </code> de la même façon) :</p><pre id="r-420796" data-claire-element-id="420796"><code data-claire-semantic="haskell">head' (x:_) = x</code></pre><p id="r-420797" data-claire-element-id="420797">Quelque chose pourrait vous choquer dans ce code : il ne traite pas tous les cas possibles. Qu'est-ce qui se passe si on donne la liste vide à la fonction ? Rien de bien : on obtient une erreur.</p><pre id="r-420798" data-claire-element-id="420798"><code data-claire-semantic="console">*** Exception: &lt;interactive&gt;:1:4-18: Non-exhaustive patterns in function head'</code></pre><p id="r-420799" data-claire-element-id="420799">Par défaut, GHC ne vérifie pas que le filtrage traite tous les cas possibles, mais vous pouvez activer un avertissement avec l'option <strong>-fwarn-incomplete-patterns</strong>. L'erreur qu'on obtient dans le cas de la liste vide n'est pas très claire, mais il est possible de renvoyer son propre message d'erreur avec la fonction <code data-claire-semantic="haskell">error </code> :</p><pre id="r-420800" data-claire-element-id="420800"><code data-claire-semantic="haskell">head' [] = error &quot;Liste vide&quot;
head' (x:_) = x</code></pre><p id="r-420801" data-claire-element-id="420801">Le filtrage de motif est quelque chose de très pratique (essayez de coder &quot;addition&quot; sans : le code serait beaucoup moins clair), mais pas magique : on ne peut pas utiliser n'importe qu'elle fonction dans un filtrage. Par exemple, on aimerait bien créer une fonction qui renvoie le prénom d'une personne lorsqu'on lui donne une chaîne de la forme <code>&quot;Bonjour &lt;prénom&gt;!&quot;</code>. Une chaîne de caractères est une liste de caractères, donc on peut utiliser les même fonctions dessus, dont la fonction <strong>++</strong> qui concatène deux listes.</p><pre id="r-420802" data-claire-element-id="420802"><code data-claire-semantic="haskell">prenom msg = case msg of
    &quot;Bonjour &quot; ++ prenom ++ &quot;!&quot; -&gt; prenom
    _ -&gt; &quot;Anonyme&quot;</code></pre><p id="r-420803" data-claire-element-id="420803">Mais ce genre de code ne marche pas : on ne peut pas utiliser n'importe quelle fonction dans un filtrage de motif. En fait, les seules choses qu'on a le droit d'utiliser sont les <em>constructeurs</em> du type qu'on cherche à filtrer. Ils correspondent à la façon dont le type a été défini, et aussi à la représentation en mémoire du type. Pour les listes, les constructeurs sont <strong>:</strong> et <strong>[]</strong>. Pour les booléens, ce sont <strong>True</strong> et <strong>False</strong>, et pour les nombres, c'est n'importe quel nombre : par exemple, on peut utiliser <strong>0</strong> comme un motif.</p><h5 id="r-gestion-des-erreurs-2" data-claire-element-id="420842">Gestion des erreurs</h5><p id="r-420805" data-claire-element-id="420805">Le filtrage de motifs et les <em>types sommes</em> (pour lesquels on a plusieurs constructeurs possibles) ne servent pas qu'avec les listes. Par exemple, ils servent pour la gestion des erreurs.</p><h6 id="r-maybe-pour-representer-l-absence-de-valeur" data-claire-element-id="420816">Maybe : pour représenter l'absence de valeur</h6><p id="r-420806" data-claire-element-id="420806">Le type Maybe a deux constructeurs : <strong>Nothing</strong> qui ne prend pas de paramètre, et <strong>Just</strong>, qui prend une valeur en paramètre. Par exemple, on peut écrire <code data-claire-semantic="haskell">Nothing </code>, <code data-claire-semantic="haskell">Just 42 </code> ou même <code data-claire-semantic="haskell">Just Nothing </code> et <code data-claire-semantic="haskell">Just (Just 42) </code> (on a alors un Maybe qui contient lui-même un Maybe).</p><p id="r-420807" data-claire-element-id="420807">On l'utilise souvent pour la valeur de retour d'une fonction qui peut échouer : par exemple, si on a une annuaire, et une fonction qui recherche le numéro de téléphone d'une personne à partir de son nom, elle renverrait <code data-claire-semantic="haskell">Nothing </code> si la personne n'est pas dans l'annuaire, et <code data-claire-semantic="haskell">Just (numéro) </code> si la personne est dans l'annuaire.</p><p id="r-420808" data-claire-element-id="420808">Pour manipuler ces valeurs, on utilise le filtrage de motif. Par exemple, ici, on a une fonction <code data-claire-semantic="haskell">demanderLeNomDuChat </code> qui appelle un numéro, et renvoie le nom du chien. Mais cette fonction peut échouer : par exemple, la personne qu'on appelle peut ne pas répondre. Elle doit donc renvoyer une valeur de type Maybe. Maintenant, si on veut faire une fonction qui renvoie (peut-être) le nom du chat d'une personne à partir de son nom, on récupère d'abord le numéro de téléphone dans Maybe. Pour vérifier si on a vraiment un numéro de téléphone, on utilise le filtrage :</p><pre id="r-420809" data-claire-element-id="420809"><code data-claire-semantic="haskell">nomDuChat nom = case numeroDeTelephone nom of
  Nothing -&gt; Nothing
  Just numero -&gt; demanderLeNomDuChat numero</code></pre><p id="r-420810" data-claire-element-id="420810">En fait, Nothing peut être vu comme la valeur <code>null</code> qui est disponible dans certains langages de programmation, et qui sert aussi à indiquer l'absence de valeur intéressante. Cependant, il y a une différence importante : les types ne portent pas de valeur nulle par défaut, mais seulement lorsqu'on les &quot;enveloppe&quot; dans Maybe. L'avantage, c'est qu'on ne peut pas accidentellement passer la valeur nulle à une fonction qui ne l'attend pas, puisque le type attendu est différent. C'est pour ça qu'il faut faire bien attention à ne pas oublier Just. Par exemple, le code ci-dessous est incorrect :</p><pre id="r-420811" data-claire-element-id="420811"><code data-claire-semantic="haskell">-- Renvoie l'adresse ip du serveur d'un site web
adresseIP &quot;www.siteduzero.com&quot; = &quot;92.243.25.239&quot;
adresseIP &quot;progmod.org&quot; = &quot;178.33.42.21&quot;
adresseIP &quot;google.fr&quot; = &quot;66.249.92.104&quot;
adresseIP _ = Nothing</code></pre><p id="r-420812" data-claire-element-id="420812">Pourquoi ? Parce que dans presque tous les cas, on renvoie une valeur simple, qui ne peut jamais valoir Nothing, alors qu'on renvoie Nothing si le site n'est pas trouvé. Les types de retour ne correspondent pas, donc ce code est invalide. Il faut penser à mettre à chaque fois les valeurs définies dans Just :</p><pre id="r-420813" data-claire-element-id="420813"><code data-claire-semantic="haskell">-- Renvoie l'adresse ip du serveur d'un site web
adresseIP &quot;www.siteduzero.com&quot; = Just &quot;92.243.25.239&quot;
adresseIP &quot;progmod.org&quot; = Just &quot;178.33.42.21&quot;
adresseIP &quot;google.fr&quot; = Just &quot;66.249.92.104&quot;
adresseIP _ = Nothing</code></pre><p id="r-420814" data-claire-element-id="420814">Une dernière chose : pour rechercher dans un &quot;annuaire&quot; représenté par une liste de couples (clé, valeur), vous pouvez utiliser la fonction <code data-claire-semantic="haskell">lookup </code> : <code data-claire-semantic="haskell">lookup cle liste </code> renvoie <code data-claire-semantic="haskell">Just valeur </code> si la clé est trouvée dans la liste, et <code data-claire-semantic="haskell">Nothing </code> sinon. Exemples :</p><pre id="r-420815" data-claire-element-id="420815"><code data-claire-semantic="console">Prelude&gt; let ips = [(&quot;www.siteduzero.com&quot;,&quot;92.243.25.239&quot;),
    (&quot;progmod.org&quot;, &quot;178.33.42.21&quot;), (&quot;google.fr&quot;, &quot;66.249.92.104&quot;)]
Prelude&gt; lookup &quot;www.siteduzero.com&quot; ips
Just &quot;92.243.25.239&quot;
Prelude&gt; lookup &quot;reddit.com&quot; ips
Nothing</code></pre><h6 id="r-exemple-des-fonctions-mathematiques" data-claire-element-id="420835">Exemple : des fonctions mathématiques</h6><p id="r-420817" data-claire-element-id="420817">Vous savez surement qu'il y a des opérations qu'on n'a pas le droit de faire : par exemple, on ne peut pas diviser par 0. Mais il arrive souvent qu'on fasse des calculs avec des nombres dont on ne peut pas être sûr à l'avance si ils sont égaux à 0 ou pas. Par défaut, ce genre d'erreurs donne une exception qui arrête l'éxécution du programme (il y a des moyens de les intercepter, mais vous ne verrez pas ça tout de suite). Mais on pourrait adopter une autre solution : puisque la division peut échouer, pourquoi ne pas lui faire renvoyer une valeur dans Maybe ?</p><p id="r-420818" data-claire-element-id="420818">Par exemple, on pourrait faire cela :</p><pre id="r-420819" data-claire-element-id="420819"><code data-claire-semantic="haskell">-- On utilise la fonction div, qui correspond à la division euclidienne
-- On la met entre ` ` pour l'utiliser comme un opérateur
divise _ 0 = Nothing
divise x y = Just (x `div` y)</code></pre><p id="r-420820" data-claire-element-id="420820">Ce code marche très bien :</p><pre id="r-420821" data-claire-element-id="420821"><code data-claire-semantic="console">*Main&gt; 12 `divise` 5
Just 2
*Main&gt; 12 `divise` 0
Nothing</code></pre><p id="r-420822" data-claire-element-id="420822">Mais, quand on essaye de faire des calculs compliqués, on a des problèmes, puisque les autres opérations n'attendent pas &quot;peut-être un nombre&quot;, mais un nombre normal. Il y a alors deux solutions : soit on utilise à chaque fois <code data-claire-semantic="haskell">case </code> sur le résultat de <code data-claire-semantic="haskell">divise </code> pour distinguer les différents cas, soit on adapte les opérations mathématiques pour prendre des valeurs dans <code data-claire-semantic="haskell">Maybe </code> comme arguments. C'est cette deuxième approche qui nous intéresse ici.</p><p id="r-420823" data-claire-element-id="420823">On va commencer par la fonction <code data-claire-semantic="haskell">plus </code> :</p><pre id="r-420824" data-claire-element-id="420824"><code data-claire-semantic="haskell">-- Cas faciles : lorsqu'un argument est &quot;Nothing&quot;, on renvoie Nothing pour propager l'erreur
plus Nothing _ = Nothing
plus _ Nothing = Nothing
-- Le cas intéressant : pas d'erreur
plus (Just a) (Just b) = Just (a + b)</code></pre><p id="r-420825" data-claire-element-id="420825">On teste la fonction :</p><pre id="r-420826" data-claire-element-id="420826"><code data-claire-semantic="console">*Main&gt; Nothing `plus` Just 1
Nothing
*Main&gt; Just 2 `plus` Just 3
Just 5</code></pre><p id="r-420827" data-claire-element-id="420827">On peut faire de même pour <code data-claire-semantic="haskell">plus </code> et <code data-claire-semantic="haskell">fois </code> qui ne peuvent pas non plus échouer :</p><pre id="r-420828" data-claire-element-id="420828"><code data-claire-semantic="haskell">moins Nothing _ = Nothing
moins _ Nothing = Nothing
moins (Just a) (Just b) = Just (a - b)

fois Nothing _ = Nothing
fois _ Nothing = Nothing
fois (Just a) (Just b) = Just (a * b)</code></pre><p id="r-420829" data-claire-element-id="420829">Il ne reste plus qu'à coder la division, où on doit aussi vérifier si on ne divise pas par <code data-claire-semantic="haskell">Just 0 </code>:</p><pre id="r-420830" data-claire-element-id="420830"><code data-claire-semantic="haskell">-- Propager les erreurs
divise Nothing _ = Nothing
divise _ Nothing = Nothing
-- la division par 0 donne un résultat indéfini
divise _ (Just 0) = Nothing
divise (Just a) (Just b) = Just (a `div` b)</code></pre><p id="r-420831" data-claire-element-id="420831">On peut ensuite faire quelques calculs pour tester :</p><pre id="r-420832" data-claire-element-id="420832"><code data-claire-semantic="console">*Main&gt; let n0 = Just 0
*Main&gt; let n1 = Just 1
*Main&gt; let n2 = Just 2
*Main&gt; let undef = Nothing
*Main&gt; n1 `plus` n2
Just 3
*Main&gt; n1 `fois` undef
Nothing
*Main&gt; n2 `divise` n1
Just 2
*Main&gt; n2 `divise` n0
Nothing
*Main&gt; (n2 `plus` n1) `divise` (n1 `moins` n1)
Nothing</code></pre><p id="r-420833" data-claire-element-id="420833">Et voilà, on a maintenant un moyen d'effectuer des opérations mathématiques sans faire de division par zéro, et sans vérifier à chaque fois par quoi on divise. Les notations ne sont pas très pratique, mais vous verrez bientôt comment redéfinir les opérateurs mathématiques (+,-,*,div, ...).</p><p id="r-420834" data-claire-element-id="420834">On remarque aussi qu'une partie du code est répétée à chaque fois, et que les définitions se ressemblent toutes. La gestion des erreurs demande beaucoup de code supplémentaire, mais vous verrez dans le chapitre sur les monades qu'on peut faire la même chose avec un code beaucoup plus court et sans répétition.</p><h6 id="r-either-un-choix" data-claire-element-id="420841">Either : un choix</h6><p id="r-420836" data-claire-element-id="420836">Either est un type qui ressemble beaucoup à Maybe. Il y a deux constructeurs, qui prennent chacun une valeur : <code data-claire-semantic="haskell">Left </code> et <code data-claire-semantic="haskell">Right </code>. On peut par exemple les utiliser pour représenter un choix : soit un marchand de glaces livre à domicile, et dans ce cas on renvoie une valeur <code data-claire-semantic="haskell">Left adresse </code>, soit il fait des glaces à emporter, et dans ce cas on renvoie <code data-claire-semantic="haskell">Right (adresse du marchand) </code>. Le mangeur de glace peut alors faire un filtrage de motif pour choisir d'aller acheter une glace, ou de la commander par téléphone.</p><p id="r-420837" data-claire-element-id="420837">Mais on utilise aussi souvent Either pour gérer des erreurs : si il n'y a pas d'erreur, on renvoie <code data-claire-semantic="haskell">Right (valeur demandée) </code>, sinon <code data-claire-semantic="haskell">Left (détails de l'erreur) </code> (utiliser Left pour indiquer l'échec et Right la réussite est une convention presque toujours respectée). L'avantage, c'est qu'on peut de cette façon donner plus de détails sur l'erreur qu'avec un simple <code data-claire-semantic="haskell">Nothing </code>. On pourrait adapter nos fonctions mathématiques pour utiliser Either :</p><pre id="r-420838" data-claire-element-id="420838"><code data-claire-semantic="haskell">plus (Left erra) _ = Left erra 
plus _ (Left errb) = Left errb
plus (Right a) (Right b) = Right (a + b)

divise (Left erra) _ = Left erra
divise _ (Left errb) = Left errb
divise (Right _) (Right 0) = Left &quot;Division par 0&quot;
divise (Right a) (Right b) = Right (a `div` b)</code></pre><p id="r-420839" data-claire-element-id="420839">Encore une fois, il est pénible de gérer tous les cas, mais les monades nous permettront de le faire sans efforts.</p><p id="r-420840" data-claire-element-id="420840">Ce chapitre est terminé. Si vous ne deviez n'en retenir qu'une chose, le filtrage de motif est le point le plus important : il est très utilisé en Haskell et permet de faire beaucoup de manipulations sur les types impossibles autrement.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
<span class="arrow"></span>
<span class="next">Conditions et filtrage de motif</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">
<span class="next">Types et classes de types</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Typesetclassesdetypes"></a><h2>Types et classes de types</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
<span class="arrow"></span>
<span class="next">Plus de filtrage de motif</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
<span class="next">Types simples</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-420845" data-claire-element-id="420845">Haskell est un langage statiquement et fortement typé. Cependant, l'inférence de type (le fait que les types soient devinés automatiquement par le compilateur) fait que vous n'avez pas vraiment eu à vous soucier des questions de type jusqu'ici. Il est quand même très utile de savoir comment fonctionne le système de type d'Haskell, qui va vous être présenté dans ce chapitre de façon progressive, en commençant par des types simples.</p>
</div><a name="Typessimples"></a><h2>Types simples</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">
<span class="arrow"></span>
<span class="next">Types et classes de types</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
<span class="next">Polymorphisme et classes de types</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-types-simples" data-claire-element-id="420881">Types simples</h4><h5 id="r-types-de-variables-1" data-claire-element-id="420871">Types de variables</h5><h6 id="r-determiner-le-type-d-une-expression" data-claire-element-id="420858">Déterminer le type d'une expression</h6><p id="r-420846" data-claire-element-id="420846">Pour commencer, on va mettre quelques déclarations simples dans un fichier :</p><pre id="r-420847" data-claire-element-id="420847"><code data-claire-semantic="haskell">-- types.hs
reponse = 42
presquePi = 3.14
lettre = 'c'
vrai = True</code></pre><p id="r-420848" data-claire-element-id="420848">Maintenant, on charge ce fichier dans ghci. La commande <code data-claire-semantic="console">:t</code> permet de connaître le type d'une expression inféré par le compilateur:</p><pre id="r-420849" data-claire-element-id="420849"><code data-claire-semantic="console">Prelude&gt; :l &quot;types.hs&quot;
[1 of 1] Compiling Main             ( types.hs, interpreted )
Ok, modules loaded: Main.
Prelude&gt; :t reponse
reponse :: Integer
Prelude&gt; :t presquePi
presquePi :: Double
Prelude&gt; :t lettre
lettre :: Char
Prelude&gt; :t vrai
vrai :: Bool</code></pre><p id="r-420850" data-claire-element-id="420850">On a donc trouvé les types de nos trois variables : <code data-claire-semantic="haskell">reponse </code> a pour type <code data-claire-semantic="haskell">Integer </code> (c'est-à-dire &quot;nombre entier&quot;), <code data-claire-semantic="haskell">presquePi </code> a pour type <code data-claire-semantic="haskell">Double </code> (le type des nombres décimaux), <code data-claire-semantic="haskell">lettre </code> a le type <code data-claire-semantic="haskell">Char </code>, le type des caractères, et <code data-claire-semantic="haskell">vrai </code> a le type <code data-claire-semantic="haskell">Bool </code> des booléens.</p><p id="r-420851" data-claire-element-id="420851">On peut écrire les types directement dans le code source. La déclaration de type doit se situer juste avant la déclaration de la variable, et a pour forme : <code data-claire-semantic="haskell">nom :: Type </code>. Par exemple :</p><pre id="r-420852" data-claire-element-id="420852"><code data-claire-semantic="haskell">reponse :: Integer
reponse = 42

presquePi :: Double
presquePi = 3.14</code></pre><p id="r-420853" data-claire-element-id="420853">Si on indique un type qui ne correspond pas au type de la variable, ghc se plaint :</p><pre id="r-420854" data-claire-element-id="420854"><code data-claire-semantic="haskell">lettre :: Integer
lettre = 'a'</code></pre><p id="r-420855" data-claire-element-id="420855">On charge ce code dans ghci :</p><pre id="r-420856" data-claire-element-id="420856"><code data-claire-semantic="console">Prelude&gt; :l types.hs
types.hs:7:9:
    Couldn't match expected type `Integer' against inferred type `Char'
    In the expression: 'c'
    In the definition of `lettre': lettre = 'c'
Failed, modules loaded: none.</code></pre><p id="r-420857" data-claire-element-id="420857">On obtient un message d'erreur effrayant. N'ayez pas trop peur, vous allez apprendre à le déchiffrer : ghc indique d'abord le fichier et la ligne à laquelle l'erreur se produit, puis l'erreur en elle-même. Ici, il nous indique qu'il attendait (<em>expected type</em>) une valeur de type <code data-claire-semantic="haskell">Integer </code>, mais qu'il a trouvé que l'expression avait comme type (<em>inferred type</em>) <code data-claire-semantic="haskell">Char </code>, et que les deux types ne correspondent pas.</p><h6 id="r-des-types-composes" data-claire-element-id="420870">Des types composés</h6><p id="r-420859" data-claire-element-id="420859">Maintenant, on pourrait se demander quel est le type de quelque chose comme <code data-claire-semantic="haskell">(12, &quot;Coucou&quot;) </code>. On pourrait d'abord penser que le type est <code data-claire-semantic="haskell">Paire </code>, ou quelque chose d'équivalent. Cependant, dans ce cas-là, si je prends le premier élément d'une paire et que je lui ajoute un nombre, rien ne me garantit que cet élément sera vraiment un nombre. Si c'est un caractère, ou quelque chose d'autre de bizarre, j'obtiendrais alors une erreur de type à l'exécution, ce qui ne devrait pas arriver en Haskell. C'est pour cela que le type d'une paire indique le type de ses deux éléments :</p><pre id="r-420860" data-claire-element-id="420860"><code data-claire-semantic="haskell">paire = (12, 'a')

triplet = (42,23,paire)</code></pre><p id="r-420861" data-claire-element-id="420861">Testons-cela dans ghci :</p><pre id="r-420862" data-claire-element-id="420862"><code data-claire-semantic="console">Prelude&gt; :l types.hs
Prelude&gt; :t paire
paire :: (Integer, Char)</code></pre><p id="r-420863" data-claire-element-id="420863">On note le type des n-uplets en notant entre parenthèses les types des éléments, séparés par des virgules. Essayez de deviner le type de <code data-claire-semantic="haskell">triplet </code> puis comparez avec celui donné par ghci.</p><p id="r-420864" data-claire-element-id="420864">Pour les listes, le type se note entre crochets :</p><pre id="r-420865" data-claire-element-id="420865"><code data-claire-semantic="haskell">liste :: [Integer]
liste = [1,2,3,4,5]

message :: String
message = &quot;Hello World !&quot;</code></pre><p id="r-420866" data-claire-element-id="420866">Pour <code data-claire-semantic="haskell">message </code>, on a écrit le type <code data-claire-semantic="haskell">String </code>, mais les chaînes de caractères ne sont qu'un raccourci pour écrire une liste de caractères, et ainsi le type <code data-claire-semantic="haskell">String </code> n'est qu'un autre nom pour <code data-claire-semantic="haskell">[Char] </code>. Dans ses messages d'erreur et les types qu'il donne, ghc mélange parfois les deux noms, mais cela reste le même type.</p><p id="r-420867" data-claire-element-id="420867">Le type d'une valeur Maybe s'écrit avec le constructeur de type Maybe, qui prend un argument qui est le type contenu :</p><pre id="r-420868" data-claire-element-id="420868"><code data-claire-semantic="haskell">numero :: Maybe Integer
numero = Just 123</code></pre><p id="r-420869" data-claire-element-id="420869">J'ai appelé ces types &quot;types composés&quot; car ils sont formés à partir d'un constructeur de type et des plusieurs types qu'on lui donne en paramètre, et pas seulement d'un type simple.</p><h5 id="r-fonctions-6" data-claire-element-id="420880">Fonctions</h5><p id="r-420872" data-claire-element-id="420872">Les fonctions aussi ont un type : il faut indiquer les types et le nombre de leurs arguments, ainsi que le type de données qu'elles renvoient.<br/> Par exemple, on prend le code suivant, qui contient un certain nombre de fonctions pas très utiles (c'est juste pour l'exemple) :</p><pre id="r-420873" data-claire-element-id="420873"><code data-claire-semantic="haskell">nombre = 23

ajouter x = x + nombre
bonjour x = &quot;Bonjour &quot; ++ x

super x y = (ajouter x, bonjour y)</code></pre><p id="r-420874" data-claire-element-id="420874">Prenez le temps de les tester un peu dans ghci pour voir ce qu'elles font.<br/> Maintenant, on veut trouver leur type :</p><pre id="r-420875" data-claire-element-id="420875"><code data-claire-semantic="console">Prelude&gt; :t ajouter
Integer -&gt; Integer
Prelude&gt; :t bonjour
[Char] -&gt; [Char]</code></pre><p id="r-420876" data-claire-element-id="420876">Le type d'une fonction à un argument s'écrit <code data-claire-semantic="haskell">A -&gt; B </code>, où A est le type de l'argument et B le type renvoyé par la fonction. On comprend bien le sens de la flèche : la fonction transforme une valeur de type A en une valeur de type B.</p><p id="r-420877" data-claire-element-id="420877">Maintenant, passons aux fonctions à deux arguments :</p><pre id="r-420878" data-claire-element-id="420878"><code data-claire-semantic="console">Prelude&gt; :t super
Integer -&gt; [Char] -&gt; (Integer,[Char])</code></pre><p id="r-420879" data-claire-element-id="420879">Le type d'une fonction à deux arguments s'écrit donc <code data-claire-semantic="haskell">A -&gt; B -&gt; C </code>. De même, le type d'une fonction à trois arguments s'écrit sous la forme <code data-claire-semantic="haskell">A -&gt; B -&gt; C -&gt; D </code>, et ainsi de suite. Ici, le sens de la flèche parait plus difficile à comprendre, mais vous saurez tout dans le chapitre sur la programmation fonctionnelle.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">
<span class="arrow"></span>
<span class="next">Types et classes de types</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
<span class="next">Polymorphisme et classes de types</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Polymorphismeetclassesdetypes"></a><h2>Polymorphisme et classes de types</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
<span class="arrow"></span>
<span class="next">Types simples</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">
<span class="next">Récursivité</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-polymorphisme-et-classes-de-types" data-claire-element-id="420914">Polymorphisme et classes de types</h4><h5 id="r-le-polymorphisme-4" data-claire-element-id="420891">Le polymorphisme</h5><h6 id="r-un-probleme" data-claire-element-id="420883">Un problème</h6><p id="r-420882" data-claire-element-id="420882">Maintenant, quel est le type de la fonction head qui prend le premier élément d'une liste ? Si on veut l'utiliser sur une liste d'entiers, il faut que son type soit <code data-claire-semantic="haskell">[Integer] -&gt; Integer </code>. Si on veut pouvoir l'utiliser sur une liste de caractères, son type doit être <code data-claire-semantic="haskell">[Char] -&gt; Char </code>, et la même chose avec tous les types. <br/> On pourrait dire que c'est une fonction qui prend une liste d'éléments de n'importe quel type, et renvoie un élément de n'importe quel type, mais dans ce cas on perd le fait que la valeur retournée est du même type que les éléments de la liste, et on risque toujours d'avoir des erreurs de types à l'exécution du programme.</p><h6 id="r-la-solution-12" data-claire-element-id="420890">La solution</h6><p id="r-420884" data-claire-element-id="420884">Regardons quel est le type de head :</p><pre id="r-420885" data-claire-element-id="420885"><code data-claire-semantic="console">Prelude&gt; :t head
head :: [a] -&gt; a</code></pre><p id="r-420886" data-claire-element-id="420886">Le a n'est pas un nom de type, puisqu'il ne commence pas par une lettre majuscule. En réalité c'est une variable de type, et on peut la remplacer par n'importe quel type, à partir du moment où on remplace à chaque endroit où elle apparait la variable par ce type.<br/> Par exemple, on pourrait utiliser head comme une fonction de type <code data-claire-semantic="haskell">[Integer] -&gt; Integer </code>, ou <code data-claire-semantic="haskell">[Char] -&gt; Char </code>, mais pas comme une fonction de type <code data-claire-semantic="haskell">[Integer] -&gt; Char </code>, puisqu'on a remplacé a par deux types différents.</p><p id="r-420887" data-claire-element-id="420887">On peut aussi introduire plusieurs variables de types dans une même signature. Par exemple, quel est le type de la fonction suivante ?</p><pre id="r-420888" data-claire-element-id="420888"><code data-claire-semantic="haskell">construireTriplet x y z = (x,y,z)</code></pre><p id="r-420889" data-claire-element-id="420889">Le polymorphisme ne concerne pas que les fonctions : par exemple, Nothing a pour type <code data-claire-semantic="haskell">Maybe a </code>.<br/> Pour vous entrainer, vos pouvez essayer de trouver le type de quelques fonctions sur les listes, comme <code data-claire-semantic="haskell">: </code>, <code data-claire-semantic="haskell">++ </code>, <code data-claire-semantic="haskell">reverse </code> ou <code data-claire-semantic="haskell">concat </code> simplement en pensant à ce qu'elles font, et le vérifier avec la commande <code data-claire-semantic="console">:t</code>. Si vous ne vous souvenez plus de ce que font ces fonctions, vous pouvez relire la partie sur les listes du deuxième chapitre.<br/> Quand vous écrivez le code d'une fonction et que vous savez ce qu'elle fait mais pas comment la coder, il est souvent pratique de commencer par penser au type de la fonction et de l'écrire, car cela peut donner des indications sur comment devrait fonctionner la fonction.</p><h5 id="r-classes-de-types" data-claire-element-id="420913">Classes de types</h5><h6 id="r-quel-le-type-de" data-claire-element-id="420893">Quel le type de + ?</h6><p id="r-420892" data-claire-element-id="420892">Le polymorphisme règle un certain nombre de problèmes, mais on a toujours des problèmes pour donner le type de certaines fonctions. Par exemple, l'opérateur + doit permettre d'additionner tous les types de nombres : on doit donc pouvoir l'utiliser avec le type <code data-claire-semantic="haskell">Integer -&gt; Integer -&gt; Integer </code>, mais aussi avec le type <code data-claire-semantic="haskell">Double -&gt; Double -&gt; Double </code>. On pourrait donc penser que le type de + est <code data-claire-semantic="haskell">a -&gt; a -&gt; a </code>. Cependant, cela pose toujours un problème : pour certains types, l'addition n'a pas de sens. Par exemple, que voudraient dire la multiplication ou la division sur les listes ?<br/> Pour régler ce problème, on utilise les classes de types. Regardez dans ghci le type de + avec la commande <code data-claire-semantic="haskell">:t (+) </code> (on a besoin de la notation infixe quand on veut parler de l'opérateur tout seul en tant que fonction) : c'est <code data-claire-semantic="haskell">(Num a) =&gt; a -&gt; a -&gt; a </code>. <br/> Comme prévu, il y a bien une variable de type, puisque la fonction doit être polymorphe. Cependant, cette signature est composée de deux parties, séparées par une double flèche =&gt;. La partie à droite est un type construit normalement, qui peut contenir des variables de type. La partie à gauche est plus intéressante : c'est un ensemble de <em>contraintes</em> sur ces variables de type, séparées par des virgules. Une contrainte de la forme <code data-claire-semantic="haskell">Num a </code> signifie que le type a doit faire partie de la classe de types Num, qui correspond aux nombres. On peut donc comprendre cette contrainte comme &quot;a doit être un type numérique&quot;. On voit aussi qu'on ne peut additionner que des nombres <strong>du même type</strong>. Par exemple, il est impossible d'ajouter un Double et un Integer.<br/> On peut avoir plusieurs contraintes dans une même signature. Par exemple, le type de <code data-claire-semantic="haskell">f x y = (x+1,y+1) </code> est <code data-claire-semantic="haskell">f :: (Num a, Num b) =&gt; a -&gt; b -&gt; (a,b) </code>.</p><h6 id="r-limitations-2" data-claire-element-id="420902">Limitations</h6><p id="r-420894" data-claire-element-id="420894">Quand on écrit un nombre entier dans le code source du programme, il est vu par le compilateur comme une valeur de type <code data-claire-semantic="haskell">(Num a) =&gt; a </code>, c'est-à-dire n'importe quel type de nombre. De même, quand on entre un nombre décimal, il est vu comme une valeur de type <code data-claire-semantic="haskell">(Fractional a) =&gt; a </code>.<br/> Cependant, pour des raisons de performances et sous certaines conditions, il peut arriver que le compilateur décide d'utiliser un type moins polymorphe que prévu. Par exemple, avec le fichier suivant :</p><pre id="r-420895" data-claire-element-id="420895"><code data-claire-semantic="haskell">entier = 13
decimal = 2.5</code></pre><pre id="r-420896" data-claire-element-id="420896"><code data-claire-semantic="console">Prelude&gt; :t entier
Integer
Prelude&gt; :t decimal
Double</code></pre><p id="r-420897" data-claire-element-id="420897">On voit que dans ce cas-là, le type est plus restreint que prévu. Cela pose des problèmes, par exemple une erreur de type quand on tente de multiplier les deux nombres. Il est possible de forcer le compilateur à donner un type polymorphe en indiquant soi-même le type :</p><pre id="r-420898" data-claire-element-id="420898"><code data-claire-semantic="haskell">entier :: (Num a) =&gt; a
entier = 13

decimal :: (Fractional a) =&gt; a
decimal = 2.5</code></pre><p id="r-420899" data-claire-element-id="420899">Vous pouvez aussi obtenir des erreurs du type :</p><pre id="r-420900" data-claire-element-id="420900"><code data-claire-semantic="console">../haskell/Test.hs:8:7:
    Ambiguous type variable `a' in the constraint:
      `Eq a' arising from a use of `==' at ../haskell/Test.hs:8:7-10
    Possible cause: the monomorphism restriction applied to the following:
      egal :: a -&gt; a -&gt; Bool (bound at ../haskell/Test.hs:8:0)
    Probable fix: give these definition(s) an explicit type signature
                  or use -XNoMonomorphismRestriction</code></pre><p id="r-420901" data-claire-element-id="420901">Dans ce cas, il suffit de donner un type à la variable qui pose problème pour résoudre le problème.</p><h6 id="r-classes-de-types-les-plus-courantes" data-claire-element-id="420912">Classes de types les plus courantes</h6><p id="r-420903" data-claire-element-id="420903">Maintenant, il est temps de voir les classes de types définies dans le Prelude. Je ne décrirais pour chaque classe que quelques fonctions utiles, ou seulement ce qu'elle représente. Pour plus d'information sur une classe donnée, reportez-vous à <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">la documentation du Prelude</a>.<br/> Ne vous sentez pas obligés de tout connaitre par coeur : vous pourrez revenir à cette partie du tuto ou lire la documentation plus tard. Les principales classes à retenir sont Num, Fractional, Eq et Ord.</p><p id="r-420904" data-claire-element-id="420904">Commençons par les classes numériques. Elles forment une hiérarchie de classes assez compliqué.<br/> La classe <strong>Num</strong> fournit les opérations mathématiques de base : l'addition, la soustraction et la multiplication. Elle fournit aussi une fonction <code data-claire-semantic="haskell">fromInteger :: (Num a) =&gt; Integer -&gt; a </code>, qui permet de transformer tout nombre entier en n'importe quel autre type de nombre.<br/> La classe <strong>Real</strong> représente les types qui sont un sous-ensemble de nombres rationnels. Elle permet d'utiliser la fonction <code data-claire-semantic="haskell">toRational :: (Real a) =&gt; a -&gt; Rational </code>, qui permet de transformer un nombre en nombre ratinonel. Il doivent aussi pouvoir être ordonnés.<br/> La classe <strong>Integral</strong> correspond aux nombres entiers. Par exemple, les types Int (entiers à nombre de chiffre limité) et Integer (entiers aussi grands qu'on veut) sont tous les deux des instances de cette classe. Les opérations intéressantes sont div et mod, qui permettent de trouver respectivement le quotient et le reste de la division euclidienne d'un nombre par un autre, et les opérations gcd et lcm qui permettent de trouver respectivement le PGCD et le PPCM de deux nombres. Il y a aussi une opération <code data-claire-semantic="haskell">toInteger :: (Integral a) =&gt; a -&gt; Integer </code> qui permet de transformer n'importe quel nombre entier en Integer.<br/> La classe <strong>Fractional</strong> permet d'utiliser la division.<br/><strong>Floating</strong> rajoute toutes les opérations trigonométriques, l'exponentielle et les logarithmes.<br/> La classe <strong>RealFrac</strong> intègre les opérations d'arrondi vers le haut et vers le bas.</p><p id="r-420905" data-claire-element-id="420905">Pour les autres classes, c'est plus simple :<br/> La classe <strong>Eq</strong> est la classe des objets dont on peut déterminer s'ils sont égaux ou pas. Elle permet d'utiliser les fonctions == et /=.<br/> La classe <strong>Ord</strong> correspond aux types dont on peut comparer les éléments. Elle fournit les fonctions de comparaison habituelles.<br/> Enfin, la classe <strong>Enum</strong> correspond aux types dont on peut énumérer les éléments, et permet par exemple <br/> d'utiliser la notation de séquences. Par exemple, les entiers et les caractères font partie de cette classe, donc on peut écrire <code data-claire-semantic="haskell">[1..10] </code> et <code data-claire-semantic="haskell">['a'..'z'] </code>.</p><p id="r-420906" data-claire-element-id="420906">Enfin, deux classes . La classe <strong>Show</strong> fournit une fonction <code data-claire-semantic="haskell">show :: (Show a) =&gt; a -&gt; String </code>. Elle permet de convertir une valeur en chaine de caractères, par exemple pour l'afficher. Les valeurs sont représentées sous une forme qui peut normalement être utilisées dans du code Haskell. Par exemple :</p><pre id="r-420907" data-claire-element-id="420907"><code data-claire-semantic="console">Prelude&gt; show 42
&quot;42&quot;
Prelude&gt; show [1,2,3]
&quot;[1,2,3]&quot;</code></pre><p id="r-420908" data-claire-element-id="420908">La fonction read, de la classe de types <strong>Read</strong> fait l'inverse : elle transforme une chaine de caractère en la valeur qu'elle représente. Cependant, le type n'est pas déterminé dynamiquement en fonction de ce qui est lu, mais à la compilation. Si on veut tester cette fonction dans ghci, il ne sait pas quel type de données on attend, il faut donc le préciser (cela n'est pas nécessaire en général, puisque le type de la valeur est déterminé suivant le contexte dans lequel on l'utilise). Pour cela, on utilise la notation ::</p><pre id="r-420909" data-claire-element-id="420909"><code data-claire-semantic="console">Prelude&gt; read &quot;42&quot; :: Int
42
Prelude&gt; read &quot;[1,2,3]&quot; :: [Int]
[1,2,3]
Prelude&gt; read &quot;[1,2,3]&quot; :: Int
*** Exception: Prelude.read: no parse</code></pre><p id="r-420910" data-claire-element-id="420910">Si read n'arrive pas à lire correctement la valeur, il renvoie une erreur.</p><p id="r-420911" data-claire-element-id="420911">Maintenant, vous devriez être capable de comprendre une erreur de type. Ce chapitre ne vous permet pas de coder beaucoup de choses nouvelles, mais plutôt de savoir ce que vous faites. Le chapitre suivant va vous présenter la récursivité, une technique très puissante qui permet de coder beaucoup de choses que vous ne pouvez pas faire jusqu'à maintenant.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
<span class="arrow"></span>
<span class="next">Types simples</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">
<span class="next">Récursivité</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Rcursivit"></a><h2>Récursivité</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
<span class="arrow"></span>
<span class="next">Polymorphisme et classes de types</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
<span class="next">C&#039;est quoi ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-420916" data-claire-element-id="420916">Jusqu'à maintenant, ce que vous pouviez coder était en réalité assez limité. Si vous avez déjà programmé avant, vous vous demandez peut-être où sont les boucles. Dans ce chapitre, vous allez apprendre à utiliser la récursivité pour écrire des programmes qui font des choses que vous ne savez pas encore faire.</p>
</div><a name="C039estquoi"></a><h2>C&#039;est quoi ?</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">
<span class="arrow"></span>
<span class="next">Récursivité</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
<span class="next">Filtrage de motif et récursivité</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-c-est-quoi" data-claire-element-id="420939">C'est quoi ?</h4><h5 id="r-la-recursivite" data-claire-element-id="420938">La récursivité</h5><h6 id="r-exemple-la-fonction-factorielle" data-claire-element-id="420921">Exemple : la fonction factorielle</h6><p id="r-420917" data-claire-element-id="420917">La factorielle de n (notée n!) est le produit de tous les nombres de 1 à n. Vous avez déjà vu un moyen de coder cette fonction, en utilisant la fonction product : <code data-claire-semantic="haskell">fac n = product [1..n] </code>. Pour montrer l'intérêt de la récursivité, nous allons maintenant essayer de coder cette fonction sans utiliser de fonctions prédéfinies, mais seulement quelques opérations de base.<br/> Pour cela, on va utiliser une propriété de la factorielle : on a n!=1 imes 2 imes \cdots imes (n-1) imes n = n imes (1 imes 2 imes \cdots imes (n-1)) = n imes (n-1)!. En résumé, cela donne : n!=n imes (n-1)!. Cette propriété est intéressante, car elle nous permet de calculer n! à partir de (n-1)!. Donc, pour pouvoir calculer n!, il suffit de savoir calculer (n-1)!, donc de savoir calculer (n-2)!, et ainsi de suite. Cependant, si on ne fait que répéter à l'infini cette méthode, le calcul ne donnera jamais de résultat. Pour cela, il faut définir un cas pour lequel on donne immédiatement le résultat. On dira donc que 1!=1, et à partir de ce résultat, on peut calculer n! pour tout n \ge 1.<br/> Pour coder la fonction factorielle en Haskell, on fera exactement la même chose :</p><pre id="r-420918" data-claire-element-id="420918"><code data-claire-semantic="haskell">fac 1 = 1
fac n = n * fac (n-1)</code></pre><p id="r-420919" data-claire-element-id="420919">Ici, comme on utilise le filtrage de motif, seul le premier motif qui correspond sera utilisé pour faire le calcul : l'ordre des lignes est donc important. <br/> Cette fonction est un exemple de fonction récursive, car elle s'appelle elle-même. Quand la fonction fac est exécutée, il se passe quelque chose qui ressemble à cela :</p><pre id="r-420920" data-claire-element-id="420920"><code>calculer fac 4:
  la définition &quot;fac n = n * fac (n-1)&quot; est la première qui correspond
  j'ai besoin de fac 3:
    la définition &quot;fac n = n * fac (n-1)&quot; est la première qui correspond
    j'ai besoin de fac 2:
      la définition &quot;fac n = n * fac (n-1)&quot; est la première qui correspond
      j'ai besoin de fac 1:
        la définition &quot;fac 1 = 1&quot; est la première qui correspond
        fac 1 vaut 1  
      je multiplie par 2, fac 2 vaut 2
    je multiplie par 3, fac 3 vaut 6
  je multiplie par 4, fac 4 vaut 24</code></pre><h6 id="r-utiliser-la-recursivite" data-claire-element-id="420931">Utiliser la récursivité</h6><p id="r-420922" data-claire-element-id="420922">L'idée que l'on applique souvent pour coder une fonction récursive est de rapporter un problème (calculer n!) à un ou plusieurs problèmes plus faciles (calculer (n-1)!).<br/> On n'est donc pas obligé d'enlever un à chaque fois : par exemple, on va coder une fonction qui calcule le pgcd de deux nombres. Si vous êtes déjà allés en troisième, vous devez connaître l'algorithme d'Euclide. Il se base sur la propriété suivante : quand on écrit la division euclidienne de a par b, a = bq+r, on a : pgcd(a,b)=pgcd(b,r). Il suffit donc à chaque étape de diviser le nombre le plus petit par le plus grand, jusqu'à se ramener à un cas donc le pgcd est très facile à calculer : celui où un des deux nombres divise l'autre. En fait, on remarque que quand un des nombres divise l'autre, à la prochaine étape, le reste vaudra 0, et donc on aura à calculer le pgcd d'un nombre et 0, qui est ce nombre (pour que cela reste cohérent).</p><pre id="r-420923" data-claire-element-id="420923"><code data-claire-semantic="haskell">pgcd 0 k = k
pgcd k 0 = k
pgcd a b = pgcd c (d `mod` c)
    where d = max a b
          c = min a b</code></pre><p id="r-420924" data-claire-element-id="420924">À chaque étape, on diminue le maximum des deux nombres : on se ramène donc bien à chaque fois à un cas plus simple à résoudre.</p><p id="r-420925" data-claire-element-id="420925">Parfois, on n'arrive pas tout de suite à trouver comme faire quelque chose de façon récursive. Par exemple, arrivez-vous à coder une fonction récursive qui donne le plus petit diviseur (plus grand que 1) d'un nombre donné ? On ne voit pas sur quoi faire la récursivité dans ce cas-là : quels seraient les sous-problèmes ?<br/> En fait, telle quelle, cette fonction ne peut pas être définie de manière récursive. Par contre, on peut trouver une fonction qui fait plus de choses, et qui se définit bien par récurrence. On va donc définir la fonction diviseurPlusGrandQue qui donne le plus petit diviseur d'un nombre plus grand ou égal à un autre nombre (par exemple, <code data-claire-semantic="haskell">diviseurPlusGrandQue 12 5 </code> donne 6, car 6 divise 12 et 6 est plus grand que 5). Il est très facile de coder plusPetitDiviseur&quot; à partir de cette fonction :</p><pre id="r-420926" data-claire-element-id="420926"><code data-claire-semantic="haskell">plusPetitDiviseur n = diviseurPlusGrandQue n 2</code></pre><p id="r-420927" data-claire-element-id="420927">Il ne nous reste plus qu'à coder la fonction diviseurPlusGrandQue. Appelons n le nombre dont on doit trouver un diviseur, et d la valeur minimale du diviseur (le diviseur doit être plus grand que d). On obtient donc le code suivant :</p><pre id="r-420928" data-claire-element-id="420928"><code data-claire-semantic="haskell">d `divise` n = n `mod` d == 0

diviseurPlusGrandQue n d 
    | d `divise` n = d
    | otherwise    = diviseurPlusGrandQue n (d+1)</code></pre><p id="r-420929" data-claire-element-id="420929">Cette fonction a une propriété intéressante : regardons comment se passe le calcul de <code data-claire-semantic="haskell">diviseurPlusGrandQue 35 2 </code> :</p><pre id="r-420930" data-claire-element-id="420930"><code>calculer diviseurPlusGrandQue 35 2:
  2 ne divise pas 35, on doit calculer diviseurPlusGrandQue 35 3
  calculer diviseurPlusGrandQue 35 3:
    3 ne divise pas 35, on doit calculer diviseurPlusGrandQue 35 4
    calculer diviseurPlusGrandQue 35 4:
      4 ne divise pas 35, n doit calculer diviseurPlusGrandQue 35 5
      calculer diviseurPlusGrandQue 35 5:
        5 divise 35, on retourne 5
      on retourne le résultat : 5
    on retourne le résultat : 5
  on retourne le résultat : 5</code></pre><h6 id="r-recursion-terminale" data-claire-element-id="420937">Récursion terminale</h6><p id="r-420932" data-claire-element-id="420932">Quand on calcule diviseurPlusGrandQue, à chaque étape, après avoir appelé la fonction suivante, on ne fait que retourner le résultat. Dans ce cas, il n'y a pas besoin de retenir d'informations sur la pile sur ce que la fonction doit faire après l'appel, puisqu'elle retourne juste la valeur renvoyée par la fonction appelée. Dans ce cas, le compilateur est capable d'appliquer une optimisation, qui fait que le code est plutôt exécuté de cette façon :</p><pre id="r-420933" data-claire-element-id="420933"><code>calculer diviseurPlusGrandQue 35 2:
  2 ne divise pas 35, on doit calculer diviseurPlusGrandQue 35 3
  3 ne divise pas 35, on doit calculer diviseurPlusGrandQue 35 4
  4 ne divise pas 35, on doit calculer diviseurPlusGrandQue 35 5
  5 divise 35, donc le résultat est 5</code></pre><p id="r-420934" data-claire-element-id="420934">On dit que cette fonction est <em>tail-recursive</em>, car l'appel récursif est la dernière chose faite par la fonction. Certaines fonctions peuvent être réécrites de manière tail-recursive en utilisant un accumulateur. C'est le cas de la fonction factorielle :</p><pre id="r-420935" data-claire-element-id="420935"><code data-claire-semantic="haskell">fac n = fac' n 1

fac' 1 acc = acc
fac' n acc = fac' (n-1) (n*acc)</code></pre><p id="r-420936" data-claire-element-id="420936">Si vous calculez le résultat dans votre tête, vous vous apercevrez que cette fonction donne bien n!, et elle est tail-récursive. On a réussi à écrire fac de façon tail-récursive, mais cela n'est pas possible pour toutes les fonctions.<br/> La tail-récursivité peut améliorer légèrement les performances (car le compilateur est capable de transformer l'appel récursif en boucle), mais interagit assez mal avec l'évaluation paresseuse. En général, il ne faut pas essayer de toujours réécrire une fonction de façon tail-recursive, mais préférer la forme la plus naturelle à écrire et la plus lisible. Par exemple, pour plusPetitDiviseur, il est naturel de formuler le calcul de cette façon, mais la définition tail-recursive de fac est moins claire que la définition du début du chapitre.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">
<span class="arrow"></span>
<span class="next">Récursivité</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
<span class="next">Filtrage de motif et récursivité</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Filtragedemotifetrcursivit"></a><h2>Filtrage de motif et récursivité</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
<span class="arrow"></span>
<span class="next">C&#039;est quoi ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">
<span class="next">Programmation fonctionnelle</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-filtrage-de-motif-et-recursivite" data-claire-element-id="420987">Filtrage de motif et récursivité</h4><p id="r-420940" data-claire-element-id="420940">Cette sous-partie va vous montrer comment on utilise la récursivité pour manipuler les listes. En effet, les listes sont définies de manière récursive : le constructeur :, pour créer une liste prend un élément et... une liste. Il est donc naturel d'utiliser la récursivité pour parcourir une liste.</p><h5 id="r-parcourir-des-listes" data-claire-element-id="420968">Parcourir des listes</h5><h6 id="r-longueur-d-une-liste" data-claire-element-id="420944">Longueur d'une liste</h6><p id="r-420941" data-claire-element-id="420941">Pour illustrer cette idée, on va commencer par un exemple pas trop compliqué : comment calculer la longueur d'une liste ?<br/> On sait que la longueur d'une liste vide est 0. De plus, quand une liste est de la forme <code data-claire-semantic="haskell">x:xs</code>, sa longueur est la longueur de xs plus 1. On obtient donc le code suivant :</p><pre id="r-420942" data-claire-element-id="420942"><code data-claire-semantic="haskell">longueur [] = 0
longueur (x:xs) = 1 + longueur xs</code></pre><p id="r-420943" data-claire-element-id="420943">On va voir comment s'exécute ce code (ici, = veut dire &quot;revient à calculer à&quot;) :<br/><code data-claire-semantic="haskell">longueur (1:2:3:[]) = 1 + longueur (2:3:[]) = 1 + (1 + longueur (3:[])) = 1 + ( 1 + (1 + longueur [])) = 1 + (1 + (1 + 0)) = 1 + (1 + 1) = 1 + 2 = 3</code><br/> Et voilà, ce code calcule bien la longueur d'une liste. Le code de la plupart des fonctions sur les listes que vous coderez ressemblera à celui-là.</p><h6 id="r-plus-d-exemples" data-claire-element-id="420960">Plus d'exemples ?</h6><p id="r-420945" data-claire-element-id="420945">Par exemple, comment calculeriez-vous la somme des éléments d'une liste (par convention, la somme des éléments d'une liste sans éléments est 0) ? Réfléchissez bien, vous devriez pouvoir y arriver.</p><div id="r-420948" data-claire-element-id="420948"><pre id="r-420946" data-claire-element-id="420946"><code data-claire-semantic="haskell">somme :: (Num a) =&gt; [a] -&gt; a
somme [] = 0
somme (x:xs) = x + somme xs</code></pre><p id="r-420947" data-claire-element-id="420947">Vous pouvez aussi coder la fonction produit de la même manière.</p></div><p id="r-420949" data-claire-element-id="420949">De la même façon, vous pouvez coder une fonction monMinimum qui donne l'élément le plus petit d'une liste. Le minimum d'une liste vide n'est pas défini.</p><pre id="r-420950" data-claire-element-id="420950"><code data-claire-semantic="haskell">myMinimum :: (Ord a) =&gt; [a] -&gt; a
myMinimum [x] = x
myMinimum (x:xs) = min x (myMinimum xs)</code></pre><p id="r-420951" data-claire-element-id="420951">On peut aussi coder des fonctions qui construisent des listes, toujours de façon récursive. Par exemple, vous devriez pouvoir coder la fonction compter qui prend deux arguments et renvoie la liste des nombres entre ces deux arguments (un équivalent de la notation <code data-claire-semantic="haskell">[a..b]</code>).</p><pre id="r-420952" data-claire-element-id="420952"><code data-claire-semantic="haskell">compter a b | a &gt; b     = []
            | otherwise = a:compter (a+1) b</code></pre><p id="r-420953" data-claire-element-id="420953">Pourrez-vous, en combinant les idées des deux dernières fonctions, coder une fonction qui ajoute 1 à chaque élément d'une liste ? Et une fonction qui multiplie par 2 chaque élément d'une liste ?</p><div id="r-420955" data-claire-element-id="420955"><pre id="r-420954" data-claire-element-id="420954"><code data-claire-semantic="haskell">ajouter1 [] = []
ajouter1 (x:xs) = (x+1):ajouter1 xs

multiplierPar2 [] = []
multiplierPar2 (x:xs) = (2*x):multiplierPar2 xs</code></pre></div><p id="r-420956" data-claire-element-id="420956">Et maintenant, vous pouvez essayer de coder une fonction supprimer qui prend une liste et un élément, et renvoie une liste où toutes les occurrences de cet élément ont été supprimées.</p><div id="r-420958" data-claire-element-id="420958"><pre id="r-420957" data-claire-element-id="420957"><code data-claire-semantic="haskell">supprimer _ [] = []
supprimer el (x:xs) | el == x   = supprimer el xs
                    | otherwise = x:supprimer el xs</code></pre></div><p id="r-420959" data-claire-element-id="420959">Maintenant, pour vous entrainer, vous pouvez essayer de recoder quelques fonctions du Prelude. Par exemple, codez une fonction append qui fait la même chose que ++. Un indice : la récursivité se fait sur la première liste.</p><h6 id="r-renverser-une-liste" data-claire-element-id="420967">Renverser une liste</h6><p id="r-420961" data-claire-element-id="420961">Vous allez voir ici comment renverser une liste de manière efficace, c'est-à-dire transformer la liste <code data-claire-semantic="haskell">[1,2,3]</code> en <code data-claire-semantic="haskell">[3,2,1]</code>. La version ci-dessous n'utilise pas de concept nouveau et donne le bon résultat.</p><pre id="r-420962" data-claire-element-id="420962"><code data-claire-semantic="haskell">renverser [] = []
renverser (x:xs) = renverser xs ++ [x]</code></pre><p id="r-420963" data-claire-element-id="420963">Cependant, elle est assez inefficace : elle prend environ n² opérations où n est la longueur de la liste. On va donc chercher une version plus efficace. En fait, le problème est qu'on construit la liste dans le mauvais sens, c'est-à-dire en commençant par l'avant (<code data-claire-semantic="haskell">renverser xs</code>) puis en rajoutant un élément à la fin avec ++, ce qui n'est pas du tout efficace. Pourtant, on a toutes les informations pour construire la liste dans l'autre sens. Pour cela, on va créer une fonction renverser' à laquelle on va rajouter un argument suite, qui donne la suite de la liste à construire.<br/> On obtient donc ça :</p><pre id="r-420964" data-claire-element-id="420964"><code data-claire-semantic="haskell">renverser' [] suite = [] ++ suite
renverser' (x:xs) suite = renverser' xs [] ++ [x] ++ suite</code></pre><p id="r-420965" data-claire-element-id="420965">Or, la partie <code data-claire-semantic="haskell">[x] ++ suite</code> peut être utilisée comme suite pour l'appel récursif, puisqu'elle doit être appelée à la fin. On obtient donc le code suivant, efficace et récursif terminal. C'est un bon exemple d'un cas où la tail-récursivité donne une formulation naturelle pour la fonction.</p><pre id="r-420966" data-claire-element-id="420966"><code data-claire-semantic="haskell">renverser l = renverser' l []

renverser' [] suite = suite
renverser' (x:xs) suite = renverser' xs (x:suite)</code></pre><h5 id="r-application-un-tri" data-claire-element-id="420986">Application : un tri</h5><p id="r-420969" data-claire-element-id="420969">Nous allons utiliser tout ce que vous avez vu pour trier des listes. Essayez de coder les fonctions nécessaires sans regarder le code source, mais seulement grâce à la description. Si vous n'y arrivez pas et que vous bloquez, ce n'est pas grave, les solutions sont là.</p><h6 id="r-tri-par-insertion-2" data-claire-element-id="420975">Tri par insertion</h6><p id="r-420970" data-claire-element-id="420970">Ce premier tri se base sur l'idée suivante : une liste vide est triée, et pour trier une liste de n+1 éléments, il suffit de trier une liste de n éléments puis d'ajouter le n+1 ème à la bonne position.<br/> Pour cela, il faut coder une fonction insertion, qui prend une liste triée dans l'ordre croissant et un élément, et insère l'élément au bon endroit pour que la liste soit triée (c'est-à-dire avant le premier élément plus grand que lui).</p><pre id="r-420971" data-claire-element-id="420971"><code data-claire-semantic="haskell">insertion el [] = [el]
insertion el (x:xs) | x &gt; el    = el:x:xs
                    | otherwise = x:insertion el xs</code></pre><p id="r-420972" data-claire-element-id="420972">Ensuite, pour trier une liste, il suffit de trier la queue de la liste, et d'insérer la tête au bon endroit.</p><pre id="r-420973" data-claire-element-id="420973"><code data-claire-semantic="haskell">triInsertion [] = []
triInsertion (x:xs) = insertion x (triInsertion xs)</code></pre><p id="r-420974" data-claire-element-id="420974">On a donc une première fonction de tri.</p><h6 id="r-tri-fusion" data-claire-element-id="420985">Tri fusion</h6><p id="r-420976" data-claire-element-id="420976">Le tri fusion, plus efficace, se base sur le principe &quot;diviser pour régner&quot; : on découpe la liste à trier en deux listes, qu'on trie chacune indépendamment, puis on regroupe les deux listes triées avec une fonction de fusion.<br/> On va commencer par la fonction de fusion : elle prend deux listes triées, et renvoie une liste triée contenant les éléments des deux listes. Pour cela, on procède par récursivité : à chaque étape, on enlève un élément de l'une des deux listes (le minimum des éléments en tête), puis on l'ajoute devant la liste triée formée du reste des éléments.</p><pre id="r-420977" data-claire-element-id="420977"><code data-claire-semantic="haskell">fusion xs [] = xs
fusion [] ys = ys
fusion (x:xs) (y:ys) | x &gt;= y = y:fusion (x:xs) ys
                     | y &gt;= x = x:fusion xs (y:ys)</code></pre><p id="r-420978" data-claire-element-id="420978">Ensuite, il faut une fonction pour diviser la liste en deux parties. Elle renvoie une paire de listes, et elle fonctionne de manière récursive en consommant des éléments deux par deux.</p><pre id="r-420979" data-claire-element-id="420979"><code data-claire-semantic="haskell">couper [] = ([],[])
couper (x:[]) = ([x],[]) -- et pas (x,[]) car on doit renvoyer une liste
couper (x:y:l) = let (xs,ys) = couper l in (x:xs,y:ys)</code></pre><p id="r-420980" data-claire-element-id="420980">Finalement, on combine tout ça pour faire notre fonction de tri :</p><pre id="r-420981" data-claire-element-id="420981"><code data-claire-semantic="haskell">triFusion [] = []
triFusion [x] = [x]
triFusion l = let (xs,ys) = couper l in 
              fusion (triFusion xs) (triFusion ys)</code></pre><p id="r-420982" data-claire-element-id="420982">Et voilà, notre deuxième fonction de tri est terminée. Il faut gérer les cas de la liste vide et de la liste à deux éléments particulièrement, sinon elles seraient coupées respectivement en deux listes vides, et une liste à un élément et une autre vide, et le tri ne se terminerait jamais (vous pouvez exécuter le programme dans votre tête pour tester).</p><p id="r-420983" data-claire-element-id="420983">Si vous cherchez plus d'explications sur les algorithmes de tri, vous pouvez lire les cours de <a href="http://www.siteduzero.com/tutoriel-2-217-algorithmique.html">la partie algorithmique du site du zéro</a>, ou le tutoriel <a href="http://www.siteduzero.com/tutoriel-3-51781-algorithmique-pour-l-apprenti-programmeur.html">Algorithmique pour l'apprenti programmeur</a>.</p><p id="r-420984" data-claire-element-id="420984">La récursivité est une technique très puissante : elle permet de remplacer les boucles utilisées en programmation impérative, parfois de façon plus claire. C'est donc important de bien comprendre ce concept. Si vous avez du mal avec ce chapitre, vous pouvez aussi essayer de lire <a href="http://www.siteduzero.com/tutoriel-3-36703-la-recursivite.html">le tutoriel de bluestorm sur la récursivité</a>. Les langages utilisés sont PHP et OCaml (vous n'aurez pas de mal à lire le code, car la syntaxe d'ocaml est assez proche de celle utilisée en Haskell).</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
<span class="arrow"></span>
<span class="next">C&#039;est quoi ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">
<span class="next">Programmation fonctionnelle</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Programmationfonctionnelle"></a><h2>Programmation fonctionnelle</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
<span class="arrow"></span>
<span class="next">Filtrage de motif et récursivité</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
<span class="next">Exemple : la fonction map</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-420989" data-claire-element-id="420989">Dans ce chapitre, vous allez découvrir une idée qui fait que Haskell est un langage différent de ce que vous avez vu jusqu'à maintenant (en tout cas si vous vous êtes limités à la programmation impérative et orientée objet) : la programmation fonctionnelle.</p><p id="r-420990" data-claire-element-id="420990">L'idée est assez simple : à partir d'une fonction de base (l'addition), on peut construire des fonctions plus complexes (calculer la somme des éléments d'une liste, faire une liste contenant la somme des éléments deux à deux de deux listes). Mais souvent, en changeant juste la fonction de base (par exemple par la multiplication), on peut créer d'autres fonctions toutes aussi utiles (calculer le produit des éléments d'une liste, construire une liste contenant le produit des éléments de deux listes deux à deux). <br/> Au lieu de répéter le code de ces deux fonctions en changeant juste l'addition en multiplication, pour maximiser la réutilisation du code, on crée des opérations qui à partir d'une fonction créent des fonctions plus complexes. Ainsi, on peut créer une telle opération et lui donner la fonction addition : le résultat sera une fonction qui donne la somme des éléments d'une liste. Mais on peut aussi lui donner la fonction multiplier, et on obtiendra une fonction qui fait le produit des éléments d'une liste.</p><p id="r-420991" data-claire-element-id="420991">L'avantage de tout cela, c'est qu'on n'a pas à répéter le code, qu'on peut créer un grand nombre de fonctions à partir de quelques fonctions de base et de transformations simples, et que cela peut rendre la lecture plus claire si on est habitué à ce style de programmation. Enfin, on peut facilement changer les <em>fonctions d'ordre supérieur</em> (les fonctions qui prennent d'autres fonctions comme arguments), pour les optimiser (par exemple permettre de réaliser les calculs sur plusieurs processeurs en parallèle), et toutes les fonctions construites à partir de ces opérations profiteront de ces optimisations.</p>
</div><a name="Exemplelafonctionmap"></a><h2>Exemple : la fonction map</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">
<span class="arrow"></span>
<span class="next">Programmation fonctionnelle</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
<span class="next">Fonctions sur les listes</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-exemple-la-fonction-map" data-claire-element-id="421018">Exemple : la fonction map</h4><h5 id="r-utilite-11" data-claire-element-id="421004">Utilité</h5><h6 id="r-des-fonctions-qui-se-ressemblent" data-claire-element-id="420997">Des fonctions qui se ressemblent</h6><p id="r-420992" data-claire-element-id="420992">Reprenons le code de deux fonctions codées au chapitre précédent :</p><pre id="r-420993" data-claire-element-id="420993"><code data-claire-semantic="haskell">-- ajoute 1 à tous les éléments d'une liste
ajouter1 [] = []
ajouter1 (x:xs) = (x+1):ajouter1 xs

-- multiplie tous les éléments d'une liste par 2
multiplierPar2 [] = []
multiplierPar2 (x:xs) = (2*x):multiplierPar2 xs</code></pre><p id="r-420994" data-claire-element-id="420994">Ces deux morceaux de code font des choses similaires et se ressemblent beaucoup : ils transforment chaque élément d'une liste. La ressemblance est encore plus frappante quand on isole la fonction qui est appliquée à chaque élément :</p><pre id="r-420995" data-claire-element-id="420995"><code data-claire-semantic="haskell">ajouter1 [] = []
ajouter1 (x:xs) = f x:ajouter1 xs
    where f x = x + 1

multiplierPar2 [] = []
multiplierPar2 (x:xs) = f x:multiplierPar2 xs
    where f x = 2 * x</code></pre><p id="r-420996" data-claire-element-id="420996">À partir de là, vous pourriez vous contenter d'apprendre ce code par coeur (ou de le noter quelque part), et le recopier à chaque fois que vous devez coder une fonction qui applique la même transformation à tous les éléments d'une liste. Cependant, cela crée du code répété et demande trop d'effort. En plus, vous risqueriez de faire des fautes de frappe.</p><h6 id="r-la-solution-13" data-claire-element-id="421003">La solution</h6><p id="r-420998" data-claire-element-id="420998">Pour résoudre ce problème, on va créer une fonction transformerElements qui prend comme arguments la fonction qui sera appliquée à chaque élément, et une liste :</p><pre id="r-420999" data-claire-element-id="420999"><code data-claire-semantic="haskell">transformerElements f [] = []
transformerElements f (x:xs) = f x:transformerElements f xs</code></pre><p id="r-421000" data-claire-element-id="421000">Maintenant, on peut définir des fonctions et les utiliser avec transformerElements :</p><pre id="r-421001" data-claire-element-id="421001"><code data-claire-semantic="haskell">plus1 x = x + 1
fois2 x = 2 * x

ajouter1 xs = transformerElements plus1 xs
fois2 xs = transformerElements fois2 xs</code></pre><p id="r-421002" data-claire-element-id="421002">Vous pouvez tester, ces fonctions donnent le même résultat. Si on peut faire ça, c'est qu'en Haskell, les fonctions sont des valeurs comme les autres : on peut prendre une fonction en argument, renvoyer une fonction, les transformer,...<br/> En réalité, la fonction transformerElements existe déjà par défaut : c'est la fonction map. Si vous avez le choix entre utiliser la récursivité, ou utiliser directement la fonction map, préférez map : le code est plus court, vous avez moins de chance de faire une erreur en écrivant votre fonction, et n'importe quel programmeur qui lira votre code comprendra immédiatement ce que fait la fonction, alors qu'une fonction récursive est plus difficile à lire, puisqu'il faut suivre le déroulement des appels récursifs.<br/> Les fonctions qui prennent des fonctions en argument sont parfois appelées fonctions d'ordre supérieur.</p><h5 id="r-remarques-utiles" data-claire-element-id="421017">Remarques utiles</h5><h6 id="r-le-type-de-la-fonction-map" data-claire-element-id="421006">Le type de la fonction map</h6><p id="r-421005" data-claire-element-id="421005">La fonction map a pour type <code data-claire-semantic="haskell">(a -&gt; b) -&gt; [a] -&gt; [b] </code>. Le type du premier argument, <code data-claire-semantic="haskell">a -&gt; b </code> est donc un type de fonction. On le met entre parenthèse, car sinon le type serait interprété comme <code data-claire-semantic="haskell">a -&gt; b -&gt; [a] -&gt; [b] </code>, c'est-à-dire le type d'une fonction qui prend trois arguments. Le type de map ne veut pas dire que la fonction qu'on lui donne doit être du type polymorphique <code data-claire-semantic="haskell">a -&gt; b </code>, mais que a et b doivent correspondre respectivement au type des éléments de la liste donnée en argument, et au type des éléments de la liste retournée.</p><h6 id="r-fonctions-anonymes-operateurs" data-claire-element-id="421016">Fonctions anonymes, opérateurs</h6><p id="r-421007" data-claire-element-id="421007">Les fonctions anonymes sont quelque chose de bien pratique quand on a des fonctions qu'on n'utilisera qu'une seule fois. Par exemple, imaginons que je veuille appliquer la fonction définie par f(x) = x^2+2x+1 à tous les éléments de ma liste. Au lieu de définir une fonction qui ne servira qu'une fois, il est possible d'utiliser une fonction anonyme :</p><pre id="r-421008" data-claire-element-id="421008"><code data-claire-semantic="haskell">fonctionLouche liste = map (\x -&gt; x*x + 2*x + 1) liste</code></pre><p id="r-421009" data-claire-element-id="421009">L'avantage des fonctions anonymes, c'est que si elles sont courtes et simples, on voit très vite ce qu'elles font. <code data-claire-semantic="haskell">(\x -&gt; x*x + 2*x + 1) </code> est une fonction à un argument, qui correspond à la fonction mathématique f que l'on a vu plus haut. On note une fonction anonyme <code data-claire-semantic="haskell">(\ arg1 arg2 ... argn -&gt; expression ) </code>.</p><p id="r-421010" data-claire-element-id="421010">Voilà un autre exemple intéressant :</p><pre id="r-421011" data-claire-element-id="421011"><code data-claire-semantic="haskell">ajouter n liste = map (\x -&gt; x+n) liste</code></pre><p id="r-421012" data-claire-element-id="421012">Cette fonction ajoute un nombre à chacun des éléments d'une liste. Elle montre une propriété intéressante des fonctions anonymes : elles <em>capturent</em> leur environnement : dans le corps de la fonction anonyme, n désigne le n de l'endroit où la fonction a été <em>définie</em>.</p><p id="r-421013" data-claire-element-id="421013">Enfin, il existe une notation spéciale quand on utilise des opérateurs simples appelée la <em>section d'opérateur</em> :</p><pre id="r-421014" data-claire-element-id="421014"><code data-claire-semantic="haskell">ajouter1 liste = map (+1) liste
multiplierPar2 liste = map (*2) liste
inverser liste = map (1/) liste</code></pre><p id="r-421015" data-claire-element-id="421015">Vous remarquez que dans <code data-claire-semantic="haskell">(+1) </code>, <code data-claire-semantic="haskell">(*2) </code> et <code data-claire-semantic="haskell">(/1) </code>, il y a à chaque fois un &quot;trou&quot;, c'est-à-dire qu'il manque un argument à l'opérateur. En fait, cette notation équivaut à la fonction anonyme qui prend un argument, et où l'argument prend la place de ce qui manque. Par exemple, <code data-claire-semantic="haskell">(+1) </code> est équivalent à <code data-claire-semantic="haskell">(\x -&gt; x + 1) </code>.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">
<span class="arrow"></span>
<span class="next">Programmation fonctionnelle</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
<span class="next">Fonctions sur les listes</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Fonctionssurleslistes"></a><h2>Fonctions sur les listes</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
<span class="arrow"></span>
<span class="next">Exemple : la fonction map</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
<span class="next">Composer des fonctions</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-fonctions-sur-les-listes" data-claire-element-id="421063">Fonctions sur les listes</h4><p id="r-421019" data-claire-element-id="421019">Il y a d'autres fonctions très utilisées sur les listes qui, comme map, prennent une fonction comme argument.</p><h5 id="r-filtrer-les-elements-1" data-claire-element-id="421029">Filtrer les éléments</h5><p id="r-421020" data-claire-element-id="421020">La fonction filter permet de sélectionner seulement certains éléments d'une liste. Elle a pour type <code data-claire-semantic="haskell">(a -&gt; Bool) -&gt; [a] -&gt; [a]</code>, et elle renvoie la liste de tous les éléments pour lesquels la fonction renvoie True.<br/> Par exemple, on peut s'en servir pour trouver les diviseurs d'un nombre :</p><pre id="r-421021" data-claire-element-id="421021"><code data-claire-semantic="haskell">d `divise` n = n `mod` d == 0
diviseurs n = filter (`divise` n) [1..n]</code></pre><p id="r-421022" data-claire-element-id="421022">Les fonctions break et span ont toutes les deux pour type <code data-claire-semantic="haskell">(a -&gt; Bool) -&gt; [a] -&gt; ([a],[a])</code>. break coupe la liste au premier endroit où le prédicat (la fonction donnée en argument, qui renvoie un booléen) renvoie True, et renvoie les deux parties. La fonction span coupe la liste en deux parties, la première est le plus long préfixe où tous les éléments respectent le prédicat. Par exemple, on peut se servir de span pour couper une chaîne de caractère comme &quot;47 pommes&quot; en 47 et &quot;pommes&quot; :</p><pre id="r-421023" data-claire-element-id="421023"><code data-claire-semantic="haskell">chiffres = ['0'..'9']
lettre = ['a'..'z'] ++ ['A'..'Z']

-- ces fonctions renvoient True si le caractère donné en argument est un chiffre/une lettre
isChiffre car = car `elem` chiffres
isLettre car = car `elem` lettres

-- On doit donner le type, pour que read sache ce qu'il faut essayer de lire
lireNombre :: String -&gt; (Integer,String)
lireNombre xs = let (nombre, suite) = span isChiffre xs in -- vaut (&quot;47&quot;,&quot; pommes&quot;) si l'entrée est &quot;47 pommes&quot;
                let (_,unite) = break isLettre suite in    -- unite vaut &quot;pommes&quot;
                (read nombre, unite)                       -- (47,&quot;pommes&quot;)</code></pre><p id="r-421024" data-claire-element-id="421024">En fait, break et span sont presque la même fonction : break retourne le plus long préfixe sur lequel le prédicat renvoie False (puisqu'il coupe dès que le prédicat renvoie True) et le reste de la liste, alors que span retourne le plus long préfixe sur lequel le prédicat renvoie True et le reste de la liste. Il suffit donc d'inverser le prédicat pour passer de break à span.</p><aside id="r-421026" data-claire-element-id="421026" data-claire-semantic="information"><p id="r-421025" data-claire-element-id="421025">Comme dans cet exemple, on peut utiliser du filtrage de motif avec let. C'est très pratique pour récupérer des éléments depuis un n-uplet renvoyé par une fonction, mais on ne peut mettre qu'un seul motif possible, donc on ne peut pas faire tout ce qui est faisable avec case.</p></aside><p id="r-421027" data-claire-element-id="421027">Il existe aussi des fonctions takeWhile et dropWhile, qui font presque la même chose que take et drop : takeWhile renvoie une liste qui contient tous les éléments jusqu'au premier élément pour lequel le prédicat renvoie faux (c'est donc le premier élément du résultat de span), et dropWhile correspond à l'autre partie de la liste.</p><p id="r-421028" data-claire-element-id="421028">N'hésitez pas à essayer de coder votre propre version de toutes ces fonctions, vous en savez assez pour le faire. Vous ne pourrez pas leur donner le même nom que la fonction qui existe déjà dans le Prelude, sinon vous aurez une erreur quand vous essaierez de l'appeler.</p><h5 id="r-fold-et-scan" data-claire-element-id="421062">fold et scan</h5><h6 id="r-foldr-une-fonction-tres-generale" data-claire-element-id="421042">foldr, une fonction très générale</h6><p id="r-421030" data-claire-element-id="421030">Reprenons les fonctions somme et produit du chapitre précédent :</p><pre id="r-421031" data-claire-element-id="421031"><code data-claire-semantic="haskell">somme [] = 0
somme (x:xs) = x + somme xs

produit [] = 1
produit (x:xs) = x *  produit xs</code></pre><p id="r-421032" data-claire-element-id="421032">Ces deux fonctions ont beaucoup en commun : les seules différences sont que l'on remplace + par * et 0 par 1. On peut donc factoriser les parties communes en une fonction qu'on va appeler reduire, qui prend deux arguments de plus :</p><pre id="r-421033" data-claire-element-id="421033"><code data-claire-semantic="haskell">reduire _ n [] = n
reduire f n (x:xs) = f x (reduire f n xs)

somme liste = reduire (+) 0 liste
produit liste = reduire (*) 1 liste</code></pre><p id="r-421034" data-claire-element-id="421034">En fait, la fonction reduire existe déjà par défaut : elle s'appelle foldr, et a pour type <code data-claire-semantic="haskell">(a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code>. La fonction fold est en fait une fonction très générale et très puissante, car elle permet de réécrire toutes les fonctions récursives qui parcourent la liste en entier, de la forme suivante :</p><pre id="r-421035" data-claire-element-id="421035"><code data-claire-semantic="haskell">f [] = k
f (x:xs) = g x (f xs)</code></pre><p id="r-421036" data-claire-element-id="421037"><a href="../../en.wikipedia.org/wiki/File_Right-fold-transformation.html"><img id="r-421037" data-claire-element-id="421036" src="medias/uploads.siteduzero.com_files_179001_180000_179844.png" alt="Image utilisateur"/></a>Finalement, <code data-claire-semantic="haskell">foldr f n [x,y,z]</code> donne <code data-claire-semantic="haskell">f x (f y (f z n))</code>. Cette idée est illustrée par le schéma ci-contre : <code data-claire-semantic="haskell">foldr f n liste</code> revient à transformer tous les constructeurs : en appels à f, et [] par n. Par exemple <code data-claire-semantic="haskell">foldr (:) [] liste</code> renvoie la liste sans la modifier. C'est donc une transformation très naturelle sur les listes, et très souvent utilisée. Ce type de transformation se généralise très bien sur d'autres structures de données récursives.</p><p id="r-421038" data-claire-element-id="421038">Par exemple, on peut recoder la fonction length, avec une fonction qui ignore l'élément et rajoute 1 à la longueur :</p><pre id="r-421039" data-claire-element-id="421039"><code data-claire-semantic="haskell">longueur liste = foldr (\ _ longueurReste -&gt; 1 + longueurReste) 0 liste</code></pre><p id="r-421040" data-claire-element-id="421040">Vous pouvez aussi essayer de coder map et filter de cette façon.</p><p id="r-421041" data-claire-element-id="421041">foldr est une fonction intéressante à utiliser, parce qu'elle est souvent plus concise que la version où la récursivité est explicite. De plus, elle sera probablement plus claire pour quelqu'un habitué à utiliser foldr. Enfin, foldr donne des informations utiles sur la façon dont la liste sera parcourue; c'est pourquoi il est souvent mieux d'utiliser foldr qu'écrire soi-même la récursivité.</p><h6 id="r-foldl-un-fold-dans-l-autre-sens" data-claire-element-id="421055">foldl : un fold dans l'autre sens</h6><p id="r-421043" data-claire-element-id="421043">Maintenant, prenons la fonction renverser :</p><pre id="r-421044" data-claire-element-id="421044"><code data-claire-semantic="haskell">renverser l = renverser' l []

renverser' [] suite = suite
renverser' (x:xs) suite = renverser' xs (x:suite)</code></pre><p id="r-421045" data-claire-element-id="421045">On peut réécrire avec la fonction foldl, définie par :</p><pre id="r-421046" data-claire-element-id="421046"><code data-claire-semantic="haskell">foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a
foldl f n [] = n
foldl f n (x:xs) = foldl f (f x n) xs

renverser liste = foldl (\x y -&gt; y:x) [] liste</code></pre><p id="r-421047" data-claire-element-id="421047">En utilisant cette fonction, on peut réécrire les versions tail-récursies des fonctions somme et produit :</p><pre id="r-421048" data-claire-element-id="421048"><code data-claire-semantic="haskell">somme liste = somme' 0 liste
somme' s [] = s
somme' s (x:xs) = somme' (x+s) xs

produit liste = produit' 1 liste
produit' p [] = p
produit' p (x:xs) = produit' (x*p) xs</code></pre><p id="r-421049" data-claire-element-id="421049">On obtient alors :</p><pre id="r-421050" data-claire-element-id="421050"><code data-claire-semantic="haskell">somme liste = foldl (+) 0 liste
produit liste = foldl (*) 1 liste</code></pre><figure id="r-421052" data-claire-element-id="421053"><img id="r-421051" data-claire-element-id="421051" src="medias/uploads.siteduzero.com_files_179001_180000_179903.png" alt="Image utilisateur"/></figure><p id="r-421054" data-claire-element-id="421054">Alors que <code data-claire-semantic="haskell">foldr f n [x,y,z]</code> donne <code data-claire-semantic="haskell">f x (f y (f z n))</code>, <code data-claire-semantic="haskell">foldl f n [x,y,z]</code> donne <code data-claire-semantic="haskell">f (f (f n x) y) z</code> : le sens des appels de fonction est donc renversé. Cela correspond au schéma ci-contre. Dans le cas de +, l'ordre d'évaluation ne change rien : <code data-claire-semantic="haskell">((0+1)+2)+3</code> donne le même résultat que <code data-claire-semantic="haskell">1+(2+(3+0))</code>. Cependant, avec certaines opérations, passer de foldr à foldl change le résultat. Par exemple, <code data-claire-semantic="haskell">foldr (:) [] liste</code> renvoie la liste, alors que <code data-claire-semantic="haskell">foldl (\x y -&gt; y:x) [] liste</code> la renverse.<br/> Avec la fonction reverse, il faut parcourir toute la liste donnée en argument pour pouvoir renvoyer le premier élément du résultat. C'est la même chose pour la fonction foldl : elle joue mal avec l'évaluation paresseuse. Si vous devez choisir entre deux codes tout aussi clairs, l'un utilisant foldl et l'autre foldr (par exemple, <code data-claire-semantic="haskell">somme liste = foldr (+) 0 liste</code> et <code data-claire-semantic="haskell">somme' liste = foldl (+) 0 liste</code>), le meilleur choix est d'utiliser foldr, qui utilise un modèle de récursivité plus simple à comprendre.</p><h6 id="r-variantes-1" data-claire-element-id="421061">Variantes</h6><p id="r-421056" data-claire-element-id="421056">Les fonctions foldl et foldr ne nous permettent pas de coder facilement la fonction myMinimum, qui prend le minimum d'une liste. En effet, sans fold, voici la fonction qu'on coderait :</p><pre id="r-421057" data-claire-element-id="421057"><code data-claire-semantic="haskell">myMinimum [x] = x
myMinimum (x:xs) = min x (myMinimum xs)</code></pre><p id="r-421058" data-claire-element-id="421058">Il existe cependant une fonction foldr1 qui permet de faire cela : le premier élément de la liste est utilisé comme valeur initiale. Son type est <code data-claire-semantic="haskell">(a -&gt; a -&gt; a) -&gt; [a] -&gt; [a]</code>.<br/> On a donc :</p><pre id="r-421059" data-claire-element-id="421059"><code data-claire-semantic="haskell">myMinimum liste = foldr1 min liste</code></pre><p id="r-421060" data-claire-element-id="421060">Et voilà, c'est aussi simple que ça. Il existe aussi une version de foldl, appelée foldl1 qui joue le même role.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
<span class="arrow"></span>
<span class="next">Exemple : la fonction map</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
<span class="next">Composer des fonctions</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Composerdesfonctions"></a><h2>Composer des fonctions</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
<span class="arrow"></span>
<span class="next">Fonctions sur les listes</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">
<span class="next">Créez vos propres types</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-composer-des-fonctions-1" data-claire-element-id="421116">Composer des fonctions</h4><h5 id="r-le-sens-de-la-fleche" data-claire-element-id="421092">Le sens de la flèche</h5><h6 id="r-ce-qu-on-aimerait-bien-faire" data-claire-element-id="421073">Ce qu'on aimerait bien faire</h6><p id="r-421064" data-claire-element-id="421064">Avec les fonctions anonymes, on peut définir des fonctions comme on définirait des variables :</p><pre id="r-421065" data-claire-element-id="421065"><code data-claire-semantic="haskell">mafonction = (\x y -&gt; blabla)
-- ce code est équivalent à :
mafonction x y = blabla</code></pre><p id="r-421066" data-claire-element-id="421066">Si on reprend la fonction map, on remarque qu'on l'utilise très souvent pour définir une fonction qui prend une liste et la donne en argument à <code data-claire-semantic="haskell">map f </code>, où f est une fonction. On va donc essayer de créer une fonction mapF pour factoriser ce code : mapF prend en argument une fonction, et renvoie une fonction qui prend en argument une liste et renvoie la liste transformée avec la fonction</p><pre id="r-421067" data-claire-element-id="421067"><code data-claire-semantic="haskell">foisDeux xs = map (*2) xs
plusUn xs =  map (+1) xs

mapF f = (\xs -&gt; map f xs)
-- on peut redéfinir nos fonctions en utilisant mapF
foisDeux' = mapF (*2)
plusUn' = mapF (+1)</code></pre><p id="r-421068" data-claire-element-id="421068">On remarque que l'on n'a plus à mentionner la liste qui est transformée : c'est un style de programmation différent, où au lieu de se concentrer sur les données qu'on prend en argument, manipule et renvoie, on prend un autre point de vue et on crée des transformations (des fonctions) en combinant des fonctions de base avec des fonctions d'ordre supérieur comme mapF. On peut aussi créer les fonctions filterF et foldrF, qui sont les équivalents de filter et foldr :</p><pre id="r-421069" data-claire-element-id="421069"><code data-claire-semantic="haskell">filterF p = (\xs -&gt; filter p xs)
foldrF f k = (\xs -&gt; foldr f k xs)

somme = foldrF (+) 0  -- Somme des éléments d'une liste
pairs = filterF even      -- Renvoie tous les éléments pairs</code></pre><p id="r-421070" data-claire-element-id="421070">Pour vous exercer, essayez de deviner les types de mapF et filterF :</p><div id="r-421072" data-claire-element-id="421072"><pre id="r-421071" data-claire-element-id="421071"><code data-claire-semantic="haskell">mapF :: (a -&gt; b) -&gt; ([a] -&gt; [b])
filterF :: (a -&gt; Bool) -&gt; ([a] -&gt; [a])</code></pre></div><h6 id="r-l-application-partielle" data-claire-element-id="421086">L'application partielle</h6><p id="r-421074" data-claire-element-id="421074">Maintenant que vous avez recodé vos fonctions d'ordre supérieur préférées pour penser en termes de transformations, voilà la bonne nouvelle : vous avez fait tout ça pour rien. En effet, il existe un mécanisme appelé l'application partielle qui permet de ne pas avoir à coder les fonctions mapF, filterF, etc. <br/> Prenons la fonction f ci-dessous comme exemple :</p><pre id="r-421075" data-claire-element-id="421075"><code data-claire-semantic="haskell">f :: String -&gt; Int -&gt; String
f x n = concat (replicate n x)</code></pre><p id="r-421076" data-claire-element-id="421076">Quand on applique la fonction (c'est-à-dire on l'appelle) sans avoir fourni le bon nombre d'arguments, on obtient une fonction qui prend les arguments manquants et renvoie le résultat :</p><pre id="r-421077" data-claire-element-id="421077"><code data-claire-semantic="console">Prelude&gt; let g = f &quot;NI! &quot;
Prelude&gt; :t g
g :: Int -&gt; String
Prelude&gt; g 5
&quot;NI! NI! NI! NI! NI!&quot;</code></pre><p id="r-421078" data-claire-element-id="421078">Ici, en définissant g, on a appliqué partiellement la fonction f, ce qui a donné une fonction qui, quand on lui donne un nombre, affiche ce nombre de fois &quot;NI! &quot;.<br/> On se rend compte qu'on peut utiliser l'application partielle pour remplacer mapF :</p><pre id="r-421079" data-claire-element-id="421079"><code data-claire-semantic="haskell">foisDeux = map (*2)
-- c'est la même chose que :
foisDeux xs = map (*2) xs</code></pre><p id="r-421080" data-claire-element-id="421080">On peut faire de même pour filterF et foldrF. Finalement, cela veut dire que quand on a des fonctions définies comme <code data-claire-semantic="haskell">fonction x = f a b c d x </code>, on peut enlever l'argument et se retrouver avec <code data-claire-semantic="haskell">fonction = f a b c d </code>. Par exemple, essayez de réécrire les fonctions suivantes :</p><pre id="r-421081" data-claire-element-id="421081"><code data-claire-semantic="haskell">somme xs = foldr (+) 0 xs
produit xs = foldr (*) 1 xs
impairs xs = filter odd xs
plusUn xs = map (+1) xs
listesFoisDeux xss = map (\xs -&gt; map (*2) xs) xss</code></pre><p id="r-421082" data-claire-element-id="421082"></p><div id="r-421085" data-claire-element-id="421085"><p id="r-421083" data-claire-element-id="421083">On obtient :</p><pre id="r-421084" data-claire-element-id="421084"><code data-claire-semantic="haskell">somme = foldr (+) 0
produit = foldr (*) 1
impairs = filter odd
plusUn = map (+1)
listesFoisDeux = map (map (*2))</code></pre></div><h6 id="r-des-fonctions-qui-renvoient-des-fonctions" data-claire-element-id="421091">Des fonctions qui renvoient des fonctions</h6><p id="r-421087" data-claire-element-id="421087">En fait, il n'y a aucune différence entre les fonctions map et mapF. Cela vient en fait de la manière dont l'application partielle fonctionne. <br/> Regardons les types et les définitions de map et mapF :</p><pre id="r-421088" data-claire-element-id="421088"><code data-claire-semantic="haskell">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
map = (\f xs -&gt; ... )

mapF :: (a -&gt; b) -&gt; ([a] -&gt; [b])
mapF = (\f -&gt; (\xs -&gt; ... ))</code></pre><p id="r-421089" data-claire-element-id="421089">La seule différence entre ces deux fonctions est une paire de parenthèses autour de <code data-claire-semantic="haskell">[a] -&gt; [b] </code> et deux fonctions anonymes imbriquées au lieu d'une. Ces deux fonctions seraient donc les mêmes si les fonctions à plusieurs arguments étaient des fonctions qui prennent un argument et renvoient des fonctions à un argument, et ainsi de suite, jusqu'à renvoyer le résultat. <br/> C'est exactement ce qui se produit : quand on écrit le type <code data-claire-semantic="haskell">a -&gt; b -&gt; c -&gt; d </code>, il est en réalité compris comme <code data-claire-semantic="haskell">a -&gt; (b -&gt; (c -&gt; d)) </code>. De même, quand on écrit une fonction anonyme <code data-claire-semantic="haskell">(\a b c -&gt; quelque chose) </code>, c'est comme si on écrivait <code data-claire-semantic="haskell">(\a -&gt; (\b -&gt; (\c -&gt; quelque chose))) </code>. Et on a la même chose pour l'application de fonction : au lieu d'écrire <code data-claire-semantic="haskell">((f a) b) c </code> (c'est-à-dire appliquer la fonction f à a, appliquer la fonction renvoyer à b, puis à c, ce qui donnerait le &quot;quelque chose&quot; de notre fonction définie plus haut), on peut simplement écrire <code data-claire-semantic="haskell">f a b c </code>.<br/> Vous pouvez voir que c'est comme ça que fonctionne l'application partielle : quand on donne seulement un argument à une fonction, elle renvoie bien une autre fonction qui prend les arguments restants et renvoie le résultat. On dit que les fonctions sont <em>curryfiées</em> (du nom d'<a href="http://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>)</p><p id="r-421090" data-claire-element-id="421090">Après ce passage un peu abstrait, nous allons voir quelques applications intéressantes de cette idée.</p><h5 id="r-quelques-fonctions-d-ordre-superieur" data-claire-element-id="421115">Quelques fonctions d'ordre supérieur</h5><h6 id="r-quelques-fonctions-de-base-1" data-claire-element-id="421103">Quelques fonctions de base</h6><p id="r-421093" data-claire-element-id="421093">L'opérateur <strong>$</strong> est plutôt utile. Pourtant, sa définition est très simple :</p><pre id="r-421094" data-claire-element-id="421094"><code data-claire-semantic="haskell">f $ x = f x</code></pre><p id="r-421095" data-claire-element-id="421095">Cet opérateur correspond donc à l'application de fonction. Cependant, il y a une grosse différence entre les deux : ils n'ont pas la même priorité. On se sert surtout de $ pour supprimer des parenthèses, comme dans l'exemple suivant (<code data-claire-semantic="haskell">Just </code> est en réalité un constructeur, mais les constructeurs peuvent s'utiliser exactement de la même manière qu'une fonction).</p><pre id="r-421096" data-claire-element-id="421096"><code data-claire-semantic="haskell">plusMaybe a b = Just (a+b)
-- on peut le remplacer par :
plusMaybe a b = Just $ a + b</code></pre><p id="r-421097" data-claire-element-id="421097">$ a aussi une utilité avec la section d'opérateurs : par exemple, imaginons qu'on ait une liste de fonctions, et qu'on veuille la liste des valeurs renvoyées par chacune de ces fonctions quand on leur donne une valeur en argument :</p><pre id="r-421098" data-claire-element-id="421098"><code data-claire-semantic="haskell">fonctions = [(+1),(*2),(3-),(2/),abs]
resultats = map (\f -&gt; f 5) fonctions

-- on peut aussi écrire :
resultats = map ($ 5) fonctions</code></pre><p id="r-421099" data-claire-element-id="421099">Une autre fonction parfois utile est la fonction flip. Vous devriez pouvoir deviner ce qu'elle fait simplement avec son type, qui est <code data-claire-semantic="haskell">flip :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c) </code> : la fonction flip renverse les arguments d'une fonction. En fait, on peut aussi noter le type de la fonction comme <code data-claire-semantic="haskell">flip :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c </code>. Cela veut dire qu'on peut écrire des choses comme ceci :</p><pre id="r-421100" data-claire-element-id="421100"><code data-claire-semantic="haskell">reverse = foldl (flip (:)) [] -- Une définition de reverse sans utiliser de fonction anonyme

flipFilter = flip filter -- la fonction filter avec ses arguments renversés
selectEntiers = flipFilter [0..]
-- on peut en fait écrire :
selectEntiers = flip filter [0..]</code></pre><p id="r-421101" data-claire-element-id="421101">Mais on peut aussi passer une fonction à plus de deux arguments à flip, et l'effet de flip sera d'inverser les deux premiers arguments (ça se voit très bien en regardant le type). Dans le cas de flip, la curryfication des fonctions est très utile, puisqu'elle permet de ne pas avoir à écrire un flip dépendant du nombre d'arguments de la fonction, et de fournir sans problème un argument à la fonction après avoir appelé flip. Finalement, vous pouvez écrire vous-même une définition pour flip :</p><pre id="r-421102" data-claire-element-id="421102"><code data-claire-semantic="haskell">flip' f a b = f b a</code></pre><h6 id="r-composer-des-fonctions" data-claire-element-id="421114">Composer des fonctions</h6><p id="r-421104" data-claire-element-id="421104">Une fonction très utile (et que vous rencontrerez souvent si vous voulez lire du code) est l'opérateur <code data-claire-semantic="haskell">. </code>. On note <code data-claire-semantic="haskell">f . g </code> la <em>composition</em> des fonctions f et g. Vous avez peut-être déjà rencontré cette opération en maths, notée f \circ g. En fait, on a <code data-claire-semantic="haskell">(f . g) x = f (g x) </code>. Vous comprendrez mieux comment ça marche avec quelques exemples :</p><pre id="r-421105" data-claire-element-id="421105"><code data-claire-semantic="haskell">foisDeux = (*2)
plusUn = (+1)

maFonction x = 2*x+1 -- on peut aussi écrire :
maFonction' = (+1) . (*2)</code></pre><p id="r-421106" data-claire-element-id="421106">Maintenant, vous pouvez regarder le type de ., et essayer de comprendre (comme avec flip) comment cet opérateur interagit avec les fonctions qui prennent plus d'un argument.</p><p id="r-421107" data-claire-element-id="421107">On peut bien sûr mettre plus de 2 fonctions à la suite :</p><pre id="r-421108" data-claire-element-id="421108"><code data-claire-semantic="haskell">sommeCarresPairs xs = sum . map (^2) . filter even $ xs
-- on pourrait aussi écrire 
sommeCarresPairs' = sum . map (^2) . filter even</code></pre><p id="r-421109" data-claire-element-id="421109">Cette façon d'écrire les fonctions, sans indiquer les arguments, est assez utilisée en Haskell. Dans beaucoup de cas, ça rend le code plus concis, et facile à lire (plus besoin de faire attention aux 3 niveaux de parenthèses imbriquées. Mais dans certains cas, cela peut donner du code complètement illisible, où il est impossible de deviner ce que fait un enchaînement de points. Par exemple, regardons le code suivant, qui teste si un élément est dans une liste :</p><pre id="r-421110" data-claire-element-id="421110"><code data-claire-semantic="haskell">mem x xs = any (== x) xs

-- On transforme ça simplement en :
mem' x = any (==x) -- Cette fonction est encore raisonnablement lisible

-- Mais on peut pousser le style plus loin :
mem'' = any . (==)</code></pre><p id="r-421111" data-claire-element-id="421111">Si vous essayez de comprendre comment marche la fonction <code data-claire-semantic="haskell">mem'' </code>, vous vous apercevrez qu'elle fait exactement la même chose que la fonction <code data-claire-semantic="haskell">mem </code>. Cependant, cette dernière version est totalement illisible. C'est très pratique pour gagner un concours où il faut un code le plus court possible, mais si vous n'êtes pas dans ce cas, pensez à ceux qui vont relire votre code (vous y compris). Il ne faut surtout pas hésiter à donner des noms à des résultats ou des fonctions intermédiaires pour clarifier le fonctionnement de la fonction.<br/> Certains s'amusent à essayer de réécrire (ou d'écrire directement) du code de cette façon. Juste pour l'exemple, voici quelques opérateurs effrayants tirés de la page <a href="http://haskell.org/haskellwiki/Pointfree">http://haskell.org/haskellwiki/Pointfree</a> :</p><pre id="r-421112" data-claire-element-id="421112"><code data-claire-semantic="haskell">owl = ((.)$(.))
dot = ((.).(.))
swing =  flip . (. flip id)</code></pre><p id="r-421113" data-claire-element-id="421113">Ce chapitre sur la programmation fonctionnelle est terminée. Les fonctions d'ordre supérieur sont utilisées partout en Haskell, et si vous voyez quelque chose qui se répète, votre premier réflexe doit être de chercher à factoriser le code, parce que moins de code, c'est moins de bugs, et c'est un programme plus facile à comprendre. De plus, cela vous entraînera à appliquer les techniques vues dans ce chapitre.<br/> Dans le prochain chapitre, on s'attaque à deux choses très importantes : les types et les classes de types. Alors que jusqu'à maintenant, vous n'avez fait qu'utiliser les types prédéfinis, vous allez apprendre à créer vos propres types, et à les utiliser pour, par exemple, manipuler des opérations mathématiques... et pourquoi pas créer un interpréteur pour un petit langage de programmation ?</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
<span class="arrow"></span>
<span class="next">Fonctions sur les listes</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">
<span class="next">Créez vos propres types</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Crezvosproprestypes"></a><h2>Créez vos propres types</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
<span class="arrow"></span>
<span class="next">Composer des fonctions</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
<span class="next">Déclarer un type</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-421118" data-claire-element-id="421118">Haskell est un langage au typage fort et statique. Les types ont souvent une assez grande importance dans un programme : ils permettent d'éviter un certain nombre de bugs, en vérifiant qu'on manipule toujours les données de manière correcte. Mais les types prédéfinis ne suffisent pas toujours à assurer ces propriétés.</p><p id="r-421119" data-claire-element-id="421119">Par exemple, que faire si on veut un type similaire à Either mais avec 3 possibilités ? Si on représente les coordonnées d'un point dans l'espace par un triplet de réels, et qu'on utilise la même représentation pour une couleur, comment faire pour ne pas les confondre ? Et quel type utiliser pour représenter un arbre binaire ?</p><p id="r-421120" data-claire-element-id="421120">Pour résoudre tous ces problèmes, il faut pouvoir créer de nouveaux types, ce qui est le sujet de la première partie de ce chapitre. La partie suivante s'intéresse aux classes de types : avec quelques exemples, vous verrez comment déclarer un type comme instance d'une classe, et comment créer vos propres classes de types.</p>
</div><a name="Dclareruntype"></a><h2>Déclarer un type</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">
<span class="arrow"></span>
<span class="next">Créez vos propres types</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
<span class="next">Des instances de classes de types</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-declarer-un-type" data-claire-element-id="421227">Déclarer un type</h4><p id="r-421121" data-claire-element-id="421121">Il existe trois manières de déclarer un type en Haskell, qui ont toutes une utilité différente.</p><h5 id="r-type-un-autre-nom-pour-un-type" data-claire-element-id="421131">type : un autre nom pour un type</h5><p id="r-421122" data-claire-element-id="421122">Avec <code data-claire-semantic="haskell">type</code>, vous pouvez déclarer un nouveau nom pour un type qui existe déjà. Par exemple, vous avez déjà vu que le type <code data-claire-semantic="haskell">String</code> est en fait un autre nom pour le type <code data-claire-semantic="haskell">[Char]</code>. En réalité, le type String est défini de la façon suivante :</p><pre id="r-421123" data-claire-element-id="421123"><code data-claire-semantic="haskell">type String = [Char]</code></pre><p id="r-421124" data-claire-element-id="421124">Ce genre de définition ne crée pas à proprement parler un nouveau type : les deux types String et [Char] sont interchangeables, String n'est qu'un autre nom pour [Char]. Cependant, ce genre de définition présente un avantage quand on écrit le type d'une variable. Par exemple, si on utilise <code data-claire-semantic="haskell">(Double,Double,Double)</code> comme type pour représenter une couleur, et qu'on crée une liste de couleurs, si on indique le type comme dans l'exemple ci-dessous, son rôle est assez obscur :</p><pre id="r-421125" data-claire-element-id="421125"><code data-claire-semantic="haskell">palette :: [(Double,Double,Double)]
palette = [(1,0,0), (0,1,1), (0,1,0)]

inverser :: (Double,Double,Double) -&gt; (Double,Double,Double)
inverser (r,g,b) = (1-r,1-g,1-b)</code></pre><p id="r-421126" data-claire-element-id="421126">Comparez avec ce code-là, où on a défini un type avec <code data-claire-semantic="haskell">type</code>. Le code est tout de suite plus clair, et comme c'est moins long d'écrire les signatures de chaque valeur, vous pourrez toutes les écrire sans perdre votre temps, ce qui fait que le code est plus sûr et plus compréhensible.</p><pre id="r-421127" data-claire-element-id="421127"><code data-claire-semantic="haskell">type Couleur = (Double, Double, Double)

palette :: [Couleur]
palette = [(1,0,0), (0,1,1), (0,1,0)]

inverser :: Couleur -&gt; Couleur
inverser (r,g,b) = (1-r,1-g,1-b)</code></pre><p id="r-421128" data-claire-element-id="421128">Pour définir en général un nouveau nom pour un type déjà existant, il faut écrire : <code data-claire-semantic="haskell">type NomDuType = UnAutreType (Au,Nom) Super Long</code></p><aside id="r-421130" data-claire-element-id="421130" data-claire-semantic="information"><p id="r-421129" data-claire-element-id="421129">Les noms de types doivent toujours commencer par une majuscule. Par exemple, MonSuperType est un nom valide, pas monSuperType</p></aside><h5 id="r-utiliser-data-pour-definir-des-types-algebriques" data-claire-element-id="421163">Utiliser data pour définir des types algébriques</h5><p id="r-421132" data-claire-element-id="421132">La deuxième manière de déclarer des types utilise <code data-claire-semantic="haskell">data</code>. Cette construction permet de faire beaucoup de choses, comme vous allez le voir dans les paragraphes qui suivent.</p><h6 id="r-des-enumerations" data-claire-element-id="421141">Des énumérations</h6><p id="r-421133" data-claire-element-id="421133">Imaginons que vous êtes en train de coder un logiciel pour un marchand de glace. Ce marchand vend des glaces avec plusieurs goûts différents, et certains coûtent plus cher que d'autres. Il faut donc coder une fonction qui, pour un parfum donné, renvoie le prix d'une boule de glace à ce goût-là. Pour cela, il faut d'abord vous demander comment vous allez représenter un parfum. Une première solution serait d'utiliser des chaînes de caractères; la fonction ressemblerait à ceci :</p><pre id="r-421134" data-claire-element-id="421134"><code data-claire-semantic="haskell">type Parfum = String

prixParfum :: Parfum -&gt; Double
prixParfum &quot;chocolat&quot; = 1.5
prixParfum &quot;vanille&quot; = 1.2
prixParfum &quot;framboise&quot; = 1.4</code></pre><p id="r-421135" data-claire-element-id="421135">Le problème, c'est qu'il est très facile d'introduire des valeurs invalides, comme &quot;qsd%ù&amp;é&quot; (ou de faire une faute d'orthographe quelque part dans le code). Pour être sûr de ne pas faire d'erreur, il faudrait mettre beaucoup de vérifications dans toutes les fonctions qui utilisent des parfums. Et même dans ce cas, on ne profite pas du système de types : les erreurs ne sont pas détectées à la compilation. On pourrait représenter les parfums avec des entiers, mais on se retrouve avec le même problème. On va donc utiliser data pour faire une énumération :</p><pre id="r-421136" data-claire-element-id="421136"><code data-claire-semantic="haskell">data Parfum = Chocolat 
     	     | Vanille 
	     | Framboise
	deriving Show</code></pre><p id="r-421137" data-claire-element-id="421137">Cette fois, on a créé un nouveau type. Cette déclaration veut dire qu'une valeur de type Parfum est soit Fraise, soit Framboise, soit Chocolat. Le <code data-claire-semantic="haskell">deriving Show</code> à la fin de la déclaration fait que ghc génère automatiquement une instance de Show pour notre type, si c'est possible. Cela nous permet notamment de travailler facilement avec dans ghci, c'est donc une bonne idée de l'indiquer.<br/> Maintenant, pour traiter des valeurs de notre nouveau type, on doit utiliser le filtrage de motif. Ici, on définit la fonction prixParfum pour utiliser notre nouveau type :</p><pre id="r-421138" data-claire-element-id="421138"><code data-claire-semantic="haskell">prixParfum :: Parfum -&gt; Double
prixParfum Chocolat = 1.5
prixParfum Vanille = 1.2
prixParfum Framboise = 1.4</code></pre><p id="r-421139" data-claire-element-id="421139">On peut définir d'autres énumérations avec data, mais un nom ne doit être utilisé qu'une fois. Il est donc impossible de créer une autre énumération qui comprend une valeur comme Chocolat, Vanille ou Framboise. On peut redéfinir les booléens de cette façon :</p><pre id="r-421140" data-claire-element-id="421140"><code data-claire-semantic="haskell">data Booleen = Vrai | Faux</code></pre><h6 id="r-types-algebriques" data-claire-element-id="421150">Types algébriques</h6><p id="r-421142" data-claire-element-id="421142">Vous savez maintenant utiliser data pour créer des énumérations. Mais ce n'est qu'un cas particulier de quelque chose de plus général : les types algébriques, qu'on définit avec data.<br/> Revenons à notre logiciel pour commander des glaces. Le glacier fait deux types de glace : des glaces à une boule, et des glaces à deux boules. On pourrait utiliser une liste pour représenter ces deux types de glace, mais dans ce cas, on risque d'avoir des commandes pour des glaces à 0 boule ou à 3 boules, alors que le glacier n'en fait pas. On va donc utiliser data pour créer un nouveau type :</p><pre id="r-421143" data-claire-element-id="421143"><code data-claire-semantic="haskell">data Glace = UneBoule Parfum
           | DeuxBoules Parfum Parfum
    deriving Show</code></pre><p id="r-421144" data-claire-element-id="421144">Si on prononce &quot;|&quot; comme &quot;ou&quot;, le sens de cette déclaration devient évident : une glace est soit une glace à une boule ayant un parfum, soit une glace à deux boules ayant deux parfums. Ensuite, on utilise le filtrage de motif pour différencier les deux cas dans nos fonctions :</p><pre id="r-421145" data-claire-element-id="421145"><code data-claire-semantic="haskell">prixGlace (UneBoule a) = 0.10 + prixParfum a
prixGlace (DeuxBoules a b) = 0.15 + prixParfum a + prixParfum b</code></pre><p id="r-421146" data-claire-element-id="421146">Ainsi, pour créer un type avec data, on donne une liste de possibilité (les différents constructeurs, UneBoule et DeuxBoules dans le cas de glace), et les attributs qui correspondent à chaque possibilité.<br/> Par exemple, pour un programme de dessin, on pourrait vouloir représenter des formes géométriques : cercle et rectangle. Pour définir un cercle, on a besoin de son centre (un point), et de son rayon; pour définir un rectangle, il faut deux points : la position du sommet en bas à gauche, et celle du sommet en haut à droite. Vous pouvez donc essayer d'écrire le type correspondant, et des fonctions <code data-claire-semantic="haskell">aire</code> et <code data-claire-semantic="haskell">perimetre</code> qui renvoient l'aire et le périmètre d'une forme.</p><pre id="r-421147" data-claire-element-id="421147"><code data-claire-semantic="haskell">type Point = (Float,Float)

data Forme = Cercle Point Float | Rectangle Point Point

aire :: Forme -&gt; Float
aire (Rectangle (a,b) (c,d)) = abs (a-c) * abs (b-d)
aire (Cercle _ r) = pi * r^2

perimetre :: Forme -&gt; Float
perimetre (Rectangle (a,b) (c,d)) = 2 * ( abs (a-c) + abs (b-d) )
perimetre (Cercle _ r) = 2 * pi * r</code></pre><aside id="r-421149" data-claire-element-id="421149" data-claire-semantic="information"><p id="r-421148" data-claire-element-id="421148">La troisième façon de définir des types en Haskell est d'utiliser <code data-claire-semantic="haskell">newtype</code>. En fait, newtype est un cas particulier de data : il permet seulement de définir des types à un seul constructeur, et ce constructeur ne doit prendre qu'un seul argument. Par exemple, pour éviter de mélanger les points avec autre chose, on pourrait écrire <code data-claire-semantic="haskell">newtype Point = Point (Float, Float)</code> (le Point à gauche du signe = est un nom de type, celui à droite le nom d'un constructeur de type, donc utiliser deux fois le nom Point ne pose pas de problème ici). La seule différence est qu'avec newtype, le compilateur sait qu'une valeur de type Point utilise forcément le constructeur Point, donc peut optimiser le programme pour qu'il fonctionne comme si on utilisait le type <code data-claire-semantic="haskell">(Float,Float)</code> à la place de <code data-claire-semantic="haskell">Point</code>. Cependant, quand le compilateur vérifie les types, les deux types sont différents, ce qui permet de repérer les erreurs où on utilise l'un à la place de l'autre.</p></aside><h6 id="r-enregistrements" data-claire-element-id="421162">Enregistrements</h6><p id="r-421151" data-claire-element-id="421151">Maintenant, le glacier veut garder un profil de chacun de ses utilisateurs. Pour cela, il veut stocker le nom, le prénom, l'adresse e-mail, la date des première et dernière commandes de ce client, et la somme totale dépensée chez le glacier. On a donc toutes les informations nécessaires pour créer un type, et quelques fonctions utiles :</p><pre id="r-421152" data-claire-element-id="421152"><code data-claire-semantic="haskell">data Date = Date Int Int Int -- Une date : jour/mois/année

data Client = Client String String String Date Date Float

-- Créer un nouveau client qui n'a encore rien commandé
nouveauClient :: String -&gt; String -&gt; String -&gt; Client
nouveauClient nom prenom mail = Client nom prenom mail (Date 0 0 0) (Date 0 0 0) 0

-- Actualiser les infos d'un client qui vient de passer une commande
actualiserClient : Date -&gt; Float -&gt; Client -&gt; Client
actualiserClient date somme (Client nom prenom mail premiereCommande _ sommeCommandes) =
    Client nom prenom mail premiereCommande date (sommeCommandes + somme)

-- Donne l'adresse mail d'un client
mailClient :: Client -&gt; String
mailClient (Client _ _ mail _ _ _) = mail</code></pre><p id="r-421153" data-claire-element-id="421153">Comme vous le voyez, ce type n'est pas facile à manipuler : on ne voit pas nettement le nom des champs, donc on risque d'inverser l'ordre de deux champs de même type, et d'avoir une erreur non trouvée par le système de type, ce n'est pas facile d'accéder à un champ du type, et quand on veut modifier une valeur, on est obligé de copier toutes les autres explicitement, ce qui fait du code vraiment très lourd.</p><p id="r-421154" data-claire-element-id="421154">Heureusement, pour ce genre de choses, on peut utiliser les enregistrements. On définit un type d'enregistrement comme ceci :</p><pre id="r-421155" data-claire-element-id="421155"><code data-claire-semantic="haskell">data Client = Client {
      nom :: String,
      prenom :: String,
      mail :: String,
      premiereCommande :: Date,
      derniereCommande :: Date,
      sommeCommandes :: Float
    } deriving Show</code></pre><p id="r-421156" data-claire-element-id="421156">On peut toujours créer un client en utilisant le constructeur et en donnant la valeur des champs dans l'ordre, mais on peut aussi indiquer le nom des champs. Dans ce cas, l'ordre n'importe pas :</p><pre id="r-421157" data-claire-element-id="421157"><code data-claire-semantic="haskell">unClient = Client { nom = &quot;Dupont&quot;,
                    prenom = &quot;Hubert&quot;,
                    mail = &quot;<a class="__cf_email__" href="http://www.cloudflare.com/email-protection" data-cfemail="4a223f282f383e642e3f3a25243e0a2f322b273a262f64292527">[email&nbsp;protected]</a><script type="text/javascript">
/* <![CDATA[ */
(function(){try{var s,a,i,j,r,c,l,b=document.getElementsByTagName("script");l=b[b.length-1].previousSibling;a=l.getAttribute('data-cfemail');if(a){s='';r=parseInt(a.substr(0,2),16);for(j=2;a.length-j;j+=2){c=parseInt(a.substr(j,2),16)^r;s+=String.fromCharCode(c);}s=document.createTextNode(s);l.parentNode.replaceChild(s,l);}}catch(e){}})();
/* ]]> */
</script>&quot;,
                    premiereCommande = Date 1 2 2003,
                    derniereCommande = Date 9 9 2009,
                    sommeCommandes = 13.3
                  }

autreClient = Client &quot;Dupont&quot; &quot;Robert&quot; &quot;<a class="__cf_email__" href="http://www.cloudflare.com/email-protection" data-cfemail="98eafcede8f7f6ecd8fde0f9f5e8f4fdb6fbf7f5">[email&nbsp;protected]</a><script type="text/javascript">
/* <![CDATA[ */
(function(){try{var s,a,i,j,r,c,l,b=document.getElementsByTagName("script");l=b[b.length-1].previousSibling;a=l.getAttribute('data-cfemail');if(a){s='';r=parseInt(a.substr(0,2),16);for(j=2;a.length-j;j+=2){c=parseInt(a.substr(j,2),16)^r;s+=String.fromCharCode(c);}s=document.createTextNode(s);l.parentNode.replaceChild(s,l);}}catch(e){}})();
/* ]]> */
</script>&quot; (Date 29 2 2003) (Date 1 10 2009) 42</code></pre><p id="r-421158" data-claire-element-id="421158">On peut aussi utiliser le nom des champs avec le filtrage de motif. Cependant, quand on définit un enregistrement, des fonctions sont automatiquement créées pour accéder à chacun des champs :</p><pre id="r-421159" data-claire-element-id="421159"><code data-claire-semantic="haskell">nomPrenom (Client {nom = nom, prenom = prenom}) = nom ++ &quot; &quot; ++ prenom

nomPrenom' client = nom client ++ &quot; &quot; ++ prenom client</code></pre><p id="r-421160" data-claire-element-id="421160">Enfin, on dispose d'une syntaxe plus pratique pour modifier seulement quelques champs d'un enregistrement :</p><pre id="r-421161" data-claire-element-id="421161"><code data-claire-semantic="haskell">actualiserClient :: Date -&gt; Float -&gt; Client -&gt; Client
actualiserClient date somme client = client {
                                       derniereCommande = date, 
                                       sommeCommandes = sommeCommandes client + somme
                                     }</code></pre><h5 id="r-types-recursifs-types-parametres" data-claire-element-id="421177">Types récursifs, types paramétrés</h5><h6 id="r-des-parametres-pour-les-types" data-claire-element-id="421171">Des paramètres pour les types</h6><p id="r-421164" data-claire-element-id="421164">Dans cette partie, on va créer un nouveau type qui correspond aux listes à au moins un élément. Ce n'est pas forcément un type utile dans toutes les situations, mais des fois il peut être utile, pour des opérations qui n'ont pas de sens sur des listes vides. Une façon simple de créer un type qui correspond est de prendre une paire constituée d'un élément, et d'une liste d'éléments, ce qui garantit qu'on a au moins un élément. Cependant, en essayant de déclarer un tel type, vous allez avoir un problème : quel est le type de l'élément ?<br/> On va commencer par définir notre type pour les entiers, et une ou deux fonctions :</p><pre id="r-421165" data-claire-element-id="421165"><code data-claire-semantic="haskell">data SomeInt = SomeInt Int [Int]

someIntToList :: SomeInt -&gt; [Int]
someIntToList (SomeInt x xs) = x:xs

addInt :: Int -&gt; SomeInt -&gt; SomeInt
addInt i s = SomeInt i (someIntToList s)</code></pre><p id="r-421166" data-claire-element-id="421166">On pourrait alors redéfinir un type à chaque fois qu'on veut un type différent pour les éléments. Mais ça nous oblige aussi à redéfinir les fonctions. On pourrait le faire par copier-coller, mais vous savez déjà que c'est une bonne façon de faire des erreurs bêtes, et de les copier partout dans le programme pour les rendre impossible à corriger, et que ça va à l'encontre du premier principe du programmeur (et de n'importe qui) : faire le moins possible de choses inutiles et inintéressantes. Dans ce cas, les fonctions ne font rien de spécial sur les éléments contenus dans le type SomeInt, on devrait donc pouvoir en faire des fonctions polymorphes. C'est ce qu'on ferait avec des listes, ou avec Maybe. <br/> Pour résoudre ce problème, on va utiliser les types paramétrés :</p><pre id="r-421167" data-claire-element-id="421167"><code data-claire-semantic="haskell">data Some a = Some a [a]

someToList :: Some a -&gt; [a]
someToList (Some x xs) = x:xs

add :: a -&gt; Some a -&gt; Some a
add i s = Some i (someToList s)</code></pre><p id="r-421168" data-claire-element-id="421168">En fait, vous aviez déjà utilisé des types paramétrés, comme Maybe ou le type des listes. La seule chose que vous ne saviez pas faire, c'est en définir. Maintenant, vous êtes capables de redéfinir le type Maybe, mais pas encore le type des listes : ce sera le sujet de la suite.</p><p id="r-421169" data-claire-element-id="421169">Notez que vous pouvez aussi utiliser des paramètres quand vous déclarez un alias avec type, de la même façon qu'avec data. Il est aussi possible de prendre plusieurs paramètres. Vous pouvez donc définir des types comme :</p><pre id="r-421170" data-claire-element-id="421170"><code data-claire-semantic="haskell">-- Ce type représente des listes d'associations : par exemple [(&quot;Jean Dupont&quot;, 42), (&quot;Jean Bon&quot;, 12)]
-- pour représenter l'argent dans le compte en banque d'un certain nombre de personnes
type Assoc a b = [(a,b)]</code></pre><h6 id="r-types-recursifs" data-claire-element-id="421176">Types récursifs</h6><p id="r-421172" data-claire-element-id="421172">Rappelez-vous du chapitre sur les suites : elles sont définies par deux constructeurs possibles, <code data-claire-semantic="haskell">[]</code> (la liste vide), et <code data-claire-semantic="haskell">:</code> qui permet d'ajouter un élément en tête d'une liste, et qui prend donc deux arguments, un élément et une liste d'éléments. Ce type est défini en fonction de lui même : c'est un type récursif. <br/> Pour vous montrer comment définir des types récursifs, on va créer un type <code data-claire-semantic="haskell">MyList a</code>, qui correspond en fait au type <code data-claire-semantic="haskell">[a]</code>, avec deux constructeurs : Nil et Cons.</p><pre id="r-421173" data-claire-element-id="421173"><code data-claire-semantic="haskell">data MyList a = Nil | Cons a (MyList a)</code></pre><p id="r-421174" data-claire-element-id="421174">Voilà, définir un type récursif n'est pas vraiment compliqué. Ensuite, on peut l'utiliser comme n'importe quel type normal :</p><pre id="r-421175" data-claire-element-id="421175"><code data-claire-semantic="haskell">liste = Cons 1 (Cons 2 (Cons 3 Nil))</code></pre><h5 id="r-exemples-20" data-claire-element-id="421226">Exemples</h5><h6 id="r-manipuler-des-arbres" data-claire-element-id="421197">Manipuler des arbres</h6><figure id="r-421179" data-claire-element-id="421180"><img id="r-421178" data-claire-element-id="421178" src="medias/uploads.siteduzero.com_files_197001_198000_197405.png" alt="Image utilisateur"/></figure><p id="r-421181" data-claire-element-id="421181">Un arbre binaire est une structure de donnée qui peut se représenter sous la forme d'un arbre, dont chaque noeud contient une valeur et deux éléments fils (c'est à dire deux arbres), comme sur la figure ci-contre.<br/> On voit bien qu'une telle structure de données se définit très facilement de manière récursive : à chaque niveau, soit on est arrivé au bout de l'arbre (représenté par le constructeur Feuille), soit on arrive à un embranchement, où l'arbre se sépare en deux branches. À chaque embranchement, on trouve un élément.</p><pre id="r-421182" data-claire-element-id="421182"><code data-claire-semantic="haskell">data Arbre a = Branche a (Arbre a) (Arbre a)
             | Feuille 
               deriving Show</code></pre><p id="r-421183" data-claire-element-id="421183">Par exemple, l'arbre donné comme exemple est représenté de la façon suivante :</p><pre id="r-421184" data-claire-element-id="421184"><code data-claire-semantic="haskell">arbreExemple = Branche 1 
                (Branche 2 
                  (Branche 4 Feuille Feuille) 
                  (Branche 5 
                   (Branche 7 Feuille Feuille) 
                   (Branche 8 Feuille Feuille)))
                (Branche 3 
                  Feuille
                  (Branche 6
                    (Branche 9 Feuille Feuille)
                    Feuille))</code></pre><p id="r-421185" data-claire-element-id="421185">On appelle profondeur d'un arbre la distance maximale de la racine à une Feuille. Par exemple, si la racine est une Feuille, la profondeur vaut 0. On peut donc calculer la profondeur d'un arbre à l'aide d'une fonction récursive. On veut aussi des fonctions pour calculer le nombre de branches et le nombre de feuilles d'un arbre. On crée aussi une fonction permettant de calculer la somme des éléments d'un arbre.</p><pre id="r-421186" data-claire-element-id="421186"><code data-claire-semantic="haskell">profondeur Feuille = 0
profondeur (Branche _ gauche droite) = 1 + max (profondeur gauche) (profondeur droite)

feuilles Feuille = 1
feuilles (Branche _ gauche droite) = feuilles gauche + feuilles droite

branches Feuille = 0
branches (Branche _ gauche droite) = 1 + branches gauche + branches droite

somme Feuille = 0
somme (Branche el gauche droite) = el + somme gauche + somme droite</code></pre><p id="r-421187" data-claire-element-id="421187">Comme vous pouvez le constater, ces fonctions se ressemblent beaucoup : on donne une valeur fixée pour les Feuilles, et pour chaque Branche, on combine les résultats obtenus avec la fonction sur les deux sous-arbres. On aimerait bien créer une fonction d'ordre supérieur pour factoriser ce code. Si vous suivez vraiment attentivement, vous devriez avoir une impression de déjà vu : dans le chapitre sur les listes, c'est à partir d'un procédé de récursivité utilisé par un certain nombre de fonctions qu'on a montré l'utilité de la fonction foldr sur les listes. Et en effet, la fonction d'ordre supérieur foldArbre qu'on va créer suit le même principe :</p><pre id="r-421188" data-claire-element-id="421188"><code data-claire-semantic="haskell">foldArbre f n Feuille = n
foldArbre f n (Branche e d g) = f e (foldArbre f n d) (foldArbre f n g)

profondeur' = foldArbre (\ _ d g -&gt; 1 + max d g) 0
feuilles' = foldArbre (\ _ d g -&gt; d + g) 1
branches' = foldArbre (\ _ d g -&gt; 1 + d + g) 0
somme' = foldArbre (\ e d g -&gt; e + d + g) 0

retourner = foldArbre (\ e d g -&gt; Branche e g d) Feuille</code></pre><p id="r-421189" data-claire-element-id="421189">Pour vous convaincre de la similarité entre foldr et foldArbre, comparez ces deux schémas :</p><figure id="r-421191" data-claire-element-id="421192"><img id="r-421190" data-claire-element-id="421190" src="medias/uploads.siteduzero.com_files_179001_180000_179844.png" alt="Image utilisateur"/></figure><figure id="r-421194" data-claire-element-id="421195"><img id="r-421193" data-claire-element-id="421193" src="medias/uploads.siteduzero.com_files_197001_198000_197406.png" alt="Image utilisateur"/></figure><p id="r-421196" data-claire-element-id="421196">Dans les deux schémas, fold remplace tous les constructeurs Branche par un appel à la fonction f, et tous les constructeurs Branche (qui ne prennent pas d'argument) par la valeur z. On peut définir de manière similaire une opération fold sur tous les types récursifs.</p><h6 id="r-arbres-binaires-de-recherche" data-claire-element-id="421216">Arbres binaires de recherche</h6><figure id="r-421199" data-claire-element-id="421200"><img id="r-421198" data-claire-element-id="421198" src="medias/uploads.siteduzero.com_files_197001_198000_197408.png" alt="Image utilisateur"/></figure><p id="r-421201" data-claire-element-id="421201">Les arbres binaires servent de base à un certain nombre de structures de données. Une structure simple et pourtant intéressante est l'arbre binaire de recherche (ou ABR). C'est un arbre binaire qui doit respecter une propriété particulière : pour chaque noeud de l'arbre, tous les éléments dans la branche gauche de l'arbre doivent être inférieurs à l'élément placé dans le noeud, et tous ceux situés à droite doivent être supérieurs. Par exemple, l'arbre ci-contre est un arbre binaire de recherche, mais celui donné comme exemple d'arbre n'en est pas un.</p><p id="r-421202" data-claire-element-id="421202">On peut déjà créer une fonction qui teste si un arbre est un ABR ou pas, et la tester dans ghci :</p><pre id="r-421203" data-claire-element-id="421203"><code data-claire-semantic="haskell">-- teste si une propriété p est respectée par tous les éléments d'un arbre
allArbre _ Feuille = True
allArbre p (Branche e g d) = p e &amp;&amp; allArbre p g &amp;&amp; allArbre p d

abrValide Feuille = True
abrValide (Branche e g d) = allArbre (&lt; e) g &amp;&amp; allArbre (&gt; e) d &amp;&amp; abrValide g &amp;&amp; abrValide d

abr = Branche 10 
      (Branche 5 Feuille (Branche 8 (Branche 7 Feuille Feuille) (Branche 9 Feuille Feuille)))
      (Branche 20 
       (Branche 15 (Branche 12 Feuille Feuille) (Branche 17 Feuille Feuille))
       (Branche 25 Feuille Feuille))

invalide = Branche 10 Feuille (Branche 3 Feuille Feuille)</code></pre><pre id="r-421204" data-claire-element-id="421204"><code data-claire-semantic="console">Prelude&gt; abrValide abr
True
Prelude&gt; abrValide invalide
False</code></pre><p id="r-421205" data-claire-element-id="421205">Si un arbre binaire s'appelle un arbre binaire de recherche, c'est bien parce qu'il est facile de rechercher des éléments dedans. Imaginons qu'on veuille vérifier si un élément est dans l'arbre. On se trouve donc à une Branche. Soit l'élément se trouve à cette branche, soit il se trouve à gauche, soit il se trouve à droite. On doit donc parcourir tout l'arbre pour savoir si un élément se trouve dans l'arbre avec cette méthode, ce n'est donc pas plus efficace que de chercher dans une simple liste. Cependant, on n'a pas pris en compte la propriété de l'arbre binaire de recherche, donc notre algorithme marche même sur un arbre binaire normal.<br/> Dans le cas des arbres binaires de recherche, on sait que les éléments sont ordonnés. Donc, quand on se trouve à une Branche, on peut décider de quel côté aller chercher l'élément. On a donc qui un algorithme, qui au lieu d'explorer les deux possibilités à chaque branche n'en choisit qu'une seule : il est donc beaucoup plus performant.</p><pre id="r-421206" data-claire-element-id="421206"><code data-claire-semantic="haskell">rechercher _ Feuille = False
rechercher e (Branche f g d) | e == f = True
                             | e &lt; f = rechercher e g
                             | e &gt; f = rechercher e d</code></pre><p id="r-421207" data-claire-element-id="421207">On teste ce code dans ghci pour voir s'il marche comme prévu :</p><pre id="r-421208" data-claire-element-id="421208"><code data-claire-semantic="console">*Main&gt; rechercher 15 abr
True
*Main&gt; rechercher 10 abr
True
*Main&gt; rechercher 100 abr
False</code></pre><p id="r-421209" data-claire-element-id="421209">Et voilà, il a l'air de marcher correctement. Maintenant, on a besoin d'autres opérations pour manipuler les ABR, par exemple ajouter et supprimer des éléments. Pour ajouter un élément, on fait comme pour rechercher un élément, sauf qu'on reconstruit un nouvel arbre avec les données, et qu'on ajoute l'élément dès qu'on rencontre une feuille :</p><pre id="r-421210" data-claire-element-id="421210"><code data-claire-semantic="haskell">inserer e Feuille = Branche e Feuille Feuille
inserer e (Branche f g d) | e == f = Branche f g d
                          | e &lt; f = Branche f (inserer e g) d
                          | e &gt; f = Branche f g (inserer e d)</code></pre><p id="r-421211" data-claire-element-id="421211">Ce code ne modifie pas l'arbre, mais en renvoie un nouveau. On pourrait donc s'inquiéter de ses performances : est-ce que tout l'arbre est copié à chaque fois pour rendre cela possible ? En regardant le code, vous pouvez trouver la réponse : seules les branches qui sont sur le chemin pour aller de la racine à l'élément qu'on a inséré ont été recréées. Les performances sont donc plutôt bonnes : avec une liste, il aurait fallu en moyenne recréer la moitié de la liste, alors que là on ne recopie que quelques branches de l'arbre.<br/> D'ailleurs, on peut se servir de l'arbre binaire de recherche pour faire un tri plus rapide que le tri par insertion : au lieu d'insérer les éléments dans une liste triée, on les insère dans un ABR (donc trié lui aussi). Pour cela, on doit coder deux fonctions auxiliaires : une fonction <code data-claire-semantic="haskell">construireArbre</code>, qui construit un arbre binaire de recherche à partir d'une liste triée, et d'une fonction <code data-claire-semantic="haskell">aplatir</code> qui renvoie une liste triée constituée de tous les éléments d'un arbre binaire.</p><pre id="r-421212" data-claire-element-id="421212"><code data-claire-semantic="haskell">-- construire un arbre à partir d'une liste
construireArbre :: (Ord a) =&gt; [a] -&gt; Arbre a
construireArbre = foldr inserer Feuille

aplatir :: Arbre a -&gt; [a]
aplatir = foldArbre (\e g d -&gt; g ++ [e] ++ d) []
-- version sans foldArbre :
aplatir' Feuille = []
aplatir' (Branche e g d) = aplatir' g ++ [e] ++ aplatir' d

triABR :: (Ord a) =&gt; [a] -&gt; [a]
triABR = aplatir . construireArbre</code></pre><p id="r-421213" data-claire-element-id="421213">Une dernière opération utile sur les ABR est la suppression d'un élément (autrement dit, créer un nouvel arbre auquel on a enlevé un élément donné). C'est une opération un peu plus délicate à effectuer, et je vous invite à y réfléchir et à essayer de la coder vous-même avant de lire la solution (avec du papier et un crayon, c'est plus facile pour dessiner les arbres).<br/> Puisqu'on sait déjà trouver un élément dans un arbre, on peut se ramener au cas où l'élément que l'on souhaite supprimer se trouve à la racine. Ensuite, on doit envisager différents cas suivant le ce qu'on trouve en allant à droite et à gauche : si on trouve deux Feuilles, il suffit de remplacer la racine par une Feuille. Si on trouve une Feuille et une Branche, on remplace la racine par cette Branche. Le cas compliqué est celui où on a deux branches. On doit donc chercher un nouvel élément qui servira de racine : pour cela, on prend le plus grand élément de la branche de gauche.</p><pre id="r-421214" data-claire-element-id="421214"><code data-claire-semantic="haskell">supprimerPlusGrand (Branche e g Feuille) = (g,e)
supprimerPlusGrand (Branche e g d) = let (d',grand) = supprimerPlusGrand d in 
                                     (Branche e g d', grand) 

supprimerRacine (Branche _ Feuille Feuille) = Feuille
supprimerRacine (Branche _ g Feuille) = g
supprimerRacine (Branche _ Feuille d) = d
supprimerRacine (Branche _ g d) = Branche e' g' d
    where (g',e') = supprimerPlusGrand g

supprimer _ Feuille = Feuille
supprimer e (Branche f g d) | e == f = supprimerRacine (Branche f g d)
                            | e &lt; f = Branche f (supprimer e g) d
                            | e &gt; f = Branche f g (supprimer e d)</code></pre><p id="r-421215" data-claire-element-id="421215">On a donc vu comment utiliser les arbres binaires de recherche comme structure de données pour représenter des ensembles, et les opérations qui vont avec.<br/> Un problème se pose cependant. Quand on introduit successivement des éléments déjà ordonnés dans un ABR, à chaque fois l'élément qu'on insère va se retrouver à droite de l'arbre. Donc, tous les éléments vont être concentrés d'un côté, ce qui fait qu'on se retrouve finalement avec des opérations de recherche, d'insertion et de suppression inefficaces. Par exemple, avec un arbre à 2^n éléments, il faut 2^n opérations dans le pire des cas pour trouver si un élément est dans l'arbre. Au contraire, si l'arbre est équilibré (c'est-à-dire si la feuille qui est à la plus grande profondeur n'a pas une profondeur très différente de celle qui est le plus proche de la racine), il va avoir à peu près une profondeur de n, et donc il faudra n opérations pour rechercher un élément. Il existe des arbres où les opérations de modification rééquilibrent automatiquement l'arbre : c'est le cas des <a href="http://fr.wikipedia.org/wiki/Arbre_AVL">arbres AVL</a> et des <a href="http://fr.wikipedia.org/wiki/Arbre_bicolore">arbres rouge-noir</a>.</p><h6 id="r-representer-des-expressions-mathematiques" data-claire-element-id="421225">Représenter des expressions mathématiques</h6><p id="r-421217" data-claire-element-id="421217">On peut aussi utiliser des types algébriques récursifs pour représenter un petit langage de programmation. Par exemple, ici on va créer un type qui représente des expressions mathématiques simples (addition, multiplication, soustraction). Le constructeur Litt permet d'utiliser des valeurs littérales dans les expressions (par exemple <code data-claire-semantic="haskell">Lit 42</code>), et Var sert à représenter une variable.</p><pre id="r-421218" data-claire-element-id="421218"><code data-claire-semantic="haskell">data Expr =
            Litt Integer
          | Var String
          | Add Expr Expr
          | Mul Expr Expr
            deriving (Eq, Show)

-- Exemple : cette expression correspond à x^2+7x+1
test = Add (Mul (Var &quot;x&quot;) (Var &quot;x&quot;)) (Add (Mul (Litt 7) (Var &quot;x&quot;)) (Litt 1))</code></pre><p id="r-421219" data-claire-element-id="421219">On peut commencer par coder une fonction pour évaluer une expression, c'est-à-dire donner sa valeur. Elle prend en argument un contexte, qui donne la valeur des variables utilisées, et bien sûr une expression. Pour des raisons de simplicité, on ne s'occupera pas de la gestion des erreurs, par exemple si on ne connaît pas la valeur d'une variable utilisée.</p><pre id="r-421220" data-claire-element-id="421220"><code data-claire-semantic="haskell">-- Cette fonction renvoie la valeur d'une variable dans le contexte ctx
valeur ctx var = snd $ head $ filter (\(nom,_) -&gt; nom == var) ctx

eval ctx (Add a b) = eval ctx a + eval ctx b
eval ctx (Mul a b) = eval ctx a * eval ctx b
eval ctx (Litt a) = a
eval ctx (Var s) = valeur ctx s 

-- On évalue l'expression test pour x=5
valTest = eval [(&quot;x&quot;,5)] test</code></pre><p id="r-421221" data-claire-element-id="421221">Le code pour évaluer nos expressions est donc plutôt simple. En revanche, la syntaxe pour écrire les expressions est très lourde : on pourrait vouloir créer un parser pour nos expressions mathématiques, qui transforme une chaîne de caractère comme <code data-claire-semantic="haskell">(x^2+72x+2)(20+y+xy)</code> en la valeur du type Expr qui correspond. Si vous cherchez quelque chose à faire, ça peut être amusant de regarder comment faire. En tout cas, vous verrez dans la prochaine sous-partie une astuce amusante pour ne pas avoir à faire ça vous même.</p><p id="r-421222" data-claire-element-id="421222">On peut aussi coder des fonctions qui font des transformations sur les expressions : développer, évaluer tout ce qui peut être évalué sans connaître la valeur de toutes les variables, réduire une expression (regrouper les termes en x ensembles, puis les termes en x^2, ...</p><pre id="r-421223" data-claire-element-id="421223"><code data-claire-semantic="haskell">developper (Add x y) = Add (developper x) (developper y)
developper (Mul x y) = case (developper x, developper y) of
                          (Add a b,y') -&gt; developper (Add (Mul a y') (Mul b y'))
                          (x', Add a b) -&gt; developper (Add (Mul x' a) (Mul x' b))
                          (x',y') -&gt; Mul x' y'
developper e = e</code></pre><p id="r-421224" data-claire-element-id="421224">Il y a beaucoup de choses intéressantes à faire à partir de ça : vous pouvez coder d'autres fonctions de manipulation des expressions mathématiques (par exemple, mettre les expressions dans une forme correcte ou essayer de factoriser une expression) ou bien rajouter des opérations à ce tout petit langage de base pour créer un petit langage de programmation.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">
<span class="arrow"></span>
<span class="next">Créez vos propres types</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
<span class="next">Des instances de classes de types</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Desinstancesdeclassesdetypes"></a><h2>Des instances de classes de types</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
<span class="arrow"></span>
<span class="next">Déclarer un type</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">
<span class="next">Modules, IO et compilation</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-des-instances-de-classes-de-types" data-claire-element-id="421281">Des instances de classes de types</h4><p id="r-421228" data-claire-element-id="421228">Maintenant que vous pouvez créer vos propres types, vous aurez probablement besoin de créer des instances de classes de types qui leur correspondent. Par exemple, on ne peut pas savoir si des éléments de notre type Parfum sont égaux, puisqu'on n'a pas d'instance de Eq pour Parfum. Cette sous-partie va donc vous apprendre à définir des instances d'une classe de type.</p><h5 id="r-deriving-une-instance-sans-se-fatiguer" data-claire-element-id="421235">deriving : une instance sans se fatiguer</h5><p id="r-421229" data-claire-element-id="421229">La manière la plus simple de créer une instance est d'utiliser <code data-claire-semantic="haskell">deriving </code> : on a déjà utilisé cette technique avec Show, pour pouvoir afficher les valeurs dans ghci. Par exemple, le code ci-dessous permet de déclarer un type Parfum, et en même temps une instance de Eq qui va avec :</p><pre id="r-421230" data-claire-element-id="421230"><code data-claire-semantic="haskell">data Parfum = Chocolat 
     	    | Vanille 
	    | Framboise
	deriving Eq</code></pre><p id="r-421231" data-claire-element-id="421231">On peut dériver des instances de plusieurs classes en utilisant des parenthèses :</p><pre id="r-421232" data-claire-element-id="421232"><code data-claire-semantic="haskell">data Parfum = Chocolat 
     	    | Vanille 
	    | Framboise
	deriving (Eq, Show, Read)</code></pre><pre id="r-421233" data-claire-element-id="421233"><code data-claire-semantic="console">*Main&gt; show Framboise
&quot;Framboise&quot;
*Main&gt; read &quot;Framboise&quot; :: Parfum
Framboise
*Main&gt; Framboise == Chocolat
False
*Main&gt; Vanille == Vanille
True</code></pre><p id="r-421234" data-claire-element-id="421234">Cependant, il y a quelques limitations : d'abord, on ne peut dériver que des instances de classes &quot;simples&quot;, comme Eq, Ord, Read ou Show. Ensuite, l'instance générée n'est pas toujours satisfaisante : par exemple, on pourrait aimer que l'instance de Eq pour les arbres binaires de recherche ne vérifie pas si les deux arbres ont la même forme et les mêmes éléments, mais juste si ils contiennent les mêmes éléments : dans ces deux cas, on doit déclarer l'instance de façon manuelle.</p><h5 id="r-creer-une-instance-1" data-claire-element-id="421250">Créer une instance</h5><h6 id="r-instances-simples" data-claire-element-id="421245">Instances simples</h6><p id="r-421236" data-claire-element-id="421236">La première chose à faire quand on veut créer une instance d'une classe de type est de lire la documentation. En effet, elle indique les fonctions qui doivent être déclarées pour que l'instance soit valide. De plus, parfois, les classes de types fournissent des déclarations par défaut pour certaines fonctions de la classe. Par exemple, la classe Eq fournit une fonction <code data-claire-semantic="haskell">(==) </code> et une fonction <code data-claire-semantic="haskell">(/=) </code>. Cependant, il est très facile de définir == à partir de /= et inversement : ces deux fonctions ont donc une déclaration par défaut qui utilise l'autre, et ce serait inutile de déclarer les deux.<br/> Une fois que vous avez trouvé les informations nécessaires, vous pouvez déclarer votre instance (avant cela, enlevez le <code data-claire-semantic="haskell">deriving Eq </code> de la déclaration de Parfum).</p><pre id="r-421237" data-claire-element-id="421237"><code data-claire-semantic="haskell">instance Eq Parfum where
    Chocolat == Chocolat = True
    Vanille == Vanille = True
    Framboise == Framboise = True
    _ == _ = False</code></pre><p id="r-421238" data-claire-element-id="421238">Maintenant, vous avez une préférence pour les parfums des glaces, donc vous aimeriez bien les ordonner, de celui que vous aimez le plus à celui que vous aimez le moins. Pour cet exemple, on va dire que dans l'ordre, les parfums préférés sont Framboise, Chocolat et Vanille mais je ne veux pas déclencher une guerre de religion sur les parfums de glace, donc si vous voulez un autre ordre, vous avez le droit de le changer.<br/> Donc, première étape, on va chercher la documentation de Ord. Cette classe de type est définie dans le Prelude, donc sa documentation devrait se trouver ici : <a href="http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/Prelude.html">http://www.haskell.org/ghc/docs/6.10.4 [...] /Prelude.html</a>. Ensuite, regardez dans la partie Synopsis : vous trouverez une ligne qui ressemble à <code data-claire-semantic="haskell">class Eq a =&gt; Ord a where </code>. C'est ce que vous cherchez, donc cliquez sur le mot Ord. Vous trouvez une liste de fonctions qui font parties de la classe, et cette phrase :</p><p id="r-421239" data-claire-element-id="421239"><cite>Citation : documentation</cite></p><blockquote id="r-421241" data-claire-element-id="421241"><p id="r-421240" data-claire-element-id="421240">Minimal complete definition: either <code data-claire-semantic="haskell">compare </code> or <code data-claire-semantic="haskell">&lt;= </code>. Using <code data-claire-semantic="haskell">compare </code> can be more efficient for complex types.</p></blockquote><p id="r-421242" data-claire-element-id="421242">Cette phrase nous indique donc qu'il suffit de définir soir la fonction compare, soit l'opérateur &lt;=. Pour cet exemple, on va choisir de définir &lt;= :</p><pre id="r-421243" data-claire-element-id="421243"><code data-claire-semantic="haskell">instance Ord Parfum where
    _ &lt;= Framboise = True -- La Framboise, c'est le mieux
    Chocolat &lt;= Chocolat = True
    Vanille &lt;= Vanille = True
    Vanille &lt;= Chocolat = True
    _ &lt;= _ = False -- Dans le reste des cas, c'est faux</code></pre><p id="r-421244" data-claire-element-id="421244">Voilà, vous savez définir des classes de types pour des types simples.</p><h6 id="r-pour-des-types-parametres" data-claire-element-id="421249">Pour des types paramétrés</h6><p id="r-421246" data-claire-element-id="421246">Maintenant, on veut définir une instance d'Eq pour notre type Arbre : deux arbres binaires de recherche sont égaux si et seulement s'ils contiennent les mêmes éléments (on ne s'intéresse donc pas à la structure de l'arbre). Cependant, en voulant définir cette instance, on rencontre un problème : les éléments du type <code data-claire-semantic="haskell">Arbre a </code> (éléments de type a) ne sont pas forcément membres de la classe Eq. On doit donc indiquer une condition pour que l'instance soit définie :</p><pre id="r-421247" data-claire-element-id="421247"><code data-claire-semantic="haskell">instance (Eq a) =&gt;  Eq (Arbre a) where
    a == b = aplatir a == aplatir b</code></pre><p id="r-421248" data-claire-element-id="421248">Cette déclaration se lit &quot;Si on peut comparer des a pour l'égalité, on peut comparer des Arbre a pour l'égalité&quot;. Parfois, vous aurez besoin de plusieurs conditions : vous pouvez les séparer par des virgules. Notez aussi qu'on ne peut pas écrire <code data-claire-semantic="haskell">instance (Eq a) =&gt; Eq Arbre </code> : Arbre n'est pas un type mais un constructeur de type, une valeur de type Arbre ne peut pas exister.</p><h5 id="r-des-instances-pour-le-type-expr" data-claire-element-id="421268">Des instances pour le type Expr</h5><p id="r-421251" data-claire-element-id="421251">Nous allons définir deux instances utiles pour le type Expr.</p><h6 id="r-afficher-des-expressions-mathematiques" data-claire-element-id="421260">Afficher des expressions mathématiques</h6><p id="r-421252" data-claire-element-id="421252">Pour l'instant, quand on essayer d'afficher des valeurs de type Expr, on obtient un résultat illisible, comme par exemple <code data-claire-semantic="haskell">Mul (Add (Mul (Var &quot;x&quot;) (Var &quot;x&quot;)) (Add (Mul (Litt 7) (Var &quot;x&quot;)) (Litt 1))) (Add (Add (Mul (Mul (Mul (Var &quot;x&quot;) (Var &quot;x&quot;)) (Mul (Var &quot;x&quot;) (Var &quot;x&quot;))) (Var &quot;x&quot;)) (Mul (Litt 3) (Var &quot;x&quot;))) (Litt 7)) </code> au lieu de <code data-claire-semantic="haskell">(x^2+7*x+1)*(x^5 + 3*x + 7) </code>. On va donc essayer de créer une instance de Show pour résoudre ce problème. On va commencer par une idée simple : remplacer les Mul par des * et les Add par des +. On va aussi rajouter des parenthèses autour de chaque expression pour éviter les problèmes de priorités. On définit aussi quelques expressions pour tester notre instance :</p><pre id="r-421253" data-claire-element-id="421253"><code data-claire-semantic="haskell">instance Show Expr where
    show (Litt a) | a &lt; 0 = &quot;(&quot;++ show a ++ &quot;)&quot;
                  | otherwise = show a
    show (Var s) = s
    show (Add a b) = &quot;(&quot; ++ show a ++ &quot;+&quot; ++ show b ++ &quot;)&quot;
    show (Mul a b) = &quot;(&quot; ++ show a ++ &quot;*&quot; ++ show b ++ &quot;)&quot;

expr1 = Add (Add (Mul (Var &quot;x&quot;) (Var &quot;x&quot;)) (Mul (Litt 3) (Var &quot;x&quot;))) (Litt 7)
expr2 = Add (Add (Mul (Var &quot;x&quot;) (Var &quot;x&quot;)) (Mul (Litt 3) (Mul (Var &quot;y&quot;) (Var &quot;y&quot;)))) (Litt 2)</code></pre><p id="r-421254" data-claire-element-id="421254">On peut comparer les résultats :</p><pre id="r-421255" data-claire-element-id="421255"><code data-claire-semantic="console">### Avant
Main&gt; expr1 * expr2
Mul (Add (Add (Mul (Var &quot;x&quot;) (Var &quot;x&quot;)) (Mul (Litt 3) (Var &quot;x&quot;))) (Litt 7)) (Add (Add (Mul (Var &quot;x&quot;) (Var &quot;x&quot;)) (Mul (Litt 3) (Mul (Var &quot;y&quot;) (Var &quot;y&quot;)))) (Litt 2))
### Après
Main&gt; expr1 * expr2
((((x*x)+(3*x))+7)*(((x*x)+(3*(y*y)))+2))</code></pre><p id="r-421256" data-claire-element-id="421256">C'est un peu mieux, mais il y a des parenthèses en trop : par exemple, <code data-claire-semantic="haskell">Add (Litt 1) (Add (Litt 2) (Litt 3)) </code> est affiché <code data-claire-semantic="haskell">1+(2+3) </code>, alors qu'on pourrait afficher <code data-claire-semantic="haskell">1+2+3 </code>. Cependant, on ne peut pas simplement enlever les parenthèses partout : elles sont nécessaires quand on veut afficher une addition à l'intérieur d'une multiplication. On peut donc mettre un niveau de priorité : le niveau de priorité de l'addition est 0, celui de la multiplication est 1, et on ne peut enlever les parenthèses que si le niveau de priorité de ce qu'on veut afficher est supérieur ou égal au niveau de priorité courant. Cependant, on ne peut pas magiquement rajouter un paramètre pour ça à show : on va devoir créer une autre fonction.</p><pre id="r-421257" data-claire-element-id="421257"><code data-claire-semantic="haskell">-- Cette fonction ajoute les parenthèses si nécessaire
addPar k n s | k &lt;= n = s
             | otherwise = &quot;(&quot; ++ s ++ &quot;)&quot;

showExpr k (Add a b) = addPar k 0 (showExpr 0 a ++ &quot;+&quot; ++ showExpr 0 b)
showExpr k (Mul a b) = addPar k 1 (showExpr 1 a ++ &quot;*&quot; ++ showExpr 1 b)
showExpr _ (Var s) = s
showExpr _ (Litt a) | a &lt; 0 = &quot;(&quot;++ show a ++ &quot;)&quot;
                    | otherwise = show a 

instance Show Expr where
    show e = showExpr 0 e</code></pre><p id="r-421258" data-claire-element-id="421258">En testant dans ghci, on obtient le résultat qu'on attendait :</p><pre id="r-421259" data-claire-element-id="421259"><code data-claire-semantic="console">*Main&gt; expr1 * expr2
(x*x+3*x+7)*(x*x+3*y*y+2)</code></pre><h6 id="r-combiner-les-expressions" data-claire-element-id="421267">Combiner les expressions</h6><p id="r-421261" data-claire-element-id="421261">On peut additionner, soustraire et multiplier des expressions : il est donc naturel de créer une instance de Num pour Expr. Si on regarde la documentation, on voit qu'on doit définir en plus de ces trois opérations les fonctions fromInteger, signum et abs. fromInteger correspond très bien au constructeur Litt, et on va ignorer abs et signum pour l'instant. De plus, on voit que notre type doit obligatoirement pouvoir être affiché (Show) et comparé (Eq) : ces conditions sont déjà réalisées. On peut donc déclarer notre instance :</p><pre id="r-421262" data-claire-element-id="421262"><code data-claire-semantic="haskell">instance Num Expr where
    (+) = Add
    (*) = Mul
    negate = Mul (Litt (-1))
    fromInteger = Litt</code></pre><p id="r-421263" data-claire-element-id="421263">On a préféré déclarer negate plutôt que (-) : la documentation signale que l'on peut déclarer l'un ou l'autre, au choix. Vous aurez un avertissement du compilateur en chargeant ce programme puisqu'il manque les méthodes signum et abs.</p><p id="r-421264" data-claire-element-id="421264">L'avantage de cette instance, c'est qu'on peut écrire des expressions avec les opérations mathématiques normales. On profite même de l'opérateur puissance alors qu'on n'a rien défini pour que ça marche !</p><pre id="r-421265" data-claire-element-id="421265"><code data-claire-semantic="haskell">x = Var &quot;x&quot;
y = Var &quot;y&quot;

exprTest = 3*x^5 + 7*x + 9 + 12 * x * y</code></pre><pre id="r-421266" data-claire-element-id="421266"><code data-claire-semantic="console">*Main&gt; eval [(&quot;x&quot;,5),(&quot;y&quot;,12)] exprTest
10139
*Main&gt;  eval [(&quot;x&quot;,5),(&quot;y&quot;,12)] (exprTest ^ 2)
102799321</code></pre><h5 id="r-creer-des-classes-de-types" data-claire-element-id="421280">Créer des classes de types</h5><p id="r-421269" data-claire-element-id="421269">Vous pouvez aussi créer vos propres classes de types. Par exemple, dans certains langages, on peut utiliser if sur d'autres choses que des booléens : une conversion en booléen est réalisée. Par exemple, une liste vide ou le nombre 0 donneraient False, et une liste non vide donnerait True.<br/> On définit donc notre classe comme ceci :</p><pre id="r-421270" data-claire-element-id="421270"><code data-claire-semantic="haskell">class OuiNon a where
    toBool :: a -&gt; Bool</code></pre><p id="r-421271" data-claire-element-id="421271">Voilà, ce n'est pas compliqué : on indique le nom de la classe de type, puis le type des différentes fonctions qui devront être fournies.</p><p id="r-421272" data-claire-element-id="421272">Ensuite, on rajoute quelques instances :</p><pre id="r-421273" data-claire-element-id="421273"><code data-claire-semantic="haskell">instance OuiNon Bool where
    toBool = id

instance OuiNon Int where
    toBool 0 = False
    toBool _ = True

instance OuiNon Integer where
    toBool 0 = False
    toBool _ = True

instance OuiNon [a] where
    toBool [] = False
    toBool _ = True

instance OuiNon (Arbre a) where
    toBool Feuille = False
    toBool _ = True

instance OuiNon (Maybe a) where
    toBool Nothing = False
    toBool _ = True</code></pre><p id="r-421274" data-claire-element-id="421274">On peut alors tester le code :</p><pre id="r-421275" data-claire-element-id="421275"><code data-claire-semantic="console">Main&gt; toBool Nothing
False
Main&gt; let (a,b) = (0,1)
Main&gt; let f n = if (toBool n) then &quot;YEAH !&quot; else &quot;NON :(&quot;
Main&gt; f a
&quot;NON :(&quot;
Main&gt; f b
&quot;YEAH !&quot;
Main&gt; f []
&quot;NON :(&quot;</code></pre><p id="r-421276" data-claire-element-id="421276">Il est possible de créer des définitions plus compliquées, en ayant par exemple des conditions ou des définitions par défaut pour certaines fonctions, comme par exemple avec la définition de la classe Ord, tirée directement du code source du Prelude (vous pouvez regarder le code source des fonctions qui vous intéressent en cliquant sur le lien &quot;Source&quot; à côté de la documentation de la fonction) :</p><pre id="r-421277" data-claire-element-id="421277"><code data-claire-semantic="haskell">-- Pour qu'on puisse déclarer une instance de Ord, on a besoin d'une instance de Eq
class  (Eq a) =&gt; Ord a  where
    -- on définit les fonctions nécessaires et leurs types
    compare              :: a -&gt; a -&gt; Ordering
    (&lt;), (&lt;=), (&gt;), (&gt;=) :: a -&gt; a -&gt; Bool
    max, min             :: a -&gt; a -&gt; a

    -- Les définitions par défaut : compare est défini en fonction de &lt;= et inversement
    compare x y = if x == y then EQ
                  else if x &lt;= y then LT
                  else GT

    x &lt;  y = case compare x y of { LT -&gt; True;  _ -&gt; False }
    x &lt;= y = case compare x y of { GT -&gt; False; _ -&gt; True }
    x &gt;  y = case compare x y of { GT -&gt; True;  _ -&gt; False }
    x &gt;= y = case compare x y of { LT -&gt; False; _ -&gt; True }

    max x y = if x &lt;= y then y else x
    min x y = if x &lt;= y then x else y</code></pre><p id="r-421278" data-claire-element-id="421278">Vous pouvez lire le code original (et les commentaires associés) ici : <a href="http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/src/GHC-Classes.html#Ord">http://www.haskell.org/ghc/docs/6.10.4 [...] sses.html#Ord</a></p><p id="r-421279" data-claire-element-id="421279">Voilà, ce chapitre est terminé. Dans le prochain chapitre, vous allez voir comment découper votre code en modules, créer des programmes qui interagissent avec l'extérieur et comment les compiler.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
<span class="arrow"></span>
<span class="next">Déclarer un type</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">
<span class="next">Modules, IO et compilation</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="ModulesIOetcompilation"></a><h2>Modules, IO et compilation</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
<span class="arrow"></span>
<span class="next">Des instances de classes de types</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
<span class="next">Créer des modules</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-421283" data-claire-element-id="421283">Ce chapitre va aborder quelques points que vous vous attendriez surement à voir arriver avant. D'abord, vous apprendrez comment utiliser des fonctions qui viennent d'autres modules que le Prelude, et à créer vos propres modules.<br/> Ensuite, vous apprendrez à utiliser les entrées-sorties. Il est un peu plus difficile d'afficher des choses à l'écran en Haskell que dans les autres langages, mais il y a une bonne raison à cela. Ne vous inquiétez pas pour autant : ce n'est pas très compliqué, mais ça demande quelques explications.</p>
</div><a name="Crerdesmodules"></a><h2>Créer des modules</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">
<span class="arrow"></span>
<span class="next">Modules, IO et compilation</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
<span class="next">Entrées et sorties</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-creer-des-modules-1" data-claire-element-id="421320">Créer des modules</h4><h5 id="r-importer-un-module" data-claire-element-id="421307">Importer un module</h5><p id="r-421284" data-claire-element-id="421284">Pour l'instant, on n'a utilisé que les fonctions du Prelude. Mais maintenant, on veut créer une fonction <code data-claire-semantic="haskell">anagramme :: String -&gt; String -&gt; Bool </code>, qui prend deux chaînes de caractères et vérifie si elles forment un anagramme. En réfléchissant un peu, on se rend compte que si, après avoir enlevé les espaces et les avoir triées, les deux chaînes sont égales, on peut renvoyer True. <br/> Il n'y a pas de fonction dans le Prelude pour trier une liste, mais en lisant la documentation, vous vous êtes aperçu que la fonction <code data-claire-semantic="haskell">sort :: [a] -&gt; [a] </code> dans le module <a href="http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/Data-List.html">Data.List</a> fait exactement ce que vous voulez. Comment l'utiliser ?</p><h6 id="r-charger-un-module-dans-ghci" data-claire-element-id="421290">Charger un module dans ghci</h6><p id="r-421285" data-claire-element-id="421285">Pour charger le module dans ghci, vous devez utiliser la commande <code data-claire-semantic="console">:m NomDu.Module</code> :</p><pre id="r-421286" data-claire-element-id="421286"><code data-claire-semantic="console">$ ghci
GHCi, version 6.10.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer ... linking ... done.
Loading package base ... linking ... done.
Prelude&gt; sort [6,5,9,2,1]

&lt;interactive&gt;:1:0: Not in scope: `sort'
Prelude&gt; :m +Data.List
Prelude Data.List&gt; sort [6,5,9,2,1]
[1,2,5,6,9]</code></pre><p id="r-421287" data-claire-element-id="421287">Si vous importez beaucoup de modules, le prompt de ghci (la partie <code data-claire-semantic="haskell">Prelude Data.List&gt; </code>) peut devenir très long. Vos pouvez le remplacer par quelque chose de moins long avec la commande <code data-claire-semantic="console">:set prompt &quot;ghci&gt; &quot;</code> :</p><pre id="r-421288" data-claire-element-id="421288"><code data-claire-semantic="console">*Main&gt; :m +Data.List
*Main Data.List&gt; :m +Data.Map
*Main Data.List Data.Map&gt; :m +Control.Monad
*Main Data.List Data.Map Control.Monad&gt; :m +Control.Concurrent
*Main Data.List Data.Map Control.Monad Control.Concurrent&gt; :set prompt &quot;ghci&gt; &quot;
ghci&gt;</code></pre><p id="r-421289" data-claire-element-id="421289">Pour lire ce code, je vous recommande de lire la documentation des fonctions de Data.Map que vous ne comprenez pas (en particulier celle de la fonction alter).<br/> Maintenant, on va tester ce code en le chargeant dans ghci.</p><h6 id="r-importer-un-module-dans-un-fichier" data-claire-element-id="421306">Importer un module dans un fichier</h6><p id="r-421291" data-claire-element-id="421291">Si vous voulez utiliser la fonction sort dans votre code, il faut rajouter en haut du fichier une ligne comme celle-ci :</p><pre id="r-421292" data-claire-element-id="421292"><code data-claire-semantic="haskell">import Data.List

anagramme xs = xs == reverse xs</code></pre><p id="r-421293" data-claire-element-id="421293">Le module Data.Map est très pratique : il fournit un type pour des dictionnaire qui à une clé associent une valeur, et beaucoup d'opérations plus efficaces que sur les listes. D'ailleurs, l'implémentation est basée sur des arbres binaires équilibrés. Voilà le lien vers la documentation de ce module : <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html">http://www.haskell.org/ghc/docs/latest [...] Data-Map.html</a>.<br/> Par exemple, imaginons que vous voulez créer une fonction pour compter le nombre de fois qu'une lettre apparait dans une chaîne de caractères. Vous allez donc commencer votre module par :</p><pre id="r-421294" data-claire-element-id="421294"><code data-claire-semantic="haskell">import Data.Map

-- Pour compter les lettres, on ajoute au fur et à mesure les lettres trouvées dans notre Map
compterLettres :: String -&gt; Map Char Integer
compterLettres = foldr (alter ajouterLettre) empty

-- Cette fonction modifie la valeur associée à un caractère en fonction de la valeur précédente
ajouterLettre Nothing = Just 1 -- On n'avait pas rencontré le caractère avant
ajouterLettre (Just a) = Just (a+1)

nombreLettres :: Map Char Integer -&gt; Char -&gt; Integer
nombreLettres m c = case lookup c m of
                      Nothing -&gt; 0 -- la lettre n'est pas présente
                      Just a -&gt; a</code></pre><p id="r-421295" data-claire-element-id="421295">Pour lire ce code, je vous recommande de lire la documentation des fonctions de Data.Map que vous ne comprenez pas (en particulier celle de la fonction alter). <br/> Maintenant, on va tester ce code en le chargeant dans ghci :</p><pre id="r-421296" data-claire-element-id="421296"><code data-claire-semantic="console">[1 of 1] Compiling Main             ( realworld.hs, interpreted )

realworld.hs:12:25:
    Ambiguous occurrence `lookup'
    It could refer to either `Prelude.lookup', imported from Prelude
                          or `Data.Map.lookup', imported from Data.Map at realworld.hs:1:0-14
Failed, modules loaded: none.</code></pre><p id="r-421297" data-claire-element-id="421297">On obtient donc une jolie erreur : la fonction <code data-claire-semantic="haskell">lookup </code> est définie à la fois dans le Prelude et dans le module Data.Map, et ces deux modules sont importés : il est donc impossible de savoir à quelle fonction on se réfère.<br/> Pour résoudre ce problème, il y a plusieurs solutions. La première, puisque l'on n'utilise pas la fonction lookup du Prelude, serait de ne pas l'importer. Pour cela, on peut ajouter en haut du fichier une ligne comme celle-ci, pour demander d'avoir toutes les fonctions du Prelude sauf lookup (le Prelude est importé par défaut, cette déclaration annule ce comportement et permet donc de choisir les options souhaitées) :</p><pre id="r-421298" data-claire-element-id="421298"><code data-claire-semantic="haskell">import Prelude hiding (lookup)</code></pre><p id="r-421299" data-claire-element-id="421299">Mais cette solution n'est pas très satisfaisante : pas mal d'autres fonctions de Data.Map utilisent un nom déjà utilisé dans le Prelude, et on pourrait vouloir utiliser la fonction lookup du Prelude dans le même module. L'autre solution est alors d'utiliser un préfixe qu'on devra indiquer quand on appelle les fonctions de Data.Map. Pour faire cela, on peut utiliser une déclaration comme ceci :</p><pre id="r-421300" data-claire-element-id="421300"><code data-claire-semantic="haskell">import qualified Data.Map</code></pre><p id="r-421301" data-claire-element-id="421301">Il faut alors réécrire tout le code pour ajouter <code data-claire-semantic="haskell">Data.Map. </code> devant le nom de toutes les fonctions de ce module, comme ceci : <code data-claire-semantic="haskell">Data.Map.alter </code>. Mais c'est très long à taper. Il est possible de définir un préfixe personnalisé de cette façon :</p><pre id="r-421302" data-claire-element-id="421302"><code data-claire-semantic="haskell">import qualified Data.Map as M</code></pre><p id="r-421303" data-claire-element-id="421303">Voilà, on n'a plus qu'à utiliser M comme préfixe, c'est beaucoup plus court et pratique. Comme il n'y a pas de type Map dans le Prelude, il est même possible d'importer le module de cette façon :</p><pre id="r-421304" data-claire-element-id="421304"><code data-claire-semantic="haskell">import Data.Map (Map)
import qualified Data.Map as M


-- Pour compter les lettres, on ajoute au fur et à mesure les lettres trouvées dans notre Map
compterLettres :: String -&gt; Map Char Integer
compterLettres = foldr (M.alter ajouterLettre) M.empty

-- Cette fonction modifie la valeur associée à un caractère en fonction de la valeur précédente
ajouterLettre Nothing = Just 1 -- On n'avait pas rencontré le caractère avant
ajouterLettre (Just a) = Just (a+1)

nombreLettres :: Map Char Integer -&gt; Char -&gt; Integer
nombreLettres m c = case M.lookup c m of
                      Nothing -&gt; 0 -- la lettre n'est pas présente
                      Just a -&gt; a</code></pre><p id="r-421305" data-claire-element-id="421305">On indique au compilateur qu'on veut importer seulement le type Map de Data.Map sans préfixe, et qu'on veut importer tout le module avec le préfixe M.</p><h5 id="r-creer-un-module-1" data-claire-element-id="421319">Créer un module</h5><h6 id="r-votre-premier-module" data-claire-element-id="421316">Votre premier module !</h6><p id="r-421308" data-claire-element-id="421308">Vous pouvez aussi créer vos propres modules. Par exemple, reprenons le code des arbres binaires de recherche du chapitre précédent. On veut mettre le code dans un module. D'abord, choisissons un nom pour le module : ce sera <code data-claire-semantic="haskell">ABR </code>. Ensuite, on va mettre tout le code en question dans un fichier nommé <code>ABR.hs</code>.</p><div id="r-421310" data-claire-element-id="421310"><pre id="r-421309" data-claire-element-id="421309"><code data-claire-semantic="haskell">data Arbre a = Branche a (Arbre a) (Arbre a)
             | Feuille 
               deriving Show


foldArbre f n Feuille = n
foldArbre f n (Branche e d g) = f e (foldArbre f n d) (foldArbre f n g)

-- on est tombé sur une Feuille, donc on n'a rien trouvé
rechercher _ Feuille = False
rechercher e (Branche f g d) | e == f = True
                             | e &lt; f = rechercher e g
                             | e &gt; f = rechercher e d

inserer e Feuille = Branche e Feuille Feuille
inserer e (Branche f g d) | e == f = Branche f g d
                          | e &lt; f = Branche f (inserer e g) d
                          | e &gt; f = Branche f g (inserer e d)

-- construire un arbre à partir d'une liste
construireArbre :: (Ord a) =&gt; [a] -&gt; Arbre a
construireArbre = foldr inserer Feuille

aplatir ::  Arbre a -&gt; [a]
aplatir = foldArbre (\e g d -&gt; g ++ [e] ++ d) []
-- version sans foldArbre :
aplatir' Feuille = []
aplatir' (Branche e g d) = aplatir g ++ [e] ++ aplatir d

triABR :: (Ord a) =&gt; [a] -&gt; [a]
triABR = aplatir . construireArbre


supprimerPlusGrand (Branche e g Feuille) = (g,e)
supprimerPlusGrand (Branche e g d) = let (d',grand) = supprimerPlusGrand d in 
                                     (Branche e g d', grand) 

supprimerRacine (Branche _ Feuille Feuille) = Feuille
supprimerRacine (Branche _ g Feuille) = g
supprimerRacine (Branche _ Feuille d) = d
supprimerRacine (Branche _ g d) = Branche e' g' d
    where (g',e') = supprimerPlusGrand g

supprimer _ Feuille = Feuille
supprimer e (Branche f g d) | e == f = supprimerRacine (Branche f g d)
                            | e &lt; f = Branche f (supprimer e g) d
                            | e &gt; f = Branche f g (supprimer e d)

arbreVide = Feuille</code></pre></div><p id="r-421311" data-claire-element-id="421311">Ensuite, pour déclarer notre module ABR, il faut rajouter une déclaration tout en haut du fichier :</p><pre id="r-421312" data-claire-element-id="421312"><code data-claire-semantic="haskell">module ABR (Arbre(Branche, Feuille), inserer, rechercher, construireArbre, aplatir, supprimer, arbreVide) where</code></pre><p id="r-421313" data-claire-element-id="421313">On a indiqué après le nom du module l'ensemble des fonctions et types qui sont exportés par ce module. Cela nous permet de masquer certaines fonctions qui ne serviraient pas à l'utilisateur du module, comme la fonction <code data-claire-semantic="haskell">aplatir' </code>, qui n'est qu'une fonction utilitaire. On a aussi exporté le type Arbre, et ses deux constructeurs Branche et Feuille avec <code data-claire-semantic="haskell">Arbre(Branche,Feuille) </code>. Quand on exporte tous les constructeurs d'un type, il est aussi possible d'écrire <code data-claire-semantic="haskell">Arbre(..) </code> (il y a deux points, pas trois). Voilà, vous avez créé votre premier module.</p><p id="r-421314" data-claire-element-id="421314">Mais imaginons maintenant que l'utilisateur de votre module ne soit pas très malin (ou trop...), et modifie les valeurs de type Arbre à la main. Il risquerait de créer accidentellement des arbres invalides, et d'introduire des bugs dans son programme. Pour l'empêcher de faire ça, il suffit de ne pas exporter le type Arbre. De cette façon, il est impossible de le manipuler autrement qu'en utilisant les fonctions que vous avez définies. Vous pourrez aussi changer la représentation de l'arbre sans rendre votre module incompatible avec ce qui a été codé avant le changement. Remplacez donc la première ligne par celle-ci :</p><pre id="r-421315" data-claire-element-id="421315"><code data-claire-semantic="haskell">module ABR (inserer, rechercher, construireArbre, aplatir, supprimer, arbreVide) where</code></pre><h6 id="r-utiliser-votre-module-depuis-un-autre-fichier" data-claire-element-id="421318">Utiliser votre module depuis un autre fichier</h6><p id="r-421317" data-claire-element-id="421317">Pour pouvoir importer votre module, son chemin d'accès depuis l'endroit où vous lancez ghci (ou le compilateur) doit correspondre au nom du module : par exemple, si je décide de renommer mon module Data.ABR et que je veux l'utiliser depuis le module Test, le chemin de Data.ABR doit être (par rapport au dossier du module Test) <code data-claire-semantic="console">Data/ABR.hs</code>. Ensuite, placez-vous dans le bon dossier et lancez simplement <code data-claire-semantic="console">ghci Test.hs</code>.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">
<span class="arrow"></span>
<span class="next">Modules, IO et compilation</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
<span class="next">Entrées et sorties</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Entresetsorties"></a><h2>Entrées et sorties</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
<span class="arrow"></span>
<span class="next">Créer des modules</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
<span class="next">Plus de fonctions, compilation</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-entrees-et-sorties" data-claire-element-id="421370">Entrées et sorties</h4><h5 id="r-un-probleme-epineux-1" data-claire-element-id="421323">Un problème épineux</h5><p id="r-421321" data-claire-element-id="421321">Haskell est un langage purement fonctionnel : cela veut dire qu'une fonction ne peut pas modifier l'environnement extérieur (par exemple, une variable globale), et que sa valeur de retour ne doit dépendre que de ses arguments. Cela a des avantages : il est possible de raisonner beaucoup plus facilement sur un programme, par exemple de supprimer un appel de fonction sans risque si son résultat n'est pas utilisé. Le compilateur peut aussi appliquer certaines optimisations beaucoup plus facilement : par exemple, si une fonction est appelée deux fois avec les mêmes arguments, il peut choisir de ne faire le calcul qu'une seule fois. Cependant, cela pose un problème : comment créer une fonction qui communique avec l'extérieur du programme ?<br/> Prenons l'exemple d'une fonction qui sert à lire une ligne entrée au clavier par l'utilisateur du programme : son résultat dépend du moment où elle est appelée, donc son résultat ne dépend pas seulement de ses arguments. Pour une fonction qui affiche quelque chose à l'écran, c'est moins compliqué : l'action réalisée ne dépend bien que des arguments. Cependant, cette fonction modifie quand même le monde extérieur, ce qui ne se reflète pas dans sa valeur de retour. Il est aussi impossible d'enlever un appel à cette fonction dont le résultat n'est pas utilisé sans changer le résultat du programme.<br/> On pourrait choisir d'ignorer ces problèmes théoriques, et d'utiliser tout de même des fonctions impures, en laissant le soin au compilateur de ne pas y toucher. Cependant, il y a un autre problème : l'évaluation paresseuse fait que les opérations ne sont effectuées qu'au moment où leur résultat est nécessaire. Par exemple, si vous faites un programme qui demande le nom puis le prénom de l'utilisateur, et que vous utilisez le prénom avant le nom, les informations risquent d'être demandées dans le désordre. Pire encore, les opérations dont le résultat ne sert pas, par exemple afficher un texte à l'écran, ne seront pas effectuées.</p><p id="r-421322" data-claire-element-id="421322">Rassurez-vous, il est quand même possible de faire des programmes qui servent à quelque chose en Haskell : il existe une solution pour communiquer avec l'extérieur sans rencontrer ce genre de problèmes, que vous allez découvrir progressivement dans ce chapitre.</p><h5 id="r-le-type-io-et-la-notation-do" data-claire-element-id="421369">Le type IO et la notation do</h5><h6 id="r-des-actions-io" data-claire-element-id="421332">Des actions IO</h6><p id="r-421324" data-claire-element-id="421324">Pour commencer, nous allons utiliser ghci.<br/> La fonction <code data-claire-semantic="haskell">putStrLn </code> permet d'afficher quelque chose à l'écran. Vous pouvez la tester dans ghci :</p><pre id="r-421325" data-claire-element-id="421325"><code data-claire-semantic="console">Prelude&gt; putStrLn &quot;Hello, World!&quot;
Hello, World !</code></pre><p id="r-421326" data-claire-element-id="421326">Voilà, vous avez affiché votre premier texte à l'écran. Maintenant, regardons le type de cette fonction : <code data-claire-semantic="haskell">putStrLn :: String -&gt; IO () </code>. Cette fonction prend donc une valeur de type String et renvoie une valeur de type IO (). Le type <code data-claire-semantic="haskell">() </code> est aussi appelé <em>unit</em> : il ne contient qu'une seule valeur, qui se note aussi <code data-claire-semantic="haskell">() </code>. Cela veut donc dire quelque chose comme « cette valeur n'est pas intéressante ». Mais le type renvoyé est <code data-claire-semantic="haskell">IO () </code>. Vous pouvez voir le type IO comme un conteneur, dans lequel toutes les fonctions qui font des opérations qui interagissent avec l'extérieur renvoient leur valeur. D'ailleurs, IO vient de l'anglais input/output qui signifie entrées-sorties. Pour des raisons que vous verrez plus tard, on peut aussi parler de la <em>monade</em> IO.</p><p id="r-421327" data-claire-element-id="421327">On va continuer avec un deuxième exemple : <code data-claire-semantic="haskell">getLine </code> permet de lire une ligne de texte entrée par l'utilisateur. Un petit exemple :</p><pre id="r-421328" data-claire-element-id="421328"><code data-claire-semantic="console">Prelude&gt; getLine
Bonjour
&quot;Bonjour&quot;</code></pre><p id="r-421329" data-claire-element-id="421329">La première ligne où il y a écrit <code data-claire-semantic="console">Bonjour</code> a été entrée au clavier. La ligne a bien été lue, puisque getLine renvoie comme résultat <code data-claire-semantic="haskell">&quot;Bonjour&quot; </code>. Cependant, quelque chose doit vous étonner : getLine n'est pas une fonction, puisqu'on ne lui a pas donné d'arguments. On peut confirmer ce fait en regardant son type : <code data-claire-semantic="haskell">getLine :: IO String </code>. En fait, une valeur de type <code>IO a</code> est une <em>action</em> qui renvoie une valeur de type <code>a</code>, et ghci exécute pour nous les actions qu'on lui donne, puis affiche leur résultat.<br/> Mais dans ce cas, putStrLn n'affiche pas non plus directement la valeur qu'on lui donne, mais renvoie plutôt une action, qui est ensuite exécutée par ghci. On peut confirmer cela en se livrant à un petit test :</p><pre id="r-421330" data-claire-element-id="421330"><code data-claire-semantic="console">Prelude&gt; let hello = putStrLn &quot;Hello, World !&quot;
Prelude&gt; :t hello
hello :: IO ()
Prelude&gt; hello
Hello, World!
Prelude&gt; hello
Hello, World!</code></pre><p id="r-421331" data-claire-element-id="421331">Ici, rien n'a été affiché au niveau du let, même si on a utilisé la fonction putStrLn : on a juste créé une action hello, qui affiche &quot;Hello, World!&quot;. Ensuite, on peut utiliser cette action plusieurs fois, et à chaque fois qu'elle est exécutée, le message est affiché.</p><h6 id="r-composer-des-actions-avec-do" data-claire-element-id="421353">Composer des actions avec do</h6><p id="r-421333" data-claire-element-id="421333">Vous savez maintenant exécuter des actions simples, au moins dans ghci, mais seulement une seule à la fois. Comment faire pour exécuter plusieurs actions à la suite, ou réutiliser le résultat d'une action dans une autre action ?<br/> Pour cela il faut utiliser la notation do. On va commencer avec un exemple simple : un programme qui affiche deux lignes de texte.<br/> Ouvrez un nouveau fichier, et entrez-y le code suivant :</p><pre id="r-421334" data-claire-element-id="421334"><code data-claire-semantic="haskell">conversation = do
  putStrLn &quot;Bonjour&quot;
  putStrLn &quot;Au revoir&quot;</code></pre><p id="r-421335" data-claire-element-id="421335">Maintenant, vous pouvez lancer ce code dans ghci :</p><pre id="r-421336" data-claire-element-id="421336"><code data-claire-semantic="console">*Main&gt; :t conversation
conversation :: IO ()
*Main&gt; conversation
Bonjour
Au revoir</code></pre><p id="r-421337" data-claire-element-id="421337">La notation do permet de combiner plusieurs actions pour en faire une seule action. Elle garantit que les actions sont réalisées dans l'ordre spécifié : plus de problèmes avec l'évaluation paresseuse. Il est bien sûr possible de faire des fonctions qui prennent des arguments :</p><pre id="r-421338" data-claire-element-id="421338"><code data-claire-semantic="haskell">conversation nom = do
  putStrLn $ &quot;Bonjour &quot; ++ nom
  putStrLn &quot;Au revoir&quot;</code></pre><pre id="r-421339" data-claire-element-id="421339"><code data-claire-semantic="console">*Main&gt; conversation &quot;toi&quot;
Bonjour toi
Au revoir</code></pre><p id="r-421340" data-claire-element-id="421340">La notation do permet aussi de récupérer le résultat des actions effectuées. Pour cela on utilise la flèche pour récupérer le résultat :</p><pre id="r-421341" data-claire-element-id="421341"><code data-claire-semantic="haskell">echo = do
  putStrLn &quot;Entrez un mot&quot;
  mot &lt;- getLine
  putStrLn $ &quot;Vous avez dit &quot; ++ mot</code></pre><p id="r-421342" data-claire-element-id="421342">Vous pouvez maintenant tester ce code dans ghci :</p><pre id="r-421343" data-claire-element-id="421343"><code data-claire-semantic="console">*Main&gt; echo
Entrez un mot
banane
Vous avez dit banane</code></pre><p id="r-421344" data-claire-element-id="421344">Vous pouvez définir des valeurs intermédiaires avec let. Cependant, la syntaxe est différente d'un let normal : il n'y a pas besoin d'indiquer &quot;in&quot; à la fin :</p><pre id="r-421345" data-claire-element-id="421345"><code data-claire-semantic="haskell">retourner = do
  putStrLn &quot;Entrez un mot&quot;
  mot &lt;- getLine
  let envers = reverse mot
  putStrLn $ &quot;Dites plutôt &quot; ++ envers</code></pre><p id="r-421346" data-claire-element-id="421346">Enfin, vous devez savoir que le résultat de la dernière action est renvoyé. Il est donc possible de factoriser le code de cette façon :</p><pre id="r-421347" data-claire-element-id="421347"><code data-claire-semantic="haskell">lireMot = do
  putStrLn &quot;Entrez un mot&quot;
  getLine

echo = do
  mot &lt;- lireMot
  putStrLn $ &quot;Vous avez dit &quot; ++ mot

retourner = do
  mot &lt;- lireMot
  let envers = reverse mot
  putStrLn $ &quot;Dites plutôt &quot; ++ envers</code></pre><p id="r-421348" data-claire-element-id="421348">Mais imaginons que vous ne voulez pas renvoyer la dernière valeur. Dans ce cas, vous ne pouvez pas écrire un code comme :</p><pre id="r-421349" data-claire-element-id="421349"><code data-claire-semantic="haskell">lireMot = do
  putStrLn &quot;Entrez un mot&quot;
  x &lt;- getLine
  putStrLn &quot;Merci !&quot;
  x</code></pre><p id="r-421350" data-claire-element-id="421350">En effet, il n'est possible de mettre que des actions IO dans do, et x n'est pas une action. Heureusement, il existe un moyen de transformer une valeur pure en une action qui donne cette valeur : c'est la fonction <code data-claire-semantic="haskell">return :: a -&gt; IO a </code> (vous ne trouverez pas le même type si vous le demandez à ghci, et c'est normal : en réalité, cette fonction est plus générale). Vous pouvez donc écrire un code comme celui-ci :</p><pre id="r-421351" data-claire-element-id="421351"><code data-claire-semantic="haskell">lireMot = do
  putStrLn &quot;Entrez un mot&quot;
  x &lt;- getLine
  putStrLn &quot;Merci !&quot;
  return x</code></pre><p id="r-421352" data-claire-element-id="421352">Gardez tout de même à l'esprit que return n'est pas une fonction spéciale : il n'y a pas forcément besoin d'un return à la fin d'un bloc do, et un return au milieu d'un bloc do ne fait rien de spécial : l'exécution continue normalement, contrairement au return des langages comme le C.</p><h6 id="r-do-structures-conditionnelles-et-recursion" data-claire-element-id="421368">do, structures conditionnelles et récursion</h6><p id="r-421354" data-claire-element-id="421354">On peut aussi utiliser les structures conditionnelles classiques. Par exemple, on va créer une fonction qui demande un mot à l'utilisateur, et le compare avec un mot gardé secret :</p><pre id="r-421355" data-claire-element-id="421355"><code data-claire-semantic="haskell">motSecret x = do
  putStrLn &quot;Entrez le mot secret&quot;
  m &lt;- getLine
  if x == m
    then return True
    else return False</code></pre><p id="r-421356" data-claire-element-id="421356">Vous pouvez aussi de la même manière utiliser case ... of. Attention, l'indentation est importante : si vous oubliez d'indenter le then et le else, vous risquez d'avoir une erreur de syntaxe. Maintenant, imaginons qu'on veuille mettre un message un peu plus intéressant à l'utilisateur pour indiquer si l'opération a réussi. Vous pourriez essayer d'écrire un code comme celui-ci :</p><pre id="r-421357" data-claire-element-id="421357"><code data-claire-semantic="haskell">motSecret x = do
  putStrLn &quot;Entrez le mot secret&quot;
  m &lt;- getLine
  if x == m
    then putStrLn &quot;Vous avez trouvé !&quot;
         return True
    else putStrLn &quot;Non, ce n'est pas le mot secret&quot;
         return False</code></pre><p id="r-421358" data-claire-element-id="421358">Si vous essayez d&quot;utiliser ce code, vous allez obtenir un message d'erreur pas très clair, et qui ne correspond pas du tout à ce que vous attendez. En effet, dans les blocs do, if n'a pas de comportement spécial, et on doit mettre des expressions après then et else. Pour faire ce que vous voulez faire, vous devez donc commencer un nouveau bloc do à l'intérieur :</p><pre id="r-421359" data-claire-element-id="421359"><code data-claire-semantic="haskell">motSecret x = do
  putStrLn &quot;Entrez le mot secret&quot;
  m &lt;- getLine
  if x == m
    then do
      putStrLn &quot;Vous avez trouvé !&quot;
      return True
    else do
      putStrLn &quot;Non, ce n'est pas le mot secret&quot;
      return False</code></pre><p id="r-421360" data-claire-element-id="421360">Maintenant, on veut faire une dernière modification : si le mot entré n'est pas le bon, on veut redemander le mot. Vous pensez peut-être tout de suite à utiliser une boucle : tant que le mot entré n'est pas le bon, on demande un mot à l'utilisateur. En Haskell, on utilise la récursivité à la place : il suffit de rappeler la fonction motSecret si le mot entré n'est pas le bon :</p><pre id="r-421361" data-claire-element-id="421361"><code data-claire-semantic="haskell">motSecret x = do
  putStrLn &quot;Entrez le mot secret&quot;
  m &lt;- getLine
  if x == m
    then putStrLn &quot;Vous avez trouvé !&quot;
    else do
      putStrLn &quot;Non, ce n'est pas le mot secret.&quot;
      motSecret x</code></pre><p id="r-421362" data-claire-element-id="421362">Cette idée peut servir pour des choses plus intéressantes. Par exemple, on peut coder facilement un plus ou moins de cette façon :</p><pre id="r-421363" data-claire-element-id="421363"><code data-claire-semantic="haskell">plusOuMoins x xmin xmax ncoups = do
  putStrLn $ &quot;Entrez un nombre entre &quot; ++ show xmin ++ &quot; et &quot; ++ show xmax
  y &lt;- readLn
  case compare x y of 
    LT -&gt; do
      putStrLn &quot;Plus petit !&quot;
      plusOuMoins x xmin (y-1) (ncoups + 1)
    GT -&gt; do
      putStrLn &quot;Plus grand !&quot;
      plusOuMoins x (y+1) xmax (ncoups + 1)
    EQ -&gt; do
      putStrLn $ &quot;Bravo, vous avez trouvé le nombre en &quot; ++ show ncoups ++ &quot; essais&quot;</code></pre><p id="r-421364" data-claire-element-id="421364">En plus de simplement demander un nombre, on garde à chaque étape l'intervalle dans lequel se trouve le nombre, et le nombre de coups qui ont été joués. On utilise aussi la fonction compare, qui compare deux nombres et renvoie LT (plus petit), GT (plus grand) ou EQ (égal). La fonction readLn combine les fonctions de getLine et read : elle lit une ligne de l'entrée standard, et applique la fonction read à la chaîne obtenue pour convertir ça dans le type qui nous intéresse (ici, en un entier).</p><p id="r-421365" data-claire-element-id="421365">Vous pouvez aussi utiliser cette technique pour redemander une information à l'utilisateur si il a entré quelque chose d'invalide la première fois. Par exemple, la fonction lireValide prend en argument une fonction de lecture, et redemande l'information tant que la chaîne donnée n'est pas valide (la fonction de validation doit renvoyer Nothing pour indiquer que la lecture a échoué).</p><pre id="r-421366" data-claire-element-id="421366"><code data-claire-semantic="haskell">ouiNon :: String -&gt; Maybe Bool
ouiNon s = if s' `elem` oui 
                then Just True 
           else if s' `elem` non 
                then Just False 
                else Nothing
    where oui = [&quot;y&quot;,&quot;yes&quot;,&quot;oui&quot;,&quot;o&quot;]
          non = [&quot;n&quot;,&quot;no&quot;,&quot;non&quot;]
          s' = map toLower s

lireValide lire = do
  s &lt;- getLine
  case lire s of
    Nothing -&gt; do
                putStrLn &quot;Réponse invalide&quot;
                lireValide lire
    Just r -&gt; return r

lireOuiNon = lireValide ouiNon</code></pre><p id="r-421367" data-claire-element-id="421367">Vous pouvez voir que la notation do ne permet pas de faire sortir une valeur d'une action IO : il n'est pas possible de créer une fonction de type IO a -&gt; a. C'est une bonne nouvelle : cela signifie que les effets de bords des actions n'impacteront pas sur la partie pure du programme, puisqu'à la fin, on doit forcément renvoyer une action IO.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
<span class="arrow"></span>
<span class="next">Créer des modules</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
<span class="next">Plus de fonctions, compilation</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Plusdefonctionscompilation"></a><h2>Plus de fonctions, compilation</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
<span class="arrow"></span>
<span class="next">Entrées et sorties</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">
<span class="next">Programmez avec des effets</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-plus-de-fonctions-compilation" data-claire-element-id="421440">Plus de fonctions, compilation</h4><h5 id="r-ameliorons-le-plus-ou-moins" data-claire-element-id="421383">Améliorons le plus ou moins</h5><p id="r-421371" data-claire-element-id="421371">Pour commencer, nous allons améliorer le plus ou moins. Ce sera l'occasion de voir comment générer des nombres aléatoires, manipuler les fichiers, et compiler un programme.</p><h6 id="r-generer-un-nombre" data-claire-element-id="421378">Générer un nombre</h6><p id="r-421372" data-claire-element-id="421372">Il n'y a pas de fonction pure pour générer un nombre aléatoire en Haskell : par principe, une telle fonction devrait renvoyer une même valeur pour les mêmes arguments, et ce n'est pas ce que l'on veut. Cependant, il est tout de même possible de générer des nombres aléatoires, en utilisant les fonctions du <a href="http://www.haskell.org/ghc/docs/6.10.4/html/libraries/random/System-Random.html">module System.Random</a>. La première chose à avoir est une source de nombre aléatoires. En réalité, on ne peut pas générer de nombres vraiment aléatoires avec un ordinateur : le résultat des opérations est parfaitement déterminé. Mais il existe des techniques pour générer, à partir d'une valeur de départ, des suites de nombres qui ont l'air aléatoires.<br/> Il y a deux possibilités : vous pouvez décider de passer explicitement l'état du générateur à chaque fonction, et compter sur ces fonctions pour retourner l'état suivant du générateur. Par exemple, pour tirer deux nombres aléatoires à la suite, le code ressemblerait à ceci :</p><pre id="r-421373" data-claire-element-id="421373"><code data-claire-semantic="haskell">random2 :: (RandomGen g) =&gt; g -&gt; (Int,Int,g)
random2 gen = let (a,gen2) = random gen in
              let (b,gen3) = random gen2 in
              (a,b,gen3)</code></pre><p id="r-421374" data-claire-element-id="421374">Cette fonction prend donc en argument un générateur aléatoire, et doit renvoyer un générateur aléatoire pour être utilisé par la fonction suivante. Le code n'est pas très beau, et en plus vous risquez de vous tromper et d'utiliser deux fois random avec le même état, ce qui fait que vous obtiendrez deux fois le même nombre (puisque la valeur de retour ne dépend que des arguments).</p><p id="r-421375" data-claire-element-id="421375">Soit vous décidez d'utiliser la solution simple, et vous utilisez les fonctions de génération des nombres aléatoires retournant une valeur dans la monade IO. Ces fonctions stockent en réalité un état global du générateur de nombres aléatoires, mais il est caché et vous n'avez pas à vous en soucier. Pour générer un nombre aléatoire, utilisez simplement la fonction randomRIO en lui indiquant l'intervalle qui vous intéresse. Vous pouvez aussi utiliser la fonction randomIO, mais elle ne prend pas d'intervalle en argument et risque de vous donner des nombres beaucoup trop grands pour ce que vous voulez en faire. Vous devrez parfois aussi indiquer le type de retour que vous souhaitez (ce n'est pas nécessaire ici, car le type des arguments de randomRIO permet de déterminer son type de retour).</p><pre id="r-421376" data-claire-element-id="421376"><code data-claire-semantic="haskell">jouer xmin xmax = do
  x &lt;- randomRIO (xmin,xmax)
  plusOuMoins x xmin xmax 0</code></pre><p id="r-421377" data-claire-element-id="421377">Voilà, votre plus ou moins est capable de générer des nombres aléatoires.</p><h6 id="r-compiler-votre-programme" data-claire-element-id="421382">Compiler votre programme</h6><p id="r-421379" data-claire-element-id="421379">Maintenant que vos programmes sont capables de faire quelque chose en dehors de retourner une valeur, il est temps d'apprendre à les compiler. Il n'y a pas grand-chose de compliqué. D'abord, vous devez mettre une fonction main quelque part (par exemple, notre fichier PlusOuMoins.hs) :</p><pre id="r-421380" data-claire-element-id="421380"><code data-claire-semantic="haskell">import System.Random

plusOuMoins x xmin xmax ncoups = do
  putStrLn $ &quot;Entrez un nombre entre &quot; ++ show xmin ++ &quot; et &quot; ++ show xmax
  y &lt;- readLn
  case compare x y of 
    LT -&gt; do
      putStrLn &quot;Plus petit !&quot;
      plusOuMoins x xmin (y-1) (ncoups + 1)
    GT -&gt; do
      putStrLn &quot;Plus grand !&quot;
      plusOuMoins x (y+1) xmax (ncoups + 1)
    EQ -&gt; do
      putStrLn $ &quot;Bravo, vous avez trouvé le nombre en &quot; ++ show (ncoups + 1) ++ &quot; essais&quot;
      return (ncoups + 1)

jouer :: Int -&gt; Int -&gt; IO Int
jouer xmin xmax = do
  x &lt;- randomRIO (xmin,xmax)
  plusOuMoins x xmin xmax 0

main = jouer 1 100</code></pre><p id="r-421381" data-claire-element-id="421381">Ensuite, pour compiler ce programme, il suffit de lancer la commande <code data-claire-semantic="console">ghc --make PlusOuMoins.hs</code>. Si vous n'obtenez pas d'erreurs, vous devriez trouver dans le dossier un exécutable appelé <code data-claire-semantic="console">PlusOuMoins</code>. Vous n'avez plus qu'à le lancer pour jouer !</p><h5 id="r-plus-de-fonctions-d-entrees-sorties" data-claire-element-id="421420">Plus de fonctions d'entrées-sorties</h5><h6 id="r-combiner-des-actions-io" data-claire-element-id="421401">Combiner des actions IO</h6><p id="r-421384" data-claire-element-id="421384">Imaginons que vous voulez coder un programme qui prend du texte en entrée, et à chaque ligne de texte, renvoie cette ligne en majuscule. Il y a dans le module Data.Char une fonction toUpper qui met un caractère en majuscule. Le premier coder qui pourrait vous venir à l'esprit est celui-ci :</p><pre id="r-421385" data-claire-element-id="421385"><code data-claire-semantic="haskell">import Data.Char

main = do
  l &lt;- getLine
  putStrLn $ map toUpper l
  main</code></pre><p id="r-421386" data-claire-element-id="421386">Vous remarquez qu'on utilise un appel récursif à la fin de la fonction, pour que l'action se répète. Il y a une fonction pour ça, dans le module Control.Monad : c'est la fonction <code data-claire-semantic="haskell">forever</code>. Vous pouvez donc réécrire votre programme comme ceci :</p><pre id="r-421387" data-claire-element-id="421387"><code data-claire-semantic="haskell">import Data.Char
import Control.Monad

main = forever $ do
         l &lt;- getLine
         putStrLn $ map toUpper l</code></pre><p id="r-421388" data-claire-element-id="421388">Son type est <code data-claire-semantic="haskell">forever :: IO a -&gt; IO b</code> (en effet, cette fonction ne devrait jamais se terminer, donc la valeur de retour n'est pas utilisée). Son type réel est un peu plus général, mais ce type devrait vous suffire pour recoder forever vous-même :</p><pre id="r-421389" data-claire-element-id="421389"><code data-claire-semantic="haskell">forever a = do
  a
  forever a</code></pre><aside id="r-421391" data-claire-element-id="421391" data-claire-semantic="information"><p id="r-421390" data-claire-element-id="421390">Si vous voulez utiliser votre programme sans le compiler d'abord, vous pouvez utiliser le programme runhaskell : par exemple, si vous avez enregistré votre programme dans le fichier <code data-claire-semantic="console">up.hs</code>, utilisez simplement la commande <code data-claire-semantic="console">runhaskell up.hs</code></p></aside><p id="r-421392" data-claire-element-id="421392">Comme les fonctions, les actions IO ne subissent pas de traitement particulier : il est possible de les prendre comme arguments, et de les combiner pour donner d'autres actions. D'ailleurs, Control.Monad comprend plein d'autres fonctions pour combiner des actions.<br/> Par exemple, les fonctions <code data-claire-semantic="haskell">when</code> et <code data-claire-semantic="haskell">unless</code> permettent d'exécuter une action IO conditionnellement : <code data-claire-semantic="haskell">when condition action</code> exécute l'action si la condition est vraie, et <code data-claire-semantic="haskell">return ()</code> sinon, et <code data-claire-semantic="haskell">unless</code> fait l'inverse.<br/> Par exemple, si vous voulez créer un programme qui n'affiche que les lignes qui ne commencent pas par un espace :</p><pre id="r-421393" data-claire-element-id="421393"><code data-claire-semantic="haskell">import Data.List
import Control.Monad

main = forever $ do
         l &lt;- getLine
         unless (&quot; &quot; `isPrefixOf` l) $ putStrLn l</code></pre><p id="r-421394" data-claire-element-id="421394">La fonction sequence est aussi plutôt utile : son type est <code data-claire-semantic="haskell">sequence :: [IO a] -&gt; IO [a]</code>. Elle exécute donc toutes les actions d'une liste à la suite, et donne le résultat. On peut donc l'utiliser avec toutes les fonctions qui donnent des listes, comme map. Par exemple, vous pouvez faire un programme qui compte jusqu'à 10 en utilisant map :</p><pre id="r-421395" data-claire-element-id="421395"><code data-claire-semantic="haskell">compter n = sequence $ map (putStrLn . show) [1..n]</code></pre><p id="r-421396" data-claire-element-id="421396">Mais pour ce genre d'utilisation, vous pouvez utiliser directement la fonction mapM :</p><pre id="r-421397" data-claire-element-id="421397"><code data-claire-semantic="haskell">compter n = mapM (putStrLn . show) [1..n]</code></pre><p id="r-421398" data-claire-element-id="421398">La fonction mapM_ peut aussi servir si vous n'avez pas besoin du résultat des fonctions (ce qui est le cas dans notre exemple) : elle retourne une valeur de type IO () (donc ignore les résultats) :</p><pre id="r-421399" data-claire-element-id="421399"><code data-claire-semantic="haskell">compter n = mapM_ (putStrLn . show) [1...n]</code></pre><p id="r-421400" data-claire-element-id="421400">Vous pourrez aussi parfois voir les fonctions forM et forM_ : il s'agit de mapM et mapM_ avec leurs arguments inversés.</p><h6 id="r-entrees-et-sorties-standard" data-claire-element-id="421419">Entrées et sorties standard</h6><p id="r-421402" data-claire-element-id="421402">Il y a quelques fonctions utiles pour interagir avec l'utilisateur que vous n'avez pas encore vues.</p><p id="r-421403" data-claire-element-id="421403">La fonction putStr fait la même chose que putStrLn mais n'insère pas de retour à la ligne automatiquement. Cela peut être utile pour faire un prompt pour demander des informations :</p><pre id="r-421404" data-claire-element-id="421404"><code data-claire-semantic="haskell">allo = do
  putStr &quot;Dites quelque chose: &quot;
  l &lt;- getLine
  putStr &quot;Vous avez dit : &quot;
  putStrLn l</code></pre><p id="r-421405" data-claire-element-id="421405">Cependant, ce code ne marche pas comme vous l'attendez : dans ghci, vous verrez bien &quot;Dites quelque chose:&quot;, mais si vous lancez ce script avec runhaskell, il attendra une entrée, puis il affichera le message demandant l'entrée. Cela ne vient pas encore d'un problème avec l'ordre d'exécution, mais du fait que par défaut, la sortie n'est affichée qu'à chaque caractère de retour à la ligne. Si cela pose un problème, vous pouvez désactiver ce comportement de plusieurs façons. La première, c'est d'utiliser la fonction hFlush du module System.IO : quand vous voulez que la sortie soit affichée immédiatement, ajoutez simplement <code data-claire-semantic="haskell">hFlush stdout</code>. Sinon, vous pouvez désactiver complètement la mise en cache en exécutant l'action <code data-claire-semantic="haskell">hSetBuffering stdout NoBuffering</code>.</p><p id="r-421406" data-claire-element-id="421406">Vous pouvez rencontrer le même problème avec la fonction <code data-claire-semantic="haskell">getChar</code> : cette fonction attend un caractère de l'utilisateur. L'entrée standard aussi n'est lue que lorsque l'utilisateur appuie sur entrée. Pour régler ce problème, vous pouvez si besoin utiliser <code data-claire-semantic="haskell">hSetBuffering stdin NoBuffering</code>. Ensuite, vous pouvez créer un programme qui réagit dès que l'utilisateur appuie sur une touche. Par exemple, ce bout de programme permet de répondre par o ou n à une question sans avoir à appuyer sur entrée après :</p><pre id="r-421407" data-claire-element-id="421407"><code data-claire-semantic="haskell">import System.IO


main = do
  hSetBuffering stdout NoBuffering
  hSetBuffering stdin NoBuffering
  r &lt;- ouiNon
  putStrLn $ show r

ouiNon = do
  putStr &quot;Oui ou non? &quot;
  c &lt;- getChar
  putChar '\n'
  case c of
    'y' -&gt; return True
    'n' -&gt; return False
    _ -&gt;  ouiNon</code></pre><p id="r-421408" data-claire-element-id="421408">La fonction putChar utilisée ici permet d'afficher un caractère. Une autre fonction très pratique est la fonction print : vous écrivez souvent <code data-claire-semantic="haskell">putStrLn (show a)</code> ? Remplacez ce code tout simplement par <code data-claire-semantic="haskell">print a</code>.</p><p id="r-421409" data-claire-element-id="421409">Si votre programme lit toute l'entrée d'un coup, la fonction getContents peut vous être utile : elle lit toute l'entrée d'un seul coup. Par exemple, on peut facilement créer un programme qui compte les lignes d'un fichier avec getContents :</p><pre id="r-421410" data-claire-element-id="421410"><code data-claire-semantic="haskell">main = do 
  l &lt;- getContents
  print $ length (lines l)</code></pre><p id="r-421411" data-claire-element-id="421411">Ce genre de programme peut être utile si on lui passe la sortie d'un autre programme : par exemple, au lieu de compter les lignes d'un fichier avec la commande <code data-claire-semantic="console">wc</code>, vous pouvez faire <code data-claire-semantic="console">cat fichier | runhaskell wc.hs</code> (en tout cas, ça marche sous un environement type Unix). Faisons un autre test : on va créer un programme qui affiche le nombre de caractères de chaque ligne.</p><pre id="r-421412" data-claire-element-id="421412"><code data-claire-semantic="haskell">main = do 
  l &lt;- getContents
  mapM_ (print . length) (lines l)</code></pre><p id="r-421413" data-claire-element-id="421413">On teste ce programme avec un exemple (les chiffres sont ce qui est renvoyé par le programme) :</p><pre id="r-421414" data-claire-element-id="421414"><code data-claire-semantic="console">Hello, world!
13
ABC
3
haskell c'est bien
18</code></pre><p id="r-421415" data-claire-element-id="421415">Surprise : au lieu d'attendre la fin de l'entrée pour donner le résultat, notre programme affiche le nombre de caractères après chaque ligne. En fait, la fonction getContents est <em>paresseuse</em> : au lieu de lire tout le contenu, puis de le renvoyer, elle crée une liste, et à chaque fois qu'un caractère de cette liste est demandé, elle le lit sur l'entrée standard. C'est très pratique pour un certain nombre de programmes, où on aimerait bien afficher le résultat dès que possible. Par exemple, quand on utilise des <em>pipes</em> pour connecter les entrées et les sorties de plusieurs programmes, on aime bien que chaque programme affiche le résultat en fonction de ce qu'il a déjà reçu, au lieu d'attendre la fin de l'entrée pour tout afficher.<br/> Dans le même esprit, il y a la fonction interact : elle prend une fonction de type String -&gt; String, et renvoie une action IO (). On peut donc interagir en même temps avec l'entrée et la sortie, et coder notre programme de cette façon :</p><pre id="r-421416" data-claire-element-id="421416"><code data-claire-semantic="haskell">main = interact (unlines . map (show . length) . lines)</code></pre><p id="r-421417" data-claire-element-id="421417">C'est plutôt court ! En fait, ce qu'on fait, c'est qu'on prend ce qui arrive en entrée, on le découpe en lignes, on compte le nombre de caractères de chaque ligne, qu'on transforme immédiatement en chaîne de caractères, et on regroupe le tout avec unlines. Avec interact, lines et unlines, il est possible de coder très rapidement des programmes qui traitent l'entrée ligne par ligne. Si vous avez du mal avec les compositions de fonctions en chaîne, vous pouvez découper un peu plus, en donnant un nom à notre fonction de traitement d'une ligne.</p><p id="r-421418" data-claire-element-id="421418">Par contre, il est moins facile d'utiliser ces fonctions pour des programmes qui doivent interagir plus directement avec l'utilisateur : on sait que les informations seront demandées dans l'ordre, affichées dans l'ordre, mais il est difficile de déterminer dans quel ordre exact seront faites les entrées par rapport aux sorties.</p><h5 id="r-fichiers-dossiers-et-ligne-de-commande" data-claire-element-id="421439">Fichiers, dossiers et ligne de commande</h5><h6 id="r-manipuler-des-fichiers" data-claire-element-id="421431">Manipuler des fichiers</h6><p id="r-421421" data-claire-element-id="421421">Il est aussi possible de manipuler les fichiers. Toutes les fonctions permettant de manipuler les fichiers se trouvent dans le module <code>System.IO</code>. Pour ouvrir un fichier, on utilise la fonction <code data-claire-semantic="haskell">openFile :: FilePath -&gt; IOMode -&gt; IO Handle</code>. Le type FilePath est juste un autre nom pour le type String : c'est donc le nom du fichier. Le type IOMode sert à indiquer ce qu'on souhaite faire avec le fichier. Il est défini par <code data-claire-semantic="haskell">data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode</code>. Il définit la façon dont on veut interagir avec le fichier : le lire uniquement (ReadMode), écrire dedans (WriteMode), écrire à la fin du fichier (AppendMode), ou lire et écrire (ReadWriteMode). Ensuite, on obtient un <code>Handle</code>, qui représente le fichier ouvert.</p><p id="r-421422" data-claire-element-id="421422">Ensuite, on peut lire et modifier le fichier avec des opérations comme hGetContents, hPutChar, hPutStr, hGetLine, ou hGetChar. Ces fonctions marchent presque comme leurs versions sans h devant, sauf qu'elles prennent un paramètre supplémentaire : un Handle qui correspond au fichier que l'on veut modifier. Enfin, après avoir terminé avec un fichier, n'oubliez pas de le fermer avec la fonction hClose.<br/> Par exemple, ce programme lit un fichier, rajoute un numéro de ligne devant chaque ligne et écrit les lignes obtenues dans un deuxième fichier :</p><pre id="r-421423" data-claire-element-id="421423"><code data-claire-semantic="haskell">import System.IO

numeroter inp outp n = do
  t &lt;- hIsEOF inp
  if t 
    then return () 
    else do  
      x &lt;- hGetLine inp
      hPutStrLn outp $ show n ++ &quot;: &quot; ++ x
      numeroter inp outp (n+1)

main = do
  inp &lt;- openFile &quot;test&quot; ReadMode
  outp &lt;- openFile &quot;test.num&quot; WriteMode
  numeroter inp outp 1
  hClose inp
  hClose outp</code></pre><p id="r-421424" data-claire-element-id="421424">En plus des fonctions mentionnées plus haut, on a utilisé la fonction <code>hIsEOF</code> : elle permet de tester si on est arrivé à la fin du fichier ou s'il reste du contenu à lire. Au lieu d'utiliser openFile et hClose, vous pouvez utiliser la fonction withFile. L'avantage de cette fonction est que le fichier est automatiquement fermé, quoi qu'il arrive. Son type est <code data-claire-semantic="haskell">withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO r) -&gt; IO r</code> : elle prend une fonction qui utilise le fichier ouvert, et lui passe le descripteur de fichier, puis ferme le fichier avant de retourner le résultat. Par exemple, on peut réécrire notre fonction main de cette façon :</p><pre id="r-421425" data-claire-element-id="421425"><code data-claire-semantic="haskell">main = do
  withFile &quot;test&quot; ReadMode 
       (\inp -&gt; withFile &quot;test.num&quot; WriteMode 
        (\outp -&gt; numeroter inp outp 1))</code></pre><p id="r-421426" data-claire-element-id="421426">Enfin, vous aimerez probablement utiliser les fonctions readFile, writeFile et appendFile : la fonction readFile retourne le contenu d'un fichier, la fonction writeFile écrit le contenu qu'on lui donne dans un fichier (et écrase le contenu si le fichier existait déjà), et la fonction appendFile ajoute quelque chose à la fin d'un fichier, en le créant si nécessaire. Par exemple, on peut numéroter les lignes comme ceci :</p><pre id="r-421427" data-claire-element-id="421427"><code data-claire-semantic="haskell">main = do
  x &lt;- readFile &quot;test&quot;
  writeFile &quot;test.num&quot; $ unlines . zipWith (\n l -&gt; show n ++ &quot;: &quot; ++ l) [1..] . lines $ x</code></pre><p id="r-421428" data-claire-element-id="421428">Comme avec getContents, le fichier est lu de façon paresseuse. Ce code fonctionne un peu comme les programmes qui utilisent interact : on coupe l'entrée (ici, le contenu d'un fichier) en lignes, puis on traite le contenu comme une liste de lignes, et enfin on le regroupe avant de l'afficher.</p><aside id="r-421430" data-claire-element-id="421430" data-claire-semantic="information"><p id="r-421429" data-claire-element-id="421429">Si votre programme a besoin d'afficher des résultats à l'écran ou de les écrire dans un fichier suivant le choix de l'utilisateur, pas besoin de faire une fonction pour chaque cas : l'entrée et la sortie standard peuvent aussi être traitées comme un fichier. Utilisez simplement stdin et stdout comme Handle (respectivement pour l'entrée et la sortie)</p></aside><h6 id="r-arguments-de-la-ligne-de-commande" data-claire-element-id="421438">Arguments de la ligne de commande</h6><p id="r-421432" data-claire-element-id="421432">Si vous développez des programmes qui s'utilisent en ligne de commande, vous aurez besoin de gérer les arguments donnés à votre programme. Pour cela, il y a deux actions IO intéressantes dans le module System.Environment. La première est <code data-claire-semantic="haskell">getProgName :: IO String</code>, elle renvoie le nom du programme (argv[0] en C). La deuxième est <code data-claire-semantic="haskell">getArgs :: IO [String]</code>, qui renvoie la liste des arguments.<br/> Testons ces deux fonctions :</p><pre id="r-421433" data-claire-element-id="421433"><code data-claire-semantic="haskell">import System.Environment
import Control.Monad

main = do
  p &lt;- getProgName
  putStrLn $ &quot;Nom du programme: &quot; ++ p
  a &lt;- getArgs
  mapM_ putStrLn a</code></pre><p id="r-421434" data-claire-element-id="421434">Vous pouvez tester ce programme après l'avoir compilé :</p><pre id="r-421435" data-claire-element-id="421435"><code data-claire-semantic="console">$ ./args arg1 arg2 arg3
Nom du programme: args
arg1
arg2
arg3</code></pre><p id="r-421436" data-claire-element-id="421436">Vous pouvez aussi passer des arguments au programme avec runhaskell : par exemple, dans notre cas, on utiliserait la commande <code data-claire-semantic="console">runhaskell args.hs arg1 arg2 arg3</code>, et le nom du programme serait <code data-claire-semantic="console">args.hs</code>.</p><p id="r-421437" data-claire-element-id="421437">Voilà, maintenant vous savez faire un programme complet en Haskell. Vous n'avez pas tout vu, n'hésitez pas à lire la documentation des modules qui vous semblent intéressants. Pour manipuler les chemins des fichiers, le module <code>System.FilePath</code> fournit quelques fonctions utiles. Enfin, si vous avez besoin de lister le contenu d'un dossier, ou de déplacer, copier, supprimer des dossiers, vous trouverez sans doute ce que vous cherchez dans le module <code>System.Directory</code>.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
<span class="arrow"></span>
<span class="next">Entrées et sorties</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">
<span class="next">Programmez avec des effets</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Programmezavecdeseffets"></a><h2>Programmez avec des effets</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
<span class="arrow"></span>
<span class="next">Plus de fonctions, compilation</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
<span class="next">Les foncteurs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-421444" data-claire-element-id="421444">Les programmeurs Haskell aiment bien l'abstraction. Les classes de types servent à ça : elles permettent de déclarer des opérations qu'on peut effectuer sur beaucoup de types différents. Il existe des classes plutôt simples, comme Num ou Eq : on comprend très vite leur utilité et comment s'en servir. Mais d'autres sont plus compliquées : c'est le cas des classes Functor et Applicative que vous allez découvrir dans ce chapitre.<br/> Ils permettent d'abstraire beaucoup d'opérations courantes, comme par exemple le fait d'appliquer à une fonction &quot;pure&quot; des arguments donc l'évaluation peut échouer, entrainer des effets sur l'extérieur ou dépendre des opérations effectuées précédemment.</p>
</div><a name="Lesfoncteurs"></a><h2>Les foncteurs</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">
<span class="arrow"></span>
<span class="next">Programmez avec des effets</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
<span class="next">Appliquez des fonctions : les foncteurs applicatifs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-les-foncteurs" data-claire-element-id="421497">Les foncteurs</h4><p id="r-421445" data-claire-element-id="421445">Avant de commencer à expliquer les foncteurs, voilà la classe en question :</p><pre id="r-421446" data-claire-element-id="421446"><code data-claire-semantic="haskell">class Functor f where 
      fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></pre><h5 id="r-differentes-sortes-de-constructeurs-de-types" data-claire-element-id="421456">Différentes sortes de constructeurs de types</h5><p id="r-421447" data-claire-element-id="421447">Contrairement à ce que vous avez pu voir avant, le paramètre <code data-claire-semantic="haskell">f </code> de cette classe n'est pas un type : <code data-claire-semantic="haskell">f a </code> n'a pas de sens si f est un type. Par contre, si on remplace f par un constructeur de type (comme par exemple <code data-claire-semantic="haskell">Maybe </code>, on trouve <code data-claire-semantic="haskell">fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b </code>. Maybe n'est pas un type en lui-même, mais on peut lui passer un type pour obtenir un type : c'est pour cela qu'on dit que c'est un constructeur de type.</p><p id="r-421448" data-claire-element-id="421448">On peut aussi créer des types prenant un constructeur de type prenant un paramètre en paramètre. On rajoute une instance de Show qui ne fait rien pour pouvoir l'utiliser plus facilement dans ghci.</p><pre id="r-421449" data-claire-element-id="421449"><code data-claire-semantic="haskell">data OfInt c = OfInt (c Int)

instance Show (OfInt c) where
    show _ = &quot;OfInt&quot;</code></pre><p id="r-421450" data-claire-element-id="421450">On peut construire quelques valeurs de ce type (mais pas les afficher, parce qu'on n'a pas défini de vraie instance de Show).</p><pre id="r-421451" data-claire-element-id="421451"><code data-claire-semantic="console">*Main&gt; :set +t   (Active l'affichage des types après chaque expression)
*Main&gt; OfInt []
OfInt
it :: OfInt []
*Main&gt; OfInt (Just 42)
OfInt
it :: OfInt Maybe
*Main&gt; OfInt (Right 12)
OfInt
it :: OfInt (Either a)</code></pre><p id="r-421452" data-claire-element-id="421452">On pourrait même créer des données de type <code data-claire-semantic="haskell">OfInt IO </code> contenant un <code data-claire-semantic="haskell">IO Int </code>, c'est-à-dire une action IO renvoyant un entier. Le troisième exemple est le plus intéressant à voir : on a appliqué partiellement le type Either à a, et on a obtenu quelque chose d'équivalent à un constructeur de type comme Maybe.</p><p id="r-421453" data-claire-element-id="421453">Vous vous doutez peut-être de la suite : il y a bien des types là-dessous, ou plutôt des types de types. Ils sont appelés <em>kind</em> (sortes), et on peut les voir avec la commande <code data-claire-semantic="console">:kind</code> dans ghci. Un type a le kind <code>*</code>, et on utilise, comme pour les types normaux, <code>-&gt;</code> pour noter une fonction. Quelques exemples :</p><pre id="r-421454" data-claire-element-id="421454"><code data-claire-semantic="console">*Main&gt; :kind Int
Int :: *
*Main&gt; :kind Maybe
Maybe :: * -&gt; *
*Main&gt; :kind Either Int
Either Int :: * -&gt; *
*Main&gt; :kind Either
Either :: * -&gt; * -&gt; *
*Main&gt; :kind OfInt
OfInt :: (* -&gt; *) -&gt; *
*Main&gt; :kind (-&gt;)
(-&gt;) :: ?? -&gt; ? -&gt; *</code></pre><p id="r-421455" data-claire-element-id="421455">Le dernier kind peut vous intriguer un peu. (-&gt;), qui permet de définir le type des fonctions, est un constructeur de type comme les autres. Cependant, les kinds de ses arguments sont ?? et ?, et pas * comme on pourrait s'y attendre normalement. En réalité, ?? et ? sont des kind qui contiennent le kind *, en plus <a href="http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/primitives.html">d'autres kind particuliers beaucoup moins utilisés</a>. Vous pouvez donc, pour l'instant, les considérer comme des *.</p><h5 id="r-qu-est-ce-qu-un-foncteur" data-claire-element-id="421496">Qu'est-ce qu'un foncteur</h5><p id="r-421457" data-claire-element-id="421457">Un foncteur dispose donc, d'après la définition, d'une fonction <code data-claire-semantic="haskell">fmap </code>. Un premier exemple de foncteur, c'est les listes : il suffit de poser <code data-claire-semantic="haskell">fmap = map </code>. Sur les listes, fmap f applique donc f à tous les éléments contenus dans la liste. On peut utiliser cette idée pour trouver les instances de Functor pour d'autres types de conteneurs.</p><p id="r-421458" data-claire-element-id="421458">Par exemple, on peut définir une instance de Functor pour Maybe (vous n'avez pas besoin de charger cette définition, elle est déjà dans le Prelude) :</p><pre id="r-421459" data-claire-element-id="421459"><code data-claire-semantic="haskell">instance Functor Maybe where
    fmap f Nothing = Nothing
    fmap f (Just a) = Just (f a)</code></pre><pre id="r-421460" data-claire-element-id="421460"><code data-claire-semantic="console">Prelude&gt; fmap (*2) Nothing
Nothing
Prelude&gt; fmap (*2) (Just 21)
Just 42</code></pre><p id="r-421461" data-claire-element-id="421461">On peut aussi, de la même façon, définir une instance pour Either. Cependant, Either prend deux paramètres : il faut donc l'appliquer partiellement pour obtenir un type qui prend un seul paramètre :</p><pre id="r-421462" data-claire-element-id="421462"><code data-claire-semantic="haskell">instance Functor (Either a) where
    fmap f (Left l) = Left l
    fmap f (Right r) = Right (f r)</code></pre><p id="r-421463" data-claire-element-id="421463">Si on définit un autre conteneur, par exemple un arbre, on peut aussi définir une instance associée :</p><pre id="r-421464" data-claire-element-id="421464"><code data-claire-semantic="haskell">data Tree a = Leaf | Branch (Tree a) a (Tree a)
    deriving Show

instance Functor Tree where
    fmap f Leaf = Leaf
    fmap f (Branch l e r) = Branch (fmap f l) (f e) (fmap f r)</code></pre><p id="r-421465" data-claire-element-id="421465">Il y a une instance de Functor pour les paires : on applique la fonction au deuxième élément, en laissant le premier inchangé.</p><pre id="r-421466" data-claire-element-id="421466"><code data-claire-semantic="haskell">instance Functor ((,) e) where
    fmap f (e, x) = (e, f x)</code></pre><p id="r-421467" data-claire-element-id="421467">Sur des conteneurs, pour définir une instance de Functor, il suffit donc d'appliquer la fonction à toutes les valeurs de type a. Mais Functor ne s'applique pas qu'à des conteneurs : si vous listez les instances de Functor définies par défaut avec la commande <code data-claire-semantic="console">:info</code>, vous trouverez qu'IO est une instance de Functor :</p><pre id="r-421468" data-claire-element-id="421468"><code data-claire-semantic="console">Prelude&gt; :info Functor
class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b
          -- Defined in GHC.Base
instance Functor Maybe -- Defined in Data.Maybe
instance Functor IO -- Defined in GHC.IOBase
instance Functor [] -- Defined in GHC.Base</code></pre><p id="r-421469" data-claire-element-id="421469">En effet, on peut définir une fonction <code data-claire-semantic="haskell">mapIO </code> comme ceci (elle est déjà définie dans <code data-claire-semantic="haskell">Control.Monad </code> et s'appelle <code data-claire-semantic="haskell">liftM </code>).</p><pre id="r-421470" data-claire-element-id="421470"><code data-claire-semantic="haskell">mapIO :: (a -&gt; b) -&gt; IO a -&gt; IO b
mapIO f x = do
      vx &lt;- x
      return $ f vx</code></pre><p id="r-421471" data-claire-element-id="421471">On peut aussi définir une instance pour les fonctions : la première ligne est <code data-claire-semantic="haskell">instance Functor ((-&gt;) r) where </code>. Comme avec les opérateurs normaux, on a transformé <code>-&gt;</code> en un opérateur utilisable comme une fonction, et on l'a appliqué partiellement. Le type de fmap doit donc être : <code data-claire-semantic="haskell">fmap :: (a -&gt; b) -&gt; (-&gt;) r a -&gt; (-&gt;) r b </code>, c'est-à-dire : <code data-claire-semantic="haskell">fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b) </code> : on retrouve la composition de fonctions, et <code data-claire-semantic="haskell">fmap = (.) </code>.</p><h6 id="r-des-regles-a-respecter" data-claire-element-id="421475">Des règles à respecter</h6><p id="r-421472" data-claire-element-id="421472">Quand on écrit une instance de Functor, on s'attend à ce que quelques règles soient respectées : le foncteur doit bien se comporter par rapport à l'identité et la composition de fonctions. On peut écrire ces règles comme ceci :</p><pre id="r-421473" data-claire-element-id="421473"><code data-claire-semantic="haskell">fmap id == id
fmap (f . g) == fmap f . fmap g</code></pre><p id="r-421474" data-claire-element-id="421474">Vous pouvez définir des instances ne respectant pas ces lois, mais c'est une mauvaise idée puisque certaines fonctions sur les foncteurs peuvent supposer qu'elles sont vraies, et donc donner un résultat faux avec votre foncteur.<br/> On peut par exemple vérifier que notre instance de Maybe respecte ces lois : on a <code data-claire-semantic="haskell">fmap id Nothing == Nothing </code> et <code data-claire-semantic="haskell">fmap id (Just a) == Just (id a) == Just a </code>, donc la première loi est respectée. Pour la deuxième loi, <code data-claire-semantic="haskell">fmap (f . g) Nothing == Nothing </code> et <code data-claire-semantic="haskell">fmap f (fmap g Nothing) == fmap f Nothing == Nothing </code>, et pour Just : <code data-claire-semantic="haskell">fmap f (fmap g (Just a)) == fmap f (Just (g a)) == Just (f (g a)) == Just ((f . g) a) == fmap (f . g) (Just a) </code>. Les deux lois sont respectées, on a donc une instance valide.</p><h6 id="r-composer-des-foncteurs" data-claire-element-id="421485">Composer des foncteurs</h6><p id="r-421476" data-claire-element-id="421476">La structure des foncteurs est assez simple, mais elle a l'avantage de s'appliquer à beaucoup de types. Il est aussi très facile de composer des foncteurs simples pour créer des foncteurs plus complexes. Par exemple, une liste de liste est un foncteur : on peut créer une fonction <code data-claire-semantic="haskell">map2 f = map (map f) </code>, c'est-à-dire : <code data-claire-semantic="haskell">map2 = map . map </code>. Cependant, on ne peut pas écrire une instance de Functor pour les listes de listes, puisqu'ensuite, quand on utilise fmap, il n'est pas toujours possible de déterminer si on souhaite utiliser fmap sur les listes (avec les listes comme éléments), ou sur les listes de listes.</p><p id="r-421477" data-claire-element-id="421477">On peut de même composer généralement deux foncteurs <code data-claire-semantic="haskell">f </code> et <code data-claire-semantic="haskell">g </code>, en définissant un type <code data-claire-semantic="haskell">O f g </code> représentant la composition des deux constructeurs de types :</p><pre id="r-421478" data-claire-element-id="421478"><code data-claire-semantic="haskell">newtype O f g a = O (f (g a))
    deriving Show

instance (Functor f, Functor g) =&gt; Functor (O f g) where
    fmap f (O v) = O $ fmap (fmap f) v</code></pre><p id="r-421479" data-claire-element-id="421479"><code data-claire-semantic="haskell">newtype </code> permet, comme <code data-claire-semantic="haskell">data </code>, de définir un nouveau type, mais avec quelques restrictions : le type ne doit avoir qu'un seul constructeur, qui ne prend qu'un argument. Ces restrictions permettent au compilateur de ne pas avoir à mettre un constructeur et à l'enlever : à l'exécution, le type est exactement le même que le type original, mais il est différent pour la vérification de types. Cette astuce sert souvent à créer une copie d'un type, mais ayant des instances différentes de certaines classes de types. On a aussi indiqué une contrainte sur l'instance, notée <code data-claire-semantic="haskell">(Functor f, Functor g) =&gt; </code> : pour que O f g soit un foncteur avec cette définition, f et g doivent avoir des instances de Functor.</p><p id="r-421480" data-claire-element-id="421480">Si vous ne voulez pas , vous pouvez utiliser <code data-claire-semantic="haskell">fmap . fmap </code>. Avec l'instance de Functor pour les fonctions, on peut aussi écrire <code data-claire-semantic="haskell">fmap2 = fmap fmap fmap </code> (et pour cumuler les niveaux, rajoutez des fmap).</p><p id="r-421481" data-claire-element-id="421481">Il existe d'autres manières de composer des foncteurs. Par exemple, une paire de foncteurs est aussi un foncteur.</p><pre id="r-421482" data-claire-element-id="421482"><code data-claire-semantic="haskell">newtype P f g a = P (fmap f a, fmap g a)
    deriving Show

instance (Functor f, Functor g) =&gt; Functor (P f g) where
    fmap f (P (a,b)) = P (f a, f b)</code></pre><p id="r-421483" data-claire-element-id="421483">On peut tester ces deux instances :</p><pre id="r-421484" data-claire-element-id="421484"><code data-claire-semantic="console">*Main&gt; fmap fmap fmap (*2) [[1..2],[5..9]]
[[2,4],[10,12,14,16,18]]
*Main&gt; fmap (*2) (O [[1..2],[5..9]])
O [[2,4],[10,12,14,16,18]]
*Main&gt; fmap (*2) (P (Just 12, [1,2,3]))
P (Just 24,[2,4,6])</code></pre><h6 id="r-qu-est-ce-qui-n-est-pas-un-foncteur" data-claire-element-id="421491">Qu'est-ce qui n'est pas un foncteur ?</h6><p id="r-421486" data-claire-element-id="421486">Vous avez vu qu'on peut déclarer une instance valide de Functor pour beaucoup de types. Mais existe-t-il des types pour lesquels il n'y a pas d'instance de Functor ? La réponse est oui.</p><p id="r-421487" data-claire-element-id="421487">Il y a d'abord le problème des constructeurs de types qui prennent une contrainte sur leur argument : par exemple, le type Set du module <a href="http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/Data-Set.html">Data.Set</a> sert à stocker un ensemble de valeur. Pour des raisons d'efficacité, il suppose que les valeurs sont stockées dans un certain ordre dans l'ensemble (la structure de données utilisée est une variante des arbres binaires de recherche). Après l'opération fmap, on est donc obligé de retrier la structure, mais pour ça il faut rajouter une contrainte sur le type d'arrivée pour qu'il soit ordonné. On a donc une sorte de foncteur restreint, avec une opération <code data-claire-semantic="haskell">(Ord b) =&gt; (a -&gt; b) -&gt; Set a -&gt; Set b </code>, mais pas de foncteur général.</p><p id="r-421488" data-claire-element-id="421488">Mais certains types ne sont même pas des foncteurs restreints. C'est par exemple le cas de l'application de fonction, par rapport à son premier argument, donc en fixant le deuxième :</p><pre id="r-421489" data-claire-element-id="421489"><code data-claire-semantic="haskell">newtype RFun b a = RFun { unRFun :: a -&gt; b }</code></pre><p id="r-421490" data-claire-element-id="421490">On utilise ici la syntaxe des enregistrements, puisqu'elle permet de créer en même temps la fonction permettant de sortir le type original du conteneur créé par newtype. Si on voulait une instance de Functor pour RFun t, la fonction fmap aurait le type <code data-claire-semantic="haskell">fmap :: (a -&gt; b) -&gt; RFun t a -&gt; RFun t b </code>, c'est-à-dire un type équivalent à <code data-claire-semantic="haskell">(a -&gt; b) -&gt; (a -&gt; t) -&gt; (b -&gt; t) </code>. Mais il n'existe pas de fonctions de ce type respectant les règles pour un foncteur (intuitivement, comme les types a, b et t sont inconnus, on ne peut utiliser que les fonctions prises en paramètre pour les traiter et un paramètre de type b, mais on ne peut pas construire de valeur de type t de cette façon). Le type des fonctions est donc un foncteur pour la valeur à droite de la flèche (le type renvoyé), mais pas pour le type pris en entrée. On peut cependant définir une sorte d'«anti foncteur» qui serait l'équivalent des foncteurs pour ce type, avec une fonction <code data-claire-semantic="haskell">mapf :: (a -&gt; b) -&gt; (f b -&gt; f a) </code>. Ici, la fonction devrait (si on oublie RFun) être de type <code data-claire-semantic="haskell">mapf :: (a -&gt; b) -&gt; (b -&gt; t) -&gt; (a -&gt; t) </code>, et la définition <code data-claire-semantic="haskell">mapf = flip (.) </code> convient.</p><h6 id="r-quelques-utilisations-des-foncteurs" data-claire-element-id="421495">Quelques utilisations des foncteurs</h6><p id="r-421492" data-claire-element-id="421492">On peut par exemple utiliser les foncteurs pour créer plus facilement des fonctions pouvant échouer (donc renvoyant une valeur de type <code data-claire-semantic="haskell">Maybe a </code> ou <code data-claire-semantic="haskell">Either a b </code>). Par exemple, si on souhaite créer un site web regroupant des informations sur les meilleures glaces, on dispose d'une base de données (qu'on représentera ici par une liste d'enregistrements) et une fonction <code data-claire-semantic="haskell">rechercher </code> renvoyant une glace par son nom. On a aussi une fonction <code data-claire-semantic="haskell">pageGlace </code>, renvoyant la page associée à une glace.</p><pre id="r-421493" data-claire-element-id="421493"><code data-claire-semantic="haskell">data Glace = Glace {
  parfum :: String,
  fabriquant :: String,
  note :: Int
  }
  deriving Show

base = [Glace &quot;Framboise&quot; &quot;Ice Crime&quot; 20, Glace &quot;Chocolat&quot; &quot;Miam Glaces&quot; 17,
        Glace &quot;Vanille&quot; &quot;Pole Sud&quot; 16]

rechercher :: [Glace] -&gt; String -&gt; Either String Glace
rechercher base gl = case filter (\g -&gt; parfum g == gl) base of
    [] -&gt; Left &quot;Cette glace n'existe pas&quot;
    x:_ -&gt; Right x

pageGlace :: Glace -&gt; String
pageGlace g = &quot;Glace goût &quot; ++ parfum g ++ &quot; fabriquée par &quot; ++ fabriquant g 
              ++ &quot;. Note des lecteurs : &quot; ++ show (note g)</code></pre><p id="r-421494" data-claire-element-id="421494">Pour afficher la page d'une glace ou une erreur (si on suppose que le serveur web s'occupera de générer automatiquement un message d'erreur avec une réponse Left), il suffit donc de faire <code data-claire-semantic="haskell">servirPage g = fmap pageGlace (rechercher base g) </code>. Si la base de données était stockée à l'extérieur, le résultat de rechercher serait de type <code data-claire-semantic="haskell">IO (Either String Glace) </code>. Mais comme la composée de deux foncteurs est un foncteur, le traitement peut se poursuivre presque de la même manière, et il n'y a pas besoin de changer la fonction <code data-claire-semantic="haskell">pageGlace </code>.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">
<span class="arrow"></span>
<span class="next">Programmez avec des effets</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
<span class="next">Appliquez des fonctions : les foncteurs applicatifs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Appliquezdesfonctionslesfoncteursapplicatifs"></a><h2>Appliquez des fonctions : les foncteurs applicatifs</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
<span class="arrow"></span>
<span class="next">Les foncteurs</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-appliquez-des-fonctions-les-foncteurs-applicatifs" data-claire-element-id="421574">Appliquez des fonctions : les foncteurs applicatifs</h4><h5 id="r-appliquer-plusieurs-arguments" data-claire-element-id="421507">Appliquer plusieurs arguments</h5><p id="r-421498" data-claire-element-id="421498">Dans le chapitre sur les fonctions, on a vu qu'on pouvait définir des fonctions plus, moins, ... qui renvoient Nothing en cas d'erreur comme une division par zéro :</p><pre id="r-421499" data-claire-element-id="421499"><code data-claire-semantic="haskell">plus Nothing _ = Nothing
plus _ Nothing = Nothing
plus (Just a) (Just b) = Just (a + b)

moins Nothing _ = Nothing
moins _ Nothing = Nothing
moins (Just a) (Just b) = Just (a - b)

fois Nothing _ = Nothing
fois _ Nothing = Nothing
fois (Just a) (Just b) = Just (a * b)

divise Nothing _ = Nothing
divise _ Nothing = Nothing
-- la division par 0 donne un résultat indéfini
divise _ (Just 0) = Nothing
divise (Just a) (Just b) = Just (a / b)</code></pre><p id="r-421500" data-claire-element-id="421500">On peut essayer d'utiliser les foncteurs pour définir <code data-claire-semantic="haskell">plus </code>, <code data-claire-semantic="haskell">moins </code> et <code data-claire-semantic="haskell">fois </code> de façon plus simple. On commence simplement par traiter le premier argument avec fmap (+). Mais là on se retrouve devant un problème : <code data-claire-semantic="haskell">fmap (+) a </code> est de type <code data-claire-semantic="haskell">Maybe (Integer -&gt; Integer) </code>, alors qu'on a besoin d'une fonction d'une fonction de type &lt;mincode type=&quot;haskell&quot;&gt;Maybe Integer -&gt; Maybe Integer&lt;/minicode&gt;.</p><p id="r-421501" data-claire-element-id="421501">On a donc besoin d'une fonction de type <code data-claire-semantic="haskell">Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b </code>, qu'on peut voir comme une fonction qui applique une fonction contenue dans Maybe à une valeur contenue dans Maybe, ou alors une fonction qui transforme une fonction en une autre, suivant le point de vue. On peut la coder pour Maybe :</p><pre id="r-421502" data-claire-element-id="421502"><code data-claire-semantic="haskell">app :: Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
app (Just f) (Just x) = Just (f x)
app _ _ = Nothing</code></pre><p id="r-421503" data-claire-element-id="421503">Mais cette fonction peut très facilement se généraliser à d'autres foncteurs, comme IO :</p><pre id="r-421504" data-claire-element-id="421504"><code data-claire-semantic="haskell">appIO :: IO (a -&gt; b) -&gt; IO a -&gt; IO b
appIO fm xm = do
  f &lt;- fm
  x &lt;- xm
  return $ f x</code></pre><p id="r-421505" data-claire-element-id="421505">On peut ensuite utiliser ces fonctions (les lignes surlignées représentent l'entrée) :</p><pre id="r-421506" data-claire-element-id="421506"><code data-claire-semantic="console">*Main&gt; app (fmap (+) (Just 1)) (Just 2)
Just 3
*Main&gt; app (fmap (+) Nothing) (Just 2)
Nothing
*Main&gt; app (fmap (+) (Just 1)) Nothing
Nothing
*Main&gt; appIO (fmap (+) readLn) readLn
1
2
3</code></pre><h5 id="r-les-foncteurs-applicatifs" data-claire-element-id="421556">Les foncteurs applicatifs</h5><h6 id="r-definition-58" data-claire-element-id="421515">Définition</h6><p id="r-421508" data-claire-element-id="421508">Puisque cette fonction se retrouve avec plusieurs types, on la généralise en utilisant la classe de type Applicative, et on dit qu'un type est un <em>foncteur applicatif</em> (puisqu'on peut <em>appliquer</em> les fonctions). La classe Applicative est définie dans le module <a href="http://haskell.org/ghc/docs/6.12.1/html/libraries/base/Control-Applicative.html">Control.Applicative</a> comme ceci :</p><pre id="r-421509" data-claire-element-id="421509"><code data-claire-semantic="haskell">class (Functor f) =&gt; Applicative f where
  pure :: a -&gt; f a
  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</code></pre><p id="r-421510" data-claire-element-id="421510">L'opérateur <code data-claire-semantic="haskell">&lt;*&gt; </code> correspond à la fonction qu'on a <code data-claire-semantic="haskell">appe</code>lée app , mais est plus pratique à utiliser. Le module <code data-claire-semantic="haskell">Control.Applicative </code> définit aussi l'opérateur <code data-claire-semantic="haskell">&lt;$&gt; </code> comme un synonyme de <code data-claire-semantic="haskell">fmap </code> : on peut donc écrire <code data-claire-semantic="haskell">(+) &lt;$&gt; readLn &lt;*&gt; readLn </code> au lieu de <code data-claire-semantic="haskell">appIO (fmap (+) readLn) readLn </code>.</p><p id="r-421511" data-claire-element-id="421511">La fonction <code data-claire-semantic="haskell">pure </code> sert à créer une valeur du foncteur applicatif à partir d'une valeur normale. L'instance d'Appicative doit être liée à l'instance de Functor par la relation suivante : <code data-claire-semantic="haskell">pure f &lt;*&gt; v == fmap f v </code>. Une autre règle est qu'on doit avoir : <code data-claire-semantic="haskell">pure f &lt;*&gt; pure x == pure (f x) </code> : <code data-claire-semantic="haskell">pure </code> transforme l'application de fonctions en <code data-claire-semantic="haskell">&lt;*&gt; </code>. Il y a trois autres règles à respecter, qui sont un peu plus compliquées à comprendre et moins utiles :</p><pre id="r-421512" data-claire-element-id="421512"><code data-claire-semantic="haskell">pure id &lt;*&gt; v == v
pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w == u &lt;*&gt; (v &lt;*&gt; w)
u &lt;*&gt; pure y == pure ($ y) &lt;*&gt; u</code></pre><aside id="r-421514" data-claire-element-id="421514" data-claire-semantic="information"><p id="r-421513" data-claire-element-id="421513">Importer <code>Control.Applicative</code> ajoute un certain nombre d'instances de Functor : vous risquez de vous retrouver avec des problèmes d'instances dupliquées. Il suffit d'enlever les définitions d'instances concernées pour régler le problème.</p></aside><h6 id="r-exemples-d-instances" data-claire-element-id="421541">Exemples d'instances</h6><p id="r-421516" data-claire-element-id="421516">Il y a aussi beaucoup d'instances d'Applicative. On a vu avant que Maybe et IO disposaient d'une fonction <code data-claire-semantic="haskell">&lt;*&gt; </code>, mais on peut aussi leur donner une fonction <code data-claire-semantic="haskell">pure </code> :</p><pre id="r-421517" data-claire-element-id="421517"><code data-claire-semantic="haskell">instance Applicative Maybe where
    pure = Just
    Just f &lt;*&gt; Just x = Just $ f x
    _ &lt;*&gt; _ = Nothing

instance Applicative IO where
    pure = return
    fm &lt;*&gt; xm = do
        f &lt;- fm
        x &lt;- xm
       return (f x)</code></pre><p id="r-421518" data-claire-element-id="421518">Par contre, même si on peut définir une instance de Functor pour <code data-claire-semantic="haskell">(,) e </code>, il n'y a pas d'instance d'Applicative : pour cela, il faudrait un moyen de créer une valeur de type e, et de combiner deux valeurs, qui permette de respecter les règles des foncteurs applicatifs. Si on choisit de spécialiser l'instance (par exemple aux entiers), on obtient une instance qui marche :</p><pre id="r-421519" data-claire-element-id="421519"><code data-claire-semantic="haskell">instance Applicative ((,) Integer) where
    pure x = (0,x)
    (a,f) &lt;*&gt; (b,x) = (a+b, f x)</code></pre><p id="r-421520" data-claire-element-id="421520">Mais si vous essayez de définir cette instance, vous allez rencontrer une erreur du compilateur :</p><pre id="r-421521" data-claire-element-id="421521"><code data-claire-semantic="console">/home/gnomnain/haskell/tuto/functor.hs:54:0:
    Illegal instance declaration for `Applicative ((,) Integer)'
        (All instance types must be of the form (T a1 ... an)
         where a1 ... an are type *variables*,
         and each type variable appears at most once in the instance head.
         Use -XFlexibleInstances if you want to disable this.)
    In the instance declaration for `Applicative ((,) Integer)'</code></pre><p id="r-421522" data-claire-element-id="421522">Cela vient d'une limitation des définitions possible de typeclasses dans la version Haskell 98 du langage. Mais GHC supporte beaucoup d'extensions à Haskell 98. Ici, il nous indique d'utiliser l'extension <code>FlexibleInstances</code>. Vous pouvez l'activer de deux façons : en lançant <code>ghci</code> avec l'option <code data-claire-semantic="console">-XFlexibleInstances</code>, ou en rajoutant tout en haut de votre fichier un commentaire avec le contenu suivant : <code data-claire-semantic="console">{-# LANGUAGE FlexibleInstances #-}</code>.</p><p id="r-421523" data-claire-element-id="421523">Il est possible de définir une instance similaire en faisant le produit de deux entiers, en concaténant des listes, en prenant le minimum ou le maximum, ...</p><p id="r-421524" data-claire-element-id="421524">Pour continuer sur la gestion des erreurs, on peut aussi créer une instance d'Applicative pour Either : il suffit de prendre la première valeur d'erreur rencontrée sur les deux arguments de &lt;*&gt; :</p><pre id="r-421525" data-claire-element-id="421525"><code data-claire-semantic="haskell">instance Applicative (Either e) where 
    pure = Right
    Right f &lt;*&gt; Right x = Right $ f x
    Left e &lt;*&gt; _ = Left e
    Right _ &lt;*&gt; Left e = Left e</code></pre><p id="r-421526" data-claire-element-id="421526">Mais on pourrait aussi imaginer une instance qui prend l'erreur placée la plus à droite, et pas celle-là plus à gauche :</p><pre id="r-421527" data-claire-element-id="421527"><code data-claire-semantic="haskell">instance Applicative (Either e) where 
    pure = Right
    Right f &lt;*&gt; Right x = Right $ f x
    _ &lt;*&gt; Left e = Left e    
    Left e &lt;*&gt; _ = Left e</code></pre><p id="r-421528" data-claire-element-id="421528">On peut même envisager de stocker une liste de toutes les erreurs rencontrées :</p><pre id="r-421529" data-claire-element-id="421529"><code data-claire-semantic="haskell">instance Applicative (Either [e]) where
    pure = Right
    Right f &lt;*&gt; Right x = Right $ f x
    Left e &lt;*&gt; Right _ = Left e
    Right _ &lt;*&gt; Left f = Left f
    Left e &lt;*&gt; Left f = Left (e ++ f)</code></pre><p id="r-421530" data-claire-element-id="421530">Mais la première instance est la plus utilisée, puisqu'elle est compatible avec l'instance de la classe Monad pour Either, que vous découvrirez dans un autre chapitre. Celle qui récupère toutes les erreurs est cependant utile, si on souhaite par exemple présenter le plus d'erreurs possibles à l'utilisateur.</p><p id="r-421531" data-claire-element-id="421531">On a vu que les fonctions disposaient d'une instance de Functor. On peut aussi les rendre membres de la classe Applicative. pure doit renvoyer une fonction de type r -&gt; a à partir d'une valeur de type a : il faut logiquement renvoyer une fonction constante. On voit aussi que le type de l'opérateur <code data-claire-semantic="haskell">&lt;*&gt; </code> doit être <code data-claire-semantic="haskell">(r -&gt; a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b) </code>. On en déduit alors la définition (qui est déjà présente par défaut) :</p><pre id="r-421532" data-claire-element-id="421532"><code data-claire-semantic="haskell">instance Applicative ((-&gt;) r) where
    pure = const
    f &lt;*&gt; x = (\r -&gt; (f r) (x r)</code></pre><p id="r-421533" data-claire-element-id="421533">Cette instance d'Applicative permet de composer des actions qui accèdent à un contexte pour leur exécution. Par exemple, si on code un interpréteur, le contexte serait la liste des variables définies et leur valeur.</p><p id="r-421534" data-claire-element-id="421534">Il existe aussi une instance d'Applicative pour les listes. La fonction <code data-claire-semantic="haskell">pure </code> renvoie une liste à un élément, et <code data-claire-semantic="haskell">&lt;*&gt; </code> crée toutes les combinaisons possibles des valeurs dans les listes de ses deux éléments. Cette fonction se créer facilement grâce à <code data-claire-semantic="haskell">concatMap </code>, qui combine <code data-claire-semantic="haskell">concat </code> et <code data-claire-semantic="haskell">map </code> en concaténant les résultats de la fonction donnée sur les chaque élément :</p><pre id="r-421535" data-claire-element-id="421535"><code data-claire-semantic="haskell">instance Applicative [] where
  pure x = [x]
  fs &lt;*&gt; xs = concatMap (\f -&gt; map f xs) fs
-- on pourrait écrire
-- fs &lt;*&gt; xs = concat $ map (\f -&gt; map f xs) fs</code></pre><p id="r-421536" data-claire-element-id="421536">Cette instance est pratique dans les cas où on veut tester toutes les possibilités. Par exemple, on peut s'en servir pour savoir si une formule logique est toujours vraie (ici, ~&gt; note l'implication) :</p><pre id="r-421537" data-claire-element-id="421537"><code data-claire-semantic="haskell">True ~&gt; False = False
_ ~&gt; _ = True

prop a b c = (a ~&gt; b ~&gt; c) ~&gt; ((a ~&gt; b) ~&gt; (a ~&gt; c))
prop2 a b c = (a ~&gt; b) ~&gt; ((a ~&gt; c) ~&gt; (b ~&gt; c))

bool = [True,False]

test prop = prop &lt;$&gt; bool &lt;*&gt; bool &lt;*&gt; bool</code></pre><p id="r-421538" data-claire-element-id="421538">Grâce à ce code, on peut tester une propriété sur les 8 combinaisons possibles de a, b et c :</p><pre id="r-421539" data-claire-element-id="421539"><code data-claire-semantic="console">*Main&gt; test prop
[True,True,True,True,True,True,True,True]
*Main&gt; test prop2
[True,True,True,True,True,False,True,True]</code></pre><p id="r-421540" data-claire-element-id="421540">On voit alors que <code data-claire-semantic="haskell">prop </code> est toujours vraie, mais pas <code data-claire-semantic="haskell">prop2 </code>.</p><h6 id="r-fonctions-utiles" data-claire-element-id="421548">Fonctions utiles</h6><p id="r-421542" data-claire-element-id="421542">Le module <code data-claire-semantic="haskell">Control.Applicative </code> définit quelques fonctions utiles pour travailler avec les foncteurs. La fonction <code data-claire-semantic="haskell">liftA2 :: (Functor f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c </code> permet de transformer une fonction qui travaille sur des valeurs &quot;pures&quot; en une fonction qui agit sur les valeurs du foncteur. Elle est facile à coder, et nous permet de factoriser les fonctions <code data-claire-semantic="haskell">plus </code>, <code data-claire-semantic="haskell">moins </code> et <code data-claire-semantic="haskell">fois </code> vue en introduction. La fonction <code data-claire-semantic="haskell">liftA3 </code> fait la même chose avec les fonctions à trois arguments :</p><pre id="r-421543" data-claire-element-id="421543"><code data-claire-semantic="haskell">liftA2 f x y = f &lt;$&gt; x &lt;*&gt; y
liftA3 f x y z = f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z

plus, moins, fois :: (Num a, Functor f) =&gt; f a -&gt; f a -&gt; f a
plus = liftA2 (+)
moins = liftA2 (-)
fois = liftA2 (*)</code></pre><p id="r-421544" data-claire-element-id="421544">Pour voir le fonctionnement des fonctions suivantes, un bon exemple est le type Log, qui a une instance d'Applicative (ce n'est qu'un cas particulier des instances pour les paires) :</p><pre id="r-421545" data-claire-element-id="421545"><code data-claire-semantic="haskell">data Log e a = Log [e] a

instance Applicative (Log e) where
    pure = Log []
    Log e1 f &lt;*&gt; Log e2 x = Log (e1 ++ e2) (f x)

log a = Log [a] ()</code></pre><p id="r-421546" data-claire-element-id="421546">On voit qu'avec cette instance, l'ordre d'exécution a une importance : <code data-claire-semantic="haskell">liftA2 (+) (Log &quot;1&quot; 1) (Left &quot;2&quot; 2) </code> renvoie <code data-claire-semantic="haskell">Log &quot;12&quot; 3 </code>, alors que si on inverse les arguments, on obtient <code data-claire-semantic="haskell">Log &quot;21&quot; 3 </code>.</p><p id="r-421547" data-claire-element-id="421547">Les fonctions <code data-claire-semantic="haskell">*&gt; </code> et <code data-claire-semantic="haskell">&lt;* </code> s'occupent d'abord du premier argument puis du deuxième, mais renvoient la valeur qui est du côté de la flèche. Par exemple, <code data-claire-semantic="haskell">log &quot;123&quot; *&gt; (log &quot;456&quot; *&gt; pure 2) </code> renvoie <code data-claire-semantic="haskell">Log &quot;123456&quot; 2 </code>, alors que <code data-claire-semantic="haskell">(log &quot;456&quot; *&gt; pure 2) &lt;* log &quot;123&quot; </code> renvoie <code data-claire-semantic="haskell">Log &quot;456123&quot; 2 </code>. Elles sont donc importantes quand le foncteur a une notion d'ordre. La fonction <code data-claire-semantic="haskell">&lt;**&gt; </code> est comme <code data-claire-semantic="haskell">&lt;*&gt; </code>, sauf que la séquence est inversée : <code data-claire-semantic="haskell">f &lt;*&gt; x </code> applique d'abord l'effet de f, puis de x, alors que <code data-claire-semantic="haskell">&lt;**&gt; </code> applique d'abord l'effet de x, puis celui de f. Enfin, le module <code data-claire-semantic="haskell">Data.Traversable </code> définit une fonction <code data-claire-semantic="haskell">sequenceA </code>. Elle s'applique à tous les conteneurs ayant une instance de la classe <code data-claire-semantic="haskell">Traversable </code>. Pour les listes, le type de la fonction est : <code data-claire-semantic="haskell">sequenceA :: (Applicative f) =&gt; [f a] -&gt; f [a] </code> : les actions contenues dans la liste sont séquencées, et on renvoie la liste de leur résultats.</p><h6 id="r-une-autre-construction" data-claire-element-id="421555">Une autre construction</h6><p id="r-421549" data-claire-element-id="421549">On peut aussi construire les foncteurs applicatifs d'une autre façon. La construction avec <code data-claire-semantic="haskell">pure </code> et <code data-claire-semantic="haskell">&lt;*&gt; </code> est assez naturelle, mais donne des règles difficiles à établir et à interpréter. On va garder la fonction <code data-claire-semantic="haskell">pure </code>, mais essayer de trouver un remplacement pour <code data-claire-semantic="haskell">&gt;&lt;*&gt; </code>. La fonction <code data-claire-semantic="haskell">liftA2 </code> est une bonne candidate : en effet, on a <code data-claire-semantic="haskell">f &lt;*&gt;x = liftA2 ($) f x </code>. On a donc une première définition équivalente.</p><p id="r-421550" data-claire-element-id="421550">La deuxième remarque qu'on peut faire c'est que les fonctions à deux arguments peuvent être converties en fonction qui prennent une coupe et vice-versa grâce aux fonctions <code data-claire-semantic="haskell">curry :: ((a,b) -&gt; c) -&gt; a -&gt; b -&gt; c </code> et <code data-claire-semantic="haskell">uncurry :: (a -&gt; b -&gt; c) -&gt; (a,b) -&gt; c </code>. Le problème qui se pose pour coder &lt;minicode tyê=&quot;haskell&quot;&gt;liftA2&lt;/minicode&gt; à partir de <code data-claire-semantic="haskell">fmap </code>, c'est qu'il faut transormer des <code>f a</code> et <code>f b</code> en <code>f (a,b)</code>. Si on a une fonction pour cela, on peut retrouver les opérations sur les foncteurs applicatifs.<br/> La fonction pure n'est même pas nécessaire, elle peut être remplacée par une valeur <code data-claire-semantic="haskell">unit = pure () </code>. En effet, on a <code data-claire-semantic="haskell">pure a = const a &lt;$&gt; unit </code>. Ces définitions sont donc liées par les relations suivantes :</p><pre id="r-421551" data-claire-element-id="421551"><code data-claire-semantic="haskell">unit = pure ()
pure a = const a &lt;$&gt; unit

(&lt;&amp;&gt;) = liftA2 (,)
liftA2 f a b = f &lt;$&gt; (a &lt;&amp;&gt; b)
f &lt;*&gt;x = liftA2 ($) f x</code></pre><p id="r-421552" data-claire-element-id="421552">Les propriétés des foncteurs applicatifs s'écrivent de façon plus sympathique avec cette notation, et sont plus naturelles :</p><pre id="r-421553" data-claire-element-id="421553"><code data-claire-semantic="haskell">-- On pose :
assoc (a,(b,c)) = ((a,b),c)

(f *** g) (x,y) = (f x, f y) 

-- Les règles :
fmap (f *** g) (x &lt;&amp;&gt; y) == fmap f x &lt;&amp;&gt; fmap f y
fmap fst (x &lt;&amp;&gt; unit)  == x
fmap snd (unit &lt;&amp;&gt; x) == x 
fmap assoc (u &lt;&amp;&gt; (v &lt;&amp;&gt; w)) = (u &lt;&amp;&gt; v) &lt;&amp;&gt; w</code></pre><p id="r-421554" data-claire-element-id="421554">Cependant, en général, cette définition ne facilite pas beaucoup la définition d'une instance d'Applicative, mais risque plutôt de la compliquer puisqu'il faut définir des fonctions annexes.</p><h5 id="r-applications-interessantes" data-claire-element-id="421573">Applications intéressantes</h5><h6 id="r-generaliser-la-fonction-zipwith-a-plus-d-arguments" data-claire-element-id="421562">Généraliser la fonction zipWith à plus d'arguments</h6><p id="r-421557" data-claire-element-id="421557">La fonction <code data-claire-semantic="haskell">zipWith </code> permet d'appliquer une fonction aux éléments de deux listes pris deux à deux. On a <code data-claire-semantic="haskell">zipWith f [x1,x2,...] [y1,y2,...] = [f x1 y1, f x2 y2, ...] </code>. Il existe de même une fonction <code data-claire-semantic="haskell">zipWith3 </code> qui prend une fonction à trois arguments et trois listes. Mais il faut recréer une fonction pour chaque nombre d'arguments, ce n'est donc pas très pratique.</p><p id="r-421558" data-claire-element-id="421558">Cependant, on peut coder les fonctions <code data-claire-semantic="haskell">zipWithN </code> (où N vaut 3, 4, ...) simplement à partir de la fonction <code data-claire-semantic="haskell">zipWith </code> : on applique d'abord partiellement la <code data-claire-semantic="haskell">fo</code>nction f à tous les éléments de la première liste, puis on applique les éléments de la liste obtenue à la deuxième liste, ... Par exemple :</p><pre id="r-421559" data-claire-element-id="421559"><code data-claire-semantic="haskell">zipWith3' f xs ys zs = zipWith (zipWith ($) (map f xs) ys) zs</code></pre><p id="r-421560" data-claire-element-id="421560">En fait, on remarque que <code data-claire-semantic="haskell">zipWith ($) </code> joue le rôle de l'opérateur <code data-claire-semantic="haskell">&lt;*&gt; </code>. Il reste à trouver une fonction <code data-claire-semantic="haskell">pure </code> qui correspond. Il faut répéter l'élément donné un certain nombre de fois. Mais si on ne le met qu'un nombre fini de fois, on peut trouver une liste plus longue, et dans ce cas on n'a pas la propriété <code data-claire-semantic="haskell">pure id &lt;*&gt; u == u </code>, puisque la liste sera tronquée. Il faut donc générer une liste infinie : c'est ce que fait la fonction <code data-claire-semantic="haskell">repeat :: a -&gt; [a] </code>. Mais il y a un dernier problème : on a déjà une instance d'Applicative pour les listes. On va donc utiliser un <code data-claire-semantic="haskell">newtype </code> pour définir un synonyme pour les listes. Dans la bibliothèque standard, il est nommé <code data-claire-semantic="haskell">ZipList </code>.</p><pre id="r-421561" data-claire-element-id="421561"><code data-claire-semantic="haskell">data ZipList a = ZipList { unZipList :: [a] }

instance Applicative ZipList where
    pure = ZipList . repeat
    (ZipList f) &lt;*&gt; (ZipList x) = ZipList $ zipWith ($) f x</code></pre><h6 id="r-traiter-des-formulaires" data-claire-element-id="421572">Traiter des formulaires</h6><p id="r-421563" data-claire-element-id="421563">Si vous avez déjà programmé des sites web, par exemple en PHP, vous savez surement que traiter des formulaires peut devenir très lourd : on se retrouve parfois avec beaucoup de conditions imbriquées, du code répétitif, ... C'est un cas classique de traitement des erreurs, et on a vu que les foncteurs applicatifs s'y prêtaient plutôt bien. On veut en général présenter toutes les erreurs de traitement à l'utilisateur. De plus, on a un contexte d'exécution à transporter : ce sont les valeurs reçues du formulaire. Or, comme pour les foncteurs, on peut composer les foncteurs applicatifs, donc on peut à la fois transporter un contexte et récupérer les erreurs.</p><pre id="r-421564" data-claire-element-id="421564"><code data-claire-semantic="haskell">type Dict = [(String,String)]

data Acc a b = Error [a] | Result b 
             deriving Show

instance Functor (Acc e) where
  fmap f x = pure f &lt;*&gt; x

instance Applicative (Acc e) where
  pure = Result
  Result f &lt;*&gt; Result x = Result (f x)
  Error e &lt;*&gt; Result _ = Error e
  Result _ &lt;*&gt; Error f = Error f
  Error e &lt;*&gt; Error f = Error (e ++ f)

newtype Form a = Form { runForm :: Dict -&gt; Acc String a }

instance Functor Form where
  fmap f x = pure f &lt;*&gt; x

instance Applicative Form where
  pure = Form . pure . pure
  Form fe &lt;*&gt; Form xe = Form (liftA2 (&lt;*&gt;) fe xe)</code></pre><p id="r-421565" data-claire-element-id="421565">On a appelé <code data-claire-semantic="haskell">Acc </code> le foncteur applicatif qui accumule les erreurs. La définition de <code data-claire-semantic="haskell">&lt;*&gt; </code> pour <code data-claire-semantic="haskell">Form </code> est en fait la définition générale pour une composée de foncteurs applicatifs : si on appelle F et G les deux foncteurs, on a une fonction <code data-claire-semantic="haskell">G (a -&gt; b) -&gt; G a -&gt; G b </code> et on veut une fonction <code data-claire-semantic="haskell">F (G (a -&gt; b)) -&gt; F (G a) -&gt; F (G b) </code>. Il est donc naturel d'utiliser la fonction<code data-claire-semantic="haskell">liftA2 </code> associée à F.</p><p id="r-421566" data-claire-element-id="421566">On doit ensuite coder quelques fonctions pour récupérer et vérifier les données. Le but est de créer une structure qui contient toutes les données nécessaires pour le résultat. La fonction clé est check, qui prend un prédicat (une fonction renvoyant un booléen), et vérifie s'il est respecté par les données. On a aussi quelques fonctions pour récupérer les valeurs : <code data-claire-semantic="haskell">getInt </code>, <code data-claire-semantic="haskell">getString </code>, ...</p><pre id="r-421567" data-claire-element-id="421567"><code data-claire-semantic="haskell">getString :: String -&gt; Form String
getString s = Form $ (\env -&gt; case lookup s env of
                         Just a -&gt; Result a
                         Nothing -&gt; Result &quot;&quot;)

getInt :: String -&gt; Form Int
getInt s = Form $ (\env -&gt; case lookup s env of
                      Just a | all (`elem` ['0'..'9']) a -&gt; Result (read a) 
                      _ -&gt; Error [&quot;Le champ &quot; ++ s ++ &quot; n'est pas un entier&quot;])

check :: String -&gt; (a -&gt; Bool) -&gt; Form a -&gt; Form a
check err pred val = Form $ (\env -&gt; case runForm val env of
                                Error e -&gt; Error e
                                Result v -&gt; if pred v
                                            then Result v
                                            else Error [err])</code></pre><p id="r-421568" data-claire-element-id="421568">On peut ensuite traiter un formulaire simple, pour récupérer un enregistrement de type <code data-claire-semantic="haskell">Glace </code> défini plus haut :</p><pre id="r-421569" data-claire-element-id="421569"><code data-claire-semantic="haskell">parseGlace :: Form Glace
parseGlace = liftA3 Glace 
             (check &quot;Le champ \&quot;parfum\&quot; doit faire entre 1 et 40 caractères&quot;
              (\p -&gt; let l = length p in 1 &lt;= l &amp;&amp; l &lt;= 40) $ getString &quot;parfum&quot;)
             (getString &quot;fabriquant&quot;)
             (check &quot;La note doit être comprise entre 0 et 20&quot;
              (\n -&gt; 0 &lt;= n &amp;&amp; n &lt;= 20) $ getInt &quot;note&quot;)</code></pre><p id="r-421570" data-claire-element-id="421570">Les foncteurs et les foncteurs applicatifs sont donc un moyen de créer des fonctions pures qui ont des effets : elles peuvent garder une trace de ce qui a été exécuté, renvoyer des erreurs ou accéder à un contexte d'exécution. Ils s'appliquent aussi à beaucoup de situations, mais cela fait qu'ils ne sont pas aussi puissants qu'on le voudrait : par exemple, il n'est pas possible en général de faire dépendre l'effet d'une valeur qui est elle-même le résultat d'une action : si on a une fonction de type <code data-claire-semantic="haskell">a -&gt; f b </code>, on ne peut pas en tirer une fonction <code data-claire-semantic="haskell">f a -&gt; f b </code>, et donc faire dépendre l'effet du résultat des effets précédents.</p><p id="r-421571" data-claire-element-id="421571">Ce tutoriel n'est pas fini : de nouveaux chapitres seront progressivement ajoutés.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell">Apprenez la programmation fonctionnelle avec Haskell</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Les bases
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/haskell-c-est-quoi">Haskell ? C&#039;est quoi ?</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/pourquoi-apprendre-haskell">
Pourquoi apprendre Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/qu-est-ce-qu-on-peut-faire-en-haskell">
Qu&#039;est-ce qu&#039;on peut faire en Haskell ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/telechargez-et-installez-un-compilateur">
Téléchargez et installez un compilateur
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/decouvrez-le-langage-avec-ghci">Découvrez le langage avec ghci</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/une-calculatrice">
Une calculatrice
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/utiliser-des-fonctions">
Utiliser des fonctions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/listes-chaines-de-caracteres">
Listes, chaînes de caractères
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/definir-des-fonctions">Définir des fonctions</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarations-dans-un-fichier">
Déclarations dans un fichier
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/conditions-et-filtrage-de-motif">
Conditions et filtrage de motif
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-filtrage-de-motif">
Plus de filtrage de motif
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-et-classes-de-types">Types et classes de types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/types-simples">
Types simples
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/polymorphisme-et-classes-de-types">
Polymorphisme et classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/recursivite-1">Récursivité</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/c-est-quoi">
C&#039;est quoi ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/filtrage-de-motif-et-recursivite">
Filtrage de motif et récursivité
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmation-fonctionnelle">Programmation fonctionnelle</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/exemple-la-fonction-map">
Exemple : la fonction map
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/fonctions-sur-les-listes">
Fonctions sur les listes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/composer-des-fonctions-1">
Composer des fonctions
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creez-vos-propres-types">Créez vos propres types</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/declarer-un-type">
Déclarer un type
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/des-instances-de-classes-de-types">
Des instances de classes de types
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/modules-io-et-compilation">Modules, IO et compilation</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/creer-des-modules-1">
Créer des modules
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/entrees-et-sorties">
Entrées et sorties
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/plus-de-fonctions-compilation">
Plus de fonctions, compilation
</a>
</li>
</ul> </li></ul> </li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 2</span>
La suite
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/programmez-avec-des-effets">Programmez avec des effets</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
Les foncteurs
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/appliquez-des-fonctions-les-foncteurs-applicatifs">
Appliquez des fonctions : les foncteurs applicatifs
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/apprenez-la-programmation-fonctionnelle-avec-haskell/les-foncteurs">
<span class="arrow"></span>
<span class="next">Les foncteurs</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/apprenez-la-programmation-fonctionnelle-avec-haskell.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Oct 2013 20:02:04 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/apprenez-la-programmation-fonctionnelle-avec-haskell.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 03:45:02 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/qt-quelques-fonctionnalites-non-gui.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 07:14:20 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/qt-quelques-fonctionnalites-non-gui.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:18:24 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Qt : Quelques fonctionnalités non-GUI</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Qt : Quelques fonctionnalités non-GUI</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#QtQuelquesfonctionnalitsnon-GUI">Qt : Quelques fonctionnalités non-GUI</a><br/><a href="#UtiliserlesressourcesQt">Utiliser les ressources Qt</a><br/><a href="#Prsentation">Présentation</a><br/><a href="#Crerlefichierderessources">Créer le fichier de ressources</a><br/><a href="#Utiliserlefichierressource">Utiliser le fichier ressource</a><br/><a href="#HacheravecQt">Hacher avec Qt</a><br/><a href="#Thorie">Théorie</a><br/><a href="#HacheravecQt">Hacher avec Qt</a><br/><a href="#Lestablesdehachage">Les tables de hachage</a><br/><a href="#Thorie">Théorie</a><br/><a href="#AvecQt">Avec Qt</a><br/><a href="#TPlezLogin">TP : le zLogin</a><br/><a href="#Prsentationdusujet">Présentation du sujet</a><br/><a href="#Correction">Correction</a><br/></div>
<a name="QtQuelquesfonctionnalitsnon-GUI"></a><h2>Qt : Quelques fonctionnalités non-GUI</h2><div class="content" role="article">
<p id="r-556164" data-claire-element-id="556164">Bonjour à tous !</p><p id="r-556165" data-claire-element-id="556165">Je suis Tobast, et je vais vous présenter dans ce cours quelques fonctionnalités de Qt qui ne concernent pas la GUI !</p><p id="r-556166" data-claire-element-id="556166">En effet, jusqu'à maintenant, sur le SDZ, l'aspect GUI de Qt a été beaucoup présenté, mais Qt permet de faire beaucoup de choses, en dehors de la création de fenêtres. Dans ce tuto, je vais essayer de vous présenter du mieux que je peux certaines utilisations de Qt sortant justement de cette GUI.</p><p id="r-556167" data-claire-element-id="556167">J'espère que ce cours vous plaira :) !</p>
</div>
<div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1358423835269-0" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1358423835269-0');
        });
    }
    </script>
</div><a name="UtiliserlesressourcesQt"></a><h2>Utiliser les ressources Qt</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-140">
<span class="next">Présentation</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-556168" data-claire-element-id="556168">Dans ce chapitre, nous allons voir comment utiliser les fichiers de ressource dont parlait M@teo21 dans son cours sur Qt designer :</p><p id="r-556169" data-claire-element-id="556169"><cite>Citation : M@teo21</cite></p><blockquote id="r-556174" data-claire-element-id="556174"><p id="r-556170" data-claire-element-id="556170"><strong>Resource Browser :</strong> un petit utilitaire qui vous permet de naviguer à travers les fichiers de ressources de votre application. Ces fichiers de ressources rappellent un peu ceux de Windows (on en a brièvement parlé dans l'annexe du cours de C, à propos de l'ajout d'icône à un programme sous Windows).<br/> Ici, les fichiers de ressouces portent l'extension .qrc et ont l'avantage d'être compatibles avec tous les OS.</p><aside id="r-556172" data-claire-element-id="556172" data-claire-semantic="information"><p id="r-556171" data-claire-element-id="556171">Les fichiers de ressources servent empaqueter des fichiers (images, sons, texte...) au sein même de votre exécutable. Cela permet d'éviter d'avoir à placer ces fichiers dans le même dossier que votre programme, et cela évite donc le risque de les perdre (puisqu'ils se trouveront toujours dans votre exécutable).</p></aside><p id="r-556173" data-claire-element-id="556173">C'est un peu hors-sujet, donc je n'en parlerai pas plus ici. Consultez la doc à propos des ressources si vous voulez en savoir plus.</p></blockquote><p id="r-556175" data-claire-element-id="556175">Eh bien, je vais vous expliquer ici comment s'en servir ! C'est très simple, vous allez voir !</p>
</div><a name="Prsentation"></a><h2>Présentation</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-les-ressources-qt">
<span class="arrow"></span>
<span class="next">Utiliser les ressources Qt</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
<span class="next">Créer le fichier de ressources</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-presentation-140" data-claire-element-id="556188">Présentation</h4><div id="r-556177" data-claire-element-id="556177" data-claire-semantic="question"><p id="r-556176" data-claire-element-id="556176">C'est quoi, concrètement, ces <em>ressources</em> dont tu nous parles depuis le début ?</p></div><p id="r-556178" data-claire-element-id="556178">Pour faire simple, les ressources sont des fichiers de tout genre inclus directement <em>dans</em> votre exécutable. Le fichier .rc dont M@teo21 parlait en annexe de son cours sur le C pour <a href="http://www.siteduzero.com/tutoriel-3-14177-creer-une-icone-pour-son-programme.html#ss_part_2">mettre une icône à son programme</a><strong>est</strong> un fichier de ressources. Seulement, ces ressources ne sont compatibles qu'avec Windows et j'ai jamais réussi à les utiliser.<br/> Le gros avantage de Qt, c'est que son fichier de ressources est <em>multi-plateformes</em>, il peut donc marcher sur tous les OS gérés par Qt (dont Windows, Linux et Mac, les principaux utilisés).</p><div id="r-556180" data-claire-element-id="556180" data-claire-semantic="question"><p id="r-556179" data-claire-element-id="556179">Ok, donc les ressources c'est des fichiers intégrés à l'exécutable. Mais... Concrètement, ça va me servir à quoi, tout ça ? :euh:</p></div><p id="r-556181" data-claire-element-id="556181">À plusieurs choses ! Premièrement, l'utilisateur ne pourra pas enlever de fichiers ressources de votre exécutable (il pourra éventuellement les récupérer avec un programme adapté). Ensuite, et surtout, quel que soit l'emplacement de votre exécutable, les fichiers ressources seront toujours accessibles depuis votre programme ! Utile si on veut par exemple le déplacer dans une clé USB.</p><div id="r-556183" data-claire-element-id="556183" data-claire-semantic="question"><p id="r-556182" data-claire-element-id="556182">Mais... Pour l'instant, il n'y a rien que je ne peux pas faire sans, non ?</p></div><p id="r-556184" data-claire-element-id="556184">Bien que ça soit pratique, en effet, vous pouvez tout faire sans. Mais il y a une dernière chose très pratique dont je ne vous ai pas parlé. Imaginez que vous faites une image que vous mettez dans votre programme. Dessus, vous écrivez &quot;MonProgramme - créé par [pseudo]&quot;. Si vous voulez la traduire, il vous faudra changer le code source, et faire un exécutable par pays !<br/> C'est là que les ressources entrent en jeu. Vous pouvez définir plusieurs fois le même &quot;nom&quot;, en indiquant le pays pour chacun ! Immaginez que vous mettez en ressource un fichier &quot;MonProgramme - créé par [pseudo]&quot; avec comme langue &quot;Français&quot;, et un autre &quot;MySoftware - created by [nick]&quot; sans langue. Ainsi, si votre programme est exécuté sur un PC français, l'image française s'affichera. Mais si vous l'exécutez partout ailleurs, ça sera en anglais !</p><div id="r-556186" data-claire-element-id="556186" data-claire-semantic="question"><p id="r-556185" data-claire-element-id="556185">Mais c'est super bien tout ça ! Elle est où l'arnaque ?</p></div><p id="r-556187" data-claire-element-id="556187">En effet, il y a un défaut à cette méthode. Quand on y réfléchit 2 secondes, ça parait logique, mais <strong>la taille de votre exécutable augmentera</strong> ! Mais puisque les ressources incluses n'ont pas besoin d'être aussi dans le dossier de votre exécutable, la taille de votre application + ses dossiers sera la même.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui">Qt : Quelques fonctionnalités non-GUI</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Fonctionnalités non-GUI
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-les-ressources-qt">Utiliser les ressources Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-140">
Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
Créer le fichier de ressources
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-le-fichier-ressource">
Utiliser le fichier ressource
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">Hacher avec Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-19">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt">
Hacher avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">Les tables de hachage</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-20">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/avec-qt">
Avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">TP : le zLogin</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-du-sujet-1">
Présentation du sujet
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/correction-196">
Correction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-les-ressources-qt">
<span class="arrow"></span>
<span class="next">Utiliser les ressources Qt</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
<span class="next">Créer le fichier de ressources</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Crerlefichierderessources"></a><h2>Créer le fichier de ressources</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-140">
<span class="arrow"></span>
<span class="next">Présentation</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-le-fichier-ressource">
<span class="next">Utiliser le fichier ressource</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-creer-le-fichier-de-ressources-1" data-claire-element-id="556260">Créer le fichier de ressources</h4><h5 id="r-structure-d-un-fichier-de-ressources-qt" data-claire-element-id="556199">Structure d'un fichier de ressources Qt</h5><p id="r-556189" data-claire-element-id="556189">Les fichiers de ressources Qt sont organisés en <em>préfixes</em> et <em>fichiers</em>.</p><div id="r-556191" data-claire-element-id="556191" data-claire-semantic="question"><p id="r-556190" data-claire-element-id="556190">C'est quoi ces <em>préfixes</em> dont tu nous parles ?<br/> Il y a un rapport avec les préfixes en Français ?</p></div><p id="r-556192" data-claire-element-id="556192">D'une certaine manière, oui, il y a un rapport. Pour rappel, un préfixe en Français est un &quot;bout de mot&quot; qui a une signification propre, et qui est placé au début d'un autre mot pour en changer le sens. Par exemple, le préfixe para- signifie &quot;qui protège de&quot;. Ainsi, un <strong>para</strong>pluie protège de la pluie, un <strong>para</strong>foudre protège de la foudre, une <strong>para</strong>bole protège de... Ah non, là ça marche pas en fait :-° .</p><p id="r-556193" data-claire-element-id="556193">Un préfixe, dans Qt, est un &quot;dossier&quot; qui sert à regrouper les fichiers de même type. Par exemple, si votre fichier de ressource contient des icônes et des fichiers sons, vous créerez sûrement un préfixe &quot;icones&quot; et un &quot;sons&quot;.</p><p id="r-556194" data-claire-element-id="556194">Et... Les fichiers, eux, sont tout simplement des fichiers de votre disque dur dont vous indiquez le chemin, et qui seront inclus à la compilation.</p><p id="r-556195" data-claire-element-id="556195">On pourrait donc symboliser un fichier de ressources comme ça :</p><pre id="r-556196" data-claire-element-id="556196"><code>ressources
|
préfixe 1
|-- fichier 1
|-- fichier 2
préfixe 2
|-- fichier 3</code></pre><aside id="r-556198" data-claire-element-id="556198" data-claire-semantic="information"><p id="r-556197" data-claire-element-id="556197">Comme vous le voyez, un préfixe peut contenir autant de fichiers que l'on veut.</p></aside><h5 id="r-creer-le-fichier-de-ressources" data-claire-element-id="556259">Créer le fichier de ressources</h5><p id="r-556200" data-claire-element-id="556200">Un fichier de ressources Qt est un fichier <strong>.qrc</strong> (facile à retenir, Qt ResourCe)</p><p id="r-556201" data-claire-element-id="556201">Pour créer votre fichier ressources, il y a plusieurs possibilités :</p><ul id="r-556206" data-claire-element-id="556206"><li id="r-556203" data-claire-element-id="556203"><p id="r-556202" data-claire-element-id="556202">Vous utilisez comme IDE Qt Creator : très simple, un outil de création de ressources intégré vous permet de créer vos fichiers ressource.</p></li><li id="r-556205" data-claire-element-id="556205"><p id="r-556204" data-claire-element-id="556204">Vous n'utilisez pas Qt Creator, dans ce cas vous êtes dans la... vous allez devoir créer votre fichier de ressources &quot;à la main&quot; (ou plutôt au clavier).</p></li></ul><p id="r-556207" data-claire-element-id="556207">Nous allons commencer par la méthode &quot;à la main&quot;. Ça fera pas de mal aux utilisateurs de Qt Creator de la lire aussi, ça permet de voir comment c'est fait exactement ;) .</p><h6 id="r-a-la-main-1" data-claire-element-id="556247">&quot;À la main&quot;</h6><p id="r-556208" data-claire-element-id="556208">Un fichier ressource n'est rien d'autre qu'un fichier texte un peu spécial. Commencez donc par ouvrir votre éditeur de texte (bloc-notes ou notepad++ sous Windows, Gedit/Vim ou autres sous Ubuntu), et attaquons-nous de suite à la syntaxe d'un fichier qrc !</p><p id="r-556209" data-claire-element-id="556209">Pour ceux qui connaissent, un fichier qrc ressemble un peu à du HTML (c'est du XML pour être précis, un <em>langage de balisage</em> dont dérive le HTML). Il commence donc par un <em>doctype</em> (plus court qu'un doctype HTML, je vous rassure :D ) :</p><pre id="r-556210" data-claire-element-id="556210"><code data-claire-semantic="xml">&lt;!DOCTYPE RCC&gt;</code></pre><p id="r-556211" data-claire-element-id="556211">Ensuite, tout comme la balise &lt;html&gt; entoure une page html, la balise &lt;RCC&gt; entoure le qrc :</p><pre id="r-556212" data-claire-element-id="556212"><code data-claire-semantic="xml">&lt;!DOCTYPE RCC&gt;
&lt;RCC&gt;

&lt;/RCC&gt;</code></pre><p id="r-556213" data-claire-element-id="556213">Pour créer un préfixe, le code est</p><pre id="r-556214" data-claire-element-id="556214"><code data-claire-semantic="xml">&lt;!DOCTYPE RCC&gt;
&lt;RCC&gt;
    &lt;qresource prefix=&quot;/monPrefixe&quot;&gt;
        
    &lt;/qresource&gt;
&lt;/RCC&gt;</code></pre><p id="r-556215" data-claire-element-id="556215">Ainsi, on met la balise <strong>qresource</strong> (attention, un seul &quot;s&quot; en Anglais !), avec <strong>prefix=&quot;/nomDuPrefixe&quot;</strong> comme attribut.</p><aside id="r-556217" data-claire-element-id="556217" data-claire-semantic="information"><p id="r-556216" data-claire-element-id="556216">Le nom d'un préfixe commence toujours par un slash (&quot;/&quot;) !</p></aside><p id="r-556218" data-claire-element-id="556218">Pour insérer des fichiers dans le qrc, encore une fois c'est très simple :</p><pre id="r-556219" data-claire-element-id="556219"><code data-claire-semantic="xml">&lt;!DOCTYPE RCC&gt;
&lt;RCC&gt;
    &lt;qresource prefix=&quot;/prefix&quot;&gt;
        &lt;file&gt;dossier/nomDuFichier.png&lt;/file&gt;
    &lt;/qresource&gt;
&lt;/RCC&gt;</code></pre><p id="r-556220" data-claire-element-id="556220">La balise <strong>&lt;file&gt;</strong> se place forcément dans un préfixe ! On met ensuite entre <strong>&lt;file&gt;</strong> et <strong>&lt;/file&gt;</strong> le chemin du fichier.</p><p id="r-556221" data-claire-element-id="556221">Si le nom du fichier est compliqué, il peut être utile de le simplifier avec un <em>alias</em> :</p><pre id="r-556222" data-claire-element-id="556222"><code data-claire-semantic="xml">&lt;!DOCTYPE RCC&gt;
&lt;RCC&gt;
    &lt;qresource prefix=&quot;/prefix&quot;&gt;
        &lt;file alias=&quot;icone&quot;&gt;dossier/petiteIconePourLaFenetreEtLaBarreDesTaches.png&lt;/file&gt;
    &lt;/qresource&gt;
&lt;/RCC&gt;</code></pre><p id="r-556223" data-claire-element-id="556223">Ainsi, avec l'attribut <strong>alias</strong>, dans notre programme la ressource ne sera pas appelée &quot;petiteIconePourLaFenetreEtLaBarreDesTaches.png&quot; mais &quot;icone&quot;. Avouez que c'est plus court :D !</p><p id="r-556224" data-claire-element-id="556224"><strong>Exercice time !</strong><br/> Vous devez inclure dans votre programme les fichiers suivants :</p><ul id="r-556235" data-claire-element-id="556235"><li id="r-556226" data-claire-element-id="556226"><p id="r-556225" data-claire-element-id="556225">fichiers/icones/prog.png</p></li><li id="r-556228" data-claire-element-id="556228"><p id="r-556227" data-claire-element-id="556227">fichiers/icones/ok.png</p></li><li id="r-556230" data-claire-element-id="556230"><p id="r-556229" data-claire-element-id="556229">fichiers/icones/annuler.png</p></li><li id="r-556232" data-claire-element-id="556232"><p id="r-556231" data-claire-element-id="556231">fichiers/sons/connexion.wav</p></li><li id="r-556234" data-claire-element-id="556234"><p id="r-556233" data-claire-element-id="556233">fichiers/sons/emis_en_cas_d_echec.wav</p></li></ul><p id="r-556236" data-claire-element-id="556236">Organisez-les en préfixes, et organisez-vous bien !</p><p id="r-556237" data-claire-element-id="556237"><strong>Solution</strong></p><p id="r-556238" data-claire-element-id="556238"></p><div id="r-556241" data-claire-element-id="556241"><pre id="r-556239" data-claire-element-id="556239"><code data-claire-semantic="xml">&lt;!DOCTYPE RCC&gt;
&lt;RCC&gt;
    &lt;qresource prefix=&quot;/icones&quot;&gt;
        &lt;file&gt;fichiers/icones/prog.png&lt;/file&gt;
        &lt;file&gt;fichiers/icones/ok.png&lt;/file&gt;
        &lt;file&gt;fichiers/icones/annuler.png&lt;/file&gt;
    &lt;/qresource&gt;
    &lt;qresource prefix=&quot;/sons&quot;&gt;
        &lt;file&gt;fichiers/sons/connexion.wav&lt;/file&gt;
        &lt;file alias=&quot;echec.wav&quot;&gt;fichiers/sons/emis_en_cas_d_echec.wav&lt;/file&gt;
    &lt;/qresource&gt;
&lt;/RCC&gt;</code></pre><p id="r-556240" data-claire-element-id="556240">J'ai mis un alias au 2nd fichier son, il était un peu long :D</p></div><div id="r-556243" data-claire-element-id="556243" data-claire-semantic="question"><p id="r-556242" data-claire-element-id="556242">Et... Pour les langues ?</p></div><p id="r-556244" data-claire-element-id="556244">Il &quot;suffit&quot; de créer un 2nd préfixe appelé comme celui à &quot;traduire&quot;, en lui rajoutant un attribut <em>lang=&quot;codeLangue&quot;</em>, où codeLangue est le code à deux lettres pour identifier un pays (exemple : France = fr). Pour les fichiers à &quot;traduire&quot;, vous devrez leur donner le même alias dans toutes les langues. Un petit exemple ?</p><pre id="r-556245" data-claire-element-id="556245"><code data-claire-semantic="xml">&lt;!DOCTYPE RCC&gt;
&lt;RCC&gt;
    &lt;qresource prefix=&quot;/icones&quot;&gt;
        &lt;file alias=&quot;annuler&quot;&gt;ressources/icones/annuler.png&lt;/file&gt;
        &lt;file alias=&quot;ok&quot;&gt;ressources/icones/ok.png&lt;/file&gt;
        &lt;file alias=&quot;prog&quot;&gt;ressources/icones/prog.png&lt;/file&gt;
    &lt;/qresource&gt;
    &lt;qresource prefix=&quot;/icones&quot; lang=&quot;fr&quot;&gt;
        &lt;file alias=&quot;annuler&quot;&gt;ressources/iconesfr/annuler.png&lt;/file&gt;
        &lt;file alias=&quot;ok&quot;&gt;ressources/iconesfr/ok.png&lt;/file&gt;
        &lt;file alias=&quot;prog&quot;&gt;ressources/iconesfr/prog.png&lt;/file&gt;
    &lt;/qresource&gt;
&lt;/RCC&gt;</code></pre><p id="r-556246" data-claire-element-id="556246">Ainsi, si l'utilisateur est français, <em>annuler</em> aura pour chemin <em>ressources/iconesfr/annuler.png</em>. Sinon, <em>annuler</em> aura pour chemin <em>ressources/icones/annuler.png</em> !</p><h6 id="r-avec-qt-creator" data-claire-element-id="556252">Avec Qt Creator</h6><p id="r-556248" data-claire-element-id="556248">Qt Creator, l'IDE de Qt, inclut un éditeur de fichiers qrc, très bien fait.</p><aside id="r-556250" data-claire-element-id="556250" data-claire-semantic="information"><p id="r-556249" data-claire-element-id="556249">Je considèrerai ici que vous connaissez cet IDE, et que vous le maitrisez !</p></aside><p id="r-556251" data-claire-element-id="556251">Premièrement, créez ou ouvrez un projet. Ensuite, faites un clic droit sur le nom du projet, et faites &quot;Ajouter nouveau...&quot;, puis choisissez &quot;Fichier de ressource Qt&quot;. Donnez-lui un nom, puis créez-le.<br/> Après, est-ce bien la peine d'expliquer ? Faites &quot;ajouter un préfixe&quot; pour ajouter un préfixe, et &quot;ajouter un fichier&quot; pour ajouter un fichier ( o_O sérieux ?)...</p><h6 id="r-bonus-l-editeur-de-ressources-qt" data-claire-element-id="556258">Bonus : l'Éditeur de ressources Qt !</h6><div id="r-556254" data-claire-element-id="556254" data-claire-semantic="question"><p id="r-556253" data-claire-element-id="556253">Mais... Si j'ai pas le Qt Creator, je suis obligé de créer mes .qrc à la main ?</p></div><p id="r-556255" data-claire-element-id="556255">Bon, je vous l'ai pas dit plus tôt parce que c'était important pour que vous compreniez bien le fonctionnement des ressources que vous appreniez à créer <strong>vous-mêmes</strong> vos fichiers qrc. Mais maintenant que vous avez appris tout ça, je vais vous montrer une dernière alternative (bien que d'autres programmes du même genre existent sûrement) : l'Éditeur de ressources Qt (abrégé qrc editor) !</p><p id="r-556256" data-claire-element-id="556256">Il s'agit d'un programme fait par moi-même permettant de créer des fichiers qrc en interface graphique, un peu comme avec l'éditeur de ressources intégré de Qt Creator.<br/> Il est sous licence GNU/GPL, et donc gratuit, et <em>open-source</em> : vous pouvez télécharger le code source, le modifier, et le redistribuer toujours gratuitement, sous condition de citer le créateur original (moi, donc). Dans le cas où vous y apporteriez des modifications, ça serait sympa de me contacter pour m'en informer :D !</p><p id="r-556257" data-claire-element-id="556257">Pour le télécharger, c'est <a href="http://tobast.fr/progNbr.php?id=2">par ici</a> !</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui">Qt : Quelques fonctionnalités non-GUI</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Fonctionnalités non-GUI
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-les-ressources-qt">Utiliser les ressources Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-140">
Présentation
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
Créer le fichier de ressources
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-le-fichier-ressource">
Utiliser le fichier ressource
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">Hacher avec Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-19">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt">
Hacher avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">Les tables de hachage</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-20">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/avec-qt">
Avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">TP : le zLogin</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-du-sujet-1">
Présentation du sujet
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/correction-196">
Correction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-140">
<span class="arrow"></span>
<span class="next">Présentation</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-le-fichier-ressource">
<span class="next">Utiliser le fichier ressource</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Utiliserlefichierressource"></a><h2>Utiliser le fichier ressource</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
<span class="arrow"></span>
<span class="next">Créer le fichier de ressources</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">
<span class="next">Hacher avec Qt</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-utiliser-le-fichier-ressource" data-claire-element-id="556291">Utiliser le fichier ressource</h4><div id="r-556262" data-claire-element-id="556262" data-claire-semantic="question"><p id="r-556261" data-claire-element-id="556261">C'est bien joli tout ça, mais moi, je sais toujours pas comment on les utilise dans le programme en lui-même !</p></div><p id="r-556263" data-claire-element-id="556263">Justement, il est temps de l'apprendre ! Alors là, accrochez-vous, c'est très dur ! Prêts ?</p><p id="r-556264" data-claire-element-id="556264">Dans un programme Qt, pour utiliser un fichier mis en ressource, il faut mettre au tout début de son chemin un &quot;:&quot;.<br/> Un exemple ?</p><p id="r-556265" data-claire-element-id="556265">Si vous avez créé le fichier de ressources suivant :</p><pre id="r-556266" data-claire-element-id="556266"><code data-claire-semantic="xml">&lt;!DOCTYPE RCC&gt;
&lt;RCC&gt;
    &lt;qresource prefix=&quot;/icones&quot;&gt;
        &lt;file alias=&quot;prog&quot;&gt;fichiers/progIcone.png&lt;/file&gt;
    &lt;/qresource&gt;
&lt;/RCC&gt;</code></pre><p id="r-556267" data-claire-element-id="556267">Vous avez créé le programme suivant :</p><pre id="r-556268" data-claire-element-id="556268"><code data-claire-semantic="cpp">#include &lt;QApplication&gt;
#include &lt;QPixmap&gt;
#include &lt;QLabel&gt;


int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    QLabel w;

    QPixmap p(&quot;:/icones/fichiers/progIcone.png&quot;);
    w.setPixmap(p);

    w.show();
    return app.exec();
}</code></pre><p id="r-556269" data-claire-element-id="556269">Vous voyez à la ligne 11 comment utiliser une ressource ! Il faut donc mettre un chemin sur le format suivant :</p><pre id="r-556270" data-claire-element-id="556270"><code>: + [préfixe] + / + [chemin complet de la ressource]</code></pre><div id="r-556272" data-claire-element-id="556272" data-claire-semantic="question"><p id="r-556271" data-claire-element-id="556271">Mais... À quoi il sert l'alias alors ?</p></div><p id="r-556273" data-claire-element-id="556273">Eh bien, j'ai commencé par vous montrer comment faire sans :D . Avec, c'est encore plus simple : le chemin ressemble à ça :</p><pre id="r-556274" data-claire-element-id="556274"><code>: + [préfixe] + / + [alias]</code></pre><p id="r-556275" data-claire-element-id="556275">Si on reprend notre programme, la ligne 11 ressemblerait à ça :</p><pre id="r-556276" data-claire-element-id="556276"><code data-claire-semantic="cpp">QPixmap p(&quot;:/icones/prog&quot;);</code></pre><div id="r-556278" data-claire-element-id="556278" data-claire-semantic="question"><p id="r-556277" data-claire-element-id="556277">Ça marche pas chez moi ! Ton code m'affiche une fenêtre sans rien dedans ! :'(</p></div><p id="r-556279" data-claire-element-id="556279">Dans ce cas, deux/trois trucs à revoir :</p><ul id="r-556284" data-claire-element-id="556284"><li id="r-556281" data-claire-element-id="556281"><p id="r-556280" data-claire-element-id="556280">Le fichier .qrc est-il bien dans le même dossier que les fichiers de code source ?</p></li><li id="r-556283" data-claire-element-id="556283"><p id="r-556282" data-claire-element-id="556282">Avez-vous lancé <strong>qmake -project</strong> depuis l'ajout du .qrc dans le dossier des fichiers source ? (dans le doute, relancez-le)</p></li></ul><p id="r-556285" data-claire-element-id="556285">Si oui, ouvrez le fichier .pro. Une ligne devrait contenir quelque chose comme</p><pre id="r-556286" data-claire-element-id="556286"><code>RESOURCES += mesressources.qrc</code></pre><p id="r-556287" data-claire-element-id="556287">Si ce n'est pas le cas, rajoutez-la quelque part (de préférence après les fichiers .cpp et les .h, ça fait plus propre), en modifiant bien sur &quot;mesressources.qrc&quot; par le nom de votre fichier qrc.</p><p id="r-556288" data-claire-element-id="556288">Si ça marche toujours pas, c'est sûrement les chemins dans le fichier .qrc qui sont en cause, vérifiez-les !</p><p id="r-556289" data-claire-element-id="556289">Voilà, vous savez maintenant créer et utiliser les fichiers de ressource Qt !</p><p id="r-556290" data-claire-element-id="556290">Si vous voulez jeter un coup d'œil sur la documentation officielle, c'est <a href="http://doc.qt.nokia.com/latest/resources.html">par ici</a> !</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui">Qt : Quelques fonctionnalités non-GUI</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Fonctionnalités non-GUI
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-les-ressources-qt">Utiliser les ressources Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-140">
Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
Créer le fichier de ressources
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-le-fichier-ressource">
Utiliser le fichier ressource
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">Hacher avec Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-19">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt">
Hacher avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">Les tables de hachage</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-20">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/avec-qt">
Avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">TP : le zLogin</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-du-sujet-1">
Présentation du sujet
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/correction-196">
Correction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
<span class="arrow"></span>
<span class="next">Créer le fichier de ressources</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">
<span class="next">Hacher avec Qt</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="HacheravecQt"></a><h2>Hacher avec Qt</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-le-fichier-ressource">
<span class="arrow"></span>
<span class="next">Utiliser le fichier ressource</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-19">
<span class="next">Théorie</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-556293" data-claire-element-id="556293">Dans ce chapitre, je vais vous expliquer comment <strong>hacher des données avec Qt</strong> !</p><div id="r-556295" data-claire-element-id="556295" data-claire-semantic="question"><p id="r-556294" data-claire-element-id="556294">Hacher ? C'est quoi ça ? Partager dans plusieurs variables ?</p></div><p id="r-556296" data-claire-element-id="556296">Mais non, rien à voir ! Si vous préférez, le hachage est une méthode de chiffrage ne permettant pas de décryptage.</p><p id="r-556297" data-claire-element-id="556297">Qt permet de hacher très facilement des données ! Je vais vous montrer comment faire tout au long de ce tuto. Prêt ? Suivez moi !</p>
</div><a name="Thorie"></a><h2>Théorie</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">
<span class="arrow"></span>
<span class="next">Hacher avec Qt</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt">
<span class="next">Hacher avec Qt</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-theorie-19" data-claire-element-id="556326">Théorie</h4><p id="r-556298" data-claire-element-id="556298">Comme je le disais plus haut, vous allez ici apprendre à <strong>hacher avec Qt</strong> !</p><p id="r-556299" data-claire-element-id="556299">Le hachage, pour faire simple, est un &quot;chiffrage&quot; qui ne peut pas être déchiffré.</p><p id="r-556300" data-claire-element-id="556300">Je vous vois déjà me demander :</p><div id="r-556302" data-claire-element-id="556302" data-claire-semantic="question"><p id="r-556301" data-claire-element-id="556301">Mais... Si on chiffre, c'est bien pour pouvoir déchiffrer après non ? Si on a pas l'intention de se resservir des données, autant ne pas les enregistrer !</p></div><p id="r-556303" data-claire-element-id="556303">En fait, le hachage ne permet pas de &quot;chiffrer&quot; toutes vos données. Vous pouvez, évidemment, mais il serait un peu inutile de hacher par exemple les meilleurs scores de votre jeu, vu que vous ne pourriez pas les afficher ensuite ! En fait, le hachage est surtout utilisé pour &quot;chiffrer&quot; des données qui seront à nouveau entrées par l'utilisateur, comme son mot de passe.</p><div id="r-556305" data-claire-element-id="556305" data-claire-semantic="question"><p id="r-556304" data-claire-element-id="556304">Ben oui, mais bon... Son mot de passe, on aura quand même besoin de le déchiffrer pour vérifier qu'il est bon ! Non ? :euh:</p></div><p id="r-556306" data-claire-element-id="556306">Pas forcément ! Prenons un exemple : On veut vérifier que 3x2 est égal à 6. On a alors deux possibilités de le vérifier.</p><ul id="r-556311" data-claire-element-id="556311"><li id="r-556308" data-claire-element-id="556308"><p id="r-556307" data-claire-element-id="556307">Soit on fait 3x2, on obtient 6, et on se rend alors compte que 6 = 6, et que donc 3x2 = 6</p></li><li id="r-556310" data-claire-element-id="556310"><p id="r-556309" data-claire-element-id="556309">Soit on fait 6/2 et 3x2/2, et on se rend compte que 3 = 3, et que donc 3x2 = 6.</p></li></ul><p id="r-556312" data-claire-element-id="556312">Si on applique cet exemple à notre mot de passe appelé ici &quot;MdP&quot; et son chiffrage appelé ici &quot;MdP chiffré&quot; (ici, pour illustrer les deux exemples, on dira que le mot de passe est chiffré et non haché, donc déchiffrable) , et qu'on a une fonction de chiffrage appelée &quot;chiffre&quot; et une de déchiffrage, &quot;déchiffre&quot; :</p><ul id="r-556317" data-claire-element-id="556317"><li id="r-556314" data-claire-element-id="556314"><p id="r-556313" data-claire-element-id="556313">Soit on fait chiffre(MdP), et on se rend compte que chiffre(MdP) = MdP chiffré</p></li><li id="r-556316" data-claire-element-id="556316"><p id="r-556315" data-claire-element-id="556315">Soit on fait déchiffre(MdP chiffré), et on se rend compte que MdP = déchiffre(MdP chiffré)</p></li></ul><p id="r-556318" data-claire-element-id="556318">Seulement, avec un hachage, on ne peut pas déchiffrer. Sans la fonction &quot;déchiffrer&quot;, il ne nous reste donc plus que la première possibilité !</p><p id="r-556319" data-claire-element-id="556319">Donc, pour résumer, pour comparer des données à des données hachées, on hache les données de la même manière que celles déjà hachées, et on compare les deux.</p><div id="r-556321" data-claire-element-id="556321" data-claire-semantic="question"><p id="r-556320" data-claire-element-id="556320">C'est bien joli, tout ça, mais après tout, à quoi ça me servirait ? Si l'utilisateur entre son mot de passe, il sera stocké sur son DD, donc à priori, il y a pas trop de risques de piratage !</p></div><p id="r-556322" data-claire-element-id="556322">Tout faux ^^ . Déjà, qui vous dit que l'utilisateur ne veut pas éviter que ses parents/ses fils/son chien n'accèdent à son mot de passe ? Ça peut donc être utile de hacher un mot de passe, même sur son propre disque dur.</p><p id="r-556323" data-claire-element-id="556323">Ensuite, imaginez que vous programmez une messagerie instantanée, par exemple (si vous préférez, un genre d'MSN). Tous les comptes créés seront sûrement stockés soit dans un fichier sur votre serveur, soit dans une base de données.</p><p id="r-556324" data-claire-element-id="556324">Si un pirate accédait à ce fichier ou cette base de données, vous imaginez un peu la catastrophe, dans le cas où les mots de passe sont en clair ! Il aurait alors accès à tous les comptes de tous les utilisateurs de votre programme :waw: ! Alors que vu qu'un hash (on appelle &quot;hash&quot; le résultat d'un hachage) est indéchiffrable... Le pirate ne pourra rien en faire.</p><p id="r-556325" data-claire-element-id="556325">Prêts pour passer au codage ? Alors, c'est parti !</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui">Qt : Quelques fonctionnalités non-GUI</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Fonctionnalités non-GUI
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-les-ressources-qt">Utiliser les ressources Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-140">
Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
Créer le fichier de ressources
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-le-fichier-ressource">
Utiliser le fichier ressource
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">Hacher avec Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-19">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt">
Hacher avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">Les tables de hachage</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-20">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/avec-qt">
Avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">TP : le zLogin</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-du-sujet-1">
Présentation du sujet
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/correction-196">
Correction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">
<span class="arrow"></span>
<span class="next">Hacher avec Qt</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt">
<span class="next">Hacher avec Qt</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="HacheravecQt"></a><h2>Hacher avec Qt</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-19">
<span class="arrow"></span>
<span class="next">Théorie</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">
<span class="next">Les tables de hachage</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-hacher-avec-qt" data-claire-element-id="556388">Hacher avec Qt</h4><aside id="r-556328" data-claire-element-id="556328" data-claire-semantic="information"><p id="r-556327" data-claire-element-id="556327">Tous les liens portant le nom d'une classe Qt seront des liens vers la doc' de Qt 4.6 !</p></aside><p id="r-556329" data-claire-element-id="556329">Bon, c'est fini avec la théorie, cette fois, on va vraiment programmer ! :D</p><p id="r-556330" data-claire-element-id="556330">Pour hacher, on va utiliser une classe du doux nom (un peu long aussi) de <a href="http://doc.trolltech.com/4.6/qcryptographichash.html">QCryptographicHash</a>. Tout se fera via la méthode statique <a href="http://doc.trolltech.com/4.6/qcryptographichash.html#hash">hash</a>.<br/> Voyons déjà son prototype :</p><pre id="r-556331" data-claire-element-id="556331"><code data-claire-semantic="cpp">QByteArray QCryptographicHash::hash ( const QByteArray &amp; data, Algorithm method )   [static]</code></pre><p id="r-556332" data-claire-element-id="556332">On voit donc plusieurs choses :</p><ul id="r-556341" data-claire-element-id="556341"><li id="r-556334" data-claire-element-id="556334"><p id="r-556333" data-claire-element-id="556333">Cette méthode est statique, mais ça je vous l'ai déjà dit :) . Pour rappel, une méthode statique peut être appelée sans avoir créé d'objet, avec <code data-claire-semantic="cpp">Classe::methode() </code>.</p></li><li id="r-556336" data-claire-element-id="556336"><p id="r-556335" data-claire-element-id="556335">La méthode retourne un <a href="http://doc.trolltech.com/4.6/qbytearray.html">QByteArray</a>, soit un tableau d'octets.</p></li><li id="r-556338" data-claire-element-id="556338"><p id="r-556337" data-claire-element-id="556337">Elle prend en premier paramètre un autre <a href="http://doc.trolltech.com/4.6/qbytearray.html">QByteArray</a>, qui ne sera pas modifié (const).</p></li><li id="r-556340" data-claire-element-id="556340"><p id="r-556339" data-claire-element-id="556339">Elle prend en second paramètre <a href="http://doc.trolltech.com/4.6/qcryptographichash.html#Algorithm-enum">Algorithm</a>, qui est une énumération définie dans QCryptographicHash.</p></li></ul><p id="r-556342" data-claire-element-id="556342">Détaillons ses paramètres :</p><ul id="r-556347" data-claire-element-id="556347"><li id="r-556344" data-claire-element-id="556344"><p id="r-556343" data-claire-element-id="556343"><strong>data</strong> est tout simplement ce que la fonction va chiffrer.</p></li><li id="r-556346" data-claire-element-id="556346"><p id="r-556345" data-claire-element-id="556345"><strong>method</strong> est la méthode de hachage. Car oui, il y a plusieurs méthodes !</p></li></ul><p id="r-556348" data-claire-element-id="556348">Reprenons donc le code de base de Qt :</p><pre id="r-556349" data-claire-element-id="556349"><code data-claire-semantic="cpp">#include &lt;QApplication&gt;
#include &lt;QWidget&gt;

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    QWidget w;

    w.show();
    return app.exec();
}</code></pre><p id="r-556350" data-claire-element-id="556350">On ne va ici utiliser que le main.</p><p id="r-556351" data-claire-element-id="556351">Ajoutons la fonction de hachage :</p><pre id="r-556352" data-claire-element-id="556352"><code data-claire-semantic="cpp">#include &lt;QApplication&gt;
#include &lt;QWidget&gt;
#include &lt;QCryptographicHash&gt;
#include &lt;QByteArray&gt;

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    QWidget w;

    QByteArray ba = QCryptographicHash::hash(/*arguments*/);

    w.show();
    return app.exec();
}</code></pre><div id="r-556354" data-claire-element-id="556354" data-claire-semantic="question"><p id="r-556353" data-claire-element-id="556353">Eh, au fait, tu nous as toujours pas dit qu'est-ce qu'on met comme arguments ! Et si j'ai pas de QByteArray, mais que je veux hacher... Je sais pas, moi ! Une chaine !<br/> Et puis, d'abord, on met quoi en deuxième argument, concrètement ?</p></div><p id="r-556355" data-claire-element-id="556355">Je vais commencer par répondre à la première, parce que c'est la plus simple pour faire ça dans l'ordre :</p><p id="r-556356" data-claire-element-id="556356">Pour envoyer une chaine de caractères (ce qui sera le cas si on veut hacher un mot de passe, par exemple), il faut que ça soit une QString, et envoyer à <strong>hash()</strong> sa conversion en UTF-8 :</p><pre id="r-556357" data-claire-element-id="556357"><code data-claire-semantic="cpp">QCryptographicHash(chaine.toUtf8(), /*arg 2*/); // chaine est une QString</code></pre><p id="r-556358" data-claire-element-id="556358">Ensuite, pour les différentes méthodes. Qt en propose à ce jour 3 :</p><ul id="r-556365" data-claire-element-id="556365"><li id="r-556360" data-claire-element-id="556360"><p id="r-556359" data-claire-element-id="556359">En <strong>MD4</strong> (<a href="http://fr.wikipedia.org/wiki/MD4">wikipedia</a>) : Cette méthode n'est pas sûre, et peut être cassée, mais elle a l'avantage d'être rapide. Dans l'absolu, mieux vaut éviter de l'utiliser, sauf si la rapidité de l'algorithme est vraiment importante. Pour l'utiliser, le second paramètre est <strong>QCryptographicHash::Md4</strong>.</p></li><li id="r-556362" data-claire-element-id="556362"><p id="r-556361" data-claire-element-id="556361">En <strong>MD5</strong> (<a href="http://fr.wikipedia.org/wiki/MD5">wikipedia</a>) : Une méthode assez sûre, bien qu'elle ne le soit de moins en moins avec l'apparition de &quot;dictionnaires Md5/texte&quot;, et la possibilité de <a href="http://fr.wikipedia.org/wiki/Collision (cryptologie)">générer des collisions</a> (merci à Phacog pour l'info sur les collisions !). Pour l'utiliser, le second paramètre est <strong>QCryptographicHash::Md5</strong>.</p></li><li id="r-556364" data-claire-element-id="556364"><p id="r-556363" data-claire-element-id="556363">En <strong>SHA-1</strong> (<a href="http://fr.wikipedia.org/wiki/Sha-1">wikipedia</a>) : La méthode considérée comme la plus sûre des trois, et celle que je vous conseille d'utiliser. Pour l'utiliser, le second paramètre est <strong>QCryptographicHash::Sha1</strong>.</p></li></ul><p id="r-556366" data-claire-element-id="556366">Essayez-donc de hacher en SHA-1 une chaine appelée <strong>chaine</strong> et définie un peu plus haut dans le code ! À vous de jouer !</p><p id="r-556367" data-claire-element-id="556367"></p><div id="r-556369" data-claire-element-id="556369"><pre id="r-556368" data-claire-element-id="556368"><code data-claire-semantic="cpp">#include &lt;QApplication&gt;
#include &lt;QWidget&gt;
#include &lt;QCryptographicHash&gt;
#include &lt;QByteArray&gt;
#include &lt;QString&gt;

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    QWidget w;

    QString chaine=&quot;Ceci sera haché.&quot;;
    QByteArray ba = QCryptographicHash::hash(chaine.toUtf8(), QCryptographicHash::Sha1);
    

    w.show();
    return app.exec();
}</code></pre></div><p id="r-556370" data-claire-element-id="556370">Et voilà ! Vous avez haché votre chaine !</p><div id="r-556372" data-claire-element-id="556372" data-claire-semantic="question"><p id="r-556371" data-claire-element-id="556371">J'ai essayé d'afficher le QByteArray dans un QMessageBox. Ça m'affiche un truc bizarre, plein de caractères spéciaux. Ça ressemble à ça un hash ? :euh:</p></div><p id="r-556373" data-claire-element-id="556373">Non :D . C'est normal que ça affiche ça, car le retour de <strong>hash</strong> n'est PAS une QString ! Pour le convertir en QString, il faut utiliser la méthode <strong>toHex()</strong> :</p><pre id="r-556374" data-claire-element-id="556374"><code data-claire-semantic="cpp">QString hash = ba.toHex();</code></pre><p id="r-556375" data-claire-element-id="556375">Là, vous obtiendrez une chaine qui ressemble à <strong>0e6d2d873c7ec7ce703e48b009723c9b820f29bd</strong>. Eh bien, ceci est votre hash !</p><p id="r-556376" data-claire-element-id="556376">Si on résume le code, on a donc :</p><pre id="r-556377" data-claire-element-id="556377"><code data-claire-semantic="cpp">#include &lt;QApplication&gt;
#include &lt;QWidget&gt;
#include &lt;QCryptographicHash&gt;
#include &lt;QByteArray&gt;
#include &lt;QString&gt;
#include &lt;QMessageBox&gt;


int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    QWidget w;

    QString chaine=&quot;Ceci sera haché.&quot;; // On crée la chaine à hacher
    QByteArray ba = QCryptographicHash::hash(chaine.toUtf8(), QCryptographicHash::Sha1); // on la hache

    QString out=ba.toHex(); // on convertit le hash en QString
    QMessageBox::information(&amp;w, &quot;test&quot;, out); // on l'affiche

    w.show();
    return app.exec();
}</code></pre><h5 id="r-plus-de-securite" data-claire-element-id="556387">Plus de sécurité ?</h5><div id="r-556379" data-claire-element-id="556379" data-claire-semantic="question"><p id="r-556378" data-claire-element-id="556378">Comment ça, &quot;plus de sécurité&quot; ? Tu nous avais dit que c'est indécryptable ! Tu nous aurais menti ? :colere2:</p></div><p id="r-556380" data-claire-element-id="556380">D'une certaine manière, non. En effet, c'est, à proprement parler, indéchiffrable. Mais... Il existe des correspondances entre les mots courants et leurs hachages MD5/SHA-1 ou autres. Évidemment, ces bases de données ne sont pas complètes ! Mais si votre hash est dedans... Pour cela, il a été mis au point une technique permettant d'assaisonner les aliments de rendre ces méthodes quasi-inutiles, et de rendre plus difficiles les attaques par force brute (test de toutes les combinaisons) : le <strong>salage</strong> (<a href="http://fr.wikipedia.org/wiki/Salage_(cryptographie)">wikipedia</a>).</p><p id="r-556381" data-claire-element-id="556381">Cette technique est très simple : pour compliquer les données à hacher, on rajoute avant ou après (ou les deux) des données qui sont toujours les mêmes. Ces données sont appelées <strong>sels</strong>.</p><p id="r-556382" data-claire-element-id="556382">Ainsi, si on veut hacher la chaine &quot;siteduzero&quot; avec le sel &quot;GRAINDESEL&quot; (où GRAINDESEL est un define d'une chaîne de caractères, méthode que je vous recommande) avant, on mettra en argument &quot;data&quot; de la fonction <strong>hash</strong><code data-claire-semantic="cpp">QString(GRAINDESEL&quot;siteduzero&quot;).toUtf8</code></p><p id="r-556383" data-claire-element-id="556383">Il y a même encore mieux : hacher les sels eux-mêmes, de préférence avec un autre algorithme de hachage (par exemple, MD5 si vous utilisez du SHA-1 pour le hash final). Vous pouvez faire de même avec votre chaîne à chiffrer elle même :</p><pre id="r-556384" data-claire-element-id="556384"><code data-claire-semantic="cpp">#include &lt;QApplication&gt;
#include &lt;QWidget&gt;
#include &lt;QCryptographicHash&gt;
#include &lt;QByteArray&gt;
#include &lt;QString&gt;
#include &lt;QMessageBox&gt;

#define SEL_AVANT &quot;D4Dqdz68$E&quot; // une technique approuvée pour vos sels est de s'endormir sur le clavier.
#define SEL_APRES &quot;7HHo£hh7YH&quot; // Si ils ne veulent rien dire, c'est mieux.


int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    QWidget w;

    QString chaine=&quot;Ceci sera haché.&quot;; // On crée la chaine à hacher
    QByteArray ba = QCryptographicHash::hash(QByteArray(QCryptographicHash::hash(QString(SEL_AVANT).toUtf8(), QCryptographicHash::Md5) +
                                                        QCryptographicHash::hash(chaine.toUtf8(), QCryptographicHash::Md5) +
                                                        QCryptographicHash::hash(QString(SEL_APRES).toUtf8(), QCryptographicHash::Md5)), QCryptographicHash::Sha1); // on la hache

    QString out=ba.toHex(); // on convertit le hash en QString
    QMessageBox::information(&amp;w, &quot;test&quot;, out); // on l'affiche

    w.show();
    return app.exec();
}</code></pre><p id="r-556385" data-claire-element-id="556385">Nous sommes donc au final arrivés à un code pas si gros, mais très sécurisé ! Par contre, il faut savoir une chose : plus vous mettez de sécurités, sels, hachages de sels, etc., plus le temps de calcul est long ! Pour hacher vos sels, l'utilisation du MD4 est éventuellement possible, si vous trouvez que le temps de calcul est trop long (mais franchement, vous devriez même pas le voir passer, sauf si vous générez 100 000 hashs, et encore).</p><p id="r-556386" data-claire-element-id="556386">Eh bien voilà ! Vous êtes maintenant des pros du hachage avec Qt !</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui">Qt : Quelques fonctionnalités non-GUI</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Fonctionnalités non-GUI
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-les-ressources-qt">Utiliser les ressources Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-140">
Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
Créer le fichier de ressources
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-le-fichier-ressource">
Utiliser le fichier ressource
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">Hacher avec Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-19">
Théorie
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt">
Hacher avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">Les tables de hachage</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-20">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/avec-qt">
Avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">TP : le zLogin</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-du-sujet-1">
Présentation du sujet
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/correction-196">
Correction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-19">
<span class="arrow"></span>
<span class="next">Théorie</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">
<span class="next">Les tables de hachage</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lestablesdehachage"></a><h2>Les tables de hachage</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt">
<span class="arrow"></span>
<span class="next">Hacher avec Qt</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-20">
<span class="next">Théorie</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<div id="r-556391" data-claire-element-id="556391" data-claire-semantic="question"><p id="r-556390" data-claire-element-id="556390">QUOI ??? On en a pas fini avec les hashs depuis le dernier chapitre ?</p></div><p id="r-556392" data-claire-element-id="556392">Rassurez-vous, ici, on ne va pas parler de hachage mais de <strong>tables de hachage</strong> ! Il s'agit de tableaux qui, au lieu de contenir leurs valeurs à l'index 0, 1, 2, etc., contiennent leurs valeurs dans des index identifiés par <strong>une chaine de caractères</strong>(ou autre chose, on verra ça après) ! Eh oui ! Vous pourrez donc accéder aux données en faisant <code data-claire-semantic="cpp">tableau[&quot;id&quot;] </code> au lieu de <code data-claire-semantic="cpp">tableau[1] </code>. Quel avantage ? Vous n'aurez plus besoin de stocker de valeurs pour retrouver vos données, dans le cas d'un tableau qui contient des données pas forcément prévisibles !</p>
</div><a name="Thorie"></a><h2>Théorie</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">
<span class="arrow"></span>
<span class="next">Les tables de hachage</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/avec-qt">
<span class="next">Avec Qt</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-theorie-20" data-claire-element-id="556479">Théorie</h4><p id="r-556393" data-claire-element-id="556393">Pour faire original, on va commencer par la théorie ( :-° ) !</p><p id="r-556394" data-claire-element-id="556394">Une table de hachage est un tableau dont l'index est représenté non pas par un nombre, comme d'habitude, mais par une chaîne de caractères (dans la plupart des cas). Ainsi, pour un tableau contenant dans l'ordre le prénom, le nom et l'âge d'une personne, on peut avoir le format suivant :</p><table id="r-556417" data-claire-element-id="556417"><thead id="r-556400" data-claire-element-id="556400"><tr id="r-556399" data-claire-element-id="556399"><th id="r-556396" data-claire-element-id="556396"><p id="r-556395" data-claire-element-id="556395">ID</p></th><th id="r-556398" data-claire-element-id="556398"><p id="r-556397" data-claire-element-id="556397">Contenu</p></th></tr></thead><tbody id="r-556416" data-claire-element-id="556416"><tr id="r-556405" data-claire-element-id="556405"><td id="r-556402" data-claire-element-id="556402"><p id="r-556401" data-claire-element-id="556401">0</p></td><td id="r-556404" data-claire-element-id="556404"><p id="r-556403" data-claire-element-id="556403">Jean</p></td></tr><tr id="r-556410" data-claire-element-id="556410"><td id="r-556407" data-claire-element-id="556407"><p id="r-556406" data-claire-element-id="556406">1</p></td><td id="r-556409" data-claire-element-id="556409"><p id="r-556408" data-claire-element-id="556408">Dupont</p></td></tr><tr id="r-556415" data-claire-element-id="556415"><td id="r-556412" data-claire-element-id="556412"><p id="r-556411" data-claire-element-id="556411">2</p></td><td id="r-556414" data-claire-element-id="556414"><p id="r-556413" data-claire-element-id="556413">25</p></td></tr></tbody></table><table id="r-556440" data-claire-element-id="556440"><thead id="r-556423" data-claire-element-id="556423"><tr id="r-556422" data-claire-element-id="556422"><th id="r-556419" data-claire-element-id="556419"><p id="r-556418" data-claire-element-id="556418">Clé</p></th><th id="r-556421" data-claire-element-id="556421"><p id="r-556420" data-claire-element-id="556420">Contenu</p></th></tr></thead><tbody id="r-556439" data-claire-element-id="556439"><tr id="r-556428" data-claire-element-id="556428"><td id="r-556425" data-claire-element-id="556425"><p id="r-556424" data-claire-element-id="556424">prenom</p></td><td id="r-556427" data-claire-element-id="556427"><p id="r-556426" data-claire-element-id="556426">Jean</p></td></tr><tr id="r-556433" data-claire-element-id="556433"><td id="r-556430" data-claire-element-id="556430"><p id="r-556429" data-claire-element-id="556429">nom</p></td><td id="r-556432" data-claire-element-id="556432"><p id="r-556431" data-claire-element-id="556431">Dupont</p></td></tr><tr id="r-556438" data-claire-element-id="556438"><td id="r-556435" data-claire-element-id="556435"><p id="r-556434" data-claire-element-id="556434">age</p></td><td id="r-556437" data-claire-element-id="556437"><p id="r-556436" data-claire-element-id="556436">25</p></td></tr></tbody></table><p id="r-556441" data-claire-element-id="556441"><strong>NB :</strong> Dans une table de hachage, on appelle l'ID &quot;clé&quot;.</p><div id="r-556443" data-claire-element-id="556443" data-claire-semantic="question"><p id="r-556442" data-claire-element-id="556442">C'est cool tout ça, mais... Je vois franchement pas le rapport avec le hachage.</p></div><p id="r-556444" data-claire-element-id="556444">En fait, l'ordinateur ne peut faire que des index numériques (avec des nombres). Le principe de la table de hachage est donc simple : hacher la clé pour avoir un index numérique ! Ainsi, le tableau suivant serait plus complet (dans ce code, on considère qu'il existe une fonction hacher(QString), qui prend en paramètre une chaine à hacher) :</p><table id="r-556475" data-claire-element-id="556475"><thead id="r-556452" data-claire-element-id="556452"><tr id="r-556451" data-claire-element-id="556451"><th id="r-556446" data-claire-element-id="556446"><p id="r-556445" data-claire-element-id="556445">Clé</p></th><th id="r-556448" data-claire-element-id="556448"><p id="r-556447" data-claire-element-id="556447">ID</p></th><th id="r-556450" data-claire-element-id="556450"><p id="r-556449" data-claire-element-id="556449">Contenu</p></th></tr></thead><tbody id="r-556474" data-claire-element-id="556474"><tr id="r-556459" data-claire-element-id="556459"><td id="r-556454" data-claire-element-id="556454"><p id="r-556453" data-claire-element-id="556453">prenom</p></td><td id="r-556456" data-claire-element-id="556456"><p id="r-556455" data-claire-element-id="556455">hacher(&quot;prenom&quot;)</p></td><td id="r-556458" data-claire-element-id="556458"><p id="r-556457" data-claire-element-id="556457">Jean</p></td></tr><tr id="r-556466" data-claire-element-id="556466"><td id="r-556461" data-claire-element-id="556461"><p id="r-556460" data-claire-element-id="556460">nom</p></td><td id="r-556463" data-claire-element-id="556463"><p id="r-556462" data-claire-element-id="556462">hacher(&quot;nom&quot;)</p></td><td id="r-556465" data-claire-element-id="556465"><p id="r-556464" data-claire-element-id="556464">Dupont</p></td></tr><tr id="r-556473" data-claire-element-id="556473"><td id="r-556468" data-claire-element-id="556468"><p id="r-556467" data-claire-element-id="556467">age</p></td><td id="r-556470" data-claire-element-id="556470"><p id="r-556469" data-claire-element-id="556469">hacher(&quot;age&quot;)</p></td><td id="r-556472" data-claire-element-id="556472"><p id="r-556471" data-claire-element-id="556471">25</p></td></tr></tbody></table><div id="r-556477" data-claire-element-id="556477" data-claire-semantic="question"><p id="r-556476" data-claire-element-id="556476">Aucun rapport avec la sécurité, la cryptographie, et tout ça ?</p></div><p id="r-556478" data-claire-element-id="556478">Non ! Les tables de hachage n'ont rien à voir avec !</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui">Qt : Quelques fonctionnalités non-GUI</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Fonctionnalités non-GUI
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-les-ressources-qt">Utiliser les ressources Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-140">
Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
Créer le fichier de ressources
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-le-fichier-ressource">
Utiliser le fichier ressource
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">Hacher avec Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-19">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt">
Hacher avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">Les tables de hachage</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-20">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/avec-qt">
Avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">TP : le zLogin</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-du-sujet-1">
Présentation du sujet
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/correction-196">
Correction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">
<span class="arrow"></span>
<span class="next">Les tables de hachage</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/avec-qt">
<span class="next">Avec Qt</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="AvecQt"></a><h2>Avec Qt</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-20">
<span class="arrow"></span>
<span class="next">Théorie</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">
<span class="next">TP : le zLogin</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-avec-qt" data-claire-element-id="556616">Avec Qt</h4><p id="r-556480" data-claire-element-id="556480">Prêts à passer à la pratique ?</p><p id="r-556481" data-claire-element-id="556481">Qt gère les tables de hachage avec la classe <a href="http://doc.trolltech.com/4.6/qhash.html">QHash</a>.</p><p id="r-556482" data-claire-element-id="556482">Pour commencer, voyons le prototype du constructeur :</p><pre id="r-556483" data-claire-element-id="556483"><code data-claire-semantic="cpp">QHash ()</code></pre><p id="r-556484" data-claire-element-id="556484">Bon, ok, on pouvait pas faire plus simple...<br/> Seulement, sa définition se fait un peu comme une QList (un exemple de QList ?) :</p><pre id="r-556485" data-claire-element-id="556485"><code data-claire-semantic="cpp">QList&lt;QWidget*&gt; liste; // crée une QList contenant des QWidget</code></pre><p id="r-556486" data-claire-element-id="556486">Pour créer un QHash, il faut donc lui indiquer le type des valeurs qui seront stockées. Mais pas seulement ! Il faut aussi lui indiquer de quel type sera la clé ! Eh oui, on peut créer des tables de hachage dont les clés sont... n'importe quel type de variables, objets compris ! Les clés peuvent donc par exemple être des pointeurs sur des QPushButtons, ça ne posera aucun problème (eh oui, c'est ça que je vous cachais depuis tout à l'heure :-° ) !<br/> Dans la plupart des cas, la clé reste une chaîne de caractères.</p><p id="r-556487" data-claire-element-id="556487">Pour créer une table de hachage, on aura donc un code ressemblant à celui-ci :</p><pre id="r-556488" data-claire-element-id="556488"><code data-claire-semantic="cpp">QHash&lt;typeCle, typeValeur&gt; table1; // clés de type typeCle, valeurs de type typeValeur
QHash&lt;QString, int&gt; table2; // clés de type QString, valeurs de type int
QHash&lt;QString, QWidget*&gt; table3; // clés de type QString, valeurs de type pointeur sur QWidget
QHash&lt;QPushButton*, int&gt; table4; // clés de type pointeur sur QPushButton, valeurs de type int</code></pre><p id="r-556489" data-claire-element-id="556489">Ce code créera 4 tables de hachage (explications dans les commentaires).</p><p id="r-556490" data-claire-element-id="556490">J'imagine qu'ensuite, vous avez l'intention d'ajouter des valeurs, en supprimer, les lire, etc., n'est-ce pas ? Eh bien, il y a plusieurs manières de faire. On va commencer par... la première.</p><h5 id="r-methode-1-comme-avec-un-tableau" data-claire-element-id="556511">Méthode 1 : comme avec un tableau</h5><p id="r-556491" data-claire-element-id="556491">La première méthode est de faire comme s'il s'agissait d'un simple tableau.</p><aside id="r-556493" data-claire-element-id="556493" data-claire-semantic="error"><p id="r-556492" data-claire-element-id="556492">Cette méthode est déconseillée dans le cas où on lit une case qui peut ne pas exister, car la case inexistante est alors créée, ce qui prend de la mémoire pour rien. Je vous conseille donc de prendre l'habitude d'utiliser la 2nde méthode, même si connaître celle-ci peut être utile pour lire le code de quelqu'un d'autre par exemple.</p></aside><p id="r-556494" data-claire-element-id="556494">Dans cette méthode, nous allons considérer qu'on a affaire à un tableau classique (mais extensible quand même, vous pouvez donc ajouter une valeur). Nous allons donc utiliser l'objet suivant :</p><pre id="r-556495" data-claire-element-id="556495"><code data-claire-semantic="cpp">QHash&lt;QString, int&gt; table;</code></pre><p id="r-556496" data-claire-element-id="556496">Tiens, d'ailleurs, normalement, vous devriez être capables de me dire quel type de clés et quel type de valeurs attend cette table !</p><p id="r-556497" data-claire-element-id="556497"><strong>Solution :</strong></p><p id="r-556498" data-claire-element-id="556498"></p><div id="r-556504" data-claire-element-id="556504"><ul id="r-556503" data-claire-element-id="556503"><li id="r-556500" data-claire-element-id="556500"><p id="r-556499" data-claire-element-id="556499">Les clés seront de type QString</p></li><li id="r-556502" data-claire-element-id="556502"><p id="r-556501" data-claire-element-id="556501">Les valeurs seront de type int</p></li></ul></div><p id="r-556505" data-claire-element-id="556505">Pour ajouter un item dans un tableau de ce genre, on ferait donc :</p><pre id="r-556506" data-claire-element-id="556506"><code data-claire-semantic="cpp">table[&quot;reponse&quot;]=42; // la clé est &quot;reponse&quot;, la valeur est &quot;42&quot;.</code></pre><p id="r-556507" data-claire-element-id="556507">Le code pour modifier la valeur associée à la clé &quot;réponse&quot; est exactement le même. Lorsqu'on modifie pour la première fois la valeur associée à une clé, on crée cet item.</p><div id="r-556509" data-claire-element-id="556509" data-claire-semantic="question"><p id="r-556508" data-claire-element-id="556508">Et pour supprimer un item ?</p></div><p id="r-556510" data-claire-element-id="556510">Ah ben ça... Avec cette méthode on peut pas :-° . Avec la méthode suivante, on verra ça !</p><h5 id="r-methode-2-avec-des-methodes" data-claire-element-id="556566">Méthode 2 : avec des méthodes</h5><p id="r-556512" data-claire-element-id="556512">Oui, je sais, le titre est un peu bizarre. Par &quot;avec des méthodes&quot;, je veux dire &quot;avec des fonctions contenues dans une classe&quot;.</p><p id="r-556513" data-claire-element-id="556513">Nous allons réutiliser notre QHash de tout à l'heure :</p><pre id="r-556514" data-claire-element-id="556514"><code data-claire-semantic="cpp">QHash&lt;QString, int&gt; table;</code></pre><p id="r-556515" data-claire-element-id="556515">Il y a des méthodes pour faire ce qu'on a vu en 1, et même plus !</p><h6 id="r-ajouter-un-item" data-claire-element-id="556526">Ajouter un item</h6><p id="r-556516" data-claire-element-id="556516">Nous utiliserons pour cela la méthode <strong>insert</strong> :</p><pre id="r-556517" data-claire-element-id="556517"><code data-claire-semantic="cpp">iterator QHash::insert ( const Key &amp; key, const T &amp; value )</code></pre><p id="r-556518" data-claire-element-id="556518">Cette méthode prend en premier paramètre la nouvelle clé (key) et en second paramètre la nouvelle valeur (value). Notez que si l'item est déjà existant, la méthode remplacera l'ancienne valeur par la nouvelle. On utilisera donc la même méthode pour modifier cette valeur.</p><div id="r-556520" data-claire-element-id="556520" data-claire-semantic="question"><p id="r-556519" data-claire-element-id="556519">C'est quoi ce &quot;iterator&quot; que ça retourne ? Et c'est quoi ce &quot;T&quot; ?</p></div><p id="r-556521" data-claire-element-id="556521">Pour le &quot;iterator&quot;, nous verrons ça après ^^ !<br/> Et pour ce qui est du &quot;T&quot;, il s'agit du type que vous avez défini pour les valeurs de cette table de hachage, ici &quot;int&quot; (QHash&lt;QString, <strong>int</strong>&gt; table). Il s'agit d'un <strong>template</strong>.</p><p id="r-556522" data-claire-element-id="556522">Donc, si vous avez bien compris, pour ajouter à notre table de hachage &quot;table&quot; l'item de valeur &quot;42&quot; et de clé &quot;reponse&quot;, le code sera...</p><p id="r-556523" data-claire-element-id="556523"></p><div id="r-556525" data-claire-element-id="556525"><pre id="r-556524" data-claire-element-id="556524"><code data-claire-semantic="cpp">table.insert(&quot;reponse&quot;, 42);</code></pre></div><h6 id="r-tester-l-existence-d-une-cle" data-claire-element-id="556530">Tester l'existence d'une clé</h6><p id="r-556527" data-claire-element-id="556527">Pour vérifier si une clé existe dans une table de hachage, on utilise la méthode <strong>contains</strong>, qui prend en paramètre la clé recherchée, et renvoie <strong>true</strong> si la clé existe, sinon <strong>false</strong>.</p><p id="r-556528" data-claire-element-id="556528">Exemple :</p><pre id="r-556529" data-claire-element-id="556529"><code data-claire-semantic="cpp">if(table.contains(&quot;reponse&quot;))
    // la clé &quot;reponse&quot; existe
else
    // la clé &quot;reponse&quot; n'existe pas</code></pre><h6 id="r-recuperer-le-nombre-d-items-contenus-dans-la-table-de-hachage" data-claire-element-id="556533">Récupérer le nombre d'items contenus dans la table de hachage</h6><p id="r-556531" data-claire-element-id="556531">On utilise la méthode <strong>count</strong> :</p><pre id="r-556532" data-claire-element-id="556532"><code data-claire-semantic="cpp">int nombre=table.count();
//nombre = nombre d'items dans &quot;table&quot;</code></pre><h6 id="r-recuperer-une-valeur-1" data-claire-element-id="556546">Récupérer une valeur</h6><p id="r-556534" data-claire-element-id="556534">La méthode est <strong>value</strong> :</p><pre id="r-556535" data-claire-element-id="556535"><code data-claire-semantic="cpp">const T QHash::value ( const Key &amp; key ) const</code></pre><p id="r-556536" data-claire-element-id="556536">Cette méthode prend pour paramètre la clé (key) de la valeur qu'on cherche, et retourne la valeur. Elle s'utilise très simplement :</p><pre id="r-556537" data-claire-element-id="556537"><code data-claire-semantic="cpp">table.insert(&quot;reponse&quot;, 42); // pour avoir quelque chose à lire
int reponse=table.value(&quot;reponse&quot;);
// reponse = 42</code></pre><p id="r-556538" data-claire-element-id="556538">Dans le cas où la clé n'existe pas, cette méthode renvoie la valeur par défaut du type de la valeur.</p><div id="r-556540" data-claire-element-id="556540" data-claire-semantic="question"><p id="r-556539" data-claire-element-id="556539">Gné ? o_O</p></div><p id="r-556541" data-claire-element-id="556541">En fait, c'est pas compliqué du tout : ça renvoie la valeur par défaut, celle qui est donnée à une variable qui vient d'être créée. Seulement, cette valeur est différente selon le type de valeurs que prend la table de hachage. Par exemple, pour une QString, la valeur par défaut est une chaine vide, alors que pour un int, la valeur par défaut est 0.</p><p id="r-556542" data-claire-element-id="556542">On peut aussi donner la valeur de retour qu'on veut dans le cas où la clé n'existe pas avec la méthode surchargée :</p><pre id="r-556543" data-claire-element-id="556543"><code data-claire-semantic="cpp">const T QHash::value ( const Key &amp; key, const T &amp; defaultValue ) const</code></pre><p id="r-556544" data-claire-element-id="556544">Exactement pareil, sauf que le 2ème paramètre devient la valeur de retour par défaut. Elle peut s'utiliser comme ça :</p><pre id="r-556545" data-claire-element-id="556545"><code data-claire-semantic="cpp">table.insert(&quot;reponse&quot;, 42); // pour avoir quelque chose à lire
int reponse=table.value(&quot;reponse&quot;, -1);
QLabel label;
label.setText(QString::number(reponse)); // affichera 42, ou -1 si un problème est survenu.</code></pre><h6 id="r-recuperer-une-cle" data-claire-element-id="556548">Récupérer une clé</h6><p id="r-556547" data-claire-element-id="556547">Je ne vais pas m'étendre sur le sujet, tout ce qui a été dit sur la récupération des valeurs est valable pour celle des clés, si ce n'est que la méthode est <strong>key</strong> et que son premier paramètre est une valeur au lieu d'une clé (en même temps, logique :-° ).</p><h6 id="r-supprimer-un-item" data-claire-element-id="556555">Supprimer un item</h6><p id="r-556549" data-claire-element-id="556549">La méthode utilisée est <strong>delete</strong> :</p><pre id="r-556550" data-claire-element-id="556550"><code data-claire-semantic="cpp">int QHash::remove ( const Key &amp; key )</code></pre><p id="r-556551" data-claire-element-id="556551">On l'utilise donc en lui passant en paramètre la clé de l'item à supprimer. Cette méthode renvoie le nombre d'items supprimés.</p><div id="r-556553" data-claire-element-id="556553" data-claire-semantic="question"><p id="r-556552" data-claire-element-id="556552">Mais... Elle renvoie donc 1 si l'item a été supprimé, ou 0 si il n'existe pas, donc ! Pourquoi ne pas avoir mis de booléen ?</p></div><p id="r-556554" data-claire-element-id="556554">Eh bien, parce que... <strong>Une clé peut contenir plusieurs valeurs</strong> ! Eh oui ! Aussi bizarre que ça puisse paraître, c'est possible !</p><h6 id="r-ajouter-une-valeur-a-une-cle" data-claire-element-id="556559">Ajouter une valeur à une clé</h6><p id="r-556556" data-claire-element-id="556556">Pour avoir plusieurs valeurs par clé, on utilise non pas <em>insert</em>, mais <strong>insertMulti</strong> :</p><pre id="r-556557" data-claire-element-id="556557"><code data-claire-semantic="cpp">iterator QHash::insertMulti ( const Key &amp; key, const T &amp; value )</code></pre><p id="r-556558" data-claire-element-id="556558">Cette méthode marche exactement comme <em>insert</em>, mais au lieu de remplacer si la valeur est déjà existante, elle &quot;ajoute&quot; la valeur.</p><h6 id="r-recuperer-des-valeurs-1" data-claire-element-id="556565">Récupérer DES valeurs</h6><div id="r-556561" data-claire-element-id="556561" data-claire-semantic="question"><p id="r-556560" data-claire-element-id="556560">Dans ce cas, value() retourne quoi ?</p></div><p id="r-556562" data-claire-element-id="556562"><em>value</em> retourne la dernière valeur ajoutée. Pour obtenir une liste de toutes les valeurs pour une clé donnée, on utilise <strong>values</strong> (attention au 'S' à la fin) :</p><pre id="r-556563" data-claire-element-id="556563"><code data-claire-semantic="cpp">QList&lt;T&gt; QHash::values ( const Key &amp; key ) const</code></pre><p id="r-556564" data-claire-element-id="556564">Cette méthode marche comme <em>value</em>, mais elle retourne une <a href="http://doc.trolltech.com/4.6/qlist.html">QList</a> contenant toutes les valeurs pour la clé <em>key</em>.</p><h5 id="r-methode-de-lecture-les-iterateurs" data-claire-element-id="556610">Méthode de lecture : les itérateurs</h5><p id="r-556567" data-claire-element-id="556567">Vous vous souvenez de cet &quot;iterator&quot; en retour de <strong>insert</strong> ? Le moment est venu de vous expliquer ce que c'est. Un &quot;iterator&quot; (in english) se traduit par un <strong>itérateur</strong>.</p><div id="r-556569" data-claire-element-id="556569" data-claire-semantic="question"><p id="r-556568" data-claire-element-id="556568">Alors là, on est bien avancés ! Mes pensées se résument en un mot : gné ? o_O</p></div><p id="r-556570" data-claire-element-id="556570">Pour vous définir ça, je pense que <a href="http://fr.wikipedia.org/wiki/Itérateur_(patron_de_conception)">Wikipedia</a> sera très bien :</p><p id="r-556571" data-claire-element-id="556571"><cite>Citation</cite></p><blockquote id="r-556573" data-claire-element-id="556573"><p id="r-556572" data-claire-element-id="556572">Un itérateur est un objet qui permet de parcourir tous les éléments contenus dans un autre objet, le plus souvent un conteneur (liste, arbre, etc).</p></blockquote><p id="r-556574" data-claire-element-id="556574">Comme il est dit dans la définition, c'est un objet à part entière. La classe qui gère ça est <a href="http://doc.trolltech.com/4.6/qhashiterator.html">QHashIterator</a>.</p><p id="r-556575" data-claire-element-id="556575">Voyons d'abord son constructeur :</p><pre id="r-556576" data-claire-element-id="556576"><code data-claire-semantic="cpp">QHashIterator::QHashIterator ( const QHash&lt;Key, T&gt; &amp; hash )</code></pre><p id="r-556577" data-claire-element-id="556577">Il prend donc en paramètre le QHash qu'il devra parcourir, mais devra, comme QHash, être déclaré avec un template :</p><pre id="r-556578" data-claire-element-id="556578"><code data-claire-semantic="cpp">QHashIterator&lt;QString, int&gt; iterator(table);</code></pre><p id="r-556579" data-claire-element-id="556579">Le gros avantage est la possibilité de faire des tests sur les positions précédentes et suivantes :</p><aside id="r-556581" data-claire-element-id="556581" data-claire-semantic="warning"><p id="r-556580" data-claire-element-id="556580">Les tables de hachage ne sont pas ordonnées. Ainsi, on ne peut pas vraiment prévoir l'ordre des valeurs.</p></aside><h6 id="r-cle-et-valeur-actuelle" data-claire-element-id="556584">Clé et valeur actuelle</h6><p id="r-556582" data-claire-element-id="556582">On peut avoir la clé et la valeur actuelle en utilisant <strong>key()</strong> et <strong>value()</strong> :</p><pre id="r-556583" data-claire-element-id="556583"><code data-claire-semantic="cpp">// prototype de key
const Key &amp; QHashIterator::key () const

// prototype de value()
const T &amp; QHashIterator::value () const</code></pre><h6 id="r-tester-l-existence-des-items-suivants-precedents" data-claire-element-id="556590">Tester l'existence des items suivants/précédents</h6><aside id="r-556586" data-claire-element-id="556586" data-claire-semantic="information"><p id="r-556585" data-claire-element-id="556585">Je ne mettrai qu'un prototype pour deux fonctions, étant donné que celles-ci marchent de la même manière, à la différence qu'une agit sur l'item précédent, et l'autre sur le suivant.</p></aside><p id="r-556587" data-claire-element-id="556587">On peut vérifier l'existence d'un item suivant ou précédent respectivement avec <strong>hasNext</strong> et <strong>hasPrevious</strong> :</p><pre id="r-556588" data-claire-element-id="556588"><code data-claire-semantic="cpp">bool QHashIterator::hasNext () const</code></pre><p id="r-556589" data-claire-element-id="556589">La méthode retourne donc un booléen (<strong>true</strong> si l'item existe, sinon <strong>false</strong>), et ne prend aucun paramètre.</p><h6 id="r-avancer-reculer-la-position-actuelle" data-claire-element-id="556594">Avancer/reculer la position actuelle</h6><p id="r-556591" data-claire-element-id="556591">Pour déplacer la position actuelle de l'itérateur, on utilise <strong>next</strong> et <strong>previous</strong> :</p><pre id="r-556592" data-claire-element-id="556592"><code data-claire-semantic="cpp">Item QHashIterator::next ()</code></pre><p id="r-556593" data-claire-element-id="556593">Donc, la méthode ne prend aucun paramètre, et retourne... un Item, qui contient la valeur et la clé de l'item sur lequel on se trouve maintenant. Ces variables s'obtiennent respectivement avec <strong>value()</strong> et <strong>key()</strong>.</p><h6 id="r-item-precedent-suivant" data-claire-element-id="556597">Item précédent/suivant</h6><p id="r-556595" data-claire-element-id="556595">Les méthodes <strong>next()</strong> et <strong>previous()</strong> retournent un Item contenant la valeur et la clé de la nouvelle valeur, après déplacement. Avec les méthodes <strong>peekNext()</strong> et <strong>peekPrevious()</strong>, on obtient la même valeur de retour, mais <strong>sans se déplacer</strong> !</p><pre id="r-556596" data-claire-element-id="556596"><code data-claire-semantic="cpp">Item QHashIterator::peekNext () const</code></pre><h6 id="r-aller-au-debut-a-la-fin" data-claire-element-id="556600">Aller au début/à la fin</h6><p id="r-556598" data-claire-element-id="556598">Pour aller au début (avant le premier item) ou à la fin (après le dernier item), on utilise les méthodes <strong>toFront()</strong> (début) ou <strong>toBack()</strong> (fin) :</p><pre id="r-556599" data-claire-element-id="556599"><code data-claire-semantic="cpp">void QHashIterator::toBack ()</code></pre><h6 id="r-rechercher-vers-l-avant-vers-l-arriere" data-claire-element-id="556609">Rechercher vers l'avant/vers l'arrière</h6><p id="r-556601" data-claire-element-id="556601">On peut également faire une recherche partant d'avant ou après l'item actuel avec les méthodes <strong>findNext()</strong> et <strong>findPrevious()</strong> qui prennent en paramètre la valeur à rechercher :</p><pre id="r-556602" data-claire-element-id="556602"><code data-claire-semantic="cpp">bool QHashIterator::findNext ( const T &amp; value )</code></pre><p id="r-556603" data-claire-element-id="556603">La méthode retourne un booléen indiquant si la valeur <em>value</em> a été trouvée ou non.<br/> L'utilisation est à peine différente selon le sens de la recherche :</p><ul id="r-556608" data-claire-element-id="556608"><li id="r-556605" data-claire-element-id="556605"><p id="r-556604" data-claire-element-id="556604"><strong>findNext() : vers l'avant</strong><br/> La recherche commence à l'item suivant l'item actuel. Si l'item est trouvé, la position courante après la fonction est <strong>juste après l'item trouvé</strong>. Sinon, la position après la fonction est après le dernier item (comme après un <strong>toBack()</strong>).</p></li><li id="r-556607" data-claire-element-id="556607"><p id="r-556606" data-claire-element-id="556606"><strong>findPrevious() : vers l'arrière</strong><br/> La recherche commence à l'item avant l'item actuel. Si l'item est trouvé, la position courante après la fonction est <strong>juste avant l'item trouvé</strong>. Sinon, la position après la fonction est avant le premier item (comme après un <strong>toFront()</strong>).</p></li></ul><h5 id="r-recuperer-toutes-les-valeurs-foreach" data-claire-element-id="556615">Récupérer toutes les valeurs : foreach()</h5><p id="r-556611" data-claire-element-id="556611">Alors là, rien de plus simple : il s'agit d'une boucle spéciale qui est exécutée pour toutes les valeurs de la table, mais qui ne permet pas de voir la clé associée.<br/> On l'utilise ainsi :</p><pre id="r-556612" data-claire-element-id="556612"><code data-claire-semantic="cpp">foreach(int valeur, table)
{
    quelqueChose(valeur); // &quot;valeur&quot; contient la valeur actuelle
}</code></pre><p id="r-556613" data-claire-element-id="556613">Eh bien voilà, normalement (enfin je l'espère), vous maîtrisez les tables de hachage !<br/> Je ne vois pas grand chose de plus à dire à ce sujet...</p><p id="r-556614" data-claire-element-id="556614">Par contre, je peux vous dire que le prochain chapitre est... un TP ! Prêts ? Alors cliquez sur &quot;suivant&quot; !</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui">Qt : Quelques fonctionnalités non-GUI</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Fonctionnalités non-GUI
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-les-ressources-qt">Utiliser les ressources Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-140">
Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
Créer le fichier de ressources
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-le-fichier-ressource">
Utiliser le fichier ressource
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">Hacher avec Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-19">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt">
Hacher avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">Les tables de hachage</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-20">
Théorie
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/avec-qt">
Avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">TP : le zLogin</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-du-sujet-1">
Présentation du sujet
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/correction-196">
Correction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-20">
<span class="arrow"></span>
<span class="next">Théorie</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">
<span class="next">TP : le zLogin</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="TPlezLogin"></a><h2>TP : le zLogin</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/avec-qt">
<span class="arrow"></span>
<span class="next">Avec Qt</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-du-sujet-1">
<span class="next">Présentation du sujet</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-556618" data-claire-element-id="556618">Nous voici arrivés au TP ! Une occasion pour vous de vérifier si vous avez bien tout retenu, et si vous êtes capables de le mettre en pratique ! On va donc appliquer tout ce qu'on a vu depuis le début :</p><ul id="r-556627" data-claire-element-id="556627"><li id="r-556620" data-claire-element-id="556620"><p id="r-556619" data-claire-element-id="556619">Les ressources</p></li><li id="r-556622" data-claire-element-id="556622"><p id="r-556621" data-claire-element-id="556621">Le hachage</p></li><li id="r-556624" data-claire-element-id="556624"><p id="r-556623" data-claire-element-id="556623">Les tables de hachage</p></li><li id="r-556626" data-claire-element-id="556626"><p id="r-556625" data-claire-element-id="556625">Et accessoirement, <a href="http://www.siteduzero.com/tutoriel-3-11396-communiquer-en-reseau-avec-son-programme.html">l'utilisation du réseau</a></p></li></ul><div id="r-556629" data-claire-element-id="556629" data-claire-semantic="question"><p id="r-556628" data-claire-element-id="556628">HEIN ?! Pourquoi du réseau, on en a jamais parlé dans ce tuto !</p></div><p id="r-556630" data-claire-element-id="556630">J'ai choisi le réseau pour différentes raisons. Premièrement, M@t' en parle dans son tuto sur le C++, que je considère comme un prérequis pour lire mon tuto. Et ensuite, franchement, j'ai trouvé aucune idée de TP qui aboutisse à un programme &quot;utile&quot; (avoir à la fin un programme qui ne vous sert à rien ne vous aurait pas énormément plu, non ? :-° ) sans utiliser le réseau. Et puis la dernière raison est que ça vous fait réviser ! (Puis bon, avouez qu'une fois qu'on a lu le tuto de M@t' dessus, c'est pas bien compliqué !)</p><aside id="r-556632" data-claire-element-id="556632" data-claire-semantic="information"><p id="r-556631" data-claire-element-id="556631">Tout le code source présent dans ce chapitre est sous licence <a href="http://www.gnu.org/licenses/gpl.html">GNU GPL</a> au nom de Théophile BASTIAN (moi). Le code source original est disponible sur <a href="http://tobast.fr/">http://tobast.fr/</a> et contient un commentaire attestant de cette licence.</p></aside><p id="r-556633" data-claire-element-id="556633">Prêts à vous y attaquer ? Suivez-moi !</p>
</div><a name="Prsentationdusujet"></a><h2>Présentation du sujet</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">
<span class="arrow"></span>
<span class="next">TP : le zLogin</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/correction-196">
<span class="next">Correction</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-presentation-du-sujet-1" data-claire-element-id="556742">Présentation du sujet</h4><p id="r-556634" data-claire-element-id="556634">Dans ce TP, nous allons créer le <strong>zLogin</strong> ! C'est un programme-serveur auquel peuvent se connecter d'autres programmes via un réseau (loopback, local, internet).</p><h5 id="r-vue-d-ensemble-3" data-claire-element-id="556641">Vue d'ensemble</h5><p id="r-556635" data-claire-element-id="556635">Son rôle est simple : un programme lui envoie un paquet en TCP, contenant un login et un mot de passe haché en MD5 (nous ne coderons pas ce programme). Le zLogin (que nous allons créer) se chargera de comparer ce mot de passe à une liste de mots de passe contenus dans un fichier, et dira au programme si le login et le mdp sont bons.</p><div id="r-556637" data-claire-element-id="556637" data-claire-semantic="question"><p id="r-556636" data-claire-element-id="556636">Et... Le hachage, les tables de hachage, et les ressources, elles sont où dans tout ça ?</p></div><p id="r-556638" data-claire-element-id="556638">Premièrement, pour le hachage, vous DEVREZ re-hacher le mdp envoyé, avec salage et toutes les sécurités qu'on a vues. Vous ne pensiez pas que nous allions stocker un mot de passe haché seulement en MD5, non ? Par contre, pensez bien à tenir compte du fait qu'il est déjà haché en MD5 lors de sa réception !</p><p id="r-556639" data-claire-element-id="556639">Ensuite, pour les tables de hachage. Vous devrez, à l'ouverture du programme, prendre tous les couples login/mdp et les stocker dans une table de hachage (clé = pseudo, valeur = mdp haché).</p><p id="r-556640" data-claire-element-id="556640">Et pour les ressources, on va faire simple : l'icône sera dans un fichier de ressources, si vous arrivez à faire ça, vous arriverez à tout faire.</p><h5 id="r-schema-des-paquets" data-claire-element-id="556675">Schéma des paquets</h5><p id="r-556642" data-claire-element-id="556642">Vous êtes libres d'utiliser les architectures de paquets que vous voulez, mais si vous ne savez pas quoi prendre, je vous donne les structures que j'utilise :</p><h6 id="r-paquets-entrants-pseudos-hashs-mdp" data-claire-element-id="556656">Paquets entrants : pseudos/hashs mdp</h6><figure id="r-556644" data-claire-element-id="556645"><img id="r-556643" data-claire-element-id="556643" src="medias/obast.fr_imgs_upload_paquetsinput.png" alt="Image utilisateur"/></figure><p id="r-556646" data-claire-element-id="556646">J'utilise donc un paquet composé de 4 parties :</p><ul id="r-556655" data-claire-element-id="556655"><li id="r-556648" data-claire-element-id="556648"><p id="r-556647" data-claire-element-id="556647">Une variable <strong>quint16</strong> contenant la taille du pseudo,</p></li><li id="r-556650" data-claire-element-id="556650"><p id="r-556649" data-claire-element-id="556649">Une variable <strong>QString</strong> contenant de pseudo,</p></li><li id="r-556652" data-claire-element-id="556652"><p id="r-556651" data-claire-element-id="556651">Une variable <strong>quint16</strong> contenant la taille du hash du mdp,</p></li><li id="r-556654" data-claire-element-id="556654"><p id="r-556653" data-claire-element-id="556653">Une variable <strong>QByteArray</strong> contenant le hash du mdp.</p></li></ul><h6 id="r-paquets-sortants-connexion-acceptee-refusee" data-claire-element-id="556674">paquets sortants : connexion acceptée/refusée</h6><figure id="r-556658" data-claire-element-id="556659"><img id="r-556657" data-claire-element-id="556657" src="medias/obast.fr_imgs_upload_paquetsoutput.png" alt="Image utilisateur"/></figure><p id="r-556660" data-claire-element-id="556660">Cette fois, le paquet se compose d'un simple <strong>quint8</strong>. Celui-ci peut prendre différentes valeurs :</p><ul id="r-556673" data-claire-element-id="556673"><li id="r-556662" data-claire-element-id="556662"><p id="r-556661" data-claire-element-id="556661">0 : Erreur indéterminée</p></li><li id="r-556664" data-claire-element-id="556664"><p id="r-556663" data-claire-element-id="556663">1 : Connexion acceptée</p></li><li id="r-556666" data-claire-element-id="556666"><p id="r-556665" data-claire-element-id="556665">2 : Mauvais login</p></li><li id="r-556668" data-claire-element-id="556668"><p id="r-556667" data-claire-element-id="556667">3 : Mauvais mdp</p></li><li id="r-556670" data-claire-element-id="556670"><p id="r-556669" data-claire-element-id="556669">4 : Erreur interne au zLogin</p></li><li id="r-556672" data-claire-element-id="556672"><p id="r-556671" data-claire-element-id="556671">5 : Service indisponible</p></li></ul><h5 id="r-fonctionnalites-gerees-par-le-zlogin" data-claire-element-id="556707">Fonctionnalités gérées par le zLogin</h5><p id="r-556676" data-claire-element-id="556676">Voici une liste des fonctionnalités que doit avoir le zLogin. Bien sûr, rien ne vous empêche d'en rajouter :D !</p><aside id="r-556678" data-claire-element-id="556678" data-claire-semantic="information"><p id="r-556677" data-claire-element-id="556677">Ne confondez pas &quot;fonctionnalités&quot; et &quot;fonction [codée dans le programme]&quot; ! Vous êtes libres de créer les fonctions que vous voulez pour implémenter les fonctionnalités données !</p></aside><ul id="r-556706" data-claire-element-id="556706"><li id="r-556680" data-claire-element-id="556680"><p id="r-556679" data-claire-element-id="556679">Charger <strong>dans une table de hachage</strong> tous les logins/mdps au démarrage depuis un fichier (voir <a href="http://www.siteduzero.com/tutoriel-3-100412-la-manipulation-des-fichiers.html">ce tuto d'Amnell et Shareman</a>, impossible de se passer des fichiers dans un TP comme ça)</p></li><li id="r-556682" data-claire-element-id="556682"><p id="r-556681" data-claire-element-id="556681">Communiquer en réseau, et fonctionner comme programme serveur</p></li><li id="r-556684" data-claire-element-id="556684"><p id="r-556683" data-claire-element-id="556683">Pouvoir recevoir des données sur un port de votre choix (j'utiliserai le 31742)</p></li><li id="r-556686" data-claire-element-id="556686"><p id="r-556685" data-claire-element-id="556685">Traiter les données reçues en les comparant avec la table de hachage générée à l'ouverture du programme</p></li><li id="r-556688" data-claire-element-id="556688"><p id="r-556687" data-claire-element-id="556687">Hacher les mdps en utilisant des sels (eux mêmes hachés séparément), en utilisant les algorithmes de votre choix</p></li><li id="r-556690" data-claire-element-id="556690"><p id="r-556689" data-claire-element-id="556689">Renvoyer des données pour confirmer (ou non) la connexion</p></li><li id="r-556692" data-claire-element-id="556692"><p id="r-556691" data-claire-element-id="556691">Aucune fenêtre. Une icône du <a href="http://www.siteduzero.com/tutoriel-3-11405-ce-que-vous-pouvez-encore-apprendre.html#ss_part_3">system tray</a> (descendez un peu, jusqu'à croiser &quot;system tray&quot;) sera la seule manifestation du zLogin (un petit tour dans la doc vous sera utile)</p></li><li id="r-556703" data-claire-element-id="556703"><p id="r-556693" data-claire-element-id="556693">Un menu sera accessible avec l'icône system tray, il contiendra :</p><ul id="r-556702" data-claire-element-id="556702"><li id="r-556695" data-claire-element-id="556695"><p id="r-556694" data-claire-element-id="556694">Ajouter/supprimer des comptes : ouvre une boite de dialogue (voir la doc de QDialog, vous devrez créer une classe héritant de QDialog) permettant de voir les comptes créés, de les supprimer, et d'en ajouter. Quand on ajoute un compte, la liste des comptes doit être rechargée. Mais dans le cas où quelqu'un enverrait une requête à ce moment, <strong>le programme ne doit pas fournir de fausse information</strong> ! La &quot;pause du service&quot; doit être la plus courte possible.</p></li><li id="r-556697" data-claire-element-id="556697"><p id="r-556696" data-claire-element-id="556696">Une option désactivée par défaut, qui, si activée, lors de chaque tentative de login, affiche une bulle d'information affichant le login de la personne, et le résultat sous forme de chaîne de caractères (et non de chiffre).</p></li><li id="r-556699" data-claire-element-id="556699"><p id="r-556698" data-claire-element-id="556698">Une option &quot;suspendre le programme&quot; : si activée, aucune demande ne sera traitée, et le code 5 (service indisponible) sera renvoyé.</p></li><li id="r-556701" data-claire-element-id="556701"><p id="r-556700" data-claire-element-id="556700">Quitter : Je ne pense pas avoir besoin de vous décrire à quoi cette action sert :D . Pensez à faire un dialogue demandant confirmation, au lieu de quitter directement !</p></li></ul></li><li id="r-556705" data-claire-element-id="556705"><p id="r-556704" data-claire-element-id="556704">L'icône du system tray sera chargée depuis un fichier de ressources</p></li></ul><h5 id="r-dernieres-recommandations" data-claire-element-id="556741">Dernières recommandations</h5><p id="r-556708" data-claire-element-id="556708">Pour commencer, 2-3 choses qui peuvent vous être utiles :</p><ul id="r-556739" data-claire-element-id="556739"><li id="r-556710" data-claire-element-id="556710"><p id="r-556709" data-claire-element-id="556709"><strong>Pack d'icônes :</strong> Je vous ai préparé un petit pack d'icônes, libre à vous de les utiliser ou non. <a href="http://tobast.fr/dl/dl.php?file=sdz/zlogin_icones.rar">Téléchargez-le</a> !</p></li><li id="r-556712" data-claire-element-id="556712"><p id="r-556711" data-claire-element-id="556711"><strong>zLogin testeur :</strong> J'ai également fait un programme client qui vous servira à tester votre zLogin, en se connectant à une adresse et un port (que vous choisissez) avec un pseudo et un mot de passe (que vous choisissez également). <a href="http://tobast.fr/progNbr.php?id=4">Téléchargez-le</a> !</p></li><li id="r-556738" data-claire-element-id="556738"><p id="r-556713" data-claire-element-id="556713"><strong>Une partie du code :</strong> En codant le programme, j'ai remarqué qu'une grosse partie de celui-ci était composé uniquement de GUI, notamment au niveau de l'interface de gestion des comptes. Pour ceux qui le veulent seulement, et qui préfèrent se concentrer sur les nouveautés et ne pas réviser la GUI, je vous propose le code source de la gestion des comptes :</p><div id="r-556737" data-claire-element-id="556737"><p id="r-556714" data-claire-element-id="556714">J'ai utilisé pour ça deux classes : une qui gère le dialogue de gestion des comptes en lui-même, que j'ai appelé GereComptes, et une autre qui gère le dialogue d'édition/création de comptes (celui où on rentre le login/mdp du futur utilisateur), que j'ai appelée DialSetUser.<br/> Je vais commencer par GereComptes :</p><p id="r-556715" data-claire-element-id="556715"><strong>gerecomptes.h</strong> (en général, mes noms de fichiers sont entièrement en minuscules par flemme de changer celui par défaut du QtCreator :-° )</p><pre id="r-556716" data-claire-element-id="556716"><code data-claire-semantic="cpp">#ifndef GERECOMPTES_H
#define GERECOMPTES_H

// eh oui, il y en a pas mal
#include &lt;QWidget&gt;
#include &lt;QTableView&gt;
#include &lt;QStandardItemModel&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QPushButton&gt;
#include &lt;QIcon&gt;
#include &lt;QHash&gt;
#include &lt;QHashIterator&gt;
#include &lt;QCloseEvent&gt;
#include &lt;QList&gt;
#include &lt;QHeaderView&gt;
#include &lt;QMessageBox&gt;
#include &lt;QFile&gt;
#include &lt;QTextStream&gt;
#include &lt;QRegExp&gt;

#include &quot;dialsetuser.h&quot;

class GereComptes : public QWidget
{
Q_OBJECT

public:
    GereComptes(QHash&lt;QString, QString&gt; authIn);

signals:
    void fini(); // émis à la fermeture du dialogue

private slots:
    void slotAddUser();
    void slotSetUser();
    void slotDelUser();
    void slotOk();

private:
    // methodes
    void majModele(); // appelé pour ajouter dans &quot;modele&quot; tout ce qui est contenu dans &quot;authTable&quot; (appelé dans le constructeur uniquement)
    void closeEvent(QCloseEvent *event); // Pour intercepter l'évènement de fermeture

    //attributs
    QHBoxLayout *l_principal;
    QTableView *tableau; // j'utilise une architecture MV (voir tuto de M@t')
    QStandardItemModel *modele;
    QVBoxLayout *l_boutons;
    QPushButton *b_addUser;
    QPushButton *b_setUser;
    QPushButton *b_delUser;
    QPushButton *b_ok;

    QHash&lt;QString, QString&gt; authTable;

    bool closing;
};

#endif // GERECOMPTES_H</code></pre><p id="r-556717" data-claire-element-id="556717">Rien de bien compliqué, ça reste un .h :D .</p><p id="r-556718" data-claire-element-id="556718"><strong>gerecomptes.cpp</strong></p><pre id="r-556719" data-claire-element-id="556719"><code data-claire-semantic="cpp">#include &quot;gerecomptes.h&quot;

GereComptes::GereComptes(QHash&lt;QString, QString&gt; authIn)
{
    setWindowTitle(&quot;zLogin - gestion des comptes&quot;);
    setWindowIcon(QIcon(&quot;:/icones/prog&quot;));
    authTable=authIn;
    closing=false;

    // GUI
    l_principal=new QHBoxLayout;
    modele=new QStandardItemModel(0, 2);
    modele-&gt;setHeaderData(0, Qt::Horizontal, &quot;Pseudo&quot;, Qt::DisplayRole);
    modele-&gt;setHeaderData(1, Qt::Horizontal, &quot;Hash du MDP&quot;, Qt::DisplayRole);
    tableau=new QTableView;
    tableau-&gt;setModel(modele);
    tableau-&gt;setMinimumWidth(425);
    majModele();
    l_principal-&gt;addWidget(tableau);

    l_boutons=new QVBoxLayout;
    b_addUser=new QPushButton(QIcon(&quot;:/icones/addUser&quot;), &quot;Créer un compte&quot;);
    l_boutons-&gt;addWidget(b_addUser);
    b_setUser=new QPushButton(QIcon(&quot;:/icones/setUser&quot;), &quot;Modifier le compte&quot;);
    l_boutons-&gt;addWidget(b_setUser);
    b_delUser=new QPushButton(QIcon(&quot;:/icones/delUser&quot;), &quot;Supprimer le compte&quot;);
    l_boutons-&gt;addWidget(b_delUser);
    b_ok=new QPushButton(QIcon(&quot;:/icones/accept&quot;), &quot;Ok&quot;);
    l_boutons-&gt;addWidget(b_ok);
    l_principal-&gt;addLayout(l_boutons);

    setLayout(l_principal);

    // connect
    connect(b_addUser, SIGNAL(clicked()), this, SLOT(slotAddUser()));
    connect(b_setUser, SIGNAL(clicked()), this, SLOT(slotSetUser()));
    connect(b_delUser, SIGNAL(clicked()), this, SLOT(slotDelUser()));
    connect(b_ok, SIGNAL(clicked()), this, SLOT(slotOk()));
}

void GereComptes::majModele()
{
    // assez simple : on ajoute dans le modèle tous les logins/hashs.
    QHashIterator&lt;QString, QString&gt; iterateur(authTable);

    while(iterateur.hasNext())
    {
        iterateur.next();
        QList&lt;QStandardItem *&gt; items;
        items &lt;&lt; new QStandardItem(iterateur.key()) &lt;&lt; new QStandardItem(iterateur.value());
        modele-&gt;appendRow(items);
    }

    tableau-&gt;resizeColumnsToContents();
}

void GereComptes::slotAddUser()
{
    // On ajoutera le nouvel utilisateur directement dans le fichier, qui devra être rechargé une fois le dialogue fermé

    QFile f_auth;
    QTextStream authStream;

    f_auth.setFileName(&quot;auth.zla&quot;);
    if(!f_auth.open(QIODevice::ReadWrite | QIODevice::Text))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur&quot;, &quot;Le programme \&quot;zLogin\&quot; a rencontré une erreur lors de l'ouverture de la liste des logins/mdps du zLogin.\nErreur : &quot;+f_auth.errorString());
        close();
    }
    authStream.setDevice(&amp;f_auth);


    User::Infos infos=DialSetUser::get(); // méthode statique

    if(infos.annule)
        return;

    QHashIterator&lt;QString, QString&gt; iterateur(authTable);

    while(iterateur.hasNext()) // vérif que le pseudo n'est pas utilisé
    {
        iterateur.next();
        if(iterateur.key() == infos.pseudo)
        {
            QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Le pseudo choisi est déjà utilisé.&quot;);
            return;
        }
    }

    authStream.readAll(); // aller à la fin du fichier
    authStream &lt;&lt; infos.pseudo+';'+infos.hashmdp+'\n';

    QList&lt;QStandardItem *&gt; items; // ajout du nouvel utilisateur au modèle
    items &lt;&lt; new QStandardItem(infos.pseudo) &lt;&lt; new QStandardItem(infos.hashmdp);
    modele-&gt;appendRow(items);
    tableau-&gt;resizeColumnsToContents();

    f_auth.close();
}

void GereComptes::slotSetUser()
{
    QFile f_auth;
    QTextStream authStream;
    f_auth.setFileName(&quot;auth.zla&quot;);
    if(!f_auth.open(QIODevice::ReadWrite | QIODevice::Text))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur&quot;, &quot;Le programme \&quot;zLogin\&quot; a rencontré une erreur lors de l'ouverture de la liste des logins/mdps du zLogin.\nErreur : &quot;+f_auth.errorString());
        close();
    }
    authStream.setDevice(&amp;f_auth);


    QModelIndex setIndex=tableau-&gt;selectionModel()-&gt;currentIndex();
    if(!setIndex.isValid()) // index invalide, pas de selection
    {
        QMessageBox::warning(this, &quot;Aucune sélection&quot;, &quot;Aucun item n'est sélectionné.&quot;);
        return;
    }

    int setRow=setIndex.row(); // récupère l'ID de la ligne sélectionnée
    QString basePseudo=modele-&gt;item(setRow, 0)-&gt;data(Qt::DisplayRole).toString(); // recup le pseudo actuel
    QString baseHash=modele-&gt;item(setRow, 1)-&gt;data(Qt::DisplayRole).toString(); // récup le hash actuel
    User::Infos infos=DialSetUser::get(basePseudo, baseHash);

    if(infos.annule) // si l'user a annulé
        return;

    if(infos.pseudo != basePseudo || infos.hashmdp != baseHash) // si il y a eu une modif
    {

        if(infos.pseudo!=basePseudo) //vérif que le pseudo est libre
        {
            QHashIterator&lt;QString, QString&gt; iterateur(authTable);

            while(iterateur.hasNext())
            {
                iterateur.next();
                if(iterateur.key() == infos.pseudo)
                {
                    QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Le pseudo choisi est déjà utilisé.&quot;);
                    return;
                }
            }
        }

        // recherche de la ligne du fichier
        QString setInfo=setIndex.data(Qt::DisplayRole).toString();
        bool isPseudo;
        if(setIndex.column() == 0)
            isPseudo=true;
        else if(setIndex.column() == 1)
            isPseudo=false;

        authStream.device()-&gt;seek(0);
        QString contenu;
        for(int i=0;!authStream.atEnd();i++)
        {
            QString ligne=authStream.readLine();
            QString info;
            if(isPseudo)
                info=ligne.section(';', 0, 0);
            else
                info=ligne.section(';', 1, 1);

            if(info != setInfo)
            {
                contenu+=ligne+'\n'; // on prend en mémoire toutes les lignes sauf celle à modif
            }
        }

        contenu += infos.pseudo+';'+infos.hashmdp+'\n'; // puis on ajoute à ça la ligne AVEC modifs

        f_auth.resize(0); // supprime le contenu du fichier
        authStream &lt;&lt; contenu; // puis le réécrit

        modele-&gt;setItem(setRow, 0, new QStandardItem(infos.pseudo)); // édite la ligne du modèle
        modele-&gt;setItem(setRow, 1, new QStandardItem(infos.hashmdp));

        tableau-&gt;resizeColumnsToContents();
    }

    f_auth.close();
}

void GereComptes::slotDelUser()
{
    // idem slotSetUser() en grande partie
    // ===================================
    QFile f_auth;
    QTextStream authStream;
    f_auth.setFileName(&quot;auth.zla&quot;);
    if(!f_auth.open(QIODevice::ReadWrite | QIODevice::Text))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur&quot;, &quot;Le programme \&quot;zLogin\&quot; a rencontré une erreur lors de l'ouverture de la liste des logins/mdps du zLogin.\nErreur : &quot;+f_auth.errorString());
        close();
    }
    authStream.setDevice(&amp;f_auth);


    QModelIndex delIndex=tableau-&gt;selectionModel()-&gt;currentIndex();
    if(!delIndex.isValid()) // index invalide, pas de selection
    {
        QMessageBox::warning(this, &quot;Aucune sélection&quot;, &quot;Aucun item n'est sélectionné.&quot;);
        return;
    }

    if(QMessageBox::warning(this, &quot;Êtes-vous sûr ?&quot;, &quot;Êtes-vous sûr de vouloir supprimer ce compte définitivement ?&quot;,
                            QMessageBox::No | QMessageBox::Yes, QMessageBox::No) == QMessageBox::No)
    {
        return;
    }

    QString delInfo=delIndex.data(Qt::DisplayRole).toString();
    bool isPseudo;
    if(delIndex.column() == 0)
        isPseudo=true;
    else if(delIndex.column() == 1)
        isPseudo=false;

    authStream.device()-&gt;seek(0);
    QString contenu;
    for(int i=0;!authStream.atEnd();i++)
    {
        QString ligne=authStream.readLine();
        QString info;
        if(isPseudo)
            info=ligne.section(';', 0, 0);
        else
            info=ligne.section(';', 1, 1);

        if(info != delInfo)
        {
            contenu+=ligne+'\n';
        }
    }

    f_auth.resize(0);
    authStream &lt;&lt; contenu;

    modele-&gt;removeRow(delIndex.row());
    tableau-&gt;resizeColumnsToContents();

    f_auth.close();
}

void GereComptes::slotOk()
{
    closing=true;
    emit fini();
    close();
}

void GereComptes::closeEvent(QCloseEvent *event)
{
    if(!closing) // si on est pas passé par slotOk()
        slotOk();
    else
        event-&gt;accept();
}</code></pre><p id="r-556720" data-claire-element-id="556720">Pour les explications, elles sont dans la correction et dans quelques commentaires (évitez de lire la correction maintenant, vous risquez de lire la correction du reste) !</p><p id="r-556721" data-claire-element-id="556721">Passons à DialSetUser :</p><p id="r-556722" data-claire-element-id="556722"><strong>dialsetuser.h</strong></p><pre id="r-556723" data-claire-element-id="556723"><code data-claire-semantic="cpp">#ifndef DIALSETUSER_H
#define DIALSETUSER_H

#include &lt;QDialog&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QFormLayout&gt;
#include &lt;QLineEdit&gt;
#include &lt;QPushButton&gt;
#include &lt;QString&gt;
#include &lt;QMessageBox&gt;

#include &quot;fonctions.h&quot;

class User // oui, je suis flemmard. C'est plus court comme ça.
{
public:
    struct Infos // structure contenant toutes les infos renvoyées par le dialogue.
    {
        QString pseudo;
        QString hashmdp;
        bool annule;
    };
};

class DialSetUser : public QDialog
{
Q_OBJECT

public:
    DialSetUser(User::Infos *out_infos, QString in_pseudo=QString(), QString in_hash=QString()); // in_pseudo et in_hash sont des paramètres facultatifs. Si ils ont été donnés, ce sont les valeurs par défaut.
    static User::Infos get(QString pseudo=QString(), QString hash=QString()); // méthode statique permettant d'appeler le dialogue sans créer un objet.

private slots:
    void slotOk();
    void slotAnnule();

private:
    QVBoxLayout *l_principal;
    QFormLayout *l_form;
    QLineEdit *linePseudo;
    QLineEdit *linePass;
    QLineEdit *linePass2;
    QHBoxLayout *l_boutons;
    QPushButton *b_ok;
    QPushButton *b_annule;

    User::Infos *infos; // pointeur vers la structure passée en paramètre du constructeur
    QString defhash;
};

#endif // DIALSETUSER_H</code></pre><p id="r-556724" data-claire-element-id="556724"><strong>dialsetuser.cpp</strong></p><pre id="r-556725" data-claire-element-id="556725"><code data-claire-semantic="cpp">#include &quot;dialsetuser.h&quot;

DialSetUser::DialSetUser(User::Infos *out_infos, QString in_pseudo, QString in_hash)
{
    QString passLabelEnd=&quot;&quot;; // permet d'afficher un message ou non en fonction des paramètres passés
    if(in_pseudo.isEmpty() &amp;&amp; in_hash.isEmpty())
        setWindowTitle(&quot;Ajouter un utilisateur&quot;);
    else
    {
        passLabelEnd=&quot; (laisser vide\npour aucun changement)&quot;;
        setWindowTitle(&quot;Modifier un utilisateur&quot;);
    }

    defhash=in_hash; // hash par défaut

    setWindowIcon(QIcon(&quot;:/icones/prog&quot;));

    infos=out_infos;

    infos-&gt;annule=true; // si fermé, considéré comme annuler

    // ===== GUI ======
    l_principal=new QVBoxLayout;
    l_form=new QFormLayout;
    linePseudo=new QLineEdit;
    linePseudo-&gt;setText(in_pseudo);
    l_form-&gt;addRow(&quot;Pseudo&quot;,linePseudo);
    linePass=new QLineEdit;
    linePass-&gt;setEchoMode(QLineEdit::Password);
    l_form-&gt;addRow(&quot;Mot de passe&quot;+passLabelEnd, linePass);
    linePass2=new QLineEdit;
    linePass2-&gt;setEchoMode(QLineEdit::Password);
    l_form-&gt;addRow(&quot;Confirmez le mot de passe&quot;, linePass2);
    l_principal-&gt;addLayout(l_form);

    l_boutons=new QHBoxLayout;
    b_annule=new QPushButton(QIcon(&quot;:/icones/cancel&quot;), &quot;Annuler&quot;);
    l_boutons-&gt;addWidget(b_annule);
    b_ok=new QPushButton(QIcon(&quot;:/icones/accept&quot;), &quot;Ok&quot;);
    b_ok-&gt;setDefault(true);
    l_boutons-&gt;addWidget(b_ok);
    l_principal-&gt;addLayout(l_boutons);

    setLayout(l_principal);

    // ===== connexions =====
    connect(b_annule, SIGNAL(clicked()), this, SLOT(slotAnnule()));
    connect(b_ok, SIGNAL(clicked()), this, SLOT(slotOk()));
}

void DialSetUser::slotAnnule()
{
    infos-&gt;annule=true;
    close();
}

void DialSetUser::slotOk()
{
    if(linePseudo-&gt;text().isEmpty())
    {
        QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Tous les champs doivent être remplis !&quot;);
        return;
    }

    if(linePass-&gt;text() != linePass2-&gt;text())
    {
        QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Les mots de passe ne correspondent pas.&quot;);
        return;
    }

    if(linePseudo-&gt;text().contains(';'))
    {
        QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Le pseudo contient des caractères interdits.&quot;);
        return;
    }

    QString hashpass=linePass-&gt;text();
    if(hashpass.isEmpty())
    {
        if(defhash.isEmpty())
        {
            QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Tous les champs doivent être remplis !&quot;);
            return;
        }
        else
        {
            hashpass=defhash;
        }
    }
    else
        hashpass=Fonctions::hash(hashpass);

    infos-&gt;annule=false;
    infos-&gt;pseudo=linePseudo-&gt;text();
    infos-&gt;hashmdp=hashpass;
    close();
}

User::Infos DialSetUser::get(QString pseudo, QString hash)
{
    User::Infos retour; // on crée une structure à retourner,
    DialSetUser dial(&amp;retour, pseudo, hash); // on crée un dialogue
    dial.exec();
    return retour; // puis on retourne la structure
}</code></pre><p id="r-556726" data-claire-element-id="556726">Et voilà, vous avez tout le code !</p><p id="r-556727" data-claire-element-id="556727">Ensuite, il faut pouvoir le faire marcher avec le code que vous allez faire ! Pour ça, il ne vous faut que trois choses :</p><ul id="r-556736" data-claire-element-id="556736"><li id="r-556729" data-claire-element-id="556729"><p id="r-556728" data-claire-element-id="556728"><strong>Slot d'appel :</strong> Vous devrez créer un slot qui créera un objet GereComptes, l'ouvrira (<em>show();</em>), puis le connectera à un autre slot avec son signal <em>fini()</em>. Seulement, pour que ça marche, la fenêtre doit être un attribut de votre classe principale ! À vous de gérer ça.</p></li><li id="r-556731" data-claire-element-id="556731"><p id="r-556730" data-claire-element-id="556730"><strong>Slot de fin :</strong> Vous devrez donc connecter le signal <em>fini()</em> de la fenêtre à ce slot, qui rechargera le fichier pour garder à jour la liste des logins/hashs.</p></li><li id="r-556735" data-claire-element-id="556735"><p id="r-556732" data-claire-element-id="556732"><strong>Fonction de hachage :</strong> J'ai choisi de la mettre dans une classe à part, <em>Fonctions</em>, contenue dans les fichiers <em>fonctions.h</em> et <em>fonctions.cpp</em>. La fonction est statique, et son prototype est :</p><pre id="r-556733" data-claire-element-id="556733"><code data-claire-semantic="cpp">QString Fonctions::hash(QString input, bool alreadyMd5 = false);</code></pre><p id="r-556734" data-claire-element-id="556734">Elle retourne une QString contenant le hash final, et prend en paramètre une QString contenant la chaîne à hacher, ainsi qu'un booléen facultatif (par défaut <em>false</em>) indiquant si <em>input</em> est déjà haché en MD5 ou pas. Ainsi, le retour doit être égal si on envoie en paramètre &quot;sdz&quot;, false et si on envoie &quot;sdz&quot; haché en MD5, true.</p></li></ul></div></li></ul><p id="r-556740" data-claire-element-id="556740">Et maintenant, à vous de jouer ! Bonne programmation !</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui">Qt : Quelques fonctionnalités non-GUI</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Fonctionnalités non-GUI
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-les-ressources-qt">Utiliser les ressources Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-140">
Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
Créer le fichier de ressources
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-le-fichier-ressource">
Utiliser le fichier ressource
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">Hacher avec Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-19">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt">
Hacher avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">Les tables de hachage</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-20">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/avec-qt">
Avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">TP : le zLogin</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-du-sujet-1">
Présentation du sujet
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/correction-196">
Correction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">
<span class="arrow"></span>
<span class="next">TP : le zLogin</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/correction-196">
<span class="next">Correction</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Correction"></a><h2>Correction</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-du-sujet-1">
<span class="arrow"></span>
<span class="next">Présentation du sujet</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h4 id="r-correction-196" data-claire-element-id="556888">Correction</h4><p id="r-556743" data-claire-element-id="556743">Alors ? Fini ?</p><p id="r-556744" data-claire-element-id="556744">Dans ce cas, attaquons la correction !</p><p id="r-556745" data-claire-element-id="556745">On va commencer soft, avec le main.cpp :</p><pre id="r-556746" data-claire-element-id="556746"><code data-claire-semantic="cpp">#include &lt;QtGui/QApplication&gt;
#include &lt;QTextCodec&gt;
#include &lt;QTranslator&gt;
#include &lt;QLocale&gt;
#include &lt;QLibraryInfo&gt;

#include &quot;trayicon.h&quot;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QString locale = QLocale::system().name().section('_', 0, 0);
    QTranslator translator;
    translator.load(QString(&quot;qt_&quot;) + locale, QLibraryInfo::location(QLibraryInfo::TranslationsPath));
    a.installTranslator(&amp;translator);

    a.setQuitOnLastWindowClosed(false); // la fermeture de toutes les fenêtres ne fermera pas le programme (utile pour un prog sans fenêtres)

    TrayIcon t;
    t.show();
    return a.exec();
}</code></pre><p id="r-556747" data-claire-element-id="556747">Rien de bien particulier, si ce n'est que j'utilise comme classe principale <em>TrayIcon</em>, une classe héritant de QSystemTrayIcon.</p><p id="r-556748" data-claire-element-id="556748">Bon, on va attaquer plus dur : TrayIcon !</p><h5 id="r-trayicon" data-claire-element-id="556801">TrayIcon</h5><p id="r-556749" data-claire-element-id="556749"><strong>trayicon.h</strong> (mes noms de fichier sont en minuscules)</p><pre id="r-556750" data-claire-element-id="556750"><code data-claire-semantic="cpp">#ifndef TRAYICON_H
#define TRAYICON_H

// Eh oui, quand on utilise pas QtGui, ça donne ça !
#include &lt;QSystemTrayIcon&gt;
#include &lt;QIcon&gt;
#include &lt;QMenu&gt;
#include &lt;QAction&gt;
#include &lt;QMessageBox&gt;
#include &lt;QHash&gt;
#include &lt;QByteArray&gt;
#include &lt;QFile&gt;
#include &lt;QTextStream&gt;
#include &lt;QCryptographicHash&gt;
#include &lt;QTcpServer&gt;
#include &lt;QTcpSocket&gt;

#include &quot;gerecomptes.h&quot;
#include &quot;fonctions.h&quot;

class TrayIcon : public QSystemTrayIcon
{
Q_OBJECT

public:
    TrayIcon();
    void genereListePass(); // analyse le fichier contenant les logins/hashs pour les mettre dans &quot;passTable&quot;

private slots:
    void slotGereComptes();
    void slotGereComptesDone(); // appelé quand la fenêtre de gestion des comptes est fermée
    void slotDisplayAll();
    void slotSuspendre();
    void slotQuitter();

    // slots réseau
    void slotNewConnexion();
    void slotDonneesRecues();
    void slotDeconnexion();

private:
    // =========== METHODES ===========
    void envoyer(QTcpSocket *sock, quint8 reponse);

    // =========== ATTRIBUTS ==========
    // GUI
    QMenu *menu;
    QAction *actGereComptes;
    QAction *actDisplayAll;
    QAction *actSuspendre;
    QAction *actQuitter;

    GereComptes *fenComptes;

    // network
    QTcpServer *serv;
    quint16 size1; // stocke la taille de la 1ere partie des paquets reçus
    QString data1; // 1ere part. paquets reçus
    quint16 size2; // idem size1 pour la 2nde
    QString data2; // idem data1 pour la 2nde
    QList&lt;QTcpSocket *&gt; listeClients;

    // pass
    QHash&lt;QString, QString&gt; passTable; // stocke les correspondances logins/hashs

    // options
    bool displayAll; // si true, chaque connexion sera affichée dans une infobulle
    bool suspendu; // si true, toute connexion renverra 5 (service indisponible)
};

#endif // TRAYICON_H</code></pre><p id="r-556751" data-claire-element-id="556751">Bon, lui je vous le donne d'un coup, c'est pas bien dur à comprendre. Vous voyez qu'on inclut <em>gerecomptes.h</em> et <em>fonctions.h</em>. gerecomptes.h contient la classe GereComptes créant l'interface graphique pour ajouter/modifier/supprimer des comptes, et fonctions.h contient la classe Fonctions, qui contient la méthode statique servant au hachage.</p><p id="r-556752" data-claire-element-id="556752">On va attaquer les méthodes une par une maintenant :</p><p id="r-556753" data-claire-element-id="556753"><strong>TrayIcon()</strong> (constructeur)</p><pre id="r-556754" data-claire-element-id="556754"><code data-claire-semantic="cpp">TrayIcon::TrayIcon()
{
    // inits
    setIcon(QIcon(&quot;:/icones/prog&quot;)); // définit l'icône
    displayAll=false; // par défaut, infobulles désactivées
    suspendu=false; // par défaut, service activé
    genereListePass();

    size1=0;
    data1=&quot;&quot;;
    size2=0;
    data2=&quot;&quot;;

    serv=new QTcpServer(this); // on démarre le serveur
    if(!serv-&gt;listen(QHostAddress::Any, 31742))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur fatale&quot;, &quot;Le programme zLogin ne peut établir de connexion. Il va donc fermer.\nErreur : &quot;+serv-&gt;errorString());
        exit(EXIT_FAILURE);
    }
    else
    {
        connect(serv, SIGNAL(newConnection()), this, SLOT(slotNewConnexion()));
    }

    // Création du menu
    menu=new QMenu(&quot;Application&quot;);
    actGereComptes=menu-&gt;addAction(&quot;Gérer les comptes&quot;, this, SLOT(slotGereComptes()));
    menu-&gt;addSeparator();
    actDisplayAll=menu-&gt;addAction(&quot;Activer les infobulles&quot;, this, SLOT(slotDisplayAll()));
    actDisplayAll-&gt;setToolTip(&quot;Affiche une infobulle à chaque tentative de connexion&quot;);
    actDisplayAll-&gt;setCheckable(true);
    actDisplayAll-&gt;setChecked(false);
    actSuspendre=menu-&gt;addAction(&quot;Suspendre le service&quot;, this, SLOT(slotSuspendre()));
    actSuspendre-&gt;setToolTip(&quot;Refuse toute tentative de connexion, tout en gardant le programme ouvert&quot;);
    actSuspendre-&gt;setCheckable(true);
    actSuspendre-&gt;setChecked(false);
    menu-&gt;addSeparator();
    actQuitter=menu-&gt;addAction(&quot;Quitter&quot;, this, SLOT(slotQuitter()));
    setContextMenu(menu);
}</code></pre><p id="r-556755" data-claire-element-id="556755">Encore une fois, rien de bien compliqué : on initialise le serveur (voir le tuto de M@t' si vous ne comprenez pas cette partie du code), puis on crée le menu de l'icône dans le system tray, en créant un menu comme pour une fenêtre, puis en l'attribuant à l'icône avec <em>setContextMenu(menu);</em>.</p><p id="r-556756" data-claire-element-id="556756">On va ensuite voir tout ce qui ne concerne pas le réseau, puis on s'attaquera à la gestion du réseau.</p><h6 id="r-non-reseau" data-claire-element-id="556777">Non-réseau</h6><p id="r-556757" data-claire-element-id="556757"><strong>genereListePass()</strong> (qui remplit la table de hachage en fonction du fichier &quot;auth.zla&quot;)</p><pre id="r-556758" data-claire-element-id="556758"><code data-claire-semantic="cpp">void TrayIcon::genereListePass()
{
    QFile f_pass(&quot;auth.zla&quot;); // zla = ZLogin Auth, fichier texte.
    if(!f_pass.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur critique&quot;, &quot;Le programme \&quot;zLogin\&quot; a rencontré une erreur critique lors de la mise à jour de la liste des logins/mdps du zLogin. Le programme va donc fermer.\nErreur : &quot;+f_pass.errorString());
        exit(EXIT_FAILURE);
    }

    QTextStream stream(&amp;f_pass);

    QHash&lt;QString, QString&gt; tempPassTable; // on crée une table temporaire pour réduire le temps d'indisponiblité du service

    while(!stream.atEnd())
    {
        QString line=stream.readLine();
        QString pseudo=line.section(';', 0, 0);
        QString pass=line.section(';', 1, 1);
        tempPassTable.insert(pseudo, pass);
    }

    f_pass.close();

    suspendu=true; // On évite les erreurs si une requête est effectuée à ce moment en désactivant le service
    passTable.empty();
    passTable=tempPassTable;
    suspendu=false; // Puis on le réactive
}</code></pre><p id="r-556759" data-claire-element-id="556759">On ouvre donc le fichier auth.zla, qui contient les logins/hashs stockés ainsi :</p><pre id="r-556760" data-claire-element-id="556760"><code>login;hash
autrelogin;autrehash</code></pre><p id="r-556761" data-claire-element-id="556761">On boucle jusqu'à la fin du fichier en remplissant une table de hachage <strong>temporaire</strong>, puis on ferme le fichier. Utiliser une table de hachage temporaire permet de réduire le temps où le service sera indisponible.<br/> Ensuite, on rend le service indisponible (en passant <em>suspendu</em> à true), on vide la table de hachage (la vraie cette fois), puis on copie les données de la table de hachage temporaire dans la table de hachage, et enfin on réactive le service. Couper le service permet d'éviter des bugs dans le cas où une requête serait effectuée pile au moment où la table de hachage est vide.</p><p id="r-556762" data-claire-element-id="556762">Ensuite, les slots appelés quand on clique sur un élément du menu :<br/><strong>slotGereComptes()</strong> (appelé par &quot;Gérer les comptes&quot;)</p><pre id="r-556763" data-claire-element-id="556763"><code data-claire-semantic="cpp">void TrayIcon::slotGereComptes()
{
    fenComptes=new GereComptes(passTable);
    fenComptes-&gt;show();
    connect(fenComptes, SIGNAL(fini()), this, SLOT(slotGereComptesDone()));
}</code></pre><p id="r-556764" data-claire-element-id="556764">Très court, on crée la fenêtre en lui passant la table de hachage qui contient les logins/hashs, on l'affiche, puis on connecte le signal personnalisé <em>fini()</em> au slot <em>slotGereComptesDone</em>.</p><p id="r-556765" data-claire-element-id="556765"><strong>slotGereComptesDone()</strong> (appelé quand la fenêtre de gestion des comptes est fermée)</p><pre id="r-556766" data-claire-element-id="556766"><code data-claire-semantic="cpp">void TrayIcon::slotGereComptesDone()
{
    genereListePass();
}</code></pre><p id="r-556767" data-claire-element-id="556767">Encore plus court, ce slot se contente de mettre à jour, à partir du fichier que la fenêtre de gestion des comptes a peut-être modifié, la table de hachage qui contient les logins/hashs. J'ai utilisé un slot en lui-même au lieu de connecter directement <em>fini()</em> à <em>genereListePass()</em>, car si on a besoin ensuite de rajouter une action lors de la fermeture du dialogue, c'est plus simple :D .</p><p id="r-556768" data-claire-element-id="556768"><strong>slotDisplayAll()</strong> (appelé par &quot;Activer les infobulles&quot;)</p><pre id="r-556769" data-claire-element-id="556769"><code data-claire-semantic="cpp">void TrayIcon::slotDisplayAll()
{
    displayAll=actDisplayAll-&gt;isChecked();

    if(displayAll)
        showMessage(&quot;Infobulles activées&quot;, &quot;Les infobulles ont été activées. Toute tentative de login sera signalée.&quot;, QSystemTrayIcon::Information, 5000);
    else
        showMessage(&quot;Infobulles désactivées&quot;, &quot;Les infobulles ont été désactivées. Les tentatives de login ne seront plus signalées.&quot;, QSystemTrayIcon::Information, 5000);
}</code></pre><p id="r-556770" data-claire-element-id="556770">On modifie la valeur de <em>displayAll</em> en fonction de l'état d'<em>actDisplayAll</em> (l'élément du menu &quot;Activer les infobulles&quot;), puis on affiche que les infobulles ont été activées/désactivées.</p><p id="r-556771" data-claire-element-id="556771"><strong>slotSuspendre()</strong> (appelé par &quot;Suspendre le service&quot;)</p><pre id="r-556772" data-claire-element-id="556772"><code data-claire-semantic="cpp">void TrayIcon::slotSuspendre()
{
    if(actSuspendre-&gt;isChecked()) // Si on demande de suspendre
    {
        if(QMessageBox::warning(0, &quot;Êtes-vous sûr ?&quot;, &quot;Voulez-vous vraiment suspendre le service ? Toute tentative de connexion sera refusée, mais le programme sera toujours ouvert.&quot;,
                                QMessageBox::No | QMessageBox::Yes, QMessageBox::No) == QMessageBox::Yes)
        {
            suspendu=true;
            showMessage(&quot;Service suspendu&quot;, &quot;Le service a bien été suspendu. Toute tentative de login sera rejetée, et renverra le code 5 (service indisponible)&quot;, QSystemTrayIcon::Information, 5000);
        }
    }
    else
    {
        suspendu=false;
        showMessage(&quot;Service activé&quot;, &quot;Le service a bien été activé. Les tentatives de login seront maintenant traitées.&quot;, QSystemTrayIcon::Information, 5000);
    }
}</code></pre><p id="r-556773" data-claire-element-id="556773">Idem à <em>slotDisplayAll</em>, sauf qu'on modifie <em>suspendu</em>, et qu'on demande une confirmation pour le faire passer à true.</p><p id="r-556774" data-claire-element-id="556774"><strong>slotQuitter()</strong> (appelé par &quot;Quitter&quot;)</p><pre id="r-556775" data-claire-element-id="556775"><code data-claire-semantic="cpp">void TrayIcon::slotQuitter()
{
    int ret = QMessageBox::warning(0, &quot;Êtes-vous sûr ?&quot;, &quot;Êtes-vous sûr de vouloir quitter le zLogin ?&quot;,
                                   QMessageBox::No | QMessageBox::Yes, QMessageBox::No);

    if(ret==QMessageBox::Yes)
        exit(EXIT_SUCCESS);
}</code></pre><p id="r-556776" data-claire-element-id="556776">On demande une confirmation, puis on quitte, tout simplement.<br/> On en a fini avec ce qui ne concerne pas le réseau !</p><h6 id="r-reseau-1" data-claire-element-id="556800">Réseau</h6><p id="r-556778" data-claire-element-id="556778"><strong>slotNewConnexion()</strong> (appelé lors d'une connexion au serveur)</p><pre id="r-556779" data-claire-element-id="556779"><code data-claire-semantic="cpp">void TrayIcon::slotNewConnexion()
{
    QTcpSocket *sock=serv-&gt;nextPendingConnection();
    listeClients &lt;&lt; sock;
    connect(sock, SIGNAL(readyRead()), this, SLOT(slotDonneesRecues()));
    connect(sock, SIGNAL(disconnected()), this, SLOT(slotDeconnexion()));
}</code></pre><p id="r-556780" data-claire-element-id="556780">Si vous avez le tuto de M@t' sur le réseau avec Qt en tête, c'est très simple : on récupère le client, on le stocke dans une liste, puis on connecte <em>readyRead()</em> et <em>disconnected</em> à des slots personnalisés.</p><p id="r-556781" data-claire-element-id="556781">Continuons avec...<br/><strong>envoyer()</strong> (appelé pour envoyer la réponse)</p><pre id="r-556782" data-claire-element-id="556782"><code data-claire-semantic="cpp">void TrayIcon::envoyer(QTcpSocket *sock, quint8 reponse)
{
    QByteArray paquet;
    QDataStream stream(&amp;paquet, QIODevice::WriteOnly);

    stream &lt;&lt; reponse;

    sock-&gt;write(paquet);
}</code></pre><p id="r-556783" data-claire-element-id="556783">On crée un QByteArray stockant ce qu'on va envoyer, on y ajoute le paramètre <em>reponse</em>, puis on l'envoie.</p><p id="r-556784" data-claire-element-id="556784"><strong>slotDeconnexion()</strong> (appelé quand un client se déconnecte)</p><pre id="r-556785" data-claire-element-id="556785"><code data-claire-semantic="cpp">void TrayIcon::slotDeconnexion()
{
    QTcpSocket *sock=qobject_cast&lt;QTcpSocket *&gt;(sender());
    if(sock==0)
        return;

    sock-&gt;deleteLater();
    listeClients.removeOne(sock);
}</code></pre><p id="r-556786" data-claire-element-id="556786">On identifie le client en question, puis on le supprime de la liste, et on le supprime tout court avec <em>deleteLater()</em>.</p><p id="r-556787" data-claire-element-id="556787">Attention, maintenant, on s'attaque au gros ! La plus grosse partie de la gestion réseau est bien évidemment celle qui gère la réception des paquets, puis ce qui sera retourné !<br/><strong>slotDonneesRecues()</strong> (gère la réception des paquets, puis le renvoi de la réponse)<br/> Je vais faire exception à la règle, et vous donner le code petit bout par petit bout.<br/> Déjà, on a deux cas possibles : le service est suspendu, ou ne l'est pas. Mais dans les deux cas, on doit savoir de qui vient la requête. Ce qui nous donne la base de code suivante :</p><pre id="r-556788" data-claire-element-id="556788"><code data-claire-semantic="cpp">void TrayIcon::slotDonneesRecues()
{
    // ==== Recup du socket
    QTcpSocket *sock = qobject_cast&lt;QTcpSocket *&gt;(sender());
    if(sock==0)
        return;

    QDataStream stream(sock);

    if(!suspendu) // si le service est actif
    {
        
    }
    else // service suspendu
    {
        
    }
}</code></pre><p id="r-556789" data-claire-element-id="556789">Commençons par le plus simple : le service est suspendu. Avant tout, il faut attendre qu'on aie reçu tous les sous-paquets. Pour cela, pas d'autre choix que de récupérer les deux tailles de parties ainsi :</p><pre id="r-556790" data-claire-element-id="556790"><code data-claire-semantic="cpp">// ==== Recup du socket
    QTcpSocket *sock = qobject_cast&lt;QTcpSocket *&gt;(sender());
    if(sock==0)
        return;

    QDataStream stream(sock);

    if(!suspendu) // si le service est actif
    {
        
    }
    else // service suspendu
    {
        // on attend la fin de la transmission

        if(size1 == 0)
        {
            if(sock-&gt;bytesAvailable() &lt; (int)sizeof(quint16))
                return;
            stream &gt;&gt; size1;
        }
        if(data1 == &quot;&quot;)
        {
            if(sock-&gt;bytesAvailable() &lt; size1)
                return;
            data1=&quot;ok&quot;;
        }
        if(size2 == 0)
        {
            if(sock-&gt;bytesAvailable() &lt; (int)sizeof(quint16))
                return;
            stream &gt;&gt; size2;
        }
        if(sock-&gt;bytesAvailable() &lt; size2)
            return;

        // fin de la transmission
        envoyer(sock, 5);

        size1=0;
        data1=&quot;&quot;;
        size2=0;
        data2=&quot;&quot;;
    }
}</code></pre><p id="r-556791" data-claire-element-id="556791">On envoie ensuite dans tous les cas le code 5, soit &quot;Service indisponible&quot;, puis on réinitialise les variables &quot;size1&quot;, &quot;data1&quot;, &quot;size2&quot; et &quot;data2&quot;.</p><p id="r-556792" data-claire-element-id="556792">La partie &quot;service actif&quot; n'est pas bien différente, on y ajoute simplement le traitement des données reçues :</p><pre id="r-556793" data-claire-element-id="556793"><code data-claire-semantic="cpp">void TrayIcon::slotDonneesRecues()
{
    // ==== Recup du socket
    QTcpSocket *sock = qobject_cast&lt;QTcpSocket *&gt;(sender());
    if(sock==0)
        return;

    QDataStream stream(sock);

    if(!suspendu) // si le service est actif
    {
        // ==== Recup des donnees
        if(size1 == 0)
        {
            if(sock-&gt;bytesAvailable() &lt; (int)sizeof(quint16))
                return;
            stream &gt;&gt; size1;
        }

        if(data1 == &quot;&quot;)
        {
            if(sock-&gt;bytesAvailable() &lt; size1)
                return;
            stream &gt;&gt; data1;
        }

        if(size2 == 0)
        {
            if(sock-&gt;bytesAvailable() &lt; (int)sizeof(quint16))
                return;
            stream &gt;&gt; size2;
        }

        if(sock-&gt;bytesAvailable() &lt; size2)
            return;

        stream &gt;&gt; data2;

        // ==== Traitement des donnees

        QString startInfo=&quot;Une tentative de connexion depuis l'IP &quot;+sock-&gt;peerAddress().toString()+&quot; a été établie (pseudo : &quot;+data1+&quot;).\nRésultat : &quot;;

        if(!passTable.contains(data1)) // existence du pseudo
        {
            if(displayAll) // infobulles activées
                showMessage(&quot;Tentative de connexion (échec)&quot;, startInfo+&quot;mauvais login.&quot;, QSystemTrayIcon::NoIcon, 5000);
            envoyer(sock, 2);

            size1=0;
            data1=&quot;&quot;;
            size2=0;
            data2=&quot;&quot;;
            return;
        }
        QString hashPass=passTable.value(data1);
        if(hashPass==&quot;&quot;) // vérif que le hash ne soit pas vide
        {
            if(displayAll) // infobulles activées
                showMessage(&quot;Tentative de connexion (échec)&quot;, startInfo+&quot;erreur interne au zLogin (aucun mdp associé au login).&quot;, QSystemTrayIcon::NoIcon, 5000);
            envoyer(sock, 4);

            size1=0;
            data1=&quot;&quot;;
            size2=0;
            data2=&quot;&quot;;
            return;
        }
        else if(hashPass != Fonctions::hash(data2, true)) // vérif mdp = mdp envoyé
        {
            if(displayAll) // infobulles activées
                showMessage(&quot;Tentative de connexion (échec)&quot;, startInfo+&quot;mauvais MDP.&quot;, QSystemTrayIcon::NoIcon, 5000);
            envoyer(sock, 3);

            size1=0;
            data1=&quot;&quot;;
            size2=0;
            data2=&quot;&quot;;
            return;
        }

        // Si on arrive là, login/mdp OK !
        if(displayAll) // infobulles activées
            showMessage(&quot;Tentative de connexion (succès)&quot;, startInfo+&quot;succès.&quot;, QSystemTrayIcon::NoIcon, 5000);
        envoyer(sock, 1);

        size1=0;
        data1=&quot;&quot;;
        size2=0;
        data2=&quot;&quot;;
    }
    else // service suspendu
    {
        // on attend la fin de la transmission

        if(size1 == 0)
        {
            if(sock-&gt;bytesAvailable() &lt; (int)sizeof(quint16))
                return;
            stream &gt;&gt; size1;
        }
        if(data1 == &quot;&quot;)
        {
            if(sock-&gt;bytesAvailable() &lt; size1)
                return;
            data1=&quot;ok&quot;;
        }
        if(size2 == 0)
        {
            if(sock-&gt;bytesAvailable() &lt; (int)sizeof(quint16))
                return;
            stream &gt;&gt; size2;
        }
        if(sock-&gt;bytesAvailable() &lt; size2)
            return;

        // fin de la transmission
        envoyer(sock, 5);

        size1=0;
        data1=&quot;&quot;;
        size2=0;
        data2=&quot;&quot;;
    }
}</code></pre><p id="r-556794" data-claire-element-id="556794">On vérifie que le login existe, sinon, on renvoie 2 et on retourne. Puis on vérifie qu'un mot de passe est bien associé à ce login, sinon on renvoie 4 (erreur interne). Ensuite, on vérifie que le hash correspond bien à celui associé au login, sinon, on renvoie 3. À la fin, si tout est OK, on renvoie 1 (succès).</p><p id="r-556795" data-claire-element-id="556795">Et voilà, on en a fini avec TrayIcon !</p><p id="r-556796" data-claire-element-id="556796">Le code entier le trayicon.cpp :</p><p id="r-556797" data-claire-element-id="556797"></p><div id="r-556799" data-claire-element-id="556799"><pre id="r-556798" data-claire-element-id="556798"><code data-claire-semantic="cpp">#include &quot;trayicon.h&quot;

TrayIcon::TrayIcon()
{
    // inits
    setIcon(QIcon(&quot;:/icones/prog&quot;));
    displayAll=false; // par défaut, infobulles désactivées
    suspendu=false; // par défaut, service activé
    genereListePass();

    size1=0;
    data1=&quot;&quot;;
    size2=0;
    data2=&quot;&quot;;

    serv=new QTcpServer(this); // on démarre le serveur
    if(!serv-&gt;listen(QHostAddress::Any, 31742))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur fatale&quot;, &quot;Le programme zLogin ne peut établir de connexion. Il va donc fermer.\nErreur : &quot;+serv-&gt;errorString());
        exit(EXIT_FAILURE);
    }
    else
    {
        connect(serv, SIGNAL(newConnection()), this, SLOT(slotNewConnexion()));
    }

    // Création du menu
    menu=new QMenu(&quot;Application&quot;);
    actGereComptes=menu-&gt;addAction(&quot;Gérer les comptes&quot;, this, SLOT(slotGereComptes()));
    menu-&gt;addSeparator();
    actDisplayAll=menu-&gt;addAction(&quot;Activer les infobulles&quot;, this, SLOT(slotDisplayAll()));
    actDisplayAll-&gt;setToolTip(&quot;Affiche une infobulle à chaque tentative de connexion&quot;);
    actDisplayAll-&gt;setCheckable(true);
    actDisplayAll-&gt;setChecked(false);
    actSuspendre=menu-&gt;addAction(&quot;Suspendre le service&quot;, this, SLOT(slotSuspendre()));
    actSuspendre-&gt;setToolTip(&quot;Refuse toute tentative de connexion, tout en gardant le programme ouvert&quot;);
    actSuspendre-&gt;setCheckable(true);
    actSuspendre-&gt;setChecked(false);
    menu-&gt;addSeparator();
    actQuitter=menu-&gt;addAction(&quot;Quitter&quot;, this, SLOT(slotQuitter()));
    setContextMenu(menu);
}

// =============================
// ====== NETWORK ==============
// =============================

void TrayIcon::slotNewConnexion()
{
    QTcpSocket *sock=serv-&gt;nextPendingConnection();
    listeClients &lt;&lt; sock;
    connect(sock, SIGNAL(readyRead()), this, SLOT(slotDonneesRecues()));
    connect(sock, SIGNAL(disconnected()), this, SLOT(slotDeconnexion()));
}

void TrayIcon::slotDonneesRecues()
{
    // ==== Recup du socket
    QTcpSocket *sock = qobject_cast&lt;QTcpSocket *&gt;(sender());
    if(sock==0)
        return;

    QDataStream stream(sock);

    if(!suspendu) // si le service est actif
    {
        // ==== Recup des donnees
        if(size1 == 0)
        {
            if(sock-&gt;bytesAvailable() &lt; (int)sizeof(quint16))
                return;
            stream &gt;&gt; size1;
        }

        if(data1 == &quot;&quot;)
        {
            if(sock-&gt;bytesAvailable() &lt; size1)
                return;
            stream &gt;&gt; data1;
        }

        if(size2 == 0)
        {
            if(sock-&gt;bytesAvailable() &lt; (int)sizeof(quint16))
                return;
            stream &gt;&gt; size2;
        }

        if(sock-&gt;bytesAvailable() &lt; size2)
            return;

        stream &gt;&gt; data2;

        // ==== Traitement des donnees

        QString startInfo=&quot;Une tentative de connexion depuis l'IP &quot;+sock-&gt;peerAddress().toString()+&quot; a été établie (pseudo : &quot;+data1+&quot;).\nRésultat : &quot;;

        if(!passTable.contains(data1)) // existence du pseudo
        {
            if(displayAll) // infobulles activées
                showMessage(&quot;Tentative de connexion (échec)&quot;, startInfo+&quot;mauvais login.&quot;, QSystemTrayIcon::NoIcon, 5000);
            envoyer(sock, 2);

            size1=0;
            data1=&quot;&quot;;
            size2=0;
            data2=&quot;&quot;;
            return;
        }
        QString hashPass=passTable.value(data1);
        if(hashPass==&quot;&quot;) // vérif que le hash ne soit pas vide
        {
            if(displayAll) // infobulles activées
                showMessage(&quot;Tentative de connexion (échec)&quot;, startInfo+&quot;erreur interne au zLogin (aucun mdp associé au login).&quot;, QSystemTrayIcon::NoIcon, 5000);
            envoyer(sock, 4);

            size1=0;
            data1=&quot;&quot;;
            size2=0;
            data2=&quot;&quot;;
            return;
        }
        else if(hashPass != Fonctions::hash(data2, true)) // vérif mdp = mdp envoyé
        {
            if(displayAll) // infobulles activées
                showMessage(&quot;Tentative de connexion (échec)&quot;, startInfo+&quot;mauvais MDP.&quot;, QSystemTrayIcon::NoIcon, 5000);
            envoyer(sock, 3);

            size1=0;
            data1=&quot;&quot;;
            size2=0;
            data2=&quot;&quot;;
            return;
        }

        // Si on arrive là, login/mdp OK !
        if(displayAll) // infobulles activées
            showMessage(&quot;Tentative de connexion (succès)&quot;, startInfo+&quot;succès.&quot;, QSystemTrayIcon::NoIcon, 5000);
        envoyer(sock, 1);

        size1=0;
        data1=&quot;&quot;;
        size2=0;
        data2=&quot;&quot;;
    }
    else // service suspendu
    {
        // on attend la fin de la transmission

        if(size1 == 0)
        {
            if(sock-&gt;bytesAvailable() &lt; (int)sizeof(quint16))
                return;
            stream &gt;&gt; size1;
        }
        if(data1 == &quot;&quot;)
        {
            if(sock-&gt;bytesAvailable() &lt; size1)
                return;
            data1=&quot;ok&quot;;
        }
        if(size2 == 0)
        {
            if(sock-&gt;bytesAvailable() &lt; (int)sizeof(quint16))
                return;
            stream &gt;&gt; size2;
        }
        if(sock-&gt;bytesAvailable() &lt; size2)
            return;

        // fin de la transmission
        envoyer(sock, 5);

        size1=0;
        data1=&quot;&quot;;
        size2=0;
        data2=&quot;&quot;;
    }
}

void TrayIcon::envoyer(QTcpSocket *sock, quint8 reponse)
{
    QByteArray paquet;
    QDataStream stream(&amp;paquet, QIODevice::WriteOnly);

    stream &lt;&lt; reponse;

    sock-&gt;write(paquet);
}

void TrayIcon::slotDeconnexion()
{
    QTcpSocket *sock=qobject_cast&lt;QTcpSocket *&gt;(sender());
    if(sock==0)
        return;

    sock-&gt;deleteLater();
    listeClients.removeOne(sock);
}

// =============================
// ====== GUI &amp; gestion pass ===
// =============================

void TrayIcon::genereListePass()
{
    QFile f_pass(&quot;auth.zla&quot;); // zla = ZLogin Auth, fichier texte.
    if(!f_pass.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur critique&quot;, &quot;Le programme \&quot;zLogin\&quot; a rencontré une erreur critique lors de la mise à jour de la liste des logins/mdps du zLogin. Le programme va donc fermer.\nErreur : &quot;+f_pass.errorString());
        exit(EXIT_FAILURE);
    }

    QTextStream stream(&amp;f_pass);

    QHash&lt;QString, QString&gt; tempPassTable; // on crée une table temporaire pour réduire le temps d'indisponiblité du service

    while(!stream.atEnd())
    {
        QString line=stream.readLine();
        QString pseudo=line.section(';', 0, 0);
        QString pass=line.section(';', 1, 1);
        tempPassTable.insert(pseudo, pass);
    }

    f_pass.close();

    suspendu=true; // On évite les erreurs si une requête est effectuée à ce moment en désactivant le service
    passTable.empty();
    passTable=tempPassTable;
    suspendu=false; // Puis on le réactive
}

void TrayIcon::slotGereComptes()
{
    fenComptes=new GereComptes(passTable);
    fenComptes-&gt;show();
    connect(fenComptes, SIGNAL(fini()), this, SLOT(slotGereComptesDone()));
}

void TrayIcon::slotGereComptesDone()
{
    genereListePass();
}

void TrayIcon::slotDisplayAll()
{
    displayAll=actDisplayAll-&gt;isChecked();

    if(displayAll)
        showMessage(&quot;Infobulles activées&quot;, &quot;Les infobulles ont été activées. Toute tentative de login sera signalée.&quot;, QSystemTrayIcon::Information, 5000);
    else
        showMessage(&quot;Infobulles désactivées&quot;, &quot;Les infobulles ont été désactivées. Les tentatives de login ne seront plus signalées.&quot;, QSystemTrayIcon::Information, 5000);
}

void TrayIcon::slotSuspendre()
{
    if(actSuspendre-&gt;isChecked()) // Si on demande de suspendre
    {
        if(QMessageBox::warning(0, &quot;Êtes-vous sûr ?&quot;, &quot;Voulez-vous vraiment suspendre le service ? Toute tentative de connexion sera refusée, mais le programme sera toujours ouvert.&quot;,
                                QMessageBox::No | QMessageBox::Yes, QMessageBox::No) == QMessageBox::Yes)
        {
            suspendu=true;
            showMessage(&quot;Service suspendu&quot;, &quot;Le service a bien été suspendu. Toute tentative de login sera rejetée, et renverra le code 5 (service indisponible)&quot;, QSystemTrayIcon::Information, 5000);
        }
    }
    else
    {
        suspendu=false;
        showMessage(&quot;Service activé&quot;, &quot;Le service a bien été activé. Les tentatives de login seront maintenant traitées.&quot;, QSystemTrayIcon::Information, 5000);
    }
}

void TrayIcon::slotQuitter()
{
    int ret = QMessageBox::warning(0, &quot;Êtes-vous sûr ?&quot;, &quot;Êtes-vous sûr de vouloir quitter le zLogin ?&quot;,
                                   QMessageBox::No | QMessageBox::Yes, QMessageBox::No);

    if(ret==QMessageBox::Yes)
        exit(EXIT_SUCCESS);
}</code></pre></div><h5 id="r-gerecomptes" data-claire-element-id="556832">GereComptes</h5><p id="r-556802" data-claire-element-id="556802">Cette classe est l'interface graphique servant à gérer les comptes.<br/> On va attaquer avec gerecomptes.h :</p><p id="r-556803" data-claire-element-id="556803"><strong>gerecomptes.h</strong></p><pre id="r-556804" data-claire-element-id="556804"><code data-claire-semantic="cpp">#ifndef GERECOMPTES_H
#define GERECOMPTES_H

// eh oui, il y en a pas mal
#include &lt;QWidget&gt;
#include &lt;QTableView&gt;
#include &lt;QStandardItemModel&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QPushButton&gt;
#include &lt;QIcon&gt;
#include &lt;QHash&gt;
#include &lt;QHashIterator&gt;
#include &lt;QCloseEvent&gt;
#include &lt;QList&gt;
#include &lt;QHeaderView&gt;
#include &lt;QMessageBox&gt;
#include &lt;QFile&gt;
#include &lt;QTextStream&gt;
#include &lt;QRegExp&gt;

#include &quot;dialsetuser.h&quot;

class GereComptes : public QWidget
{
Q_OBJECT

public:
    GereComptes(QHash&lt;QString, QString&gt; authIn);

signals:
    void fini(); // émis à la fermeture du dialogue

private slots:
    void slotAddUser();
    void slotSetUser();
    void slotDelUser();
    void slotOk();

private:
    // methodes
    void majModele(); // appelé pour ajouter dans &quot;modele&quot; tout ce qui est contenu dans &quot;authTable&quot; (appelé dans le constructeur uniquement)
    void closeEvent(QCloseEvent *event); // Pour intercepter l'évènement de fermeture

    //attributs
    QHBoxLayout *l_principal;
    QTableView *tableau; // j'utilise une architecture MV (voir tuto de M@t')
    QStandardItemModel *modele;
    QVBoxLayout *l_boutons;
    QPushButton *b_addUser;
    QPushButton *b_setUser;
    QPushButton *b_delUser;
    QPushButton *b_ok;

    QHash&lt;QString, QString&gt; authTable;

    bool closing;
};

#endif // GERECOMPTES_H</code></pre><p id="r-556805" data-claire-element-id="556805">Rien à expliquer ici je pense, si ce n'est que j'utilise une architecture MV (une MVC simplifiée, <a href="http://www.siteduzero.com/tutoriel-3-11384-l-architecture-mvc-avec-les-widgets-complexes.html">tuto de M@t' ici</a>), comme en témoignent <em>QTableView *tableau;</em> et <em>QStandardItemModel *modele;</em>.</p><p id="r-556806" data-claire-element-id="556806">Attaquons-nous maintenant à l'implémentation de ces fonctions :</p><p id="r-556807" data-claire-element-id="556807"><strong>GereComptes()</strong> (constructeur)</p><pre id="r-556808" data-claire-element-id="556808"><code data-claire-semantic="cpp">GereComptes::GereComptes(QHash&lt;QString, QString&gt; authIn)
{
    setWindowTitle(&quot;zLogin - gestion des comptes&quot;);
    setWindowIcon(QIcon(&quot;:/icones/prog&quot;));
    authTable=authIn;
    closing=false;

    // GUI
    l_principal=new QHBoxLayout;
    modele=new QStandardItemModel(0, 2);
    modele-&gt;setHeaderData(0, Qt::Horizontal, &quot;Pseudo&quot;, Qt::DisplayRole);
    modele-&gt;setHeaderData(1, Qt::Horizontal, &quot;Hash du MDP&quot;, Qt::DisplayRole);
    tableau=new QTableView;
    tableau-&gt;setModel(modele);
    tableau-&gt;setMinimumWidth(425);
    majModele();
    l_principal-&gt;addWidget(tableau);

    l_boutons=new QVBoxLayout;
    b_addUser=new QPushButton(QIcon(&quot;:/icones/addUser&quot;), &quot;Créer un compte&quot;);
    l_boutons-&gt;addWidget(b_addUser);
    b_setUser=new QPushButton(QIcon(&quot;:/icones/setUser&quot;), &quot;Modifier le compte&quot;);
    l_boutons-&gt;addWidget(b_setUser);
    b_delUser=new QPushButton(QIcon(&quot;:/icones/delUser&quot;), &quot;Supprimer le compte&quot;);
    l_boutons-&gt;addWidget(b_delUser);
    b_ok=new QPushButton(QIcon(&quot;:/icones/accept&quot;), &quot;Ok&quot;);
    l_boutons-&gt;addWidget(b_ok);
    l_principal-&gt;addLayout(l_boutons);

    setLayout(l_principal);

    // connect
    connect(b_addUser, SIGNAL(clicked()), this, SLOT(slotAddUser()));
    connect(b_setUser, SIGNAL(clicked()), this, SLOT(slotSetUser()));
    connect(b_delUser, SIGNAL(clicked()), this, SLOT(slotDelUser()));
    connect(b_ok, SIGNAL(clicked()), this, SLOT(slotOk()));
}</code></pre><p id="r-556809" data-claire-element-id="556809">On crée la GUI, on crée <em>modele</em> et on l'associe à <em>tableau</em>, puis on appelle <em>majModele()</em>, qui crée, à partir de la table de hachage reçue en paramètre du constructeur, le modèle.</p><p id="r-556810" data-claire-element-id="556810"><strong>majModele()</strong> (appelé depuis le constructeur)</p><pre id="r-556811" data-claire-element-id="556811"><code data-claire-semantic="cpp">void GereComptes::majModele()
{
    // assez simple : on ajoute dans le modèle tous les logins/hashs.
    QHashIterator&lt;QString, QString&gt; iterateur(authTable);

    while(iterateur.hasNext())
    {
        iterateur.next();
        QList&lt;QStandardItem *&gt; items;
        items &lt;&lt; new QStandardItem(iterateur.key()) &lt;&lt; new QStandardItem(iterateur.value());
        modele-&gt;appendRow(items);
    }

    tableau-&gt;resizeColumnsToContents();
}</code></pre><p id="r-556812" data-claire-element-id="556812">On crée un itérateur utilisant la table de hachage reçue en paramètre du constructeur, puis on le parcourt en ajoutant à chaque fois au modèle la clé et la valeur, soit le login et le hash. À la fin, <em>tableau-&gt;resizeColumnsToContents();</em> sert à ajuster les colonnes du tableau aux valeurs contenues.</p><p id="r-556813" data-claire-element-id="556813"><strong>slotAddUser()</strong> (appelé par un clic sur &quot;Créer un compte&quot;)</p><pre id="r-556814" data-claire-element-id="556814"><code data-claire-semantic="cpp">void GereComptes::slotAddUser()
{
    // On ajoutera le nouvel utilisateur directement dans le fichier, qui devra être rechargé une fois le dialogue fermé

    QFile f_auth;
    QTextStream authStream;

    f_auth.setFileName(&quot;auth.zla&quot;);
    if(!f_auth.open(QIODevice::ReadWrite | QIODevice::Text))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur&quot;, &quot;Le programme \&quot;zLogin\&quot; a rencontré une erreur lors de l'ouverture de la liste des logins/mdps du zLogin.\nErreur : &quot;+f_auth.errorString());
        close();
    }
    authStream.setDevice(&amp;f_auth);


    User::Infos infos=DialSetUser::get(); // méthode statique

    if(infos.annule)
        return;

    QHashIterator&lt;QString, QString&gt; iterateur(authTable);

    while(iterateur.hasNext()) // vérif que le pseudo n'est pas utilisé
    {
        iterateur.next();
        if(iterateur.key() == infos.pseudo)
        {
            QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Le pseudo choisi est déjà utilisé.&quot;);
            return;
        }
    }

    authStream.readAll(); // aller à la fin du fichier
    authStream &lt;&lt; infos.pseudo+';'+infos.hashmdp+'\n';

    QList&lt;QStandardItem *&gt; items; // ajout du nouvel utilisateur au modèle
    items &lt;&lt; new QStandardItem(infos.pseudo) &lt;&lt; new QStandardItem(infos.hashmdp);
    modele-&gt;appendRow(items);
    tableau-&gt;resizeColumnsToContents();

    f_auth.close();
}</code></pre><p id="r-556815" data-claire-element-id="556815">On ouvre d'abord le fichier <em>auth.zla</em>, puis on ouvre un dialogue demandant à l'utilisateur le login et le mot de passe du nouvel utilisateur. Le dialogue se charge de hacher le MdP. On vérifie que l'utilisateur n'a pas annulé, puis on parcourt la table pour vérifier que le pseudo n'est pas déjà présent. On se place à la fin du fichier en le lisant entièrement, puis on y ajoute la ligne formée ainsi : login;hash ( étant un retour à la ligne). Ensuite, on ajoute le nouvel utilisateur au modèle, puis on ferme le fichier.</p><p id="r-556816" data-claire-element-id="556816"><strong>slotDelUser()</strong> (appelé par un clic sur &quot;Supprimer le compte&quot;)</p><pre id="r-556817" data-claire-element-id="556817"><code data-claire-semantic="cpp">void GereComptes::slotDelUser()
{
    QFile f_auth;
    QTextStream authStream;
    f_auth.setFileName(&quot;auth.zla&quot;);
    if(!f_auth.open(QIODevice::ReadWrite | QIODevice::Text))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur&quot;, &quot;Le programme \&quot;zLogin\&quot; a rencontré une erreur lors de l'ouverture de la liste des logins/mdps du zLogin.\nErreur : &quot;+f_auth.errorString());
        close();
    }
    authStream.setDevice(&amp;f_auth);


    QModelIndex delIndex=tableau-&gt;selectionModel()-&gt;currentIndex();
    if(!delIndex.isValid()) // index invalide, pas de selection
    {
        QMessageBox::warning(this, &quot;Aucune sélection&quot;, &quot;Aucun item n'est sélectionné.&quot;);
        return;
    }

    if(QMessageBox::warning(this, &quot;Êtes-vous sûr ?&quot;, &quot;Êtes-vous sûr de vouloir supprimer ce compte définitivement ?&quot;,
                            QMessageBox::No | QMessageBox::Yes, QMessageBox::No) == QMessageBox::No)
    {
        return;
    }

    QString delInfo=delIndex.data(Qt::DisplayRole).toString();
    bool isPseudo;
    if(delIndex.column() == 0)
        isPseudo=true;
    else if(delIndex.column() == 1)
        isPseudo=false;

    authStream.device()-&gt;seek(0);
    QString contenu;
    for(int i=0;!authStream.atEnd();i++)
    {
        QString ligne=authStream.readLine();
        QString info;
        if(isPseudo)
            info=ligne.section(';', 0, 0);
        else
            info=ligne.section(';', 1, 1);

        if(info != delInfo)
        {
            contenu+=ligne+'\n';
        }
    }

    f_auth.resize(0);
    authStream &lt;&lt; contenu;

    modele-&gt;removeRow(delIndex.row());
    tableau-&gt;resizeColumnsToContents();

    f_auth.close();
}</code></pre><p id="r-556818" data-claire-element-id="556818">Pareil, on ouvre le fichier <em>auth.zla</em>, puis on récupère la sélection pour savoir quelle ligne supprimer. Si l'index est invalide, il n'y a donc pas de sélection, on affiche une erreur et on retourne. On demande confirmation, et on prend en mémoire toutes les lignes sauf celle à supprimer. Avec <em>f_auth.resize(0)</em>, on supprime tout le contenu du fichier, puis on réinscrit dedans tout ce qu'on a gardé en mémoire. On supprime la ligne du modèle, puis on ferme le fichier.</p><p id="r-556819" data-claire-element-id="556819"><strong>slotSetUser()</strong> (appelé par un clic sur &quot;Modifier le compte&quot;)</p><pre id="r-556820" data-claire-element-id="556820"><code data-claire-semantic="cpp">void GereComptes::slotSetUser()
{
    QFile f_auth;
    QTextStream authStream;
    f_auth.setFileName(&quot;auth.zla&quot;);
    if(!f_auth.open(QIODevice::ReadWrite | QIODevice::Text))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur&quot;, &quot;Le programme \&quot;zLogin\&quot; a rencontré une erreur lors de l'ouverture de la liste des logins/mdps du zLogin.\nErreur : &quot;+f_auth.errorString());
        close();
    }
    authStream.setDevice(&amp;f_auth);


    QModelIndex setIndex=tableau-&gt;selectionModel()-&gt;currentIndex();
    if(!setIndex.isValid()) // index invalide, pas de selection
    {
        QMessageBox::warning(this, &quot;Aucune sélection&quot;, &quot;Aucun item n'est sélectionné.&quot;);
        return;
    }

    int setRow=setIndex.row(); // récupère l'ID de la ligne sélectionnée
    QString basePseudo=modele-&gt;item(setRow, 0)-&gt;data(Qt::DisplayRole).toString(); // recup le pseudo actuel
    QString baseHash=modele-&gt;item(setRow, 1)-&gt;data(Qt::DisplayRole).toString(); // récup le hash actuel
    User::Infos infos=DialSetUser::get(basePseudo, baseHash);

    if(infos.annule) // si l'user a annulé
        return;

    if(infos.pseudo != basePseudo || infos.hashmdp != baseHash) // si il y a eu une modif
    {

        if(infos.pseudo!=basePseudo) //vérif que le pseudo est libre
        {
            QHashIterator&lt;QString, QString&gt; iterateur(authTable);

            while(iterateur.hasNext())
            {
                iterateur.next();
                if(iterateur.key() == infos.pseudo)
                {
                    QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Le pseudo choisi est déjà utilisé.&quot;);
                    return;
                }
            }
        }

        // recherche de la ligne du fichier
        QString setInfo=setIndex.data(Qt::DisplayRole).toString();
        bool isPseudo;
        if(setIndex.column() == 0)
            isPseudo=true;
        else if(setIndex.column() == 1)
            isPseudo=false;

        authStream.device()-&gt;seek(0);
        QString contenu;
        for(int i=0;!authStream.atEnd();i++)
        {
            QString ligne=authStream.readLine();
            QString info;
            if(isPseudo)
                info=ligne.section(';', 0, 0);
            else
                info=ligne.section(';', 1, 1);

            if(info != setInfo)
            {
                contenu+=ligne+'\n'; // on prend en mémoire toutes les lignes sauf celle à modif
            }
        }

        contenu += infos.pseudo+';'+infos.hashmdp+'\n'; // puis on ajoute à ça la ligne AVEC modifs

        f_auth.resize(0); // supprime le contenu du fichier
        authStream &lt;&lt; contenu; // puis le réécrit

        modele-&gt;setItem(setRow, 0, new QStandardItem(infos.pseudo)); // édite la ligne du modèle
        modele-&gt;setItem(setRow, 1, new QStandardItem(infos.hashmdp));

        tableau-&gt;resizeColumnsToContents();
    }

    f_auth.close();
}</code></pre><p id="r-556821" data-claire-element-id="556821">Ce slot est un simple mélange de <em>slotAddUser()</em> et de <em>slotDelUser</em>, je n'expliquerai donc rien ici, en croisant les deux explications vous devriez assez bien comprendre !</p><p id="r-556822" data-claire-element-id="556822"><strong>slotOk()</strong> (appelé par un clic sur &quot;Ok&quot;)</p><pre id="r-556823" data-claire-element-id="556823"><code data-claire-semantic="cpp">void GereComptes::slotOk()
{
    closing=true;
    emit fini();
    close();
}</code></pre><p id="r-556824" data-claire-element-id="556824">On définit <em>closing</em> à true, on émet <em>fini()</em>, puis on ferme la fenêtre.</p><p id="r-556825" data-claire-element-id="556825"><strong>closeEvent()</strong> (appelé par close(), ou un clic sur la croix)</p><pre id="r-556826" data-claire-element-id="556826"><code data-claire-semantic="cpp">void GereComptes::closeEvent(QCloseEvent *event)
{
    if(!closing) // si on est pas passé par slotOk()
        slotOk();
    else
        event-&gt;accept();
}</code></pre><p id="r-556827" data-claire-element-id="556827">Pour que <em>fini()</em> soit émit si on clique sur la croix, on vérifie si <em>closing</em> vaut true (seulement vrai après un appel de <em>slotOk()</em>, si oui, on accepte la fermeture, sinon, on appelle <em>slotOk()</em>.</p><p id="r-556828" data-claire-element-id="556828">On en a également fini avec GereComptes !<br/> Le code complet :</p><p id="r-556829" data-claire-element-id="556829"></p><div id="r-556831" data-claire-element-id="556831"><pre id="r-556830" data-claire-element-id="556830"><code data-claire-semantic="cpp">#include &quot;gerecomptes.h&quot;

GereComptes::GereComptes(QHash&lt;QString, QString&gt; authIn)
{
    setWindowTitle(&quot;zLogin - gestion des comptes&quot;);
    setWindowIcon(QIcon(&quot;:/icones/prog&quot;));
    authTable=authIn;
    closing=false;

    // GUI
    l_principal=new QHBoxLayout;
    modele=new QStandardItemModel(0, 2);
    modele-&gt;setHeaderData(0, Qt::Horizontal, &quot;Pseudo&quot;, Qt::DisplayRole);
    modele-&gt;setHeaderData(1, Qt::Horizontal, &quot;Hash du MDP&quot;, Qt::DisplayRole);
    tableau=new QTableView;
    tableau-&gt;setModel(modele);
    tableau-&gt;setMinimumWidth(425);
    majModele();
    l_principal-&gt;addWidget(tableau);

    l_boutons=new QVBoxLayout;
    b_addUser=new QPushButton(QIcon(&quot;:/icones/addUser&quot;), &quot;Créer un compte&quot;);
    l_boutons-&gt;addWidget(b_addUser);
    b_setUser=new QPushButton(QIcon(&quot;:/icones/setUser&quot;), &quot;Modifier le compte&quot;);
    l_boutons-&gt;addWidget(b_setUser);
    b_delUser=new QPushButton(QIcon(&quot;:/icones/delUser&quot;), &quot;Supprimer le compte&quot;);
    l_boutons-&gt;addWidget(b_delUser);
    b_ok=new QPushButton(QIcon(&quot;:/icones/accept&quot;), &quot;Ok&quot;);
    l_boutons-&gt;addWidget(b_ok);
    l_principal-&gt;addLayout(l_boutons);

    setLayout(l_principal);

    // connect
    connect(b_addUser, SIGNAL(clicked()), this, SLOT(slotAddUser()));
    connect(b_setUser, SIGNAL(clicked()), this, SLOT(slotSetUser()));
    connect(b_delUser, SIGNAL(clicked()), this, SLOT(slotDelUser()));
    connect(b_ok, SIGNAL(clicked()), this, SLOT(slotOk()));
}

void GereComptes::majModele()
{
    // assez simple : on ajoute dans le modèle tous les logins/hashs.
    QHashIterator&lt;QString, QString&gt; iterateur(authTable);

    while(iterateur.hasNext())
    {
        iterateur.next();
        QList&lt;QStandardItem *&gt; items;
        items &lt;&lt; new QStandardItem(iterateur.key()) &lt;&lt; new QStandardItem(iterateur.value());
        modele-&gt;appendRow(items);
    }

    tableau-&gt;resizeColumnsToContents();
}

void GereComptes::slotAddUser()
{
    // On ajoutera le nouvel utilisateur directement dans le fichier, qui devra être rechargé une fois le dialogue fermé

    QFile f_auth;
    QTextStream authStream;

    f_auth.setFileName(&quot;auth.zla&quot;);
    if(!f_auth.open(QIODevice::ReadWrite | QIODevice::Text))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur&quot;, &quot;Le programme \&quot;zLogin\&quot; a rencontré une erreur lors de l'ouverture de la liste des logins/mdps du zLogin.\nErreur : &quot;+f_auth.errorString());
        close();
    }
    authStream.setDevice(&amp;f_auth);


    User::Infos infos=DialSetUser::get(); // méthode statique

    if(infos.annule)
        return;

    QHashIterator&lt;QString, QString&gt; iterateur(authTable);

    while(iterateur.hasNext()) // vérif que le pseudo n'est pas utilisé
    {
        iterateur.next();
        if(iterateur.key() == infos.pseudo)
        {
            QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Le pseudo choisi est déjà utilisé.&quot;);
            return;
        }
    }

    authStream.readAll(); // aller à la fin du fichier
    authStream &lt;&lt; infos.pseudo+';'+infos.hashmdp+'\n';

    QList&lt;QStandardItem *&gt; items; // ajout du nouvel utilisateur au modèle
    items &lt;&lt; new QStandardItem(infos.pseudo) &lt;&lt; new QStandardItem(infos.hashmdp);
    modele-&gt;appendRow(items);
    tableau-&gt;resizeColumnsToContents();

    f_auth.close();
}

void GereComptes::slotSetUser()
{
    QFile f_auth;
    QTextStream authStream;
    f_auth.setFileName(&quot;auth.zla&quot;);
    if(!f_auth.open(QIODevice::ReadWrite | QIODevice::Text))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur&quot;, &quot;Le programme \&quot;zLogin\&quot; a rencontré une erreur lors de l'ouverture de la liste des logins/mdps du zLogin.\nErreur : &quot;+f_auth.errorString());
        close();
    }
    authStream.setDevice(&amp;f_auth);


    QModelIndex setIndex=tableau-&gt;selectionModel()-&gt;currentIndex();
    if(!setIndex.isValid()) // index invalide, pas de selection
    {
        QMessageBox::warning(this, &quot;Aucune sélection&quot;, &quot;Aucun item n'est sélectionné.&quot;);
        return;
    }

    int setRow=setIndex.row(); // récupère l'ID de la ligne sélectionnée
    QString basePseudo=modele-&gt;item(setRow, 0)-&gt;data(Qt::DisplayRole).toString(); // recup le pseudo actuel
    QString baseHash=modele-&gt;item(setRow, 1)-&gt;data(Qt::DisplayRole).toString(); // récup le hash actuel
    User::Infos infos=DialSetUser::get(basePseudo, baseHash);

    if(infos.annule) // si l'user a annulé
        return;

    if(infos.pseudo != basePseudo || infos.hashmdp != baseHash) // si il y a eu une modif
    {

        if(infos.pseudo!=basePseudo) //vérif que le pseudo est libre
        {
            QHashIterator&lt;QString, QString&gt; iterateur(authTable);

            while(iterateur.hasNext())
            {
                iterateur.next();
                if(iterateur.key() == infos.pseudo)
                {
                    QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Le pseudo choisi est déjà utilisé.&quot;);
                    return;
                }
            }
        }

        // recherche de la ligne du fichier
        QString setInfo=setIndex.data(Qt::DisplayRole).toString();
        bool isPseudo;
        if(setIndex.column() == 0)
            isPseudo=true;
        else if(setIndex.column() == 1)
            isPseudo=false;

        authStream.device()-&gt;seek(0);
        QString contenu;
        for(int i=0;!authStream.atEnd();i++)
        {
            QString ligne=authStream.readLine();
            QString info;
            if(isPseudo)
                info=ligne.section(';', 0, 0);
            else
                info=ligne.section(';', 1, 1);

            if(info != setInfo)
            {
                contenu+=ligne+'\n'; // on prend en mémoire toutes les lignes sauf celle à modif
            }
        }

        contenu += infos.pseudo+';'+infos.hashmdp+'\n'; // puis on ajoute à ça la ligne AVEC modifs

        f_auth.resize(0); // supprime le contenu du fichier
        authStream &lt;&lt; contenu; // puis le réécrit

        modele-&gt;setItem(setRow, 0, new QStandardItem(infos.pseudo)); // édite la ligne du modèle
        modele-&gt;setItem(setRow, 1, new QStandardItem(infos.hashmdp));

        tableau-&gt;resizeColumnsToContents();
    }

    f_auth.close();
}

void GereComptes::slotDelUser()
{
    QFile f_auth;
    QTextStream authStream;
    f_auth.setFileName(&quot;auth.zla&quot;);
    if(!f_auth.open(QIODevice::ReadWrite | QIODevice::Text))
    {
        QMessageBox::critical(0, &quot;zLogin : erreur&quot;, &quot;Le programme \&quot;zLogin\&quot; a rencontré une erreur lors de l'ouverture de la liste des logins/mdps du zLogin.\nErreur : &quot;+f_auth.errorString());
        close();
    }
    authStream.setDevice(&amp;f_auth);


    QModelIndex delIndex=tableau-&gt;selectionModel()-&gt;currentIndex();
    if(!delIndex.isValid()) // index invalide, pas de selection
    {
        QMessageBox::warning(this, &quot;Aucune sélection&quot;, &quot;Aucun item n'est sélectionné.&quot;);
        return;
    }

    if(QMessageBox::warning(this, &quot;Êtes-vous sûr ?&quot;, &quot;Êtes-vous sûr de vouloir supprimer ce compte définitivement ?&quot;,
                            QMessageBox::No | QMessageBox::Yes, QMessageBox::No) == QMessageBox::No)
    {
        return;
    }

    QString delInfo=delIndex.data(Qt::DisplayRole).toString();
    bool isPseudo;
    if(delIndex.column() == 0)
        isPseudo=true;
    else if(delIndex.column() == 1)
        isPseudo=false;

    authStream.device()-&gt;seek(0);
    QString contenu;
    for(int i=0;!authStream.atEnd();i++)
    {
        QString ligne=authStream.readLine();
        QString info;
        if(isPseudo)
            info=ligne.section(';', 0, 0);
        else
            info=ligne.section(';', 1, 1);

        if(info != delInfo)
        {
            contenu+=ligne+'\n';
        }
    }

    f_auth.resize(0);
    authStream &lt;&lt; contenu;

    modele-&gt;removeRow(delIndex.row());
    tableau-&gt;resizeColumnsToContents();

    f_auth.close();
}

void GereComptes::slotOk()
{
    closing=true;
    emit fini();
    close();
}

void GereComptes::closeEvent(QCloseEvent *event)
{
    if(!closing) // si on est pas passé par slotOk()
        slotOk();
    else
        event-&gt;accept();
}</code></pre></div><h5 id="r-dialsetuser" data-claire-element-id="556860">DialSetUser</h5><p id="r-556833" data-claire-element-id="556833">Assez simple celui-là, ça va aller vite !</p><p id="r-556834" data-claire-element-id="556834">Commençons par <strong>dialsetuser.h</strong></p><pre id="r-556835" data-claire-element-id="556835"><code data-claire-semantic="cpp">#ifndef DIALSETUSER_H
#define DIALSETUSER_H

#include &lt;QDialog&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QFormLayout&gt;
#include &lt;QLineEdit&gt;
#include &lt;QPushButton&gt;
#include &lt;QString&gt;
#include &lt;QMessageBox&gt;

#include &quot;fonctions.h&quot;

class User // oui, je suis flemmard. C'est plus court comme ça.
{
public:
    struct Infos // structure contenant toutes les infos renvoyées par le dialogue.
    {
        QString pseudo;
        QString hashmdp;
        bool annule;
    };
};

class DialSetUser : public QDialog
{
Q_OBJECT

public:
    DialSetUser(User::Infos *out_infos, QString in_pseudo=QString(), QString in_hash=QString()); // in_pseudo et in_hash sont des paramètres facultatifs. Si ils ont été donnés, ce sont les valeurs par défaut.
    static User::Infos get(QString pseudo=QString(), QString hash=QString()); // méthode statique permettant d'appeler le dialogue sans créer un objet.

private slots:
    void slotOk();
    void slotAnnule();

private:
    QVBoxLayout *l_principal;
    QFormLayout *l_form;
    QLineEdit *linePseudo;
    QLineEdit *linePass;
    QLineEdit *linePass2;
    QHBoxLayout *l_boutons;
    QPushButton *b_ok;
    QPushButton *b_annule;

    User::Infos *infos; // pointeur vers la structure passée en paramètre du constructeur
    QString defhash;
};

#endif // DIALSETUSER_H</code></pre><p id="r-556836" data-claire-element-id="556836">Seul truc un peu bizarre : je crée ici deux classes, dont une quasi-vide. En fait, la classe User ne contient qu'une déclaration structure, qui servira à retourner les informations entrées dans le dialogue. Par flemme de réécrire <em>DialSetUser::Infos</em> partout (oui, je confirme ce qu'on dit sur les programmeurs et la flemme :D ), j'ai créé une classe appelée User, comme ça, j'aurai juste besoin de marquer User::Infos. Sinon, <em>DialSetUser</em> est une classe héritant de <em>QDialog</em>.</p><p id="r-556837" data-claire-element-id="556837">On inclut <em>fonctions.h</em>, car on aura besoin de hacher le mot de passe. La QString <em>defhash</em> contient ici le hash passé en paramètre du constructeur, permettant de donner une valeur par défaut si on appelle le dialogue pour éditer un utilisateur.</p><p id="r-556838" data-claire-element-id="556838"><strong>DialSetUser()</strong> (constructeur)</p><pre id="r-556839" data-claire-element-id="556839"><code data-claire-semantic="cpp">DialSetUser::DialSetUser(User::Infos *out_infos, QString in_pseudo, QString in_hash)
{
    QString passLabelEnd=&quot;&quot;; // permet d'afficher un message ou non en fonction des paramètres passés
    if(in_pseudo.isEmpty() &amp;&amp; in_hash.isEmpty())
        setWindowTitle(&quot;Ajouter un utilisateur&quot;);
    else
    {
        passLabelEnd=&quot; (laisser vide\npour aucun changement)&quot;;
        setWindowTitle(&quot;Modifier un utilisateur&quot;);
    }

    defhash=in_hash; // hash par défaut

    setWindowIcon(QIcon(&quot;:/icones/prog&quot;));

    infos=out_infos;

    infos-&gt;annule=true; // si fermé, considéré comme annuler

    // ===== GUI ======
    l_principal=new QVBoxLayout;
    l_form=new QFormLayout;
    linePseudo=new QLineEdit;
    linePseudo-&gt;setText(in_pseudo);
    l_form-&gt;addRow(&quot;Pseudo&quot;,linePseudo);
    linePass=new QLineEdit;
    linePass-&gt;setEchoMode(QLineEdit::Password);
    l_form-&gt;addRow(&quot;Mot de passe&quot;+passLabelEnd, linePass);
    linePass2=new QLineEdit;
    linePass2-&gt;setEchoMode(QLineEdit::Password);
    l_form-&gt;addRow(&quot;Confirmez le mot de passe&quot;, linePass2);
    l_principal-&gt;addLayout(l_form);

    l_boutons=new QHBoxLayout;
    b_annule=new QPushButton(QIcon(&quot;:/icones/cancel&quot;), &quot;Annuler&quot;);
    l_boutons-&gt;addWidget(b_annule);
    b_ok=new QPushButton(QIcon(&quot;:/icones/accept&quot;), &quot;Ok&quot;);
    b_ok-&gt;setDefault(true);
    l_boutons-&gt;addWidget(b_ok);
    l_principal-&gt;addLayout(l_boutons);

    setLayout(l_principal);

    // ===== connexions =====
    connect(b_annule, SIGNAL(clicked()), this, SLOT(slotAnnule()));
    connect(b_ok, SIGNAL(clicked()), this, SLOT(slotOk()));
}</code></pre><p id="r-556840" data-claire-element-id="556840">On crée une QString qui sera affichée à la fin du texte associé au champ de MdP, ce qui permet de dire, dans le cas où on a passé un hash en paramètre, que le mot de passe est facultatif.<br/> Ensuite, rien de spécial, on fait pointer <em>infos</em> sur <em>out_infos</em>, soit le paramètre qu'on a reçu, ce qui permet de retourner les infos saisies, puis on définit la GUI (en définissant comme valeur par défaut de <em>linePseudo in_pseudo</em>).</p><p id="r-556841" data-claire-element-id="556841"><strong>slotAnnule()</strong> (appelé par un clic sur &quot;Annuler&quot;)</p><pre id="r-556842" data-claire-element-id="556842"><code data-claire-semantic="cpp">void DialSetUser::slotAnnule()
{
    infos-&gt;annule=true;
    close();
}</code></pre><p id="r-556843" data-claire-element-id="556843">On définit <em>annuler</em> (booléen contenu dans <em>infos</em>, la structure de retour) à <em>true</em>, puis on ferme le dialogue.</p><p id="r-556844" data-claire-element-id="556844"><strong>slotOk()</strong> (appelé par un clic sur &quot;Ok&quot;)</p><pre id="r-556845" data-claire-element-id="556845"><code data-claire-semantic="cpp">void DialSetUser::slotOk()
{
    if(linePseudo-&gt;text().isEmpty())
    {
        QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Tous les champs doivent être remplis !&quot;);
        return;
    }

    if(linePass-&gt;text() != linePass2-&gt;text())
    {
        QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Les mots de passe ne correspondent pas.&quot;);
        return;
    }

    if(linePseudo-&gt;text().contains(';'))
    {
        QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Le pseudo contient des caractères interdits.&quot;);
        return;
    }

    QString hashpass=linePass-&gt;text();
    if(hashpass.isEmpty())
    {
        if(defhash.isEmpty())
        {
            QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Tous les champs doivent être remplis !&quot;);
            return;
        }
        else
        {
            hashpass=defhash;
        }
    }
    else
        hashpass=Fonctions::hash(hashpass);

    infos-&gt;annule=false;
    infos-&gt;pseudo=linePseudo-&gt;text();
    infos-&gt;hashmdp=hashpass;
    close();
}</code></pre><p id="r-556846" data-claire-element-id="556846">On vérifie que la ligne du pseudo n'est pas vide, que les deux mdp sont identiques, que le pseudo ne contient pas de ';' (ça ferait pas bon ménage dans auth.zla, mais pour le mot de passe c'est pas grave, vu qu'il sera haché), et que le mot de passe, si aucun par défaut n'est défini, ne soit pas vide.<br/> Puis on hache le mdp, on définit les valeurs de <em>infos</em> avec ce qu'il faut y mettre, puis on ferme le dialogue.</p><p id="r-556847" data-claire-element-id="556847"><strong>get()</strong> (appelé depuis l'extérieur)</p><pre id="r-556848" data-claire-element-id="556848"><code data-claire-semantic="cpp">User::Infos DialSetUser::get(QString pseudo, QString hash)
{
    User::Infos retour; // on crée une structure à retourner,
    DialSetUser dial(&amp;retour, pseudo, hash); // on crée un dialogue
    dial.exec();
    return retour; // puis on retourne la structure
}</code></pre><div id="r-556850" data-claire-element-id="556850" data-claire-semantic="question"><p id="r-556849" data-claire-element-id="556849">C'est quoi cette méthode bizarre qui sert à rien ?</p></div><p id="r-556851" data-claire-element-id="556851">C'est une méthode que je crée tout le temps dans mes dialogues, qui m'évite de devoir créer un objet, l'exécuter, etc.<br/> En fait, cette méthode statique se charge de créer un objet, de l'exécuter, et de retourner tout simplement les valeurs de retour. Comme ça, quand j'ai besoin d'ouvrir ce dialogue, il me suffit de faire</p><pre id="r-556852" data-claire-element-id="556852"><code data-claire-semantic="cpp">User::Infos infos=DialSetUser::get();</code></pre><p id="r-556853" data-claire-element-id="556853">Sinon, on devrait faire :</p><pre id="r-556854" data-claire-element-id="556854"><code data-claire-semantic="cpp">User::Infos infos;
DialSetUser dialogue(&amp;infos);
dialogue.exec();</code></pre><p id="r-556855" data-claire-element-id="556855">Avouez que c'est un peu plus long !</p><p id="r-556856" data-claire-element-id="556856">Eh bien voilà, on en a fini avec notre DialSetUser !<br/> Code complet :</p><p id="r-556857" data-claire-element-id="556857"></p><div id="r-556859" data-claire-element-id="556859"><pre id="r-556858" data-claire-element-id="556858"><code data-claire-semantic="cpp">#include &quot;dialsetuser.h&quot;

DialSetUser::DialSetUser(User::Infos *out_infos, QString in_pseudo, QString in_hash)
{
    QString passLabelEnd=&quot;&quot;; // permet d'afficher un message ou non en fonction des paramètres passés
    if(in_pseudo.isEmpty() &amp;&amp; in_hash.isEmpty())
        setWindowTitle(&quot;Ajouter un utilisateur&quot;);
    else
    {
        passLabelEnd=&quot; (laisser vide\npour aucun changement)&quot;;
        setWindowTitle(&quot;Modifier un utilisateur&quot;);
    }

    defhash=in_hash; // hash par défaut

    setWindowIcon(QIcon(&quot;:/icones/prog&quot;));

    infos=out_infos;

    infos-&gt;annule=true; // si fermé, considéré comme annuler

    // ===== GUI ======
    l_principal=new QVBoxLayout;
    l_form=new QFormLayout;
    linePseudo=new QLineEdit;
    linePseudo-&gt;setText(in_pseudo);
    l_form-&gt;addRow(&quot;Pseudo&quot;,linePseudo);
    linePass=new QLineEdit;
    linePass-&gt;setEchoMode(QLineEdit::Password);
    l_form-&gt;addRow(&quot;Mot de passe&quot;+passLabelEnd, linePass);
    linePass2=new QLineEdit;
    linePass2-&gt;setEchoMode(QLineEdit::Password);
    l_form-&gt;addRow(&quot;Confirmez le mot de passe&quot;, linePass2);
    l_principal-&gt;addLayout(l_form);

    l_boutons=new QHBoxLayout;
    b_annule=new QPushButton(QIcon(&quot;:/icones/cancel&quot;), &quot;Annuler&quot;);
    l_boutons-&gt;addWidget(b_annule);
    b_ok=new QPushButton(QIcon(&quot;:/icones/accept&quot;), &quot;Ok&quot;);
    b_ok-&gt;setDefault(true);
    l_boutons-&gt;addWidget(b_ok);
    l_principal-&gt;addLayout(l_boutons);

    setLayout(l_principal);

    // ===== connexions =====
    connect(b_annule, SIGNAL(clicked()), this, SLOT(slotAnnule()));
    connect(b_ok, SIGNAL(clicked()), this, SLOT(slotOk()));
}

void DialSetUser::slotAnnule()
{
    infos-&gt;annule=true;
    close();
}

void DialSetUser::slotOk()
{
    if(linePseudo-&gt;text().isEmpty())
    {
        QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Tous les champs doivent être remplis !&quot;);
        return;
    }

    if(linePass-&gt;text() != linePass2-&gt;text())
    {
        QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Les mots de passe ne correspondent pas.&quot;);
        return;
    }

    if(linePseudo-&gt;text().contains(';'))
    {
        QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Le pseudo contient des caractères interdits.&quot;);
        return;
    }

    QString hashpass=linePass-&gt;text();
    if(hashpass.isEmpty())
    {
        if(defhash.isEmpty())
        {
            QMessageBox::warning(this, &quot;Erreur&quot;, &quot;Tous les champs doivent être remplis !&quot;);
            return;
        }
        else
        {
            hashpass=defhash;
        }
    }
    else
        hashpass=Fonctions::hash(hashpass);

    infos-&gt;annule=false;
    infos-&gt;pseudo=linePseudo-&gt;text();
    infos-&gt;hashmdp=hashpass;
    close();
}

User::Infos DialSetUser::get(QString pseudo, QString hash)
{
    User::Infos retour; // on crée une structure à retourner,
    DialSetUser dial(&amp;retour, pseudo, hash); // on crée un dialogue
    dial.exec();
    return retour; // puis on retourne la structure
}</code></pre></div><h5 id="r-fonctions-9" data-claire-element-id="556887">Fonctions</h5><p id="r-556861" data-claire-element-id="556861">Cette fois, on attaque la dernière classe, très courte en plus !</p><p id="r-556862" data-claire-element-id="556862">Allez, c'est parti pour le <strong>fonctions.h</strong> :</p><pre id="r-556863" data-claire-element-id="556863"><code data-claire-semantic="cpp">#ifndef FONCTIONS_H
#define FONCTIONS_H

#include &lt;QString&gt;
#include &lt;QCryptographicHash&gt;
#include &lt;QByteArray&gt;

#define SEL_BEFORE &quot;*D9)'Jj89K&quot;
#define SEL_AFTER &quot;^,iU078Jng&quot;

class Fonctions
{
public:
    Fonctions();
    static QString hash(QString input, bool alreadyMd5=false);
};

#endif // FONCTIONS_H</code></pre><p id="r-556864" data-claire-element-id="556864">Pas bien complexe, hein ?<br/> En fait, cette classe n'est pas faite pour être instanciée, mais pour contenir des méthodes statiques.</p><div id="r-556866" data-claire-element-id="556866" data-claire-semantic="question"><p id="r-556865" data-claire-element-id="556865">Pourquoi ne pas faire simplement des fonctions, sans classe ?</p></div><p id="r-556867" data-claire-element-id="556867">J'y ai pensé. Mais ainsi, on regroupe toutes les fonctions dans un &quot;ensemble&quot; (même si il n'y en a qu'une, si le programme évolue, il peut y en avoir plus).<br/> Je fais également deux defines, pour les sels.</p><p id="r-556868" data-claire-element-id="556868"><em>fichier.cpp</em> est tellement court que je vais vous le donner d'un seul coup :</p><pre id="r-556869" data-claire-element-id="556869"><code data-claire-semantic="cpp">#include &quot;fonctions.h&quot;

Fonctions::Fonctions()
{
}

QString Fonctions::hash(QString input, bool alreadyMd5)
{
    if(!alreadyMd5)
    {
        QByteArray ba_input=QCryptographicHash::hash(input.toUtf8(), QCryptographicHash::Md5);
        input=ba_input.toHex();
    }
    QByteArray ba_hash=QCryptographicHash::hash(QCryptographicHash::hash(QString(SEL_BEFORE).toUtf8(), QCryptographicHash::Md4) +
                                                input.toUtf8() +
                                                QCryptographicHash::hash(QString(SEL_AFTER).toUtf8(), QCryptographicHash::Md4),
                                                QCryptographicHash::Sha1); // hachage d'input, avec sels.
    return ba_hash.toHex();
}</code></pre><p id="r-556870" data-claire-element-id="556870">Le constructeur est vide, puisque la classe ne sera pas instanciée.<br/> La méthode statique <em>hash()</em> contient tout ce qu'on a vu dans le chapitre sur le hachage. Elle effectue les actions suivantes :</p><ol id="r-556879" data-claire-element-id="556879"><li id="r-556872" data-claire-element-id="556872"><p id="r-556871" data-claire-element-id="556871">Si l'input n'est pas déjà haché en MD5, on le hache.</p></li><li id="r-556874" data-claire-element-id="556874"><p id="r-556873" data-claire-element-id="556873">On hache avec des sels : SEL_BEFORE est haché en MD4, puis ajouté au MdP (déjà haché en MD5), et le tout est ajouté à SEL_AFTER, lui aussi haché en MD4. Puis, le tout est haché en SHA-1.</p></li><li id="r-556876" data-claire-element-id="556876"><p id="r-556875" data-claire-element-id="556875">On convertit ça en chaîne de caractères avec <em>toHex()</em></p></li><li id="r-556878" data-claire-element-id="556878"><p id="r-556877" data-claire-element-id="556877">On retourne la chaîne obtenue</p></li></ol><p id="r-556880" data-claire-element-id="556880">Eh bien, je vous annonce que le zLogin est terminé !!!<br/> En réalisant ce TP, je l'ai pas trouvé très complexe, mais long. Si vous l'avez réussi, félicitations ! Maintenant, vous n'avez plus qu'à créer des programmes qui l'utilisent :-° .</p><p id="r-556881" data-claire-element-id="556881">J'espère que ce TP vous a plu, que vous l'avez réussi et qu'il ne vous a pas paru trop long ou dur (le premier qui pense à Mozinor a gagné :-° ).</p><p id="r-556882" data-claire-element-id="556882">Si vous l'avez réussi, c'est que vous maîtrisez maintenant le hachage, les tables de hachage et les ressources Qt !</p><p id="r-556883" data-claire-element-id="556883">Et voilà, c'est fini !</p><p id="r-556884" data-claire-element-id="556884">Mais ce tuto n'est pas fermé ! Ainsi, si je pense à une autre fonctionnalité de Qt n'utilisant pas la GUI, j'ajouterai sûrement un chapitre à ce tuto. Je ne peux pas dire à l'avance si le cours sera continué ou non, et sur combien de chapitres !</p><p id="r-556885" data-claire-element-id="556885">Sinon, j'espère que vous avez compris sans problème ce cours, et que vous l'avez trouvé bien !</p><p id="r-556886" data-claire-element-id="556886">Bonne programmation à tous !<br/> @+, Tobast.</p>
<aside class="aside-menu">
<ul class="content-menu" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui">Qt : Quelques fonctionnalités non-GUI</a>
</li>
<li class="chapter">
 
<a class="chapterLink" onmouseover="$(this).addClass('box-shadow-summary').next().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').next().removeClass('box-shadow-summary');">
<span>Partie 1</span>
Fonctionnalités non-GUI
</a>
<a class="chapterOpen" href="#" onmouseover="$(this).addClass('box-shadow-summary').prev().addClass('box-shadow-summary');" onmouseout="$(this).removeClass('box-shadow-summary').prev().removeClass('box-shadow-summary');">
<span>+</span>
</a>
 
<ul class="subchapters">
<li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-les-ressources-qt">Utiliser les ressources Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-140">
Présentation
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/creer-le-fichier-de-ressources-1">
Créer le fichier de ressources
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/utiliser-le-fichier-ressource">
Utiliser le fichier ressource
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt-1">Hacher avec Qt</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-19">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/hacher-avec-qt">
Hacher avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/les-tables-de-hachage-2">Les tables de hachage</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/theorie-20">
Théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/avec-qt">
Avec Qt
</a>
</li>
</ul> </li> <li class="subchapter">
<div>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/tp-le-zlogin">TP : le zLogin</a>
<a class="subchapterOpen" href="#">
<span>+</span>
</a>
</div>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-du-sujet-1">
Présentation du sujet
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/correction-196">
Correction
</a>
</li>
</ul>
</li>
</ul>
</li>
</li>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/qt-quelques-fonctionnalites-non-gui/presentation-du-sujet-1">
<span class="arrow"></span>
<span class="next">Présentation du sujet</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/qt-quelques-fonctionnalites-non-gui.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 07:14:21 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/qt-quelques-fonctionnalites-non-gui.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:18:25 GMT -->
</html>
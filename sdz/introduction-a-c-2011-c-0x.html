<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/introduction-a-c-2011-c-0x.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 08:29:34 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/introduction-a-c-2011-c-0x.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:31:33 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Introduction à C++ 2011 (C++0x)</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/introduction-a-c-2011-c-0x.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Introduction à C++ 2011 (C++0x)</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#IntroductionC2011C0x">Introduction à C++ 2011 (C++0x)</a><br/><a href="#PourquoiunenouvellervisiondulangageC">Pourquoi une nouvelle révision du langage C++ ?</a><br/><a href="#PrparationducompilateurpourutiliserC2011">Préparation du compilateur pour utiliser C++ 2011</a><br/><a href="#Lesnumrationsfortementtypes">Les énumérations fortement typées</a><br/><a href="#Lebugdeschevrons">Le « bug » des chevrons</a><br/><a href="#Leslistesdinitialisateurs">Les listes d’initialisateurs</a><br/><a href="#Lemot-clauto">Le mot-clé auto</a><br/><a href="#Labouclebasesurunintervalle">La boucle basée sur un intervalle</a><br/><a href="#Initialisationdunpointeur">Initialisation d’un pointeur</a><br/><a href="#Lesfonctionsanonymesetlesfermetures">Les fonctions anonymes et les fermetures</a><br/><a href="#Lestableauxtaillefixe">Les tableaux à taille fixe</a><br/><a href="#Unnouveautypedeconteneurletuple">Un nouveau type de conteneur : le tuple</a><br/><a href="#Gestiondutemps">Gestion du temps</a><br/><a href="#Lesinitialisateursdattributs">Les initialisateurs d’attributs</a><br/></div>
<a name="IntroductionC2011C0x"></a><h2>Introduction à C++ 2011 (C++0x)</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
<span class="next">Pourquoi une nouvelle révision du langage C++ ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-535675" data-claire-element-id="535675">Bonjour à tous !<br/> Vous avez entendu parler de la nouvelle norme C++, ces derniers temps ?<br/> C++0x et C++1x vous disent-ils quelque chose ?<br/> Vous voulez en apprendre plus sur cette norme ?<br/> Alors, vous êtes au bon endroit !</p><p id="r-535676" data-claire-element-id="535676">Ce tutoriel a pour but de vous montrer quelques nouveautés de la norme C++ 2011 qui sont déjà utilisables par les compilateurs actuels.</p>
</div><a name="PourquoiunenouvellervisiondulangageC"></a><h2>Pourquoi une nouvelle révision du langage C++ ?</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
<span class="next">Préparation du compilateur pour utiliser C++ 2011</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-535677" data-claire-element-id="535677">La norme actuelle du C++ date de 1998, puis a été mise à jour en 2003.<br/> Nous pouvons nous demander pourquoi faire une nouvelle norme maintenant.</p><p id="r-535678" data-claire-element-id="535678">Pour répondre à la question, je cite <a href="http://fr.wikipedia.org/wiki/C++1x">Wikipédia</a> :</p><p id="r-535679" data-claire-element-id="535679"><cite>Citation : Wikipédia</cite></p><blockquote id="r-535681" data-claire-element-id="535681"><p id="r-535680" data-claire-element-id="535680">Un langage de programmation comme le C++ suit une évolution qui permettra aux programmeurs de coder plus rapidement, de façon plus élégante et permettant de faire du code maintenable.</p></blockquote><p id="r-535682" data-claire-element-id="535682">Certaines nouveautés permettent en effet d’écrire du code C++ plus simple, comme vous le verrez dans quelques instants.</p><p id="r-535683" data-claire-element-id="535683">En outre, le matériel informatique évoluant constamment, en particulier les processeurs, les besoins sont maintenant différents en matière de programmation.<br/> Ayant aujourd’hui plusieurs cœurs, les processeurs peuvent exécuter plusieurs instructions en même temps.<br/> Des classes permettant l’utilisation de la programmation concurrente sont ainsi apparues dans cette norme du C++.</p><div id="r-535685" data-claire-element-id="535685" data-claire-semantic="question"><p id="r-535684" data-claire-element-id="535684">Est-ce que la nouvelle norme du C++ est rétro-compatible avec l’ancienne ?</p></div><p id="r-535686" data-claire-element-id="535686">Presque.<br/> La plupart du code déjà écrit n’aura donc pas besoin d’être modifié.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
<span class="next">Préparation du compilateur pour utiliser C++ 2011</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="PrparationducompilateurpourutiliserC2011"></a><h2>Préparation du compilateur pour utiliser C++ 2011</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
<span class="arrow"></span>
<span class="next">Pourquoi une nouvelle révision du langage C++ ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
<span class="next">Les énumérations fortement typées</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<aside id="r-535690" data-claire-element-id="535690" data-claire-semantic="error"><p id="r-535688" data-claire-element-id="535688">Attention : tout ceci est expérimental et ne devrait pas être utilisé en production.<br/> Utilisez ces nouveautés à vos risques et périls.</p><p id="r-535689" data-claire-element-id="535689">De plus, les compilateurs actuels n’implémentent pas toutes les nouveautés de la norme C++0x.<br/> Les codes de ce tutoriel ont été testés avec g++ 4.6 sous GNU/Linux.</p></aside><p id="r-535691" data-claire-element-id="535691">Je vais vous montrer comment configurer g++ 4.6 sur Ubuntu pour utiliser les nouveaux standards du C++.</p><h2 id="r-installation-83" data-claire-element-id="535701">Installation</h2><p id="r-535692" data-claire-element-id="535692">Premièrement, <a href="http://doc.ubuntu-fr.org/ppa#ajout_d_un_ppa_a_vos_sources_logicielles">ajoutez ce ppa</a> à vos sources :</p><pre id="r-535693" data-claire-element-id="535693"><code data-claire-semantic="console">deb http://ppa.launchpad.net/ubuntu-toolchain-r/test/ubuntu YOUR_UBUNTU_VERSION_HERE main</code></pre><p id="r-535694" data-claire-element-id="535694">en modifiant YOUR_UBUNTU_VERSION HERE par votre version d’Ubuntu (natty, maverick, lucid ou karmic).</p><p id="r-535695" data-claire-element-id="535695">Vous pouvez maintenant mettre à jour le compilateur g++ :</p><pre id="r-535696" data-claire-element-id="535696"><code data-claire-semantic="console">sudo apt-get install g++</code></pre><p id="r-535697" data-claire-element-id="535697">Après l’installation, tapez la commande suivante pour vérifier que vous avez au moins la version 4.6 de g++ :</p><pre id="r-535698" data-claire-element-id="535698"><code data-claire-semantic="console">g++ -v</code></pre><p id="r-535699" data-claire-element-id="535699">La dernière ligne de la sortie devrait vous le confirmer :</p><pre id="r-535700" data-claire-element-id="535700"><code data-claire-semantic="console">gcc version 4.6.1 20110409 (prerelease) (Ubuntu 4.6.0-3~ppa1)</code></pre><h2 id="r-configuration-de-la-compilation" data-claire-element-id="535717">Configuration de la compilation</h2><p id="r-535702" data-claire-element-id="535702">Maintenant, vous allez essayer de compiler ce programme :</p><pre id="r-535703" data-claire-element-id="535703"><code data-claire-semantic="cpp">#include &lt;iostream&gt;

int main() {
    int tableau[5] = {1, 2, 3, 4, 5};
    for(int &amp;x : tableau) {
        std::cout &lt;&lt; x &lt;&lt; std::endl;
    }
    return 0;
}</code></pre><p id="r-535704" data-claire-element-id="535704">en utilisant la ligne de commande habituelle :</p><pre id="r-535705" data-claire-element-id="535705"><code data-claire-semantic="console">g++ main.cpp -o BoucleFor</code></pre><div id="r-535707" data-claire-element-id="535707" data-claire-semantic="question"><p id="r-535706" data-claire-element-id="535706">J’ai la bonne version de g++, mais j’obtiens tout de même une erreur du compilateur.<br/> Que dois-je faire ?</p></div><p id="r-535708" data-claire-element-id="535708">Vous devez simplement lui demander poliment de compiler en utilisant la nouvelle norme.<br/> Sinon, vous pouvez avoir une erreur de ce type :</p><pre id="r-535709" data-claire-element-id="535709"><code data-claire-semantic="console">main.cpp: In function ‘int main()’:
main.cpp:5:18: error: range-based-for loops are not allowed in C++98 mode</code></pre><p id="r-535710" data-claire-element-id="535710">Parfois, vous pouvez avoir un avertissement du genre :</p><pre id="r-535711" data-claire-element-id="535711"><code data-claire-semantic="console">main.cpp:3:1: warning: scoped enums only available with -std=c++0x or -std=gnu++0x [enabled by default]</code></pre><p id="r-535712" data-claire-element-id="535712">qui vous indique un peu mieux que faire.</p><p id="r-535713" data-claire-element-id="535713">Lancez donc la dernière commande avec un nouvel argument :</p><pre id="r-535714" data-claire-element-id="535714"><code data-claire-semantic="console">g++ -std=c++0x main.cpp -o BoucleFor</code></pre><p id="r-535715" data-claire-element-id="535715">Et voilà, ça compile !</p><p id="r-535716" data-claire-element-id="535716">Le précédent code source vous met-il l’eau à la bouche ?<br/> Si c’est la cas, alors continuez votre lecture, vous n’avez pas terminé de découvrir de nouvelles façons d’écrire du code plus simplement qu’avant !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
<span class="arrow"></span>
<span class="next">Pourquoi une nouvelle révision du langage C++ ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
<span class="next">Les énumérations fortement typées</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesnumrationsfortementtypes"></a><h2>Les énumérations fortement typées</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
<span class="arrow"></span>
<span class="next">Préparation du compilateur pour utiliser C++ 2011</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
<span class="next">Le « bug » des chevrons</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-535719" data-claire-element-id="535719">Pour commencer, voyons quelque chose de facile : les énumérations fortement typées.</p><h2 id="r-les-enumerations-6" data-claire-element-id="535728">Les énumérations</h2><p id="r-535720" data-claire-element-id="535720">Vous connaissez déjà les énumérations, que l’on peut créer comme ceci :</p><pre id="r-535721" data-claire-element-id="535721"><code data-claire-semantic="cpp">enum Direction { HAUT, DROITE, BAS, GAUCHE };</code></pre><p id="r-535722" data-claire-element-id="535722">On peut ensuite créer une variable utilisant cette énumération :</p><pre id="r-535723" data-claire-element-id="535723"><code data-claire-semantic="cpp">Direction direction = HAUT;</code></pre><p id="r-535724" data-claire-element-id="535724">Puis, nous pouvons afficher cette variable :</p><pre id="r-535725" data-claire-element-id="535725"><code data-claire-semantic="cpp">std::cout &lt;&lt; direction &lt;&lt; std::endl;</code></pre><p id="r-535726" data-claire-element-id="535726">Cela fonctionne, car il y a une conversion implicite vers un entier.<br/> C’est comme si nous avions fait ceci :</p><pre id="r-535727" data-claire-element-id="535727"><code data-claire-semantic="cpp">std::cout &lt;&lt; static_cast&lt;int&gt;(direction) &lt;&lt; std::endl;</code></pre><h2 id="r-les-enumerations-fortement-typees" data-claire-element-id="535744">Les énumérations fortement typées</h2><p id="r-535729" data-claire-element-id="535729">Passons aux nouveautés.<br/> Les énumérations fortement typées se créent en ajoutant le mot-clé <code data-claire-semantic="cpp">class</code> après <code data-claire-semantic="cpp">enum</code>. :</p><pre id="r-535730" data-claire-element-id="535730"><code data-claire-semantic="cpp">enum class Direction { Haut, Droite, Bas, Gauche };</code></pre><p id="r-535731" data-claire-element-id="535731">Par la suite, pour l’utiliser, il faut utiliser le nom de l’énumération, suivi par l’opérateur de résolution de portée et du nom de la valeur que l’on souhaite utilisée :</p><pre id="r-535732" data-claire-element-id="535732"><code data-claire-semantic="cpp">Direction direction = Direction::Haut;</code></pre><p id="r-535733" data-claire-element-id="535733">C’est la première différence avec les énumérations que vous connaissez.</p><p id="r-535734" data-claire-element-id="535734">La seconde, c’est qu’il n’y a pas de conversion implicite vers un entier.<br/> Ainsi, le code suivant ne compilera pas :</p><pre id="r-535735" data-claire-element-id="535735"><code data-claire-semantic="cpp">std::cout &lt;&lt; direction &lt;&lt; std::endl;</code></pre><p id="r-535736" data-claire-element-id="535736">Pour qu’il compile, il faut <strong>explicitement</strong> convertir la variable en entier :</p><pre id="r-535737" data-claire-element-id="535737"><code data-claire-semantic="cpp">std::cout &lt;&lt; static_cast&lt;int&gt;(direction) &lt;&lt; std::endl;</code></pre><div id="r-535739" data-claire-element-id="535739" data-claire-semantic="question"><p id="r-535738" data-claire-element-id="535738">Mais, à quoi ça sert d’utiliser ces énumérations ?<br/> C’était bien plus simple avant, non ?</p></div><p id="r-535740" data-claire-element-id="535740">Ces énumérations n’ont pas été créées pour le simple plaisir de compliquer les choses.<br/> Elles permettent d’assurer une certaine sécurité en codant.</p><p id="r-535741" data-claire-element-id="535741">En effet, vous ne voulez sûrement pas faire des opérations mathématiques avec votre énumération.<br/> Le code suivant n’aurait aucun sens :</p><pre id="r-535742" data-claire-element-id="535742"><code data-claire-semantic="cpp">int nombre = 5 + Direction::Droite;</code></pre><p id="r-535743" data-claire-element-id="535743">Ce code provoque une erreur de compilation et c’est bien, car ça n’a pas de sens d’ajouter une direction à un nombre.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
<span class="arrow"></span>
<span class="next">Préparation du compilateur pour utiliser C++ 2011</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
<span class="next">Le « bug » des chevrons</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lebugdeschevrons"></a><h2>Le « bug » des chevrons</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
<span class="arrow"></span>
<span class="next">Les énumérations fortement typées</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
<span class="next">Les listes d’initialisateurs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-535746" data-claire-element-id="535746">Vous souvenez-vous de la façon de créer un vecteur de vecteurs ?<br/> Il y a un petit point à ne pas oublier ; il faut mettre un espace entre les deux derniers chevrons :</p><pre id="r-535747" data-claire-element-id="535747"><code data-claire-semantic="cpp">std::vector&lt;std::vector&lt;int&gt; &gt; nombres;</code></pre><p id="r-535748" data-claire-element-id="535748">Sinon, &gt;&gt; pourrait être confondu avec l’opérateur de flux.</p><p id="r-535749" data-claire-element-id="535749">Eh bien, savez-vous quoi ?<br/> Il est maintenant possible d’écrire ceci en C++0x :</p><pre id="r-535750" data-claire-element-id="535750"><code data-claire-semantic="cpp">std::vector&lt;std::vector&lt;int&gt;&gt; nombres;</code></pre><p id="r-535751" data-claire-element-id="535751">Il n’y a plus d’erreur de compilation.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
<span class="arrow"></span>
<span class="next">Les énumérations fortement typées</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
<span class="next">Les listes d’initialisateurs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Leslistesdinitialisateurs"></a><h2>Les listes d’initialisateurs</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
<span class="arrow"></span>
<span class="next">Le « bug » des chevrons</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
<span class="next">Le mot-clé auto</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-cote-utilisateur" data-claire-element-id="535763">Côté utilisateur</h2><p id="r-535753" data-claire-element-id="535753">Pour créer un vecteur avec différentes valeurs initiales, il faut écrire plusieurs lignes de code :</p><pre id="r-535754" data-claire-element-id="535754"><code data-claire-semantic="cpp">std::vector&lt;int&gt; nombres;
nombres.push_back(1);
nombres.push_back(2);
nombres.push_back(3);
nombres.push_back(4);
nombres.push_back(5);</code></pre><p id="r-535755" data-claire-element-id="535755">Il est maintenant possible de faire beaucoup plus court avec une liste d’initialisateurs :</p><pre id="r-535756" data-claire-element-id="535756"><code data-claire-semantic="cpp">std::vector&lt;int&gt; nombres = { 1, 2, 3, 4, 5 };</code></pre><p id="r-535757" data-claire-element-id="535757">C’est comme si on initialisait un tableau normal :</p><pre id="r-535758" data-claire-element-id="535758"><code data-claire-semantic="cpp">int nombres2[] = { 1, 2, 3, 4, 5 };</code></pre><p id="r-535759" data-claire-element-id="535759">sauf qu’on peut le faire avec les conteneurs de la STL.</p><p id="r-535760" data-claire-element-id="535760">Voici un code complet présentant comment utiliser une liste d’initialisateurs avec un <code data-claire-semantic="cpp">std::map</code> :</p><pre id="r-535761" data-claire-element-id="535761"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;

int main() {
    std::map&lt;int, std::string&gt; nombres = { { 1, &quot;un&quot; }, { 2, &quot;deux&quot; }, { 3, &quot;trois&quot; } };
    std::cout &lt;&lt; nombres[1] &lt;&lt; std::endl;
}</code></pre><p id="r-535762" data-claire-element-id="535762">Simple, non ?</p><h2 id="r-cote-createur" data-claire-element-id="535776">Côté créateur</h2><p id="r-535764" data-claire-element-id="535764">Vous avez utilisé les listes d’initialisateurs, mais aimeriez-vous créer des fonctions qui les utilisent ?<br/> C’est ce que nous allons voir ici.</p><p id="r-535765" data-claire-element-id="535765">Nous allons créer une fonction très banale qui ne fait qu’afficher les éléments passés à la fonction à l’aide de la liste d’initialisateurs.</p><p id="r-535766" data-claire-element-id="535766">Notre fonction <code data-claire-semantic="cpp">main()</code> sera :</p><pre id="r-535767" data-claire-element-id="535767"><code data-claire-semantic="cpp">int main() {
    afficherListe({ 1, 2, 3, 4, 5 });
    return 0;
}</code></pre><p id="r-535768" data-claire-element-id="535768">Nous souhaitons implémenter la fonction <code data-claire-semantic="cpp">afficherListe()</code> qui affichera les éléments envoyés.</p><p id="r-535769" data-claire-element-id="535769">La fonction aura l’allure suivante :</p><pre id="r-535770" data-claire-element-id="535770"><code data-claire-semantic="cpp">void afficherListe(std::initializer_list&lt;int&gt; liste) {
    //Affichage de la liste.
}</code></pre><p id="r-535771" data-claire-element-id="535771">Étant donné que nous avons indiqué <code data-claire-semantic="cpp">int</code> entre les chevrons, nous acceptons seulement les entiers dans la liste.</p><p id="r-535772" data-claire-element-id="535772">Le code de la fonction est donc :</p><pre id="r-535773" data-claire-element-id="535773"><code data-claire-semantic="cpp">void afficherListe(std::initializer_list&lt;int&gt; liste) {
    for(std::initializer_list&lt;int&gt;::iterator i(liste.begin()) ; i != liste.end() ; ++i) {
        std::cout &lt;&lt; *i &lt;&lt; std::endl;
    }
}</code></pre><p id="r-535774" data-claire-element-id="535774">N’oubliez pas d’inclure l’entête :</p><pre id="r-535775" data-claire-element-id="535775"><code data-claire-semantic="cpp">#include &lt;initializer_list&gt;</code></pre>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
<span class="arrow"></span>
<span class="next">Le « bug » des chevrons</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
<span class="next">Le mot-clé auto</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lemot-clauto"></a><h2>Le mot-clé auto</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
<span class="arrow"></span>
<span class="next">Les listes d’initialisateurs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
<span class="next">La boucle basée sur un intervalle</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-535778" data-claire-element-id="535778">Le mot-clé <code data-claire-semantic="cpp">auto</code> est un mot-clé utilisable en C++0x qui est différent du mot-clé <code data-claire-semantic="cpp">auto</code> qui était utilisé avant. Il est possible de le mettre à la place du type de telle sorte que ce type est automagiquement déterminé à la compilation en fonction du type retourné par l’objet utilisé pour l’initialisation. :magicien: <br/> On parle ici d’<a href="http://fr.wikipedia.org/wiki/Inférence_de_types">inférence de types</a>.</p><p id="r-535779" data-claire-element-id="535779">Donc, il est possible d’écrire le code suivant :</p><pre id="r-535780" data-claire-element-id="535780"><code data-claire-semantic="cpp">auto nombre = 5;</code></pre><p id="r-535781" data-claire-element-id="535781">La variable nombre sera de type entier (<code data-claire-semantic="cpp">int</code>).<br/> Mais, je vous interdis de faire cela ! :colere: <br/> Si vous initialisez toutes vos variables avec le mot-clé <code data-claire-semantic="cpp">auto</code>, votre code va vite devenir illisible.</p><p id="r-535782" data-claire-element-id="535782">Vous devez utiliser ce mot-clé le moins possible.</p><div id="r-535784" data-claire-element-id="535784" data-claire-semantic="question"><p id="r-535783" data-claire-element-id="535783">As-tu des exemples d’utilisation ?</p></div><p id="r-535785" data-claire-element-id="535785">Oui, en voilà un :</p><pre id="r-535786" data-claire-element-id="535786"><code data-claire-semantic="cpp">for(auto i(nombres.begin()) ; i != nombres.end() ; ++i) {
    std::cout &lt;&lt; *i &lt;&lt; std::endl;
}</code></pre><p id="r-535787" data-claire-element-id="535787">Au lieu de cela :</p><pre id="r-535788" data-claire-element-id="535788"><code data-claire-semantic="cpp">for(std::vector&lt;int&gt;::iterator i(nombres.begin()) ; i != nombres.end() ; ++i) {
    std::cout &lt;&lt; *i &lt;&lt; std::endl;
}</code></pre><p id="r-535789" data-claire-element-id="535789">Mais, encore là, c’est limite.</p><p id="r-535790" data-claire-element-id="535790">Si vous utilisez beaucoup de fois un même itérateur, le mieux est de créer un <code data-claire-semantic="cpp">typedef</code> :</p><pre id="r-535791" data-claire-element-id="535791"><code data-claire-semantic="cpp">typedef std::vector&lt;int&gt;::iterator iter_entier;
for(iter_entier i(nombres.begin()) ; i != nombres.end() ; ++i) {
    std::cout &lt;&lt; *i &lt;&lt; std::endl;
}</code></pre><p id="r-535792" data-claire-element-id="535792">Vous pouvez également utiliser ce mot-clé lorsqu’une même fonction peut retourner différents types de données.</p><aside id="r-535800" data-claire-element-id="535800" data-claire-semantic="error"><p id="r-535793" data-claire-element-id="535793">Vous devez faire attention à deux points en particulier :</p><ol id="r-535799" data-claire-element-id="535799"><li id="r-535795" data-claire-element-id="535795"><p id="r-535794" data-claire-element-id="535794">Le mot-clé <code data-claire-semantic="cpp">auto</code> n’est pas comme un type qui change au cours de l’exécution du programme. Si j’assigne un entier à une variable dont le mot-clé <code data-claire-semantic="cpp">auto</code> est utilisé à l’initialisation, cette variable sera et restera un entier.</p></li><li id="r-535798" data-claire-element-id="535798"><p id="r-535796" data-claire-element-id="535796">Vous devez obligatoirement <em>initialiser</em> une variable déclarée avec le mot-clé <code data-claire-semantic="cpp">auto</code> à la déclaration. Autrement dit, il est impossible de faire :</p><pre id="r-535797" data-claire-element-id="535797"><code data-claire-semantic="cpp">auto variable;</code></pre></li></ol></aside><div id="r-535802" data-claire-element-id="535802" data-claire-semantic="question"><p id="r-535801" data-claire-element-id="535801">Si je déclare une variable avec le mot-clé <code data-claire-semantic="cpp">auto</code>, puis-je donner le même type à une autre variable ?</p></div><p id="r-535803" data-claire-element-id="535803">Oui, avec le mot-clé <code data-claire-semantic="cpp">decltype</code> :<br/> Ce mot-clé détermine le type d’une expression.</p><pre id="r-535804" data-claire-element-id="535804"><code data-claire-semantic="cpp">auto variable = 5;
decltype(variable) autreVariable;</code></pre><p id="r-535805" data-claire-element-id="535805">Ainsi, nous sommes sûr que <code data-claire-semantic="cpp">autreVariable</code> aura le même type (<code data-claire-semantic="cpp">int</code>) que <code data-claire-semantic="cpp">variable</code>.</p><p id="r-535806" data-claire-element-id="535806">L’inférence de type est très utile lorsque nous utilisons la programmation générique.<br/> Considérez ce programme :</p><pre id="r-535807" data-claire-element-id="535807"><code data-claire-semantic="cpp">#include &lt;iostream&gt;

template &lt;typename T&gt;
T maximum(const T&amp; a, const T&amp; b) {
    if(a &gt; b) {
        return a;
    }
    else {
        return b;
    }
}

template &lt;typename T&gt;
T minimum(const T&amp; a, const T&amp; b) {
    if(a &lt; b) {
        return a;
    }
    else {
        return b;
    }
}

int main() {
    int a(10), b(20);
    auto plusGrand = maximum(a, b);
    decltype(plusGrand) plusPetit = minimum(a, b);
    std::cout &lt;&lt; &quot;Le plus grand est : &quot; &lt;&lt; plusGrand &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Le plus petit est : &quot; &lt;&lt; plusPetit &lt;&lt; std::endl;
    return 0;
}</code></pre><p id="r-535808" data-claire-element-id="535808">Ce code détermine, grâce à des fonctions génériques, le plus grand et le plus petit nombres.</p><p id="r-535809" data-claire-element-id="535809">Ce qui est intéressant, c’est que nous n’avons besoin que de modifier la première ligne de la fonction <code data-claire-semantic="cpp">main()</code> si nous voulons essayer ce code avec un autre type.<br/> Remplacez-la par celle-ci et tout fonctionne :</p><pre id="r-535810" data-claire-element-id="535810"><code data-claire-semantic="cpp">double a(10.5), b(20.5);</code></pre><p id="r-535811" data-claire-element-id="535811">De plus, les mots-clés <code data-claire-semantic="cpp">auto</code> et <code data-claire-semantic="cpp">decltype</code> sont obligatoires dans certains cas utilisant la programmation générique.</p><p id="r-535812" data-claire-element-id="535812">Considérons l’exemple suivant (assez tordu, je dois l’admettre :honte: ) :<br/> Vous avez un programme de gestion des notes obtenues à l’école.<br/> Les examens comportent dix questions (chacune vaut 10 points).<br/> Votre programme stocke les notes de deux manières :</p><ul id="r-535817" data-claire-element-id="535817"><li id="r-535814" data-claire-element-id="535814"><p id="r-535813" data-claire-element-id="535813">Un nombre entier sur 100 (le pourcentage) ;</p></li><li id="r-535816" data-claire-element-id="535816"><p id="r-535815" data-claire-element-id="535815">Un nombre réel sur 1 (le pourcentage divisé par 100).</p></li></ul><p id="r-535818" data-claire-element-id="535818">Vous avez créé une fonction <code data-claire-semantic="cpp">ajouterDixPourcents()</code> surchargée pour les entiers et les réels :</p><pre id="r-535819" data-claire-element-id="535819"><code data-claire-semantic="cpp">int ajouterDixPourcents(int nombre) {
    if(nombre + 10 &lt;= 100) {
        return nombre + 10;
    }
    else {
        return 100;
    }
}

float ajouterDixPourcents(float nombre) {
    if(nombre + 0.1 &lt;= 1) {
        return nombre + 0.1;
    }
    else {
        return 1;
    }
}</code></pre><p id="r-535820" data-claire-element-id="535820">Pour une raison inconnue :lol: , vous créez également une fonction générique <code data-claire-semantic="cpp">ajouter()</code> qui appellera la fonction <code data-claire-semantic="cpp">ajouterDixPourcents()</code>.<br/> Cette fonction doit retourner le même type que celui retourné par cette dernière.<br/> Mais, comment faire pour déterminer ce type ?</p><div id="r-535822" data-claire-element-id="535822" data-claire-semantic="question"><p id="r-535821" data-claire-element-id="535821">Nous pourrions utiliser le mot-clé <code data-claire-semantic="cpp">auto</code>, non ?</p></div><p id="r-535823" data-claire-element-id="535823">Impossible, car il se base sur le type de l’objet qu’on lui affecte. Le compilateur ne saura pas sur quel objet se baser.</p><div id="r-535825" data-claire-element-id="535825" data-claire-semantic="question"><p id="r-535824" data-claire-element-id="535824">Avec <code data-claire-semantic="cpp">decltype()</code>, alors ?</p></div><p id="r-535826" data-claire-element-id="535826">Encore une fois, c’est impossible.<br/> En effet, quelle expression lui passerions-nous pour déterminer le type de retour de la fonction <code data-claire-semantic="cpp">ajouter()</code> ?</p><p id="r-535827" data-claire-element-id="535827">La solution est d’utiliser les deux mots-clés en utilisant une syntaxe alternative pour le prototype de la fonction ! (Vous ne pouviez pas vraiment le deviner. :-° )</p><p id="r-535828" data-claire-element-id="535828">Voilà enfin la fonction <code data-claire-semantic="cpp">ajouter()</code> :</p><pre id="r-535829" data-claire-element-id="535829"><code data-claire-semantic="cpp">template &lt;typename T&gt; auto ajouter(T nombre) -&gt; decltype(ajouterDixPourcents(nombre)) {
    return ajouterDixPourcents(nombre);
}</code></pre><aside id="r-535831" data-claire-element-id="535831" data-claire-semantic="warning"><p id="r-535830" data-claire-element-id="535830">Il est impossible d’utiliser <code data-claire-semantic="cpp">decltype(ajouterDixPourcents(nombre))</code> à la place du type de retour, car <code data-claire-semantic="cpp">nombre</code> n’a pas encore été parsé par le compilateur.</p></aside><p id="r-535832" data-claire-element-id="535832">Vous pouvez maintenant utiliser votre fonction générique <code data-claire-semantic="cpp">ajouter()</code> dans votre code :</p><pre id="r-535833" data-claire-element-id="535833"><code data-claire-semantic="cpp">int main() {
    int pourcentageEntier(42);
    float pourcentageFlottant = pourcentageEntier / 100.f;
    std::cout &lt;&lt; pourcentageFlottant &lt;&lt; &quot; = &quot; &lt;&lt; pourcentageEntier &lt;&lt; &quot;%&quot; &lt;&lt; std::endl;
    
    pourcentageEntier = ajouter(pourcentageEntier);
    pourcentageFlottant = ajouter(pourcentageFlottant);
    std::cout &lt;&lt; pourcentageFlottant &lt;&lt; &quot; = &quot; &lt;&lt; pourcentageEntier &lt;&lt; &quot;%&quot; &lt;&lt; std::endl;
}</code></pre><p id="r-535834" data-claire-element-id="535834">Étant donnée que nous utilisons <code data-claire-semantic="cpp">auto</code> et <code data-claire-semantic="cpp">decltype</code> dans une fonction dont le prototype est plutôt long, je vous donne un exemple plus simple pour comprendre :</p><pre id="r-535835" data-claire-element-id="535835"><code data-claire-semantic="cpp">auto cinq() -&gt; int {
    return 5;
}</code></pre><p id="r-535836" data-claire-element-id="535836">Nous utilisons le mot-clé <code data-claire-semantic="cpp">auto</code> à la place d’indiquer un type de retour.<br/> Il faut donc préciser le type de retour après la parenthèse fermante sous la forme suivante :</p><pre id="r-535837" data-claire-element-id="535837"><code data-claire-semantic="cpp">-&gt; type</code></pre><p id="r-535838" data-claire-element-id="535838">type peut être un type prédéfini comme <code data-claire-semantic="cpp">int</code>, mais la plupart du temps, nous utiliserons <code data-claire-semantic="cpp">decltype(expression)</code>.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
<span class="arrow"></span>
<span class="next">Les listes d’initialisateurs</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
<span class="next">La boucle basée sur un intervalle</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Labouclebasesurunintervalle"></a><h2>La boucle basée sur un intervalle</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
<span class="arrow"></span>
<span class="next">Le mot-clé auto</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
<span class="next">Initialisation d’un pointeur</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-535840" data-claire-element-id="535840">Vous vous rappelez du code montré dans la deuxième partie de ce tutoriel ?<br/> Cette boucle ressemblant au <code data-claire-semantic="vala">foreach</code> de nombreux autres langages ?</p><p id="r-535841" data-claire-element-id="535841">Eh bien, il est maintenant possible d’utiliser une telle boucle en C++ !</p><p id="r-535842" data-claire-element-id="535842">Alors qu’autrefois nous étions obligés d’utiliser l’algorithme <code data-claire-semantic="cpp">for_each</code> :</p><pre id="r-535843" data-claire-element-id="535843"><code data-claire-semantic="cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void afficherElement(int element) {
    cout &lt;&lt; element &lt;&lt; endl;
}

int main() {
    vector&lt;int&gt; nombres = { 1, 2, 3, 4, 5 };
    for_each(nombres.begin(), nombres.end(), afficherElement);
    
    return 0;
}</code></pre><p id="r-535844" data-claire-element-id="535844">Nous pouvons maintenant utiliser la syntaxe beaucoup plus simple de la boucle <code data-claire-semantic="cpp">for</code> :</p><pre id="r-535845" data-claire-element-id="535845"><code data-claire-semantic="cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
    vector&lt;int&gt; nombres = { 1, 2, 3, 4, 5 };
    for(int &amp;element : nombres) {
        cout &lt;&lt; element &lt;&lt; endl;
    }
    
    return 0;
}</code></pre><div id="r-535847" data-claire-element-id="535847" data-claire-semantic="question"><p id="r-535846" data-claire-element-id="535846">Comment cela fonctionne-t-il ?</p></div><p id="r-535848" data-claire-element-id="535848">Prenons la ligne du <code data-claire-semantic="cpp">for</code> :</p><pre id="r-535849" data-claire-element-id="535849"><code data-claire-semantic="cpp">for(int &amp;element : nombres)</code></pre><p id="r-535850" data-claire-element-id="535850">Sur cette ligne, nous trouvons d’abord la déclaration de la variable qui prendra chacune des valeurs du vecteur situé après les deux-points (:).<br/> Donc, au premier tour de boucle, <code data-claire-semantic="cpp">element</code> vaudra 1.<br/> Au deuxième tour, <code data-claire-semantic="cpp">element</code> aura pour valeur 2.<br/> Et ainsi de suite.</p><p id="r-535851" data-claire-element-id="535851">Étant donné que nous utilisons une référence sur l’élément, nous pouvons le modifier sans problème :</p><pre id="r-535852" data-claire-element-id="535852"><code data-claire-semantic="cpp">for(int &amp;element : nombres) {
    ++element;
}</code></pre><p id="r-535853" data-claire-element-id="535853">Pour parcourir un std::map, le principe est le même :</p><pre id="r-535854" data-claire-element-id="535854"><code data-claire-semantic="cpp">map&lt;int, string&gt; nombres = { { 1, &quot;un&quot; }, { 2, &quot;deux&quot; }, { 3, &quot;trois&quot; } };
for(auto i : nombres) {
    cout &lt;&lt; i.first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; i.second &lt;&lt; endl;
}</code></pre>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
<span class="arrow"></span>
<span class="next">Le mot-clé auto</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
<span class="next">Initialisation d’un pointeur</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Initialisationdunpointeur"></a><h2>Initialisation d’un pointeur</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
<span class="arrow"></span>
<span class="next">La boucle basée sur un intervalle</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
<span class="next">Les fonctions anonymes et les fermetures</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-535856" data-claire-element-id="535856">En C, vous aviez l’habitude d’initialiser un pointeur avec la macro <code data-claire-semantic="c">NULL</code> :</p><pre id="r-535857" data-claire-element-id="535857"><code data-claire-semantic="c">int *pointeur = NULL;</code></pre><p id="r-535858" data-claire-element-id="535858">Mais, nous évitons ceci en C++, car nous détestons utiliser des macros.</p><p id="r-535859" data-claire-element-id="535859">Vous avez donc pris l’habitude d’initialiser vos pointeurs à 0 :</p><pre id="r-535860" data-claire-element-id="535860"><code data-claire-semantic="cpp">int *pointeur(0);</code></pre><p id="r-535861" data-claire-element-id="535861">Ça fonctionne toujours, mais sachez que vous pouvez maintenant initialiser vos pointeurs avec le nouveau mot-clé <code data-claire-semantic="cpp">nullptr</code> :</p><pre id="r-535862" data-claire-element-id="535862"><code data-claire-semantic="cpp">int *pointeur(nullptr);</code></pre><p id="r-535863" data-claire-element-id="535863">Maintenant, impossible de ne pas voir du premier coup d’œil qu’il s’agit d’un pointeur.</p><p id="r-535864" data-claire-element-id="535864">Enfin, sachez qu’il est impossible d’utiliser <code data-claire-semantic="cpp">nullptr</code> comme un entier, ce qui était possible avec NULL.<br/> En effet, ce code compile :</p><pre id="r-535865" data-claire-element-id="535865"><code data-claire-semantic="cpp">int nul = NULL;</code></pre><p id="r-535866" data-claire-element-id="535866">Mais, pas celui-ci :</p><pre id="r-535867" data-claire-element-id="535867"><code data-claire-semantic="cpp">int nul = nullptr;</code></pre><div id="r-535869" data-claire-element-id="535869" data-claire-semantic="question"><p id="r-535868" data-claire-element-id="535868">Quelle en est la raison ?</p></div><p id="r-535870" data-claire-element-id="535870">Parce que <code data-claire-semantic="cpp">nullptr</code> est de type <code data-claire-semantic="cpp">std::nullptr_t</code> (un peu comme <code data-claire-semantic="cpp">true</code> et <code data-claire-semantic="cpp">false</code> sont de type <code data-claire-semantic="cpp">bool</code>), alors que <code data-claire-semantic="cpp">NULL</code> est une macro qui vaut <code data-claire-semantic="cpp">0</code>.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
<span class="arrow"></span>
<span class="next">La boucle basée sur un intervalle</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
<span class="next">Les fonctions anonymes et les fermetures</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesfonctionsanonymesetlesfermetures"></a><h2>Les fonctions anonymes et les fermetures</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
<span class="arrow"></span>
<span class="next">Initialisation d’un pointeur</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
<span class="next">Les tableaux à taille fixe</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-fonctions-anonymes-1" data-claire-element-id="535888">Fonctions anonymes</h2><p id="r-535872" data-claire-element-id="535872">Une fonction anonyme, communément appelée fonction lambda, est une fonction qui n’a pas … de nom.<br/> C’est aussi simple que cela.<br/> On peut envoyer de telles fonctions en paramètre à des fonctions ou bien les stocker dans une variable.</p><p id="r-535873" data-claire-element-id="535873">Par exemple, au lieu d’envoyer un foncteur à std::for_each, nous pouvons lui envoyer une fonction anonyme.<br/> C’est pratique dans le cas où nous ne comptons pas réutiliser la fonction ailleurs.<br/> Reprenons l’exemple donné plus haut et utilisons à la place une fonction anonyme :</p><pre id="r-535874" data-claire-element-id="535874"><code data-claire-semantic="cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
    vector&lt;int&gt; nombres = { 1, 2, 3, 4, 5 };
    for_each(nombres.begin(), nombres.end(), [](int element) {
        cout &lt;&lt; element &lt;&lt; endl;
    });
    
    return 0;
}</code></pre><p id="r-535875" data-claire-element-id="535875">Nous allons étudier la partie qui doit vous sembler étrange :</p><pre id="r-535876" data-claire-element-id="535876"><code data-claire-semantic="cpp">[](int element) {
    cout &lt;&lt; element &lt;&lt; endl;
}</code></pre><p id="r-535877" data-claire-element-id="535877">Premièrement, il y a des crochets ; nous verrons plus tard à quoi ils servent.</p><p id="r-535878" data-claire-element-id="535878">Ensuite, il y a directement les paramètres de la fonction, sans le nom devant.<br/> C’est tout à fait normal, les fonctions anonymes n’ont pas de nom.</p><p id="r-535879" data-claire-element-id="535879">Le reste est comme une fonction ordinaire : il y a l’accolade ouvrante, les instructions et l’accolade fermante.</p><p id="r-535880" data-claire-element-id="535880">Vous pouvez assigner une fonction anonyme à une variable, comme ceci :</p><pre id="r-535881" data-claire-element-id="535881"><code data-claire-semantic="cpp">std::function&lt;int (int, int)&gt; addition = [](int x, int y) -&gt; int {
    return x + y;
};</code></pre><p id="r-535882" data-claire-element-id="535882">Premièrement, il y a le type std::function&lt;&gt; que nous devons assigner à la variable.<br/> Entre les chevrons, nous devons mettre le type de retour, suivi du type des paramètres, entre parenthèses, de la fonction anonyme.<br/> En pratique, nous donnerons <code data-claire-semantic="cpp">auto</code> comme type à une variable dans laquelle nous voulons mettre une fonction anonyme :</p><pre id="r-535883" data-claire-element-id="535883"><code data-claire-semantic="cpp">auto addition = [](int x, int y) -&gt; int {
    return x + y;
};</code></pre><p id="r-535884" data-claire-element-id="535884">Dans cet exemple, il y a une petite nouveauté :</p><pre id="r-535885" data-claire-element-id="535885"><code data-claire-semantic="cpp">[](int x, int y) -&gt; int {
    return x + y;
}</code></pre><p id="r-535886" data-claire-element-id="535886">Après la parenthèse fermante, il y a <code data-claire-semantic="cpp">-&gt; int</code>.<br/> Ce code est facultatif et il indique le type de retour de la fonction anonyme.<br/> Cela peut être utile de le mettre dans le cas où nous donnons le type <code data-claire-semantic="cpp">auto</code> à la variable ou lorsque nous envoyons une fonction anonyme à une autre fonction.<br/> Ainsi, nous saurons rapidement quel type de variable retourne la fonction anonyme.</p><p id="r-535887" data-claire-element-id="535887">Si nous ne le mettons pas, le type sera calculé par <code data-claire-semantic="cpp">decltype()</code>.</p><h2 id="r-fermetures" data-claire-element-id="535924">Fermetures</h2><p id="r-535889" data-claire-element-id="535889">Une fermeture est une fonction qui capture des variables à l’extérieur de celle-ci.<br/> Il faut préciser quelles sont les variables capturées.</p><p id="r-535890" data-claire-element-id="535890">Nous devons le faire entre les crochets ([]) qui se trouvent au début d’une fonction anonyme.<br/> Pour capturer un variable, il faut écrire sont nom entre crochet.</p><p id="r-535891" data-claire-element-id="535891">Sachez qu’il y a deux façons de capturer une variable :</p><ul id="r-535896" data-claire-element-id="535896"><li id="r-535893" data-claire-element-id="535893"><p id="r-535892" data-claire-element-id="535892">par référence : de cette façon, les modifications apportées à la variable s’appliqueront à la variable capturée ;</p></li><li id="r-535895" data-claire-element-id="535895"><p id="r-535894" data-claire-element-id="535894">par valeur : c’est une copie de la variable capturée ; les modifications n’affecteront pas cette dernière.</p></li></ul><p id="r-535897" data-claire-element-id="535897">Pour capturer une variable par référence, il suffit de précéder son nom par l’esperluette (&amp;), comme ceci :</p><pre id="r-535898" data-claire-element-id="535898"><code data-claire-semantic="cpp">[&amp;somme](std::vector&lt;int&gt; vecteur {
    //...
}</code></pre><p id="r-535899" data-claire-element-id="535899">Si nous voulons capturer une variable par valeur, il suffit d’écrire son nom :</p><pre id="r-535900" data-claire-element-id="535900"><code data-claire-semantic="cpp">[x](int &amp;a) {
    a = x;
}</code></pre><p id="r-535901" data-claire-element-id="535901">Voyons un exemple complet :</p><pre id="r-535902" data-claire-element-id="535902"><code data-claire-semantic="cpp">int somme(0);
std::function&lt;void (std::vector&lt;int&gt;)&gt; sommeVecteur = [&amp;somme](std::vector&lt;int&gt; vecteur) {
    for(int &amp;x : vecteur) {
        somme += x;
    }
};

std::vector&lt;int&gt; nombres = { 1, 2, 3, 4, 5 };

sommeVecteur(nombres);
std::cout &lt;&lt; somme &lt;&lt; std::endl;</code></pre><p id="r-535903" data-claire-element-id="535903">Nous avons la confirmation que la variable somme a bien été modifiée : le nombre 15 s’affiche.</p><p id="r-535904" data-claire-element-id="535904">Il est possible de capturer toutes les variables par référence ou par valeur.</p><p id="r-535905" data-claire-element-id="535905">Voici une liste pour en résumer la syntaxe :</p><ul id="r-535918" data-claire-element-id="535918"><li id="r-535907" data-claire-element-id="535907"><p id="r-535906" data-claire-element-id="535906">[] : pas de variable externe ;</p></li><li id="r-535909" data-claire-element-id="535909"><p id="r-535908" data-claire-element-id="535908">[x, &amp;y] : x capturée par valeur, y capturée par référence ;</p></li><li id="r-535911" data-claire-element-id="535911"><p id="r-535910" data-claire-element-id="535910">[&amp;] : toutes les variables externes sont capturées par référence ;</p></li><li id="r-535913" data-claire-element-id="535913"><p id="r-535912" data-claire-element-id="535912">[=] : toutes les variables externes sont capturées par valeur ;</p></li><li id="r-535915" data-claire-element-id="535915"><p id="r-535914" data-claire-element-id="535914">[&amp;, x] : x capturée par valeur, toutes les autres variables, par référence ;</p></li><li id="r-535917" data-claire-element-id="535917"><p id="r-535916" data-claire-element-id="535916">[=, &amp;x] : x capturée par référence, toutes les autres variables, par valeur.</p></li></ul><aside id="r-535920" data-claire-element-id="535920" data-claire-semantic="error"><p id="r-535919" data-claire-element-id="535919">Bien que cela peut paraître tentant, il vaut mieux éviter de capturer toutes les variables externes lorsque possible (c’est-à-dire tout le temps :p ).<br/> En effet, cela pourrait créer des problèmes de nom avec des variables extérieures.</p></aside><p id="r-535921" data-claire-element-id="535921">Bon, vous êtes prévenus, mais voici tout de même un exemple :</p><pre id="r-535922" data-claire-element-id="535922"><code data-claire-semantic="cpp">int x(10);
auto afficherVariableX = [x]() {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
};

afficherVariableX();</code></pre><p id="r-535923" data-claire-element-id="535923">Comme vous pouvez le constater, la variable externe <code data-claire-semantic="cpp">x</code> a été affichée.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
<span class="arrow"></span>
<span class="next">Initialisation d’un pointeur</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
<span class="next">Les tableaux à taille fixe</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lestableauxtaillefixe"></a><h2>Les tableaux à taille fixe</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
<span class="arrow"></span>
<span class="next">Les fonctions anonymes et les fermetures</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
<span class="next">Un nouveau type de conteneur : le tuple</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-535926" data-claire-element-id="535926">Vous vous souvenez <a href="http://www.siteduzero.com/tutoriel-3-420445-les-tableaux.html#ss_part_1">des tableaux statiques du Cours C++</a> ?<br/> Ceux que nous pouvons déclarer comme suit :</p><pre id="r-535927" data-claire-element-id="535927"><code data-claire-semantic="cpp">int tableauFixe[5];</code></pre><p id="r-535928" data-claire-element-id="535928">Eh bien, il y a maintenant un conteneur de la STL pour ce genre de tableau.</p><div id="r-535930" data-claire-element-id="535930" data-claire-semantic="question"><p id="r-535929" data-claire-element-id="535929">Mais pourquoi créer un conteneur pour une chose existant déjà dans le langage ?</p></div><p id="r-535931" data-claire-element-id="535931">Le but de ce conteneur est de pouvoir utiliser les tableaux statiques de la même manière que les autres conteneurs de la STL tout en offrant des performances semblables aux tableaux statiques que vous connaissez déjà.</p><p id="r-535932" data-claire-element-id="535932">Premièrement, vous devez inclure cet en-tête :</p><pre id="r-535933" data-claire-element-id="535933"><code data-claire-semantic="cpp">#include &lt;array&gt;</code></pre><h2 id="r-declaration-et-initialisation" data-claire-element-id="535947">Déclaration et initialisation</h2><p id="r-535934" data-claire-element-id="535934">Pour déclarer un tableau fixe de cinq entiers, procéder comme suit :</p><pre id="r-535935" data-claire-element-id="535935"><code data-claire-semantic="cpp">std::array&lt;int, 5&gt; tableauFixe;</code></pre><p id="r-535936" data-claire-element-id="535936">Regardez ce schéma pour mieux comprendre :<br/>std::array&lt;TYPE, TAILLE&gt; NOM;</p><p id="r-535937" data-claire-element-id="535937">Vous pouvez en même temps initialiser le tableau avec la liste d’initialisateurs que vous connaissez déjà bien :</p><pre id="r-535938" data-claire-element-id="535938"><code data-claire-semantic="cpp">std::array&lt;int, 5&gt; tableauFixe = { 1, 2, 3, 4, 5 };</code></pre><p id="r-535939" data-claire-element-id="535939">La taille ne peut pas être une variable, mais peut être une constante.<br/> Donc, ce code ne compilera pas :</p><pre id="r-535940" data-claire-element-id="535940"><code data-claire-semantic="cpp">int taille = 5;
std::array&lt;int, taille&gt; tableauFixe = { 1, 2, 3, 4, 5 };</code></pre><p id="r-535941" data-claire-element-id="535941">Mais, ce code compilera :</p><pre id="r-535942" data-claire-element-id="535942"><code data-claire-semantic="cpp">int const taille = 5;
std::array&lt;int, taille&gt; tableauFixe = { 1, 2, 3, 4, 5 };</code></pre><aside id="r-535944" data-claire-element-id="535944" data-claire-semantic="information"><p id="r-535943" data-claire-element-id="535943">C’est d’ailleurs une bonne idée de créer une constante, car si la taille du tableau venait à être modifiée, il suffirait de changer la valeur de la constante.</p></aside><p id="r-535945" data-claire-element-id="535945">Il est ensuite possible de parcourir le tableau avec une boucle basée sur un intervalle :</p><pre id="r-535946" data-claire-element-id="535946"><code data-claire-semantic="cpp">for(int nombre : tableauFixe) {
    std::cout &lt;&lt; nombre &lt;&lt; std::endl;
}</code></pre><h2 id="r-methodes-36" data-claire-element-id="535959">Méthodes</h2><p id="r-535948" data-claire-element-id="535948">Pour obtenir la taille d’un tableau, utiliser l’habituelle méthode <code data-claire-semantic="cpp">size()</code>.</p><p id="r-535949" data-claire-element-id="535949">Il est toujours possible d’accéder aux éléments d’un tableau avec l’opérateur [] et la méthode at() :</p><pre id="r-535950" data-claire-element-id="535950"><code data-claire-semantic="cpp">tableauFixe[0] = 10;
tableauFixe.at(1) = 40;
std::cout &lt;&lt; tableauFixe[1] &lt;&lt; std::endl;
std::cout &lt;&lt; tableauFixe.at(0) &lt;&lt; std::endl;</code></pre><aside id="r-535952" data-claire-element-id="535952" data-claire-semantic="information"><p id="r-535951" data-claire-element-id="535951">La méthode at() fait une vérification des limites.<br/> Si vous lui passer en paramètre un indice hors limite, une exception <code data-claire-semantic="cpp">std::out_of_range</code> sera levée.</p></aside><aside id="r-535954" data-claire-element-id="535954" data-claire-semantic="error"><p id="r-535953" data-claire-element-id="535953">Attention !<br/> Il n’y a aucune vérification des limites pour l’opérateur [].<br/> Si vous lui passer un indice en dehors du tableau, le compilateur ne repèrera pas l’erreur et votre programme pourrait se terminer de façon inattendue.</p></aside><p id="r-535955" data-claire-element-id="535955">Les méthodes <code data-claire-semantic="cpp">front()</code> et <code data-claire-semantic="cpp">back()</code> permettent respectivement d’obtenir le premier et le dernier élément du tableau.</p><p id="r-535956" data-claire-element-id="535956">La méthode <code data-claire-semantic="cpp">empty()</code> nous indique si le tableau est vide.</p><p id="r-535957" data-claire-element-id="535957">Il est possible de modifier la valeur de tous les éléments par une autre avec la méthode <code data-claire-semantic="cpp">fill()</code>.</p><p id="r-535958" data-claire-element-id="535958">Enfin, il est également possible d’utiliser les itérateurs avec les tableaux statiques en utilisant les méthodes <code data-claire-semantic="cpp">begin()</code> et <code data-claire-semantic="cpp">end()</code>.</p><h2 id="r-exemple-162" data-claire-element-id="535962">Exemple</h2><p id="r-535960" data-claire-element-id="535960">Voici un exemple de code utilisant ces méthodes :</p><pre id="r-535961" data-claire-element-id="535961"><code data-claire-semantic="cpp">#include &lt;array&gt;
#include &lt;iostream&gt;

int main() {
    std::array&lt;int, 5&gt; tableauFixe = { 1, 2, 3, 4, 5 }; //Création d’un tableau à taille fixe de cinq entiers.
    
    //Affichage de tous ses éléments.
    for(int nombre : tableauFixe) {
        std::cout &lt;&lt; nombre &lt;&lt; std::endl;
    }
    
    std::cout &lt;&lt; &quot;Taille : &quot; &lt;&lt; tableauFixe.size() &lt;&lt; std::endl; //Affichage de sa taille.
    
    //Modification d’éléments.
    tableauFixe[0] = 10;
    tableauFixe.at(1) = 40;
    std::cout &lt;&lt; tableauFixe[1] &lt;&lt; std::endl; //Affichage d’un élément précis sans vérification de limite.
    std::cout &lt;&lt; tableauFixe.at(0) &lt;&lt; std::endl; //Même chose sauf qu’il y a une vérification de limite.
    std::cout &lt;&lt; tableauFixe.front() &lt;&lt; std::endl; //Afficher le premier élément.
    std::cout &lt;&lt; tableauFixe.back() &lt;&lt; std::endl; //Afficher le dernier élément.
    
    if(not tableauFixe.empty()) {
        std::cout &lt;&lt; &quot;Le tableau n’est pas vide.&quot; &lt;&lt; std::endl;
    }
    
    tableauFixe.fill(5); //Modifier tous les éléments pour la valeur 5.
    
    for(std::array&lt;int, 5&gt;::iterator i(tableauFixe.begin()) ; i != tableauFixe.end() ; ++i) {
        std::cout &lt;&lt; *i &lt;&lt; std::endl;
    }
    return 0;
}</code></pre>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
<span class="arrow"></span>
<span class="next">Les fonctions anonymes et les fermetures</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
<span class="next">Un nouveau type de conteneur : le tuple</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Unnouveautypedeconteneurletuple"></a><h2>Un nouveau type de conteneur : le tuple</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
<span class="arrow"></span>
<span class="next">Les tableaux à taille fixe</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
<span class="next">Gestion du temps</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-535964" data-claire-element-id="535964">Commençons par définir ce qu’est un tuple :</p><p id="r-535965" data-claire-element-id="535965"><cite>Citation : Wikipédia</cite></p><blockquote id="r-535967" data-claire-element-id="535967"><p id="r-535966" data-claire-element-id="535966">Un tuple est une collection de dimension fixe d'objets de types différents.</p></blockquote><p id="r-535968" data-claire-element-id="535968">Un tuple permet donc de créer un tableau statique, comme nous venons de voir, mais avec des types d’objet différents.</p><p id="r-535969" data-claire-element-id="535969">L’en-tête à inclure est :</p><pre id="r-535970" data-claire-element-id="535970"><code data-claire-semantic="cpp">#include &lt;tuple&gt;</code></pre><h2 id="r-declaration-et-initialisation-1" data-claire-element-id="535979">Déclaration et initialisation</h2><p id="r-535971" data-claire-element-id="535971">Voyons un exemple de déclaration d’un tuple :</p><pre id="r-535972" data-claire-element-id="535972"><code data-claire-semantic="cpp">std::tuple&lt;int, double, std::string&gt; nomTuple;</code></pre><p id="r-535973" data-claire-element-id="535973">Ici, nous créons un tuple nommé <code data-claire-semantic="cpp">nomTuple</code> pouvant contenir un entier, un nombre réel et une chaîne de caractères.</p><p id="r-535974" data-claire-element-id="535974">La forme générale pour déclarer un tuple est :<br/>std::tuple&lt;type1, type2, …&gt; nomTuple;</p><p id="r-535975" data-claire-element-id="535975">Si nous voulons initialiser le tuple lors de l’initialisation, nous devons envoyer des arguments au constructeur.</p><p id="r-535976" data-claire-element-id="535976">Imaginons un tuple qui contient des informations sur une personne.<br/> Nous pourrions retenir son âge, sa taille et son prénom.</p><p id="r-535977" data-claire-element-id="535977">Il serait possible de déclarer et d’initialiser ce tuple comme suit :</p><pre id="r-535978" data-claire-element-id="535978"><code data-claire-semantic="cpp">std::tuple&lt;int, double, std::string&gt; personne(22, 185.4, &quot;Jack&quot;);</code></pre><h2 id="r-acceder-aux-elements-du-tuple" data-claire-element-id="535985">Accéder aux éléments du tuple</h2><p id="r-535980" data-claire-element-id="535980">Pour accéder aux éléments d’un tuple, nous devons utiliser la fonction <code data-claire-semantic="cpp">std::get()</code>.</p><p id="r-535981" data-claire-element-id="535981">Par exemple, si nous voulons modifier l’âge de notre bon ami Jack, nous devons faire ceci :</p><pre id="r-535982" data-claire-element-id="535982"><code data-claire-semantic="cpp">std::get&lt;0&gt;(personne) = 23;</code></pre><p id="r-535983" data-claire-element-id="535983">Ensuite, nous pouvons afficher son âge :</p><pre id="r-535984" data-claire-element-id="535984"><code data-claire-semantic="cpp">std::cout &lt;&lt; &quot;Âge : &quot; &lt;&lt; std::get&lt;0&gt;(personne) &lt;&lt; std::endl;</code></pre><h2 id="r-exemple-163" data-claire-element-id="535989">Exemple</h2><p id="r-535986" data-claire-element-id="535986">Voici un exemple :</p><pre id="r-535987" data-claire-element-id="535987"><code data-claire-semantic="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

int main() {
    std::tuple&lt;int, double, std::string&gt; personne(22, 185.4, &quot;Jack&quot;); //Création d’un tuple.
    std::get&lt;0&gt;(personne) = 23; //Modification d’un objet d’un tuple.
    
    //Affichage des objets du tuple.
    std::cout &lt;&lt; &quot;Âge : &quot; &lt;&lt; std::get&lt;0&gt;(personne) &lt;&lt; std::endl &lt;&lt; &quot;Taille : &quot; &lt;&lt; std::get&lt;1&gt;(personne) &lt;&lt; std::endl &lt;&lt; &quot;Prénom : &quot; &lt;&lt; std::get&lt;2&gt;(personne) &lt;&lt; std::endl;
    
    typedef std::tuple&lt;int, double, std::string&gt; tuple_personne;
    std::cout &lt;&lt; &quot;Taille du tuple : &quot; &lt;&lt; std::tuple_size&lt;tuple_personne&gt;::value &lt;&lt; std::endl; //Affichage de la taille du tuple.
    tuple_personne jack(23, 185.4, &quot;Jack&quot;);
    if(personne == jack) { //Comparaison de tuples.
        std::cout &lt;&lt; &quot;Les tuples sont identiques.&quot; &lt;&lt; std::endl;
    }
    return 0;
}</code></pre><p id="r-535988" data-claire-element-id="535988">Comme vous pouvez le constater, nous pouvons vérifier que les valeurs de deux tuples sont égales grâce à l’opérateur ==.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
<span class="arrow"></span>
<span class="next">Les tableaux à taille fixe</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
<span class="next">Gestion du temps</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Gestiondutemps"></a><h2>Gestion du temps</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
<span class="arrow"></span>
<span class="next">Un nouveau type de conteneur : le tuple</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
<span class="next">Les initialisateurs d’attributs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-535991" data-claire-element-id="535991">Il y a maintenant une interface pour gérer le temps en C++.<br/> Voyons tout de suite comment elle fonctionne.</p><p id="r-535992" data-claire-element-id="535992">Avant tout, incluez l’en-tête :</p><pre id="r-535993" data-claire-element-id="535993"><code data-claire-semantic="cpp">#include &lt;chrono&gt;</code></pre><h2 id="r-obtenir-le-temps-actuel" data-claire-element-id="536003">Obtenir le temps actuel</h2><p id="r-535994" data-claire-element-id="535994">Pour obtenir le temps actuel, ce qui est utile pour faire une action à chaque X secondes, nous devons appeler la fonction <code data-claire-semantic="cpp">std::chrono::system_clock::now()</code> :</p><pre id="r-535995" data-claire-element-id="535995"><code data-claire-semantic="cpp">std::chrono::time_point&lt;std::chrono::system_clock&gt; temps = std::chrono::system_clock::now();</code></pre><p id="r-535996" data-claire-element-id="535996">Ou plus simplement :</p><pre id="r-535997" data-claire-element-id="535997"><code data-claire-semantic="cpp">auto temps = std::chrono::system_clock::now();</code></pre><p id="r-535998" data-claire-element-id="535998">Pour faire un test, nous allons appeler deux fois cette fonction, avec un appel à usleep() entre chaque appel.<br/> Ensuite, nous afficherons le temps pris par le programme.</p><pre id="r-535999" data-claire-element-id="535999"><code data-claire-semantic="cpp">#include &lt;chrono&gt;
#include &lt;iostream&gt;

int main() {
    auto temps1 = std::chrono::system_clock::now();
    usleep(100000);
    auto temps2 = std::chrono::system_clock::now();
    
    std::cout &lt;&lt; (temps2 - temps1).count() &lt;&lt; &quot; microsecondes.&quot; &lt;&lt; std::endl;
    
    return 0;
}</code></pre><p id="r-536000" data-claire-element-id="536000">Le résultat suivant peut s’afficher à l’écran :</p><pre id="r-536001" data-claire-element-id="536001"><code data-claire-semantic="console">100090 microsecondes.</code></pre><p id="r-536002" data-claire-element-id="536002">Et voilà, nous avons pu calculer le temps pris par la fonction usleep() pour mettre en pause le programme.</p><h2 id="r-autres-unites" data-claire-element-id="536020">Autres unités</h2><p id="r-536004" data-claire-element-id="536004">On peut également décider d’afficher le temps dans une autre unité, par exemple en nanosecondes :</p><pre id="r-536005" data-claire-element-id="536005"><code data-claire-semantic="cpp">std::chrono::nanoseconds nbrNanoSecondes = (temps2 - temps1);
std::cout &lt;&lt; nbrNanoSecondes.count() &lt;&lt; &quot; nanosecondes.&quot; &lt;&lt; std::endl;</code></pre><p id="r-536006" data-claire-element-id="536006">Le résultat :</p><pre id="r-536007" data-claire-element-id="536007"><code data-claire-semantic="console">100090000 nanosecondes.</code></pre><div id="r-536009" data-claire-element-id="536009" data-claire-semantic="question"><p id="r-536008" data-claire-element-id="536008">J’ai essayé d’obtenir le résultat en millisecondes et ça ne fonctionne pas.<br/> Est-ce normal ?</p></div><p id="r-536010" data-claire-element-id="536010">Oui, car il y aurait une perte de précisions étant donné que le nombre retourné est un entier.<br/> Pour obtenir tout de même le nombre de millisecondes, il faut faire ceci :</p><pre id="r-536011" data-claire-element-id="536011"><code data-claire-semantic="cpp">std::chrono::duration&lt;double, std::milli&gt; nbrMilliSecondes = (temps2 - temps1);
std::cout &lt;&lt; nbrMilliSecondes.count() &lt;&lt; &quot; millisecondes.&quot; &lt;&lt; std::endl;</code></pre><p id="r-536012" data-claire-element-id="536012">Toutes les unités que vous avez utilisées jusqu’à présent était des <code data-claire-semantic="cpp">typedef</code>s sur la classe <code data-claire-semantic="cpp">std::chrono::duration</code>.<br/> Par exemple, pour les nanosecondes, le <code data-claire-semantic="cpp">typedef</code> est :</p><pre id="r-536013" data-claire-element-id="536013"><code data-claire-semantic="cpp">typedef duration&lt;int64_t, nano&gt; 	nanoseconds;</code></pre><p id="r-536014" data-claire-element-id="536014">Le problème avec les millisecondes dans notre exemple est que le type utilisé est un entier.</p><p id="r-536015" data-claire-element-id="536015">Or, le nombre de millisecondes doit être de type <code data-claire-semantic="cpp">double</code>, sinon il y aurait une perte de précision.<br/> C’est pourquoi nous devons utiliser la classe <code data-claire-semantic="cpp">std::chrono::duration</code>.</p><p id="r-536016" data-claire-element-id="536016">Pour obtenir le nombre de secondes, nous pouvons faire ceci :</p><pre id="r-536017" data-claire-element-id="536017"><code data-claire-semantic="cpp">std::chrono::duration&lt;double, std::ratio&lt;1&gt;&gt; nbrSecondes = (temps2 - temps1);</code></pre><p id="r-536018" data-claire-element-id="536018">Ou plus simplement :</p><pre id="r-536019" data-claire-element-id="536019"><code data-claire-semantic="cpp">std::chrono::duration&lt;double&gt; nbrSecondes = (temps2 - temps1);</code></pre>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
<span class="arrow"></span>
<span class="next">Un nouveau type de conteneur : le tuple</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
<span class="next">Les initialisateurs d’attributs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesinitialisateursdattributs"></a><h2>Les initialisateurs d’attributs</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
<span class="arrow"></span>
<span class="next">Gestion du temps</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-536022" data-claire-element-id="536022">Les initialisateurs d’attributs permettent… d’initialiser les attributs (ah oui ? ^^ ) d’une classe ou d’un autre type de donnée.</p><p id="r-536023" data-claire-element-id="536023">Pour ce faire, il suffit d’écrire la valeur des attributs, dans le même ordre qu’ils sont déclarés dans la classe, entre accolades, séparés par une virgule.</p><p id="r-536024" data-claire-element-id="536024">Nous allons utiliser la classe suivante (qui a deux attributs publics) pour nos premiers tests :</p><pre id="r-536025" data-claire-element-id="536025"><code data-claire-semantic="cpp">struct Paire {
    int nombre1;
    int nombre2;
};</code></pre><p id="r-536026" data-claire-element-id="536026">Dans notre code, il est maintenant possible d’utiliser cette syntaxe pour initialiser les attributs :</p><pre id="r-536027" data-claire-element-id="536027"><code data-claire-semantic="cpp">int main() {
    Paire paire{ 5, 25 }; //Initialise nombre1 à 5 et nombre2 à 25.
    return 0;
}</code></pre><p id="r-536028" data-claire-element-id="536028">Nous pouvons ensuite modifier les attributs de l’objet en utilisant la même syntaxe :</p><pre id="r-536029" data-claire-element-id="536029"><code data-claire-semantic="cpp">paire = { 3, 9 };</code></pre><p id="r-536030" data-claire-element-id="536030">Il est également possible d’utiliser cette syntaxe pour retourner un objet :</p><pre id="r-536031" data-claire-element-id="536031"><code data-claire-semantic="cpp">Paire getPaire() {
    return { 10, 100 }; //Retourne une Paire dont nombre1 = 10 et nombre2 = 100.
}</code></pre><p id="r-536032" data-claire-element-id="536032">Dans notre fonction <code data-claire-semantic="cpp">main()</code>, nous pouvons tester cette fonction :</p><pre id="r-536033" data-claire-element-id="536033"><code data-claire-semantic="cpp">paire = getPaire();</code></pre><div id="r-536035" data-claire-element-id="536035" data-claire-semantic="question"><p id="r-536034" data-claire-element-id="536034">Mais on nous a dit qu’il faut éviter à tout prix les attributs publics.<br/> Alors, nous n’utiliserons pas beaucoup cette syntaxe, non ?</p></div><p id="r-536036" data-claire-element-id="536036">Eh bien… vous pouvez même l’utiliser avec des attributs privés, par l’intermédiaire du constructeur.</p><p id="r-536037" data-claire-element-id="536037">En voici un exemple :</p><pre id="r-536038" data-claire-element-id="536038"><code data-claire-semantic="cpp">#include &lt;iostream&gt;

class Paire {
    public:
        Paire(int nombre1, int nombre2) : nombre1_(nombre1), nombre2_(nombre2) {}
        
    private:
        int nombre1_;
        int nombre2_;
};

Paire getPaire() {
    return { 10, 100 }; //Retourne une Paire dont nombre1_ = 10 et nombre2_ = 100.
}

int main() {
    Paire paire{ 5, 25 }; //Initialise nombre1_ à 5 et nombre2_ à 25.
    paire = { 3, 9 };
    paire = getPaire();
    return 0;
}</code></pre><p id="r-536039" data-claire-element-id="536039">À chaque fois, le constructeur est utilisé pour initialiser les attributs.</p><aside id="r-536041" data-claire-element-id="536041" data-claire-semantic="error"><p id="r-536040" data-claire-element-id="536040">Vous devez également savoir que la liste d’initialisateurs a priorité sur les initialisateurs d’attributs.<br/> Pour faire des tests, ajoutez ce constructeur :</p></aside><pre id="r-536042" data-claire-element-id="536042"><code data-claire-semantic="cpp">Paire(std::initializer_list&lt;int&gt; liste) : nombre1_(*liste.begin()), nombre2_(*liste.end()) {
    std::cout &lt;&lt; &quot;Liste d’initialisateurs.&quot; &lt;&lt; std::endl;
}</code></pre><aside id="r-536044" data-claire-element-id="536044" data-claire-semantic="information"><p id="r-536043" data-claire-element-id="536043">Veuillez noter que cette syntaxe est utilisable pour tous les types, comme vous pouvez le constater en regardant l’exemple suivant :</p></aside><pre id="r-536045" data-claire-element-id="536045"><code data-claire-semantic="cpp">bool booleen{false};
int nombre{42};
int tableau[5] = { 1, 2, 3, 4, 5 };
std::vector&lt;int&gt; vecteurNombres{ 1, 2, 3 };
std::string chaine{&quot;Hello World!&quot;};
int* pointeurSurEntier{nullptr};</code></pre><p id="r-536046" data-claire-element-id="536046">Que de nouveautés dans la nouvelle norme, n’est-ce pas ?<br/> Pourtant, nous n’avons pas tout vu, loin de là. o_O <br/> Pour en apprendre encore plus, voici quelques liens :</p><ul id="r-536055" data-claire-element-id="536055"><li id="r-536048" data-claire-element-id="536048"><p id="r-536047" data-claire-element-id="536047"><a href="http://en.wikipedia.org/wiki/C++0x">http://en.wikipedia.org/wiki/C%2B%2B0x</a></p></li><li id="r-536050" data-claire-element-id="536050"><p id="r-536049" data-claire-element-id="536049"><a href="http://fr.wikipedia.org/wiki/C++1x">http://fr.wikipedia.org/wiki/C%2B%2B1x</a></p></li><li id="r-536052" data-claire-element-id="536052"><p id="r-536051" data-claire-element-id="536051"><a href="http://aubedesheros.blogspot.com/search/label/c++">http://aubedesheros.blogspot.com/search/label/c%2B%2B</a></p></li><li id="r-536054" data-claire-element-id="536054"><p id="r-536053" data-claire-element-id="536053"><a href="http://www2.research.att.com/~bs/C++0xFAQ.html">http://www2.research.att.com/~bs/C++0xFAQ.html</a></p></li></ul><p id="r-536056" data-claire-element-id="536056">Et si vous voulez savoir si telle ou telle fonctionnalité est implémentée dans gcc, allez <a href="http://gcc.gnu.org/gcc-4.6/cxx0x_status.html">sur ce site</a>.</p><p id="r-536057" data-claire-element-id="536057">Enfin, si vous voulez apprendre à utiliser les <a href="http://fr.wikipedia.org/wiki/Thread_(informatique)">threads</a> de la nouvelle norme (utilisable avec g++ 4.6), il y a une excellente série d’articles pour les utiliser en C++ <a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-1-starting-threads.html">sur ce site</a>.</p><aside id="r-536059" data-claire-element-id="536059" data-claire-semantic="error"><p id="r-536058" data-claire-element-id="536058">Attention, si vous utilisez g++, vous devrez ajouter un argument à la compilation (<code data-claire-semantic="console">-pthread</code>) pour pouvoir utiliser les threads.<br/> Par exemple :</p></aside><pre id="r-536060" data-claire-element-id="536060"><code data-claire-semantic="console">g++ -std=c++0x -pthread thread.cpp -o Thread</code></pre><p id="r-536061" data-claire-element-id="536061"><em>Merci à <a href="http://www.siteduzero.com/membres-294-47814.html">Babilomax</a> pour ses commentaires et remarques très utiles.</em></p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x">Introduction à C++ 2011 (C++0x)</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/pourquoi-une-nouvelle-revision-du-langage-c">
Pourquoi une nouvelle révision du langage C++ ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/preparation-du-compilateur-pour-utiliser-c-2011">
Préparation du compilateur pour utiliser C++ 2011
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-enumerations-fortement-typees-1">
Les énumérations fortement typées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-bug-des-chevrons">
Le « bug » des chevrons
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-listes-d-initialisateurs">
Les listes d’initialisateurs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/le-mot-cle-auto">
Le mot-clé auto
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/la-boucle-basee-sur-un-intervalle">
La boucle basée sur un intervalle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/initialisation-d-un-pointeur">
Initialisation d’un pointeur
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-fonctions-anonymes-et-les-fermetures">
Les fonctions anonymes et les fermetures
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-tableaux-a-taille-fixe">
Les tableaux à taille fixe
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/un-nouveau-type-de-conteneur-le-tuple">
Un nouveau type de conteneur : le tuple
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
Gestion du temps
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/les-initialisateurs-d-attributs">
Les initialisateurs d’attributs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/introduction-a-c-2011-c-0x/gestion-du-temps">
<span class="arrow"></span>
<span class="next">Gestion du temps</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/introduction-a-c-2011-c-0x.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 08:29:34 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/introduction-a-c-2011-c-0x.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:31:33 GMT -->
</html>
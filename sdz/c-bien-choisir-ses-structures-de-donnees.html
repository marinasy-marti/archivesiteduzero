<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/c-bien-choisir-ses-structures-de-donnees.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 00:05:53 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/c-bien-choisir-ses-structures-de-donnees.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:16:12 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : C++ : Bien choisir ses structures de données</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : C++ : Bien choisir ses structures de données</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#CBienchoisirsesstructuresdedonnes">C++ : Bien choisir ses structures de données</a><br/><a href="#Importanced039unchoixidal">Importance d&#039;un choix idéal</a><br/><a href="#Lesstructureslinaires">Les structures linéaires</a><br/><a href="#Lesarbres">Les arbres</a><br/><a href="#Lemotdelafin">Le mot de la fin</a><br/></div>
<a name="CBienchoisirsesstructuresdedonnes"></a><h2>C++ : Bien choisir ses structures de données</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/importance-d-un-choix-ideal">
<span class="next">Importance d&#039;un choix idéal</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-349110" data-claire-element-id="349110">Ce cours s'adresse aux programmeurs en C++.</p><p id="r-349111" data-claire-element-id="349111">On est souvent amené à implémenter des choses qui nécessitent de stocker beaucoup de données et on s'aperçoit assez vite qu'on y applique souvent le même jeu d'opérations. À partir de là, on peut se poser la question du choix de cette structure : <em>laquelle présentera les meilleures performances pour ce que je veux faire</em> ? Et comme il n'est quasiment jamais question de réinventer la roue, il existe un nombre important de structures déjà implémentées (dans la STL ou dans Boost). <em>Comment s'y retrouver</em> ?</p><p id="r-349112" data-claire-element-id="349112">Ce tutoriel est là pour répondre à ces deux questions. Beaucoup de débutants ne se les posent pas, ou pas assez. Il n'est ainsi pas surprenant de les voir &quot;patauger&quot; sur le forum de ce site en essayant soit de tout faire avec un <code data-claire-semantic="cpp">std::vector</code>, en écrivant eux-même une structure de tas parce qu'ils en ont besoin, ou encore en utilisant <code data-claire-semantic="cpp">std::set</code> pour les ensembles où l'ordre n'a pas d'importance.<br/> Souvent, le manque de recherche et l'ignorance en sont la cause. Mais ce n'est pas la seule : certains débutants sont également rebutés par des bibliothèques tierces comme Boost parce que cela sort du cadre de ce qu'ils ont l'habitude de voir sur ce site. C'est bien dommage.</p><p id="r-349113" data-claire-element-id="349113">Ce cours s'adresse aussi aux plus expérimentés. Une piqure de rappel ne fait jamais de mal.</p><p id="r-349114" data-claire-element-id="349114">De manière concrète, ce cours présentera brièvement chaque structure de données &quot;connue&quot;, la complexité des différentes opérations qu'on serait susceptibles d'y appliquer, ainsi qu'un tableau résumant les classes C++ les plus utilisées pour chaque structure en précisant dans quel cas leur utilisation est justifiée.</p>
</div><a name="Importanced039unchoixidal"></a><h2>Importance d&#039;un choix idéal</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-structures-lineaires">
<span class="next">Les structures linéaires</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-349115" data-claire-element-id="349115">La première question que vous êtes en droit de vous poser, c'est le pourquoi : pourquoi faut-il attacher une grande importance au choix des structures de données pour tel ou tel algorithme (à supposer qu'ils en utilisent) ?</p><p id="r-349116" data-claire-element-id="349116">En fait, quand on implémente un algorithme, on doit toujours chercher à le rendre le plus efficace possible. Il y a de nombreuses opérations &quot;courantes&quot; que l'on peut appliquer sur les structures de données : chercher un élément, chercher l'élément le plus grand, effacer un élément, etc. Comme on va le voir par la suite, certaines structures de données se prêtent mieux que d'autres à certaines de ses opérations. Rendre un algorithme efficace requiert donc (si l'algorithme en question en a besoin) de choisir une structure de données efficace pour les opérations qu'il est susceptible d'y appliquer en grand nombre. Indépendamment de la catégorie de la structure (linéaire, arborescente, circulaire, etc.), il faut pouvoir choisir dans une même catégorie la meilleure structure pour un cas de figure donné. Par exemple choisir une liste plutôt qu'un tableau, ou l'inverse.</p><p id="r-349117" data-claire-element-id="349117">Il faut penser &quot;grand&quot; : sur une structure comportant très peu d'éléments (par exemple 10 ou 100), on ne verra pas de différence au niveau des temps d'exécution des différentes opérations. Par contre, un mauvais choix se fait très vite remarquer dans deux cas : quand la structure est beaucoup plus grande (par exemple quand elle contient 50000 éléments, ou 10000000), ou quand ces opérations se répètent de très nombreuses fois, typiquement quand on la retrouve dans une boucle sur la taille de l'entrée, ou - pire - dans une boucle imbriquée. Voire même les deux.</p><p id="r-349118" data-claire-element-id="349118">Ce choix de la structure &quot;idéale&quot; se fait à travers l'étude des besoins de notre algorithme (par exemple, si l'on accède souvent de manière arbitraire à un élément, il faut trouver la structure de données la plus efficace pour cette opération). Parfois, deux opérations qui ne sont pas optimales sur la même structure doivent être exécuter de très nombreuses fois : dans ce cas, il faut soit revoir notre algorithme (il peut exister d'autres moyens d'arriver au même résultat), soit trouver une structure qui se comporte assez bien pour les opérations, soit choisir la structure pour laquelle l'opération la plus présente est optimale. Le mieux à faire dans ces cas où l'on hésite, c'est de déterminer de façon empirique quelle structure de données permet l'implémentation la plus efficace : on effectue alors des tests de vitesse.</p><p id="r-349119" data-claire-element-id="349119">Certaines structures de données sont carrément indispensables à certains algorithmes : l'un des moyens d'écrire un parcours en largeur nécessite une file, un analyseur syntaxique LR nécessite une pile (même si elle peut être implicite dans le cas des <a href="http://en.wikipedia.org/wiki/Recursive_ascent_parser">analyseurs récursifs ascendants</a>), le tri par tas nécessite... un tas, etc. En d'autres termes, il arrive qu'on ne peut pas utiliser une autre structure ; cela irait à l'encontre de toute logique.</p><p id="r-349120" data-claire-element-id="349120">Maintenant, venons-en au vif du sujet : en C++, <em>quand</em> utiliser <em>quoi</em> ?</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees">C++ : Bien choisir ses structures de données</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/importance-d-un-choix-ideal">
Importance d&#039;un choix idéal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-structures-lineaires">
Les structures linéaires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-arbres">
Les arbres
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/le-mot-de-la-fin-2">
Le mot de la fin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-structures-lineaires">
<span class="next">Les structures linéaires</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesstructureslinaires"></a><h2>Les structures linéaires</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/importance-d-un-choix-ideal">
<span class="arrow"></span>
<span class="next">Importance d&#039;un choix idéal</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-arbres">
<span class="next">Les arbres</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-qu-est-ce-1" data-claire-element-id="349124">Qu'est-ce ?</h2><p id="r-349122" data-claire-element-id="349122">Typiquement, la définition la plus simple que l'on pourrait donner d'une &quot;structure linéaire&quot; est la suivante : une structure est dite linéaire si l'on peut concevoir une fonction (dite &quot;successeur&quot;) qui à chacun de ses éléments sauf le dernier associe un unique autre élément de la même structure (l'élément suivant). De plus, on doit pouvoir parcourir l'intégralité de la structure à l'aide de cette fonction sans visiter deux fois le même élément.</p><p id="r-349123" data-claire-element-id="349123">Une conséquence directe de cette définition un peu barbare est que l'on peut s'imaginer et représenter le contenu d'une telle structure de façon linéaire. Commençons par la structure linéaire la plus connue.</p><h2 id="r-les-tableaux-25" data-claire-element-id="349201">Les tableaux</h2><p id="r-349125" data-claire-element-id="349125">Un tableau représente un ensemble d'éléments contigües en mémoire. Cela implique qu'il suffit de connaitre la première case pour accéder en temps constant à toutes les autres cases (c'est ce qu'on appelle l'indexage d'un tableau). En revanche, il peut y avoir des choses avant et des choses après. Quand on essaye donc d'ajouter un élément, l'environnement d'exécution ne peut pas garantir de pouvoir conserver le même tableau. Il va donc le copier intégralement dans une zone plus grande en y ajoutant notre nouvelle case. C'est cher payé.</p><p id="r-349126" data-claire-element-id="349126">Retirer un élément d'un tableau est une opération à multiples facettes : si l'on retire le premier ou le dernier élément, on n'est pas obligé de réécrire le tableau. S'il y avait de la place pour N éléments, il y en a à fortiori pour N-1. Le soucis c'est quand cette opération est répétée M fois. Beaucoup d'espace reste alors alloué et il ne sert strictement à rien, ce qui est plutôt gênant. C'est pourquoi de temps en temps il est nécessaire de réallouer tout un tableau, plus petit. L'opération nécessite donc potentiellement N-1 copies pour un tableau initial de N cases. Pas très efficaces.</p><p id="r-349127" data-claire-element-id="349127">C'est encore pire si l'on retire un élément en plein milieu : on est obligé de décaler toute la partie qui se situe après cet élément d'une case vers l'avant. De la même manière, cette opération peut nécessiter un grand nombre d'opérations.</p><table id="r-349150" data-claire-element-id="349150"><thead id="r-349133" data-claire-element-id="349133"><tr id="r-349132" data-claire-element-id="349132"><th id="r-349129" data-claire-element-id="349129"><p id="r-349128" data-claire-element-id="349128">Opérations</p></th><th id="r-349131" data-claire-element-id="349131"><p id="r-349130" data-claire-element-id="349130">Complexité</p></th></tr></thead><tbody id="r-349149" data-claire-element-id="349149"><tr id="r-349138" data-claire-element-id="349138"><td id="r-349135" data-claire-element-id="349135"><p id="r-349134" data-claire-element-id="349134">Accès arbitraire</p></td><td id="r-349137" data-claire-element-id="349137"><p id="r-349136" data-claire-element-id="349136">O(1)</p></td></tr><tr id="r-349143" data-claire-element-id="349143"><td id="r-349140" data-claire-element-id="349140"><p id="r-349139" data-claire-element-id="349139">Insertion</p></td><td id="r-349142" data-claire-element-id="349142"><p id="r-349141" data-claire-element-id="349141">O(n)</p></td></tr><tr id="r-349148" data-claire-element-id="349148"><td id="r-349145" data-claire-element-id="349145"><p id="r-349144" data-claire-element-id="349144">Suppression</p></td><td id="r-349147" data-claire-element-id="349147"><p id="r-349146" data-claire-element-id="349146">O(n)</p></td></tr></tbody></table><p id="r-349151" data-claire-element-id="349151">Pour manipuler les tableaux, nous avons différentes classes à notre disposition (je ne liste que les plus connues) :</p><table id="r-349199" data-claire-element-id="349199"><thead id="r-349157" data-claire-element-id="349157"><tr id="r-349156" data-claire-element-id="349156"><th id="r-349153" data-claire-element-id="349153"><p id="r-349152" data-claire-element-id="349152">Classe</p></th><th id="r-349155" data-claire-element-id="349155"><p id="r-349154" data-claire-element-id="349154">Description</p></th></tr></thead><tbody id="r-349198" data-claire-element-id="349198"><tr id="r-349162" data-claire-element-id="349162"><td id="r-349159" data-claire-element-id="349159"><p id="r-349158" data-claire-element-id="349158"><code data-claire-semantic="cpp">std::vector</code></p></td><td id="r-349161" data-claire-element-id="349161"><p id="r-349160" data-claire-element-id="349160">Optimisé pour les tableaux dynamiques (taille variable)</p></td></tr><tr id="r-349167" data-claire-element-id="349167"><td id="r-349164" data-claire-element-id="349164"><p id="r-349163" data-claire-element-id="349163"><code data-claire-semantic="cpp">boost::array</code></p></td><td id="r-349166" data-claire-element-id="349166"><p id="r-349165" data-claire-element-id="349165">Tableau statique (taille fixée et connue <em>at compile-time</em>)</p></td></tr><tr id="r-349172" data-claire-element-id="349172"><td id="r-349169" data-claire-element-id="349169"><p id="r-349168" data-claire-element-id="349168"><code data-claire-semantic="cpp">boost::multi_array</code></p></td><td id="r-349171" data-claire-element-id="349171"><p id="r-349170" data-claire-element-id="349170">Idéal pour l'utilisation de tableaux à plusieurs dimensions</p></td></tr><tr id="r-349177" data-claire-element-id="349177"><td id="r-349174" data-claire-element-id="349174"><p id="r-349173" data-claire-element-id="349173"><code data-claire-semantic="cpp">std::string</code></p></td><td id="r-349176" data-claire-element-id="349176"><p id="r-349175" data-claire-element-id="349175">Idéal pour les tableaux de <code data-claire-semantic="cpp">char</code> type &quot;chaine de caractères&quot;</p></td></tr><tr id="r-349182" data-claire-element-id="349182"><td id="r-349179" data-claire-element-id="349179"><p id="r-349178" data-claire-element-id="349178"><code data-claire-semantic="cpp">std::valarray</code></p></td><td id="r-349181" data-claire-element-id="349181"><p id="r-349180" data-claire-element-id="349180">Simplifie les opérations mathématiques sur les tableaux</p></td></tr><tr id="r-349187" data-claire-element-id="349187"><td id="r-349184" data-claire-element-id="349184"><p id="r-349183" data-claire-element-id="349183"><code data-claire-semantic="cpp">boost::matrix</code></p></td><td id="r-349186" data-claire-element-id="349186"><p id="r-349185" data-claire-element-id="349185">Presque indispensable pour bien manipuler des matrices</p></td></tr><tr id="r-349192" data-claire-element-id="349192"><td id="r-349189" data-claire-element-id="349189"><p id="r-349188" data-claire-element-id="349188"><code data-claire-semantic="cpp">boost::shared_array</code></p></td><td id="r-349191" data-claire-element-id="349191"><p id="r-349190" data-claire-element-id="349190">Tableau de pointeurs sur des zones allouées dynamiquement</p></td></tr><tr id="r-349197" data-claire-element-id="349197"><td id="r-349194" data-claire-element-id="349194"><p id="r-349193" data-claire-element-id="349193"><code data-claire-semantic="cpp">std::bitset</code></p></td><td id="r-349196" data-claire-element-id="349196"><p id="r-349195" data-claire-element-id="349195">Tableau de bits d'une taille connue à la compilation</p></td></tr></tbody></table><p id="r-349200" data-claire-element-id="349200">À noter que <code data-claire-semantic="cpp">boost::array</code> est devenu standard, et si votre STL est à jour, vous avez <code data-claire-semantic="cpp">std::array</code>.</p><h2 id="r-liste-pile-et-file" data-claire-element-id="349262">Liste, pile et file</h2><p id="r-349202" data-claire-element-id="349202">Quand on veut favoriser l'insertion et la suppression au profit de l'accès arbitraire, il est facile d'imaginer un ensemble de données qui ne soit pas contigus en mémoire mais dans lequel chaque élément possède en attribut l'adresse du prochain (permettant tout de même de connaitre toute la séquence). Pour cela, il y a la structure de données que vous connaissez tous : la liste.</p><p id="r-349203" data-claire-element-id="349203">À supposer que l'on connaisse le premier et le dernier élément d'une liste, on peut y accéder en temps constant. Cependant, on ne pourra pas accéder immédiatement aux autres éléments : on obligé de suivre le chainage que nous impose une liste. Dans le cas d'une liste supposée chaînée dans les deux sens de parcours (dite <em>doublement</em> chaînée), l'accès arbitraire nécessite au pire N/2 opérations où N est le nombre d'éléments. Qu'on ne s'en réjouisse pas : N/2, c'est de l'ordre de N et sur N éléments, si N opérations sont lentes, N/2 le seront aussi. La liste n'est donc pas adaptée à l'accès arbitraire aux données.</p><p id="r-349204" data-claire-element-id="349204">Là où une liste est plus intéressante, c'est au niveau des insertions/suppressions : il suffit en effet de désallouer un seul élément (c'est possible vu qu'il s'agira d'une unité mémoire) et de relier le précédent au suivant pour rétablir un chaînage correct. Grosso modo, on a donc 2 opérations. Ce n'est pas ce qui compte, il faut en réalité constater que ce nombre (déjà très petit) ne varie pas avec la taille de l'entrée. La liste est donc optimale pour tout ce qui est insertion ou suppression.</p><p id="r-349205" data-claire-element-id="349205">Parfois, on est amené à utiliser des listes d'une manière un peu spéciale. On peut par exemple ne vouloir qu'ajouter ou retirer des éléments en tête de liste. On parle alors d'une <em>pile</em>. De manière symétrique, on peut être amené à ne vouloir qu'insérer des éléments d'un côté et les retirer de l'autre. C'est une <em>file</em>.</p><table id="r-349228" data-claire-element-id="349228"><thead id="r-349211" data-claire-element-id="349211"><tr id="r-349210" data-claire-element-id="349210"><th id="r-349207" data-claire-element-id="349207"><p id="r-349206" data-claire-element-id="349206">Opérations</p></th><th id="r-349209" data-claire-element-id="349209"><p id="r-349208" data-claire-element-id="349208">Complexité</p></th></tr></thead><tbody id="r-349227" data-claire-element-id="349227"><tr id="r-349216" data-claire-element-id="349216"><td id="r-349213" data-claire-element-id="349213"><p id="r-349212" data-claire-element-id="349212">Accès arbitraire</p></td><td id="r-349215" data-claire-element-id="349215"><p id="r-349214" data-claire-element-id="349214">O(n)</p></td></tr><tr id="r-349221" data-claire-element-id="349221"><td id="r-349218" data-claire-element-id="349218"><p id="r-349217" data-claire-element-id="349217">Insertion</p></td><td id="r-349220" data-claire-element-id="349220"><p id="r-349219" data-claire-element-id="349219">O(1)</p></td></tr><tr id="r-349226" data-claire-element-id="349226"><td id="r-349223" data-claire-element-id="349223"><p id="r-349222" data-claire-element-id="349222">Suppression</p></td><td id="r-349225" data-claire-element-id="349225"><p id="r-349224" data-claire-element-id="349224">O(1)</p></td></tr></tbody></table><table id="r-349261" data-claire-element-id="349261"><thead id="r-349234" data-claire-element-id="349234"><tr id="r-349233" data-claire-element-id="349233"><th id="r-349230" data-claire-element-id="349230"><p id="r-349229" data-claire-element-id="349229">Classe</p></th><th id="r-349232" data-claire-element-id="349232"><p id="r-349231" data-claire-element-id="349231">Description</p></th></tr></thead><tbody id="r-349260" data-claire-element-id="349260"><tr id="r-349239" data-claire-element-id="349239"><td id="r-349236" data-claire-element-id="349236"><p id="r-349235" data-claire-element-id="349235"><code data-claire-semantic="cpp">std::list</code></p></td><td id="r-349238" data-claire-element-id="349238"><p id="r-349237" data-claire-element-id="349237">Liste doublement chaînée</p></td></tr><tr id="r-349244" data-claire-element-id="349244"><td id="r-349241" data-claire-element-id="349241"><p id="r-349240" data-claire-element-id="349240"><code data-claire-semantic="cpp">std::stack</code></p></td><td id="r-349243" data-claire-element-id="349243"><p id="r-349242" data-claire-element-id="349242">Bien pratique pour manipuler des piles</p></td></tr><tr id="r-349249" data-claire-element-id="349249"><td id="r-349246" data-claire-element-id="349246"><p id="r-349245" data-claire-element-id="349245"><code data-claire-semantic="cpp">std::queue</code></p></td><td id="r-349248" data-claire-element-id="349248"><p id="r-349247" data-claire-element-id="349247">Idéal pour les files</p></td></tr><tr id="r-349254" data-claire-element-id="349254"><td id="r-349251" data-claire-element-id="349251"><p id="r-349250" data-claire-element-id="349250"><code data-claire-semantic="cpp">std::deque</code></p></td><td id="r-349253" data-claire-element-id="349253"><p id="r-349252" data-claire-element-id="349252">Liste optimisée pour l'accès arbitraire</p></td></tr><tr id="r-349259" data-claire-element-id="349259"><td id="r-349256" data-claire-element-id="349256"><p id="r-349255" data-claire-element-id="349255"><code data-claire-semantic="cpp">std::forward_list</code></p></td><td id="r-349258" data-claire-element-id="349258"><p id="r-349257" data-claire-element-id="349257">Liste simplement chaînée (C++0x)</p></td></tr></tbody></table><h2 id="r-tableau-associatif-et-ensemble" data-claire-element-id="349313">Tableau associatif et ensemble</h2><p id="r-349263" data-claire-element-id="349263">Vous pouvez être amené à vouloir implémenter un dictionnaire ou toute autre association d'un élément à un autre. On parle de tableaux associatifs ou tables de symboles. On les utilise par exemple en compilation où elles peuvent associer un nom de variable à son type, une fonction avec sa définition, etc. Cette structure de données se doit d'être efficace dans la recherche d'un élément à partir de sa clef (par exemple un mot avec sa définition dans le cas d'un dictionnaire) et dans l'insertion d'un couple (clef, élément).</p><p id="r-349264" data-claire-element-id="349264">L'implémentation de ce type abstrait est souvent faite par le biais d'une table de hachage. Il s'agit en réalité d'un tableau ordinaire (pour simplifier la chose). Les indices sont des nombres entiers calculés à partir des clefs (qui peuvent être n'importe quoi) via une <em>fonction</em> de hachage. On assimile généralement ce genre de structure à <code data-claire-semantic="cpp">std::map</code>, ce qui est une grossière erreur. Vous verrez qu'un objet de type <code data-claire-semantic="cpp">std::map</code> représente en réalité autre chose.</p><p id="r-349265" data-claire-element-id="349265">Un peu de la même manière, on peut implémenter les ensembles. La vérification de l'existence d'un élément dans un ensemble ainsi que les opérations d'insertion doivent être possibles en temps constant.</p><table id="r-349283" data-claire-element-id="349283"><thead id="r-349271" data-claire-element-id="349271"><tr id="r-349270" data-claire-element-id="349270"><th id="r-349267" data-claire-element-id="349267"><p id="r-349266" data-claire-element-id="349266">Opérations</p></th><th id="r-349269" data-claire-element-id="349269"><p id="r-349268" data-claire-element-id="349268">Complexité</p></th></tr></thead><tbody id="r-349282" data-claire-element-id="349282"><tr id="r-349276" data-claire-element-id="349276"><td id="r-349273" data-claire-element-id="349273"><p id="r-349272" data-claire-element-id="349272">Recherche</p></td><td id="r-349275" data-claire-element-id="349275"><p id="r-349274" data-claire-element-id="349274">O(1)</p></td></tr><tr id="r-349281" data-claire-element-id="349281"><td id="r-349278" data-claire-element-id="349278"><p id="r-349277" data-claire-element-id="349277">Insertion</p></td><td id="r-349280" data-claire-element-id="349280"><p id="r-349279" data-claire-element-id="349279">O(1)</p></td></tr></tbody></table><table id="r-349311" data-claire-element-id="349311"><thead id="r-349289" data-claire-element-id="349289"><tr id="r-349288" data-claire-element-id="349288"><th id="r-349285" data-claire-element-id="349285"><p id="r-349284" data-claire-element-id="349284">Classe</p></th><th id="r-349287" data-claire-element-id="349287"><p id="r-349286" data-claire-element-id="349286">Description</p></th></tr></thead><tbody id="r-349310" data-claire-element-id="349310"><tr id="r-349294" data-claire-element-id="349294"><td id="r-349291" data-claire-element-id="349291"><p id="r-349290" data-claire-element-id="349290"><code data-claire-semantic="cpp">boost::unordered_map</code></p></td><td id="r-349293" data-claire-element-id="349293"><p id="r-349292" data-claire-element-id="349292">Adapté pour les tableaux associatifs</p></td></tr><tr id="r-349299" data-claire-element-id="349299"><td id="r-349296" data-claire-element-id="349296"><p id="r-349295" data-claire-element-id="349295"><code data-claire-semantic="cpp">boost::unordered_set</code></p></td><td id="r-349298" data-claire-element-id="349298"><p id="r-349297" data-claire-element-id="349297">Pour les ensembles d'éléments</p></td></tr><tr id="r-349304" data-claire-element-id="349304"><td id="r-349301" data-claire-element-id="349301"><p id="r-349300" data-claire-element-id="349300"><code data-claire-semantic="cpp">boost::unordered_multimap</code></p></td><td id="r-349303" data-claire-element-id="349303"><p id="r-349302" data-claire-element-id="349302">Tableaux associatifs où une clef peut référer à plusieurs éléments</p></td></tr><tr id="r-349309" data-claire-element-id="349309"><td id="r-349306" data-claire-element-id="349306"><p id="r-349305" data-claire-element-id="349305"><code data-claire-semantic="cpp">boost::unordered_multiset</code></p></td><td id="r-349308" data-claire-element-id="349308"><p id="r-349307" data-claire-element-id="349307">Ensembles dans lesquels une valeur peut être présente plus d'une fois</p></td></tr></tbody></table><p id="r-349312" data-claire-element-id="349312">De la même manière que <code data-claire-semantic="cpp">boost::array</code>, ces classes font désormais partie de la STL. Vous les retrouvez donc également dans l'espace de nom standard.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees">C++ : Bien choisir ses structures de données</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/importance-d-un-choix-ideal">
Importance d&#039;un choix idéal
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-structures-lineaires">
Les structures linéaires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-arbres">
Les arbres
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/le-mot-de-la-fin-2">
Le mot de la fin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/importance-d-un-choix-ideal">
<span class="arrow"></span>
<span class="next">Importance d&#039;un choix idéal</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-arbres">
<span class="next">Les arbres</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesarbres"></a><h2>Les arbres</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-structures-lineaires">
<span class="arrow"></span>
<span class="next">Les structures linéaires</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/le-mot-de-la-fin-2">
<span class="next">Le mot de la fin</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-qu-est-ce-2" data-claire-element-id="349316">Qu'est-ce ?</h2><p id="r-349315" data-claire-element-id="349315">Un arbre est un graphe acyclique orienté où l'on a définit un nœud central appelé <em>racine</em> et dans lequel chaque nœud (sauf la racine) admet exactement un parent. Les nœuds n'admettant pas de fils sont dits <em>feuilles</em>. Concrètement, une telle structure peut se représenter sous une forme arborescente que vous connaissez bien (je suppose).</p><h2 id="r-les-tas" data-claire-element-id="349362">Les tas</h2><p id="r-349317" data-claire-element-id="349317">Un tas est un arbre binaire, c'est-à-dire que chaque nœud comporte au plus deux nœuds fils. La particularité du tas réside dans l'ordre qu'il impose à ses éléments : chaque parent doit avoir une valeur plus grande (ou plus petite, mais c'est plus rare) que ses fils. Le maximum (respectivement le minimum) correspond donc à la racine. Un tas est conventionnellement équilibré, c'est-à-dire que sa profondeur en chaque point varie au plus d'une unité.</p><p id="r-349318" data-claire-element-id="349318">Les opérations que l'on peut effectuer sur un tas sont typiquement les suivantes : récupération du maximum et insertion d'un élément. Toute la subtilité réside dans le fait de devoir réaliser ces opérations sans perturber la caractère essentiel du tas.</p><p id="r-349319" data-claire-element-id="349319">Il est possible d'implémenter un tas (et tout arbre binaire équilibré) de manière linéaire, sous la forme d'un tableau. On s'imposera alors simplement une convention permettant d'associer chaque nœuds à ses fils : les deux fils du nœud à l'indice n ont respectivement pour indice 2n+1 et 2n+2 (si l'indexage commence à 0, ce qui est souvent le cas).</p><p id="r-349320" data-claire-element-id="349320">Le champ d'application des tas est très vaste : on peut s'en servir pour classer des tâches, de la plus prioritaire à la moins importante, mais cette structure est également le pilier d'un algorithme de tri appelé tri par tas. Certains langages s'en servent aussi pour les allocations dynamiques de mémoire (les allocations statiques étant effectuées sur une pile).</p><table id="r-349343" data-claire-element-id="349343"><thead id="r-349326" data-claire-element-id="349326"><tr id="r-349325" data-claire-element-id="349325"><th id="r-349322" data-claire-element-id="349322"><p id="r-349321" data-claire-element-id="349321">Opérations</p></th><th id="r-349324" data-claire-element-id="349324"><p id="r-349323" data-claire-element-id="349323">Complexité</p></th></tr></thead><tbody id="r-349342" data-claire-element-id="349342"><tr id="r-349331" data-claire-element-id="349331"><td id="r-349328" data-claire-element-id="349328"><p id="r-349327" data-claire-element-id="349327">Lecture du maximum</p></td><td id="r-349330" data-claire-element-id="349330"><p id="r-349329" data-claire-element-id="349329">O(1)</p></td></tr><tr id="r-349336" data-claire-element-id="349336"><td id="r-349333" data-claire-element-id="349333"><p id="r-349332" data-claire-element-id="349332">Suppression du maximum</p></td><td id="r-349335" data-claire-element-id="349335"><p id="r-349334" data-claire-element-id="349334">O(\log{n})</p></td></tr><tr id="r-349341" data-claire-element-id="349341"><td id="r-349338" data-claire-element-id="349338"><p id="r-349337" data-claire-element-id="349337">Insertion d'un élément</p></td><td id="r-349340" data-claire-element-id="349340"><p id="r-349339" data-claire-element-id="349339">O(\log{n})</p></td></tr></tbody></table><table id="r-349361" data-claire-element-id="349361"><thead id="r-349349" data-claire-element-id="349349"><tr id="r-349348" data-claire-element-id="349348"><th id="r-349345" data-claire-element-id="349345"><p id="r-349344" data-claire-element-id="349344">Solution</p></th><th id="r-349347" data-claire-element-id="349347"><p id="r-349346" data-claire-element-id="349346">Description</p></th></tr></thead><tbody id="r-349360" data-claire-element-id="349360"><tr id="r-349354" data-claire-element-id="349354"><td id="r-349351" data-claire-element-id="349351"><p id="r-349350" data-claire-element-id="349350"><code data-claire-semantic="cpp">std::priority_queue</code> (classe)</p></td><td id="r-349353" data-claire-element-id="349353"><p id="r-349352" data-claire-element-id="349352">Idéal pour les files de priorité (implémentées par un tas)</p></td></tr><tr id="r-349359" data-claire-element-id="349359"><td id="r-349356" data-claire-element-id="349356"><p id="r-349355" data-claire-element-id="349355"><code data-claire-semantic="cpp">std::make_heap</code>, <code data-claire-semantic="cpp">std::push_heap</code>, <code data-claire-semantic="cpp">std::pop_heap</code><br/> (fonctions)</p></td><td id="r-349358" data-claire-element-id="349358"><p id="r-349357" data-claire-element-id="349357">Conçu pour les tas représentés linéairement</p></td></tr></tbody></table><h2 id="r-les-arbres-binaires-de-recherche" data-claire-element-id="349430">Les arbres binaires de recherche</h2><p id="r-349363" data-claire-element-id="349363">Une deuxième catégorie d'arbre est également souvent sollicitée : les arbres binaires de recherche, ou ABR. Dans un tel arbre, tous les éléments du sous-arbre gauche à un nœud n sont inférieurs à n et tous les éléments du sous-arbre droit lui sont supérieurs. On doit retrouver cette propriété de manière récursive au niveau de chaque nœud.</p><p id="r-349364" data-claire-element-id="349364">Un ABR est donc une manière de représenter une collection triée d'éléments. C'est pour cette raison qu'elle est uniquement envisageable quand les éléments sont comparables entre eux (si a et b sont deux éléments, on doit pouvoir dire si a &lt; b est vrai ou faux). Généralement la fonction de comparaison est paramétrable, permettant n'importe quelle arborescence triée souhaitée. L'intérêt d'un ABR réside dans la recherche et l'insertion d'éléments dans un ensemble trié : celles-ci doivent être optimales tout en conservant l'ordre entre les éléments.</p><p id="r-349365" data-claire-element-id="349365">C'est pour cette raison qu'un ABR est idéalement équilibré, sinon on pourrait très bien envisager un arbre balancé uniquement d'un côté qui ne serait en fait nullement différent d'une simple liste chaînée triée. Dans ce cas l'insertion et la recherche d'un élément tout en conservant l'ordre ne seraient plus optimales du tout. Il existe différent type d'ABR équilibré : les arbres rouge-noir, les AVL, etc.</p><p id="r-349366" data-claire-element-id="349366">Il est possible d'utiliser un ABR de manière naïve où chaque élément ne représente qu'une information. Cependant, on peut l'utiliser d'une deuxième manière : en l'ordonnant selon des clefs et en ajoutant à chaque nœud un attribut supplémentaire correspondant à une valeur, on arrive à reproduire le type abstrait d'un tableau associatif. La seule différence réside alors dans le fait que l'on aurait alors une notion d'ordre, qui induit évident des performances moins spectaculaires que les tables de hachage.</p><p id="r-349367" data-claire-element-id="349367">Il est intéressant de noter que la valeur la plus à gauche de l'arborescence se trouve être le minimum de l'ensemble. Symétriquement, la valeur la plus à droite est le maximum. On peut alors stocker une référence sur chacune de ses valeurs afin d'y accéder en temps constant.</p><table id="r-349395" data-claire-element-id="349395"><thead id="r-349373" data-claire-element-id="349373"><tr id="r-349372" data-claire-element-id="349372"><th id="r-349369" data-claire-element-id="349369"><p id="r-349368" data-claire-element-id="349368">Opérations</p></th><th id="r-349371" data-claire-element-id="349371"><p id="r-349370" data-claire-element-id="349370">Complexité</p></th></tr></thead><tbody id="r-349394" data-claire-element-id="349394"><tr id="r-349378" data-claire-element-id="349378"><td id="r-349375" data-claire-element-id="349375"><p id="r-349374" data-claire-element-id="349374">Lecture du maximum</p></td><td id="r-349377" data-claire-element-id="349377"><p id="r-349376" data-claire-element-id="349376">O(1)</p></td></tr><tr id="r-349383" data-claire-element-id="349383"><td id="r-349380" data-claire-element-id="349380"><p id="r-349379" data-claire-element-id="349379">Lecture du minimum</p></td><td id="r-349382" data-claire-element-id="349382"><p id="r-349381" data-claire-element-id="349381">O(1)</p></td></tr><tr id="r-349388" data-claire-element-id="349388"><td id="r-349385" data-claire-element-id="349385"><p id="r-349384" data-claire-element-id="349384">Insertion d'un élément</p></td><td id="r-349387" data-claire-element-id="349387"><p id="r-349386" data-claire-element-id="349386">O(\log{n}) (ABR équilibré)</p></td></tr><tr id="r-349393" data-claire-element-id="349393"><td id="r-349390" data-claire-element-id="349390"><p id="r-349389" data-claire-element-id="349389">Recherche d'un élément</p></td><td id="r-349392" data-claire-element-id="349392"><p id="r-349391" data-claire-element-id="349391">O(\log{n}) (ABR équilibré)</p></td></tr></tbody></table><table id="r-349428" data-claire-element-id="349428"><thead id="r-349401" data-claire-element-id="349401"><tr id="r-349400" data-claire-element-id="349400"><th id="r-349397" data-claire-element-id="349397"><p id="r-349396" data-claire-element-id="349396">Classe</p></th><th id="r-349399" data-claire-element-id="349399"><p id="r-349398" data-claire-element-id="349398">Description</p></th></tr></thead><tbody id="r-349427" data-claire-element-id="349427"><tr id="r-349406" data-claire-element-id="349406"><td id="r-349403" data-claire-element-id="349403"><p id="r-349402" data-claire-element-id="349402"><code data-claire-semantic="cpp">std::set</code></p></td><td id="r-349405" data-claire-element-id="349405"><p id="r-349404" data-claire-element-id="349404">Idéal pour les ABR équilibrés et les ensembles ordonnés</p></td></tr><tr id="r-349411" data-claire-element-id="349411"><td id="r-349408" data-claire-element-id="349408"><p id="r-349407" data-claire-element-id="349407"><code data-claire-semantic="cpp">std::map</code></p></td><td id="r-349410" data-claire-element-id="349410"><p id="r-349409" data-claire-element-id="349409">Tableau associatif ordonné</p></td></tr><tr id="r-349416" data-claire-element-id="349416"><td id="r-349413" data-claire-element-id="349413"><p id="r-349412" data-claire-element-id="349412"><code data-claire-semantic="cpp">std::multiset</code></p></td><td id="r-349415" data-claire-element-id="349415"><p id="r-349414" data-claire-element-id="349414">Ensemble ordonné pouvant contenir plusieurs fois la même valeur</p></td></tr><tr id="r-349421" data-claire-element-id="349421"><td id="r-349418" data-claire-element-id="349418"><p id="r-349417" data-claire-element-id="349417"><code data-claire-semantic="cpp">std::multimap</code></p></td><td id="r-349420" data-claire-element-id="349420"><p id="r-349419" data-claire-element-id="349419">Tableau associatif ordonné pouvant indexer plusieurs fois la même clef</p></td></tr><tr id="r-349426" data-claire-element-id="349426"><td id="r-349423" data-claire-element-id="349423"><p id="r-349422" data-claire-element-id="349422"><code data-claire-semantic="cpp">boost::bimap</code></p></td><td id="r-349425" data-claire-element-id="349425"><p id="r-349424" data-claire-element-id="349424">Tableau associatif ordonné avec association dans les deux sens</p></td></tr></tbody></table><p id="r-349429" data-claire-element-id="349429">Essayez d'insérer des nombres en désordre dans un objet de type <code data-claire-semantic="cpp">std::set</code>. Ensuite, parcourez l'ensemble à l'aide des itérateurs que vous fournis la classe et remarquez que vous récupérer vos nombres de manière triée. Oui oui, si l'on a de la mémoire à gâcher, on peut implémenter un tri optimal basé sur les comparaisons (en O(n\log{n})) en se servant uniquement de <code data-claire-semantic="cpp">std::set</code> ou <code data-claire-semantic="cpp">std::multiset</code> !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees">C++ : Bien choisir ses structures de données</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/importance-d-un-choix-ideal">
Importance d&#039;un choix idéal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-structures-lineaires">
Les structures linéaires
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-arbres">
Les arbres
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/le-mot-de-la-fin-2">
Le mot de la fin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-structures-lineaires">
<span class="arrow"></span>
<span class="next">Les structures linéaires</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/le-mot-de-la-fin-2">
<span class="next">Le mot de la fin</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lemotdelafin"></a><h2>Le mot de la fin</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-arbres">
<span class="arrow"></span>
<span class="next">Les arbres</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-349432" data-claire-element-id="349432">Ce n'est pas tout ! Il existe bien d'autres structures de données avec leurs implémentations respectives. Un exemple assez exotique est Boost.Fusion. Cette bibliothèque propose une version des conteneurs classiques adaptés... à la méta-programmation template. Je vous laisse voir ça par vous-même, <a href="http://www.boost.org/doc/libs/1_49_0/libs/fusion/doc/html/fusion/container.html">ici</a>.</p><p id="r-349433" data-claire-element-id="349433">De plus, il est parfois nécessaire d'avoir une structure qui permette non pas de stocker plusieurs éléments, mais un seul élément qui peut avoir plusieurs types. Quand ces types sont connus à l'avance, on utilisera <code data-claire-semantic="cpp"><a href="http://www.boost.org/doc/libs/1_49_0/doc/html/variant.html">boost::variant</a></code>. Cette classe remplace une lacune du C++ qui est la mauvaise gestion du conteneur de type union. Quand on ne connait pas les différents types possibles, on applique une stratégie de <a href="http://en.wikipedia.org/wiki/Type_erasure">type erasure</a>. Une bonne implémentation de ce concept : <code data-claire-semantic="cpp"><a href="http://www.boost.org/doc/libs/1_49_0/doc/html/any.html">boost::any</a></code>.</p><p id="r-349434" data-claire-element-id="349434">Il existe également bon nombre d'algorithmes qui travaillent sur des graphes. Heureusement, Boost est encore là pour nous sauver avec <a href="http://www.boost.org/doc/libs/1_49_0/libs/graph/doc/index.html">Boost.Graph</a>. Plus rarement, on peut vouloir manipuler une structure circulaire (imaginer un tableau dont la dernière case rejoint ensuite la première), par exemple pour implémenter une playlist. Pour cela, il y a <code data-claire-semantic="cpp"><a href="http://www.boost.org/doc/libs/1_37_0/libs/circular_buffer/doc/circular_buffer.html">boost::circular_buffer</a></code>. Et si déjà je me retrouve à parler un peu de tout, autant ne pas le faire à moitié : pour les tableaux de bits (<code data-claire-semantic="cpp">std::bitset</code>) dont on ne connait pas la taille à la compilation, il y a <code data-claire-semantic="cpp"><a href="http://www.boost.org/doc/libs/1_36_0/libs/dynamic_bitset/dynamic_bitset.html">boost::dynamic_bitset</a></code>.</p><p id="r-349435" data-claire-element-id="349435">Avant de vous laisser, je tenais à partager avec vous ce remarquable schéma que j'ai pu trouver sur <a href="http://cpp.developpez.com/faq/cpp/?page=STL#STL_choix_conteneur">developpez.com</a> :</p><figure id="r-349437" data-claire-element-id="349438"><img id="r-349436" data-claire-element-id="349436" src="medias/uploads.siteduzero.com_files_368001_369000_368983.gif" alt="Image utilisateur"/></figure><p id="r-349439" data-claire-element-id="349439">J'espère que ce cours servira à plus d'un. Je pourrais encore vous marteler le fait que le choix d'une structure de données adaptée à votre problème est une chose primordiale. Vous ne pouvez pas espérer coder efficacement si vous n'avez pas ce réflexe et si vous utilisez <code data-claire-semantic="cpp">std::vector</code> à tort et à travers par exemple. Je veux bien que cette classe soit simple et pratique, mais ce n'est pas une raison. C'est aussi le cas de toutes les classes que je viens de vous présenter, alors : soyez efficace. :) (premier smiley)</p><p id="r-349440" data-claire-element-id="349440">Bon codage !</p><p id="r-349441" data-claire-element-id="349441">Olivier Strebler</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees">C++ : Bien choisir ses structures de données</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/importance-d-un-choix-ideal">
Importance d&#039;un choix idéal
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-structures-lineaires">
Les structures linéaires
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-arbres">
Les arbres
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/le-mot-de-la-fin-2">
Le mot de la fin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/c-bien-choisir-ses-structures-de-donnees/les-arbres">
<span class="arrow"></span>
<span class="next">Les arbres</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/c-bien-choisir-ses-structures-de-donnees.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 00:05:53 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/c-bien-choisir-ses-structures-de-donnees.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:16:12 GMT -->
</html>
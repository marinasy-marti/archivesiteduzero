<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/modifier-une-image-pixel-par-pixel.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 08:28:23 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/modifier-une-image-pixel-par-pixel.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:31:18 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Modifier une image pixel par pixel</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/modifier-une-image-pixel-par-pixel.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Modifier une image pixel par pixel</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Modifieruneimagepixelparpixel">Modifier une image pixel par pixel</a><br/><a href="#Unpeudethorie">Un peu de théorie</a><br/><a href="#Lesbasestechniquespourqueafonctionne">Les bases techniques pour que ça fonctionne</a><br/><a href="#TPDenouveauxeffetsstyls">TP : De nouveaux effets stylés !</a><br/><a href="#TPBalancedescouleurs">TP : Balance des couleurs</a><br/></div>
<a name="Modifieruneimagepixelparpixel"></a><h2>Modifier une image pixel par pixel</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/un-peu-de-theorie-12">
<span class="next">Un peu de théorie</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-550911" data-claire-element-id="550911">Bonjour !! Soyez les bienvenus dans ce mini-tuto qui va vous apprendre à modifier une image pixel par pixel en SDL.</p><div id="r-550913" data-claire-element-id="550913" data-claire-semantic="question"><p id="r-550912" data-claire-element-id="550912">Qu'est-ce que la SDL ?</p></div><p id="r-550914" data-claire-element-id="550914">:o ... Hélas, ceci est un mini-tuto et je vais me concentrer sur l'essentiel. :) Donc si vous ne savez pas ce que c'est que le C, la SDL, pas la peine de s'embêter à lire ce tutoriel, il ne vous sera pas d'une grande aide. Je vous conseille plutôt d'aller voir le très bon tutoriel de M@teo21 <a href="http://www.siteduzero.com/tuto-3-8-0-apprenez-a-programmer-en-c.html">ici</a>.</p><p id="r-550915" data-claire-element-id="550915">Les pré requis :</p><p id="r-550916" data-claire-element-id="550916">Et bien il faut connaître à fond le tutoriel de M@teo21 sur le C/C++ :) <br/> Vous devez disposer d'un IDE C++, avec la SDL installée.</p><p id="r-550917" data-claire-element-id="550917">Et puis... c'est tout :D</p><div id="r-550919" data-claire-element-id="550919" data-claire-semantic="question"><p id="r-550918" data-claire-element-id="550918">Et que saura t'on faire à la fin ?</p></div><aside id="r-550921" data-claire-element-id="550921" data-claire-semantic="information"><p id="r-550920" data-claire-element-id="550920">Modifier une image pixel par pixel. Plus précisément, je vais dans un premier temps m'attacher à l'exemple de la réalisation d'une balance des couleurs, puis nous verrons d'autres fonctions particulièrement intéressantes à réaliser.</p></aside>
</div><a name="Unpeudethorie"></a><h2>Un peu de théorie</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/les-bases-techniques-pour-que-ca-fonctionne">
<span class="next">Les bases techniques pour que ça fonctionne</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-550922" data-claire-element-id="550922"><strong>Posons le problème</strong></p><p id="r-550923" data-claire-element-id="550923">Pour ce tutoriel, je vais partir du principe que vous n'êtes plus tout à fait des zéros ;) .</p><p id="r-550924" data-claire-element-id="550924">Voici notre problème principal :</p><div id="r-550926" data-claire-element-id="550926" data-claire-semantic="question"><p id="r-550925" data-claire-element-id="550925">Lorsque j'utilise la SDL, comment faire pour modifier mes images en direct, les assombrir, enlever la moitié des pixels, dessiner un éléphant rose ?</p></div><p id="r-550927" data-claire-element-id="550927">Bon pour l'éléphant rose, je cherche encore :p .</p><p id="r-550928" data-claire-element-id="550928"><strong>Comment faire ?</strong></p><p id="r-550929" data-claire-element-id="550929">Le principe est extrêmement simple :</p><p id="r-550930" data-claire-element-id="550930">Vous savez naturellement ce qu'est une surface en SDL :D . (Sinon, allez hop au galop on va relire le cours <a href="http://www.siteduzero.com/tuto-3-5300-1-creation-d-une-fenetre-et-de-surfaces.html#ss_part_3">ici</a>)</p><p id="r-550931" data-claire-element-id="550931">Une surface est un ensemble de pixels. Elle est composée de n pixels, avec n = son nombre de pixels en largeur multiplié par son nombre de pixels en hauteur.</p><p id="r-550932" data-claire-element-id="550932">Qu'est-ce qu'un pixel ? C'est un point sur l'écran :p . Dans une surface, il contient 4 informations : une valeur en rouge, une valeur en vert, une valeur en bleu, et une valeur en alpha.<br/> Je suppose que RVB, vous voyez ce que c'est ;) .</p><div id="r-550934" data-claire-element-id="550934" data-claire-semantic="question"><p id="r-550933" data-claire-element-id="550933">Mais Alpha, c'est quoi ce machin la ?</p></div><p id="r-550935" data-claire-element-id="550935">Et bien cela représente le degré de transparence (entre 0 et 255) du pixel. Avec 255, le pixel est opaque, avec 0 il est transparent.</p><p id="r-550936" data-claire-element-id="550936">M@teo21 en a déjà causé <a href="http://www.siteduzero.com/tuto-3-5432-1-afficher-des-images.html#ss_part_2">ici</a>.</p><p id="r-550937" data-claire-element-id="550937">Le souci c'est qu'il parle d'une transparence alpha s'appliquant de manière globale, à une image entière.<br/> Il est possible de mettre une valeur alpha différente pour chaque pixel, c'est d?ailleurs le principe des masques. Je ne vais pas m'appesantir sur le sujet pour le moment, sachez seulement que ça existe, voici d?ailleurs une image expliquant assez clairement comment fonctionne un masque :</p><figure id="r-550939" data-claire-element-id="550940"><img id="r-550938" data-claire-element-id="550938" src="medias/uploads.siteduzero.com_files_5001_6000_5999.jpg" alt="Image utilisateur"/></figure><p id="r-550941" data-claire-element-id="550941">Ca va jusque là ;) ? J'espère... :-°</p><p id="r-550942" data-claire-element-id="550942"><strong>Qu'allons nous donc faire ?</strong></p><p id="r-550943" data-claire-element-id="550943">Très simple :</p><p id="r-550944" data-claire-element-id="550944">1)Je prends ma surface.<br/> 2)Je parcours ma surface suivant l'axe des X et l'axe des Y, et je modifie chaque pixel comme je l'entends.<br/> 3)Je libère ma surface.</p><p id="r-550945" data-claire-element-id="550945">Cependant, il y a quand même quelques complications :euh: .</p><p id="r-550946" data-claire-element-id="550946">En effet, pour modifier un pixel, il faut récupérer l'adresse de ce pixel dans la surface, puis récupérer la valeur représentant la couleur du pixel, la décomposer suivant ses quatre composantes, modifier ces composantes, les réunir en une seule valeur, et renvoyer cette information à l?adresse du pixel.</p><p id="r-550947" data-claire-element-id="550947">Pfiou... :euh: ça m'a pas l'air si simple que ça finalement :euh:</p><p id="r-550948" data-claire-element-id="550948">Ne vous inquiétez pas, on va réussir à simplifier grandement le problème. En effet, vous n'êtes pas les premiers à vouloir modifier une image pixel par pixel. Dans la documentation de la SDL, les exemples de codes pour modifier un pixel sont fournis. Et une fois qu'on les a, tout se simplifie !!</p><p id="r-550949" data-claire-element-id="550949">Donc merci la doc SDL et merci Internet, ça prémache le boulot :D :D</p><p id="r-550950" data-claire-element-id="550950">Bon, et bien on a tout vu d'un point de vue théorique. Si c'est pas clair... :o Je pense que ça le deviendra avec l'application !! C'est partiii !! :p</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel">Modifier une image pixel par pixel</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/un-peu-de-theorie-12">
Un peu de théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/les-bases-techniques-pour-que-ca-fonctionne">
Les bases techniques pour que ça fonctionne
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-de-nouveaux-effets-styles">
TP : De nouveaux effets stylés !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-balance-des-couleurs">
TP : Balance des couleurs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/les-bases-techniques-pour-que-ca-fonctionne">
<span class="next">Les bases techniques pour que ça fonctionne</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesbasestechniquespourqueafonctionne"></a><h2>Les bases techniques pour que ça fonctionne</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/un-peu-de-theorie-12">
<span class="arrow"></span>
<span class="next">Un peu de théorie</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-de-nouveaux-effets-styles">
<span class="next">TP : De nouveaux effets stylés !</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-550952" data-claire-element-id="550952">Dans cette seconde partie, nous allons étudier toutes les petites briques à assembler pour créer un superbe lego.</p><aside id="r-550954" data-claire-element-id="550954" data-claire-semantic="warning"><p id="r-550953" data-claire-element-id="550953">Attention, cette fois on rentre dans le code, et tout de suite c'est un peu moins marrant.</p></aside><p id="r-550955" data-claire-element-id="550955">Lesquelles ? Haha !! Grande question ;) .<br/> En fait, il nous faut une fonction pour connaître la couleur d'un pixel, et une fonction pour modifier sa couleur.</p><p id="r-550956" data-claire-element-id="550956">Et c'est la partie la plus difficile de ce tutoriel. En effet, ce sont des notions que vous n'avez pas forcement vus avec M@teo21, et qui ne sont pas évidentes à comprendre.</p><p id="r-550957" data-claire-element-id="550957">Je vous propose donc d'utiliser ces fonctions comme des boites noires :euh: . On se fiche de savoir comment elles fonctionnent, du moment qu'elles marchent autant s'en servir. Ce n'est pas très déontologique, mais ça va nous permettre d'avancer plus vite.</p><p id="r-550958" data-claire-element-id="550958">J'ai décidé de quand même commenter le code, si vous maitrisez les pointeurs et les zones de mémoires, le fonctionnement devrait vous paraitre plus clair.</p><p id="r-550959" data-claire-element-id="550959">D'abord, récupérer la couleur d'un pixel :</p><pre id="r-550960" data-claire-element-id="550960"><code data-claire-semantic="c">/* ********************************************************************* */
/*obtenirPixel : permet de récupérer la couleur d'un pixel
Paramètres d'entrée/sortie :
SDL_Surface *surface : la surface sur laquelle on va récupérer la couleur d'un pixel
int x : la coordonnée en x du pixel à récupérer
int y : la coordonnée en y du pixel à récupérer

Uint32 resultat : la fonction renvoie le pixel aux coordonnées (x,y) dans la surface
*/
Uint32 obtenirPixel(SDL_Surface *surface, int x, int y)
{
    /*nbOctetsParPixel représente le nombre d'octets utilisés pour stocker un pixel.
    En multipliant ce nombre d'octets par 8 (un octet = 8 bits), on obtient la profondeur de couleur
    de l'image : 8, 16, 24 ou 32 bits.*/
    int nbOctetsParPixel = surface-&gt;format-&gt;BytesPerPixel;
    /* Ici p est l'adresse du pixel que l'on veut connaitre */
    /*surface-&gt;pixels contient l'adresse du premier pixel de l'image*/
    Uint8 *p = (Uint8 *)surface-&gt;pixels + y * surface-&gt;pitch + x * nbOctetsParPixel;

    /*Gestion différente suivant le nombre d'octets par pixel de l'image*/
    switch(nbOctetsParPixel)
    {
        case 1:
            return *p;

        case 2:
            return *(Uint16 *)p;

        case 3:
            /*Suivant l'architecture de la machine*/
            if(SDL_BYTEORDER == SDL_BIG_ENDIAN)
                return p[0] &lt;&lt; 16 | p[1] &lt;&lt; 8 | p[2];
            else
                return p[0] | p[1] &lt;&lt; 8 | p[2] &lt;&lt; 16;

        case 4:
            return *(Uint32 *)p;

        /*Ne devrait pas arriver, mais évite les erreurs*/
        default:
            return 0; 
    }
}</code></pre><div id="r-550962" data-claire-element-id="550962" data-claire-semantic="question"><p id="r-550961" data-claire-element-id="550961">Que doit t'on retenir ?</p></div><p id="r-550963" data-claire-element-id="550963">- Cette fonction reçoit une surface en paramètre, ainsi que la position en X et en Y du pixel sur l'image (rappel : le point de coordonnées 0,0 est en haut à gauche de l'image).<br/> - Elle retourne un entier qui décrit la couleur du pixel (rouge, vert, bleu et alpha).</p><p id="r-550964" data-claire-element-id="550964">Donc, sur le même principe, voici comment modifier un pixel :</p><pre id="r-550965" data-claire-element-id="550965"><code data-claire-semantic="c">/* ********************************************************************* */
/*definirPixel : permet de modifier la couleur d'un pixel
Paramètres d'entrée/sortie :
SDL_Surface *surface : la surface sur laquelle on va modifier la couleur d'un pixel
int x : la coordonnée en x du pixel à modifier
int y : la coordonnée en y du pixel à modifier
Uint32 pixel : le pixel à insérer
*/
void definirPixel(SDL_Surface *surface, int x, int y, Uint32 pixel)
{
    /*nbOctetsParPixel représente le nombre d'octets utilisés pour stocker un pixel.
    En multipliant ce nombre d'octets par 8 (un octet = 8 bits), on obtient la profondeur de couleur
    de l'image : 8, 16, 24 ou 32 bits.*/
    int nbOctetsParPixel = surface-&gt;format-&gt;BytesPerPixel;
    /*Ici p est l'adresse du pixel que l'on veut modifier*/
    /*surface-&gt;pixels contient l'adresse du premier pixel de l'image*/
    Uint8 *p = (Uint8 *)surface-&gt;pixels + y * surface-&gt;pitch + x * nbOctetsParPixel;

    /*Gestion différente suivant le nombre d'octets par pixel de l'image*/
    switch(nbOctetsParPixel)
    {
        case 1:
            *p = pixel;
            break;

        case 2:
            *(Uint16 *)p = pixel;
            break;

        case 3:
            /*Suivant l'architecture de la machine*/
            if(SDL_BYTEORDER == SDL_BIG_ENDIAN)
            {
                p[0] = (pixel &gt;&gt; 16) &amp; 0xff;
                p[1] = (pixel &gt;&gt; 8) &amp; 0xff;
                p[2] = pixel &amp; 0xff;
            }
            else
            {
                p[0] = pixel &amp; 0xff;
                p[1] = (pixel &gt;&gt; 8) &amp; 0xff;
                p[2] = (pixel &gt;&gt; 16) &amp; 0xff;
            }
            break;

        case 4:
            *(Uint32 *)p = pixel;
            break;
    }
}</code></pre><p id="r-550966" data-claire-element-id="550966"><strong>De même :</strong><br/> Cette fonction reçoit en paramètre une surface, les coordonnées x et y du pixel, et la couleur que l'on veut y mettre.</p><div id="r-550968" data-claire-element-id="550968" data-claire-semantic="question"><p id="r-550967" data-claire-element-id="550967">L'intérêt principal de ces fonctions ?</p></div><p id="r-550969" data-claire-element-id="550969">Elles sont faites pour fonctionner avec <strong>n'importe quel format d'image</strong>, vous n'aurez jamais de couleurs faussées avec ces fonctions.</p><div id="r-550971" data-claire-element-id="550971" data-claire-semantic="question"><p id="r-550970" data-claire-element-id="550970">Mais... Qu'est-ce qu'un Uint32 ???</p></div><p id="r-550972" data-claire-element-id="550972">C'est un entier d'un type un peu particulier (<strong>non signé</strong> et <strong>enregistré sur 32 bits</strong>), créé par la bibliothèque SDL (il existe des Uint8, des Uint16, etc.).</p><p id="r-550973" data-claire-element-id="550973"><strong>Un entier non signé ne peut contenir que des valeurs positives</strong>. 32 bits indiques le nombre de valeurs qu'il peut prendre. <br/> Un <strong>Uint32</strong> peut prendre des valeurs entre 0 et (2^32) -1. <br/> Un <strong>Unit8</strong> peut prendre des valeurs entre 0 et (2^8) -1, c'est à dire entre 0 et 255.</p><p id="r-550974" data-claire-element-id="550974">Vous devez donc récupérer la valeur d'un pixel avec ce genre de code :</p><pre id="r-550975" data-claire-element-id="550975"><code data-claire-semantic="c">Uint32 pixel;
/*Pour récupérer le code couleur d'un pixel*/
pixel=obtenirPixel(surface,x,y);

/*Et pour changer la valeur d'un pixel*/
definirPixel(surface,x,y,pixel);</code></pre><p id="r-550976" data-claire-element-id="550976">Maintenant bien sur, ce qui nous intéresse, c'est modifier la valeur de la variable pixel.</p><p id="r-550977" data-claire-element-id="550977">Donc dans un premier temps, il faut <strong>récupérer</strong> les composantes rouge, vert, bleu et alpha du pixel, puis les <strong>modifier</strong>, et enfin les <strong>réinjecter</strong>.</p><aside id="r-550979" data-claire-element-id="550979" data-claire-semantic="warning"><p id="r-550978" data-claire-element-id="550978">En SDL, chaque composante couleur est stockée sur 8 bits. Ce sont donc des Uint8.</p></aside><p id="r-550980" data-claire-element-id="550980">On va utiliser les fonctions <strong>SDL_GetRGBA</strong> et <strong>SDL_MapRGBA</strong>.</p><p id="r-550981" data-claire-element-id="550981">Il faut lui passer les 4 variables de composante par référence.<br/> Voici un code relativement clair, du moins je l'espère :</p><pre id="r-550982" data-claire-element-id="550982"><code data-claire-semantic="c">/*Composantes pouvant prendre des valeurs entre 0 et 255*/
Uint8 r,g,b,a;
/* On extrait de pixel la valeur de chaque composante*/
SDL_GetRGBA(pixel, surface-&gt;format, &amp;r, &amp;v, &amp;b, &amp;a);

/* On modifiera ici les variables r, v, b et a.*/

/*Et une fois qu'on les a modifiées, on réinjecte dans pixel.*/
pixel=SDL_MapRGBA(surface-&gt;format, r, v, b, a);</code></pre><p id="r-550983" data-claire-element-id="550983"><strong>Petite précision :</strong> 'surface' est le nom de votre surface :p , et format permet à la fonction de connaître la façon dont sont enregistrés vos pixels (nous... on s'en fout :p ). Il faut juste retenir que le premier paramètre est sous la forme 'nomDeLaSurface-&gt;format'.</p><div id="r-550985" data-claire-element-id="550985" data-claire-semantic="question"><p id="r-550984" data-claire-element-id="550984">Heu.. Serait-il possible de résumer ?</p></div><p id="r-550986" data-claire-element-id="550986">Bien sur, bien sur :</p><pre id="r-550987" data-claire-element-id="550987"><code data-claire-semantic="c">Uint32 pixel;
Uint8 r,g,b,a;
int x,y;
x=3;
y=5;

SDL_LockSurface(surface); /*On bloque la surface*/

pixel=obtenirPixel(surface,x,y);
SDL_GetRGBA(pixel, surface-&gt;format, &amp;r, &amp;v, &amp;b, &amp;a);

/*Ici, on mettra du code pour modifier les composantes du pixel.*/

/*Et une fois qu'on les a modifiés :*/
pixel=SDL_MapRGBA(surface-&gt;format, r, v, b, a);

/*Et pour changer la valeur d'un pixel :*/
definirPixel(surface,x,y,pixel);

SDL_UnlockSurface(surface); /*On libère la surface, elle peut être utilisée pour une autre tâche*/</code></pre><p id="r-550988" data-claire-element-id="550988">C'est à peu près clair :) ? Bon bah on va pouvoir continuer !! C'est bientôt fini, ne vous inquiétez pas !! :D</p><p id="r-550989" data-claire-element-id="550989">Donc désormais, nous avons récupéré r, v, b, et a qui sont les composantes de notre pixel.</p><p id="r-550990" data-claire-element-id="550990">Ces composantes sont des Uint8. <strong>Ils sont stockés sur 8 bits</strong>. Donc... ?<br/> Et bien ils peuvent prendre chacun 256 valeurs différentes. <strong>C'est à dire une valeur entre 0 et 255.</strong></p><p id="r-550991" data-claire-element-id="550991">Comment ça je l'ai déjà dit ? :-° C'est pour que ça rentre mieux :D :D .</p><p id="r-550992" data-claire-element-id="550992">Le <strong>0</strong> indique <strong>l'absence de la composante</strong>, (et la <strong>transparence totale</strong> pour la composante alpha), et le <strong>255</strong> indique le <strong>maximum</strong> de cette couleur (et <strong>opaque</strong> pour la composante alpha).</p><p id="r-550993" data-claire-element-id="550993"><strong>Quelques exemples :</strong></p><p id="r-550994" data-claire-element-id="550994">r,g,b,a :</p><p id="r-550995" data-claire-element-id="550995">0,0,0,255 : Aucune couleur --&gt; noir. Et opaque.<br/> 255,255,255,255 : Toutes les couleurs --&gt; de la lumière blanche !! Et opaque aussi bien sur.<br/> 255,0,0,128 : Seule la composante rouge est présente pour les couleurs, c'est donc un rouge. Cependant, ce pixel est à moitié transparent (128=255/2) donc il laisse filtrer une partie de la couleur du pixel sur lequel il sera collé.<br/> 255,255,255,0 : Un pixel de couleur blanche... Et totalement transparent !! Donc... Il ne sera pas visible !! :)</p><p id="r-550996" data-claire-element-id="550996">C'est compris ? ;)</p><aside id="r-550998" data-claire-element-id="550998" data-claire-semantic="warning"><p id="r-550997" data-claire-element-id="550997">A savoir : les opérations sur des Uint8 ne doivent jamais sortir de l'intervalle [0,255]</p></aside><p id="r-550999" data-claire-element-id="550999">Si par exemple vous prenez un pixel qui a une composante rouge de 150, et que vous lui additionnez 150, vous n'obtiendrez ni 300 (puisque le maximum est 255), ni 255, mais plutôt... N'importe quoi :D .</p><p id="r-551000" data-claire-element-id="551000">La solution ? Convertir les Uint8 en int lors des calculs.</p><p id="r-551001" data-claire-element-id="551001">Concrètement, voici comment faire :</p><pre id="r-551002" data-claire-element-id="551002"><code data-claire-semantic="c">int tampon; /*Variable entière qui sert de tampon*/
    int ajout;
    Uint8 composante,resultat;

    composante=155;
    ajout=120;
    tampon=(int)composante + ajout;

    /*On fait en sorte que tampon reste dans l'intervalle [0,255] */
    if (tampon&gt;255) {tampon=255;} else if (tampon&lt;0) {tampon=0;}

    /*Avec l'opérateur cast (Uint8) on tranforme tampon en un entier de type Uint8*/
    resultat=(Uint8)tampon;</code></pre><p id="r-551003" data-claire-element-id="551003">Bon et bien vous avez tous les outils en main il me semble.</p><div id="r-551005" data-claire-element-id="551005" data-claire-semantic="question"><p id="r-551004" data-claire-element-id="551004">Comment modifier l'intégralité de l'image ?</p></div><aside id="r-551007" data-claire-element-id="551007" data-claire-semantic="information"><p id="r-551006" data-claire-element-id="551006">Comme dans les cours de M@teo21, avec une boucle <strong>for</strong>.</p></aside><p id="r-551008" data-claire-element-id="551008"><strong>Par exemple :</strong></p><pre id="r-551009" data-claire-element-id="551009"><code data-claire-semantic="c">int x,y;

    SDL_LockSurface(surface); /*On bloque la surface*/
    for (y=0;y&lt;surface-&gt;h;y++)
    {
        for (x=0;x&lt;surface-&gt;w;x++)
        {
/*Ici on modifie chaque pixel*/
        }
    }
    SDL_UnlockSurface(surface); /*On libère la surface, elle peut être utilisée*/</code></pre><p id="r-551010" data-claire-element-id="551010">Dernier point, mais non des moindres : une fois une image chargée en mémoire, il peut être intéressant d'en réaliser une copie, dans une autre image, afin de modifier cette deuxième image et garder l'original intact.</p><p id="r-551011" data-claire-element-id="551011">Voici donc le principe de fonctionnement :<br/> 1) Charger l'image originale<br/> 2) Créer une surface vide dans la nouvelle image, possédant les caractéristiques de l'image originale<br/> 3) Copier l'image originale dans la nouvelle image.</p><p id="r-551012" data-claire-element-id="551012">C'est donc relativement simple, voici le code :</p><pre id="r-551013" data-claire-element-id="551013"><code data-claire-semantic="c">/*On déclare les pointeurs sur des surfaces que l'on va utiliser*/
SDL_Surface *image = NULL;
SDL_Surface *copie = NULL;

/*On charge l'image à copier*/
image = SDL_LoadBMP(&quot;image.bmp&quot;);

/*On créé une surface vide de la taille de l'image à copier*/
copie = SDL_CreateRGBSurface(SDL_HWSURFACE, image-&gt;w, image-&gt;h, 32,  MASQUE_ROUGE, MASQUE_VERT, MASQUE_BLEU, MASQUE_ALPHA);

/*On copie l'image originale*/
SDL_BlitSurface(image, NULL, copie, NULL);</code></pre><p id="r-551014" data-claire-element-id="551014">Il est probable que la fonction SDL_CreateRGBSurface vous paraisse bien étrange. Voici ce qu'en dit M@teo21 dans son cours :</p><p id="r-551015" data-claire-element-id="551015"><cite>Citation : M@teo21</cite></p><blockquote id="r-551023" data-claire-element-id="551023"><p id="r-551016" data-claire-element-id="551016">Cette fonction prend... beaucoup de paramètres :p (8 !) D'ailleurs, peu d'entre eux nous intéressent pour l'instant, donc je vais éviter de vous détailler ceux qui ne nous serviront pas de suite.<br/> Comme en C nous sommes obligés d'indiquer tous les paramètres (les paramètres facultatifs n'existent qu'en C++), nous enverrons la valeur 0 quand le paramètre ne nous intéresse pas.</p><p id="r-551017" data-claire-element-id="551017">Regardons de plus près les 4 premiers paramètres, les plus intéressants :</p><p id="r-551018" data-claire-element-id="551018">* Une liste de flags (des options). Vous avez le choix entre :<br/> o SDL_HWSURFACE : la surface sera chargée en mémoire vidéo. Il y a moins d'espace dans cette mémoire que dans la mémoire système (quoique, avec les cartes 3D qu'on sort de nos jours...), mais cette mémoire est plus optimisée et accélérée.<br/> o SDL_SWSURFACE : la surface sera chargée en mémoire système où il y a beaucoup de place, mais cela obligera votre processeur à faire plus de calculs. Si vous aviez chargé la surface en mémoire vidéo, c'est la carte 3D qui aurait fait la plupart des calculs.</p><p id="r-551019" data-claire-element-id="551019">* La largeur de la surface (en pixels)<br/> * La hauteur de la surface (en pixels)<br/> * Le nombre de couleurs (en bits / pixel)</p><p id="r-551020" data-claire-element-id="551020">Voici donc comment on alloue notre nouvelle surface en mémoire :</p><p id="r-551021" data-claire-element-id="551021">Code : C<br/> rectangle = SDL_CreateRGBSurface(SDL_HWSURFACE, 220, 180, 32, 0, 0, 0, 0);</p><p id="r-551022" data-claire-element-id="551022">Les 4 derniers paramètres sont mis à 0 comme je vous l'ai dit car ils ne nous intéressent pas.</p></blockquote><aside id="r-551025" data-claire-element-id="551025" data-claire-semantic="warning"><p id="r-551024" data-claire-element-id="551024">Mais, dans ton exemple de code, tu n'as pas mis les 4 derniers paramètres à 0 !!</p></aside><p id="r-551026" data-claire-element-id="551026">Effectivement. :) N'oubliez pas que lorsque l'on manipule des images, on se rapproche beaucoup de tout ce qui est bas niveau.</p><p id="r-551027" data-claire-element-id="551027">Dans la plupart des cas, laisser les 4 derniers paramètres à 0 convient parfaitement.</p><p id="r-551028" data-claire-element-id="551028"><strong>Sauf dans un</strong> : lorsque l'on veut modifier la transparence alpha d'une image, pixel par pixel !!</p><p id="r-551029" data-claire-element-id="551029">Si l'on veut que nos modifications de transparence soient prises en compte lors d'un <strong>blit</strong> (affichage d'une image dans une autre), il va nous falloir modifier les 4 derniers paramètres, pour indiquer la façon dont les données sont enregistrées.</p><p id="r-551030" data-claire-element-id="551030">Bien sur, j'ai utilisée des constantes, que je définis ainsi au début de mon programme :</p><pre id="r-551031" data-claire-element-id="551031"><code data-claire-semantic="c">/*Suivant l'architecture de la machine, deux manières d'enregistrer des données en mémoire*/
#if SDL_BYTEORDER == SDL_BIG_ENDIAN

    #define MASQUE_ROUGE 0xff000000
    #define MASQUE_VERT  0x00ff0000
    #define MASQUE_BLEU  0x0000ff00
    #define MASQUE_ALPHA 0x000000ff

#else

    #define MASQUE_ROUGE 0x000000ff
    #define MASQUE_VERT  0x0000ff00
    #define MASQUE_BLEU  0x00ff0000
    #define MASQUE_ALPHA 0xff000000

#endif</code></pre><p id="r-551032" data-claire-element-id="551032">Tout ce que vous devez retenir, c'est qu'il vous faudra mettre ces 4 constantes en derniers paramètres pour que la modification pixel par pixel de transparence alpha fonctionne.</p><div id="r-551034" data-claire-element-id="551034" data-claire-semantic="question"><p id="r-551033" data-claire-element-id="551033">A quoi ça peut bien servir ?</p></div><p id="r-551035" data-claire-element-id="551035">Et bien, par exemple, cela peut permettre de réaliser des masques, c'est à dire rendre une image plus ou moins transparente en divers endroits.</p><p id="r-551036" data-claire-element-id="551036">Et voila !! Il ne vous reste plus qu'à mélanger tout ça pour obtenir de superbes effets.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel">Modifier une image pixel par pixel</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/un-peu-de-theorie-12">
Un peu de théorie
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/les-bases-techniques-pour-que-ca-fonctionne">
Les bases techniques pour que ça fonctionne
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-de-nouveaux-effets-styles">
TP : De nouveaux effets stylés !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-balance-des-couleurs">
TP : Balance des couleurs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/un-peu-de-theorie-12">
<span class="arrow"></span>
<span class="next">Un peu de théorie</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-de-nouveaux-effets-styles">
<span class="next">TP : De nouveaux effets stylés !</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="TPDenouveauxeffetsstyls"></a><h2>TP : De nouveaux effets stylés !</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/les-bases-techniques-pour-que-ca-fonctionne">
<span class="arrow"></span>
<span class="next">Les bases techniques pour que ça fonctionne</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-balance-des-couleurs">
<span class="next">TP : Balance des couleurs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-551038" data-claire-element-id="551038">Nous venons de voir comment réaliser une balance des couleurs en C :) .</p><p id="r-551039" data-claire-element-id="551039">Les mécanismes de modification d'une image pixel par pixel doivent commencer à vous paraître plus évidents, mais il ne faut pas s'arrêter en si bon chemin !! Nous allons donc continuer à appliquer les bases pratiques et théoriques que nous avons vu précédemment.</p><p id="r-551040" data-claire-element-id="551040">Dans ce TP, nous allons voir :</p><ul id="r-551047" data-claire-element-id="551047"><li id="r-551042" data-claire-element-id="551042"><p id="r-551041" data-claire-element-id="551041">comment modifier la luminosité d'une image</p></li><li id="r-551044" data-claire-element-id="551044"><p id="r-551043" data-claire-element-id="551043">comment ajouter un masque de transparence sur une image</p></li><li id="r-551046" data-claire-element-id="551046"><p id="r-551045" data-claire-element-id="551045">comment appliquer un pot de peinture sur une image</p></li></ul><h2 id="r-modifier-la-luminosite-d-une-image" data-claire-element-id="551059">Modifier la luminosité d'une image</h2><div id="r-551049" data-claire-element-id="551049" data-claire-semantic="question"><p id="r-551048" data-claire-element-id="551048">Première question : qu'est-ce donc que la luminosité ?</p></div><p id="r-551050" data-claire-element-id="551050">Je suppose que nous sommes tous d'accord pour dire qu'une image blanche est très lumineuse, tandis qu'une image noire n'a aucune luminosité.</p><p id="r-551051" data-claire-element-id="551051">Donc, pour éclaircir une image, il faut la faire tendre vers le blanc, tandis que pour l'assombrir, il suffit de la faire tendre vers le noir.</p><p id="r-551052" data-claire-element-id="551052">Sachant que le blanc est du (255,255,255) et le noir du (0,0,0), on va donc ajouter ou enlever une certaine quantité alpha à chaque composante de couleur de chaque pixel de l'image, la même pour tous.</p><div id="r-551054" data-claire-element-id="551054" data-claire-semantic="question"><p id="r-551053" data-claire-element-id="551053">Mais, ça ressemblerait pas à la balance des couleurs, ça ?</p></div><aside id="r-551056" data-claire-element-id="551056" data-claire-semantic="information"><p id="r-551055" data-claire-element-id="551055">En effet !! Il suffit de faire appel à la balance des couleurs, mais avec la même valeur d'ajout alpha pour chaque composante.</p></aside><p id="r-551057" data-claire-element-id="551057">Bon, voici le code, mais normalement je ne devrais même pas avoir à vous le donner :D .</p><pre id="r-551058" data-claire-element-id="551058"><code data-claire-semantic="c">/* ********************************************************************* */
/*luminosite : permet d'ajouter ou d'enlever de la lumière à toute l'image.
Paramètres d'entrée/sortie :
SDL_Surface *surface : la surface à modifier
int alpha : La quantité de lumière que l'on veut ajouter ou soustraire (entre -255 et +255)
*/
void luminosite(SDL_Surface *surface, int alpha)
{
    /*La luminosité est en fait une balance des couleurs avec un ajout uniforme*/
    balanceDesCouleurs(surface, alpha, alpha, alpha);
}</code></pre><h2 id="r-ajouter-un-masque-sur-une-image" data-claire-element-id="551085">Ajouter un masque sur une image</h2><h3 id="r-preliminaires-4" data-claire-element-id="551073">Préliminaires</h3><p id="r-551060" data-claire-element-id="551060">Je dois reconnaitre que l'effet précédent n'était pas d'une complexité affolante :-° . Nous allons maintenant nous intéresser à quelque chose qui nécessite un peu plus de réflexion.</p><p id="r-551061" data-claire-element-id="551061">Comme vous le savez désormais, les images possèdent une couche alpha. Cette couche alpha, qui correspond à la transparence de l'image, peut être chargée en même temps que l'image, principalement sur les images au format PNG, elle peut aussi être définie de manière globale, en utilisant la fonction SDL_SetAlpha, permettant par exemple de rendre une image à moitié transparente.</p><p id="r-551062" data-claire-element-id="551062">Mais il existe un troisième cas de figure :) . Imaginez que l'on ai une image, que l'on veuille rendre totalement transparente en son milieu, puis de moins en moins transparente à mesure qu'on s'approche des bords de l'image.</p><div id="r-551064" data-claire-element-id="551064" data-claire-semantic="question"><p id="r-551063" data-claire-element-id="551063">Comment y parvenir ??</p></div><p id="r-551065" data-claire-element-id="551065">La solution, c'est d'utiliser une image, en niveaux de gris, qui servira de couche alpha à notre image. Ainsi, on charge une image normale, on charge un masque, de même taille, et on applique le masque sur l'image cible.</p><p id="r-551066" data-claire-element-id="551066">Ce masque en niveau de gris permet de définir la transparence de l'image cible en tout points. Chaque pixel du masque correspond à un pixel de l'image.</p><p id="r-551067" data-claire-element-id="551067">D'autres part, je vais considérer que le noir représente un pixel totalement transparent, tandis que le blanc représente un pixel opaque. J'ai fait ce choix pour des raisons de commodité, mais si ça vous dit de décider du contraire, libre à vous :D :D .</p><div id="r-551069" data-claire-element-id="551069" data-claire-semantic="question"><p id="r-551068" data-claire-element-id="551068">Heu... Tu pourrais préciser ?</p></div><p id="r-551070" data-claire-element-id="551070"><strong>Prenons un exemple :</strong><br/> Si le pixel en haut à gauche de mon masque est blanc, alors le pixel en haut à gauche dans mon image sera totalement opaque.<br/> Sil le pixel en bas à droite de mon masque est noir, alors le pixel en bas à droite de mon image sera totalement transparent, il ne sera pas visible.</p><p id="r-551071" data-claire-element-id="551071">Je vous rappelle qu'une couleur grise possède la même valeur pour ses trois composantes rouge, vert et bleu.</p><p id="r-551072" data-claire-element-id="551072"><strong>Un dernier exemple :</strong><br/> Si le pixel en haut à droite de mon masque est d'une couleur grise rouge=128, vert=128 et noir=128. On remarque que 128 est la moitié de 256, et qu'une composante peut prendre 256 valeurs. On en déduis que le pixel de l'image en haut à droite sera... à moitié transparent !</p><h3 id="r-comment-proceder-3" data-claire-element-id="551084">Comment procéder</h3><p id="r-551074" data-claire-element-id="551074">1)Charger l'image source sur laquelle on veut appliquer un masque.<br/> 2)Charger le masque à appliquer sur l'image. Ce masque doit être en niveaux de gris.<br/> 3)Créer une image cible qui contiendra le résultat.<br/> 4)Copier l'image source dans l'image cible<br/> 5)Appliquer le masque à l'image cible :<br/> -&gt;Parcourir l'image et le masque pixel par pixel<br/> -&gt;Définir le niveaux de gris de chaque pixel du masque comme composante alpha de chaque pixel l'image cible.</p><p id="r-551075" data-claire-element-id="551075">En regardant bien, en fait, vous savez déjà tout faire !!</p><p id="r-551076" data-claire-element-id="551076">Voici comment se déroule les 4 premiers points :</p><pre id="r-551077" data-claire-element-id="551077"><code data-claire-semantic="c">/*On charge notre image, notez qu'elle fait 200*200 pixels*/
    imgOriginale = SDL_LoadBMP(&quot;image.bmp&quot;);

    /*On charge le masque, qui lui aussi fait 200*200 pixels*/
    imgMasque = SDL_LoadBMP(&quot;masque.bmp&quot;);

    /*On créé une surface vide de 200*200 dans l'image*/
    imgAjoutMasque = SDL_CreateRGBSurface(SDL_HWSURFACE, imgOriginale-&gt;w, imgOriginale-&gt;h, 32,  MASQUE_ROUGE, MASQUE_VERT, MASQUE_BLEU, MASQUE_ALPHA);

    /*On y copie ensuite l'image originale*/
    SDL_BlitSurface(imgOriginale, NULL, imgAjoutMasque, NULL);

    /*On traite une image*/
    /*On ajoute un masque à l'image*/
    ajouterMasque(imgAjoutMasque, imgMasque);</code></pre><p id="r-551078" data-claire-element-id="551078">Ah, petit rappel : il faut avoir déclarer ceci au début de votre fichier :</p><pre id="r-551079" data-claire-element-id="551079"><code data-claire-semantic="c">/*Suivant l'architecture de la machine, deux manières d'enregistrer des données en mémoire*/
#if SDL_BYTEORDER == SDL_BIG_ENDIAN

    #define MASQUE_ROUGE 0xff000000
    #define MASQUE_VERT  0x00ff0000
    #define MASQUE_BLEU  0x0000ff00
    #define MASQUE_ALPHA 0x000000ff

#else

    #define MASQUE_ROUGE 0x000000ff
    #define MASQUE_VERT  0x0000ff00
    #define MASQUE_BLEU  0x00ff0000
    #define MASQUE_ALPHA 0xff000000

#endif</code></pre><p id="r-551080" data-claire-element-id="551080">C'est ce qui permet à la SDL de savoir comment sont stockées les données en mémoire, suivant l'architecture de votre machine. J'en ai déjà parlé dans la partie &quot;Les bases techniques pour que ça fonctionne&quot;</p><p id="r-551081" data-claire-element-id="551081">Bon, et maintenant, à vos claviers !! Normalement, vous devez avoir tous les outils nécessaires pour créer la fonction ajouterMasque !!</p><p id="r-551082" data-claire-element-id="551082">Allez, comme j'ai un bon fond, je vous la donne, pour que vous puissiez comparer avez votre code :) :</p><pre id="r-551083" data-claire-element-id="551083"><code data-claire-semantic="c">/* ********************************************************************* */
/*ajouterMasque : permet d'ajouter un masque en couche alpha sur une image source.
Le masque doit être en niveaux de gris ou en niveaux de rouge.
La couche alpha de la source n'est pas pris en compte.
Seul la couche rouge du masque est prise en compte.
Paramètres d'entrée/sortie :
SDL_Surface *source : l'image sur laquelle on va appliquer le masque
SDL_Surface *masque : le masque à appliquer sur l'image
*/
void ajouterMasque(SDL_Surface *source, SDL_Surface *masque)
{

    int x,y;
    Uint32 pixelS,pixelM;
    Uint8 r,v,b,a,temp1,temp2;

    /*Si les images ont les mêmes dimensions*/
    if ((source-&gt;w==masque-&gt;w) &amp;&amp; (source-&gt;h==masque-&gt;h))
    {
        /* On bloque les deux surfaces pour pouvoir travailler dessus */
        SDL_LockSurface(source);
        SDL_LockSurface(masque);

        /*Double boucle pour parcourir l'intégralité de l'image.*/
        for (y=0;y&lt;source-&gt;h;y++)
        {
            for (x=0;x&lt;source-&gt;w;x++)
            {
                /*On récupère les codes couleurs des pixels*/
                pixelS=obtenirPixel(source,x,y);
                pixelM=obtenirPixel(masque,x,y);

                /*On extrait les composantes rouge, vert, bleu du pixel de l'image source*/
                SDL_GetRGB(pixelS, source-&gt;format, &amp;r, &amp;v, &amp;b);

                /*On extrait la composante rouge du pixel du masque*/
                /*Les deux autres couleurs ne nous interessent pas*/
                /*L'image est censée être en niveaux de gris, donc rouge=vert=bleu*/
                SDL_GetRGB(pixelM, masque-&gt;format, &amp;a, &amp;temp1, &amp;temp2);

                /*On retransforme les 4 composantes en un seul code couleur dans pixelS */
                /*Notez qu'on a ajouté le a couche alpha (masque) aux 3 couleurs rouge vert bleu du pixel*/
                pixelS=SDL_MapRGBA(source-&gt;format, r, v, b, a);

                /*On injecte le code couleur pixel dans le pixel correspondant*/
                definirPixel(source, x, y, pixelS);
            }
        }

        /*On libère les surfaces, elle peuvent désormais être réutilisées pour autre chose*/
        SDL_UnlockSurface(source);
        SDL_UnlockSurface(masque);
    }
}</code></pre><h2 id="r-un-incroyable-pot-de-peinture" data-claire-element-id="551088">Un incroyable pot de peinture</h2><h3 id="r-de-quoi-parles-t-on" data-claire-element-id="551087">De quoi parles t'on ?</h3><p id="r-551086" data-claire-element-id="551086">Le pot de peinture est un outil que l'on trouve dans la plupart des programmes de retouche d'image. Même paint en possède un !!</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel">Modifier une image pixel par pixel</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/un-peu-de-theorie-12">
Un peu de théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/les-bases-techniques-pour-que-ca-fonctionne">
Les bases techniques pour que ça fonctionne
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-de-nouveaux-effets-styles">
TP : De nouveaux effets stylés !
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-balance-des-couleurs">
TP : Balance des couleurs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/les-bases-techniques-pour-que-ca-fonctionne">
<span class="arrow"></span>
<span class="next">Les bases techniques pour que ça fonctionne</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-balance-des-couleurs">
<span class="next">TP : Balance des couleurs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="TPBalancedescouleurs"></a><h2>TP : Balance des couleurs</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-de-nouveaux-effets-styles">
<span class="arrow"></span>
<span class="next">TP : De nouveaux effets stylés !</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-551090" data-claire-element-id="551090">Nous allons attaquer le côté pratique avec la réalisation d'une fonction de <strong>Balance des couleurs</strong>.</p><div id="r-551092" data-claire-element-id="551092" data-claire-semantic="question"><p id="r-551091" data-claire-element-id="551091">Mais c'est quoi une balance des couleurs ?</p></div><p id="r-551093" data-claire-element-id="551093">C'est une fonction qui permet d'ajouter ou d'enlever une certaine dose de rouge, de vert et de bleu à une image.</p><aside id="r-551095" data-claire-element-id="551095" data-claire-semantic="information"><p id="r-551094" data-claire-element-id="551094">Vous pouvez trouver cet outil dans Photoshop : Image-&gt;Réglages-&gt;Balance des Couleurs</p></aside><div id="r-551097" data-claire-element-id="551097" data-claire-semantic="question"><p id="r-551096" data-claire-element-id="551096">Et GIMP alors, moi j'utilise que de l'open source ?</p></div><aside id="r-551099" data-claire-element-id="551099" data-claire-semantic="information"><p id="r-551098" data-claire-element-id="551098">Dans GIMP, elle se trouve dans Outils-&gt;Outils de couleurs-&gt;Balance des couleurs</p></aside><div id="r-551101" data-claire-element-id="551101" data-claire-semantic="question"><p id="r-551100" data-claire-element-id="551100">Cool ! Comment ça marche ?</p></div><p id="r-551102" data-claire-element-id="551102">On prend chaque pixel de l'image, et on lui ajoute ou enlève une certaine quantité de chaque composante (<strong>attention</strong>, on ne se préoccupe ici que des composantes <strong>rouge</strong>, <strong>vert</strong> et <strong>bleu</strong>, pas de la couche alpha).</p><p id="r-551103" data-claire-element-id="551103">Donc... Bah en théorie vous avez déjà tout !! ;)</p><p id="r-551104" data-claire-element-id="551104">Tout d'abord, l'image que je vais utiliser se trouve ici :<br/> A CHANGER<br/><a href="http://www.piwai.info/data/image.zip">http://www.piwai.info/data/image.zip</a></p><p id="r-551105" data-claire-element-id="551105">C'est un simple fichier bitmap :) . Nous n'aurons donc pas besoin de la bibliothèque SDL_Image pour cet exemple.</p><p id="r-551106" data-claire-element-id="551106">Ensuite, voici le résultat à obtenir :</p><p id="r-551107" data-claire-element-id="551107">A CHANGER</p><figure id="r-551109" data-claire-element-id="551110"><img id="r-551108" data-claire-element-id="551108" src="medias/uploads.siteduzero.com_files_9001_10000_9842.jpg" alt="Image utilisateur"/></figure><p id="r-551111" data-claire-element-id="551111">A gauche, l'image originale. A droite, la version modifiée avec la balance des couleurs ^^ .</p><p id="r-551112" data-claire-element-id="551112">Voici le principe de l'algorithme utilisé :<br/> 1)On bloque la surface, pour pouvoir dessiner dessus.<br/> 2)On parcours la surface pixel par pixel, et on ajoute ou on enlève une certaine quantité de couleur à chaque composante<br/> 3)On débloque la surface</p><p id="r-551113" data-claire-element-id="551113">Bon et maintenant... A vos claviers !! :D :D</p><div id="r-551115" data-claire-element-id="551115" data-claire-semantic="question"><p id="r-551114" data-claire-element-id="551114">Heu... Je suis un peu perdu, je peux voir la solution ?</p></div><p id="r-551116" data-claire-element-id="551116">Pas de problèmes :p !! Voici l'intégralité du code, largement commenté. Il devrait être assez clair pour que vous compreniez tout au premier coup d'oeil.</p><pre id="r-551117" data-claire-element-id="551117"><code data-claire-semantic="c">/* ********************************************************************* */
/*Fichiers d'entête inclus*/
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;SDL/SDL.h&gt;

/* ********************************************************************* */
/*Prototypes*/
/*Les commentaires sont dans les corps de fonction*/

/*Fonction de gestion système*/
void waitAndQuit();

/*Fonction de modification d'image*/
void balanceDesCouleurs(SDL_Surface *surface, int rAjout, int gAjout, int bAjout);

/*Fonctions utilisées par la fonction de modification d'image*/
Uint8 addVal(Uint8 composante, int valeur);
Uint32 obtenirPixel(SDL_Surface *surface, int x, int y);
void definirPixel(SDL_Surface *surface, int x, int y, Uint32 pixel);

/* ********************************************************************* */
/*main : fonction principale*/
int main(int argc, char **argv)
{

    /* ************Déclaration des variables************ */

    /*On déclare les trois surfaces qui vont nous servir :*/
    /*L'écran, et l'image originale et l'image à modifier*/
    SDL_Surface *ecran = NULL, *imgOriginale = NULL, *imgBalanceCouleurs = NULL;

    /*Pour positionner les images*/
    SDL_Rect position;

    /* ************Initialisation*********************** */

    /*On initialise la SDL.*/
    SDL_Init(SDL_INIT_VIDEO);

    /*On initialise l'écran*/
    ecran = SDL_SetVideoMode(400, 200, 32,  SDL_ANYFORMAT |
                                            SDL_HWSURFACE );

    /*On change le titre de la fenêtre*/
    SDL_WM_SetCaption(&quot;Balance des couleurs&quot;, NULL);

    /*On charge notre image, notez qu'elle fait 200*200 pixels*/
    imgOriginale = SDL_LoadBMP(&quot;image.bmp&quot;);

    /*On créé une surface vide de 200*200 pixels dans l'image*/
    /*Notez que cette image n'aura pas besoin de transparence alpha, les 4 derniers paramètres sont donc à 0*/
    imgBalanceCouleurs = SDL_CreateRGBSurface(SDL_HWSURFACE, imgOriginale-&gt;w, imgOriginale-&gt;h, 32, 0, 0, 0, 0);
    /*On y copie ensuite l'image originale*/
    SDL_BlitSurface(imgOriginale, NULL, imgBalanceCouleurs, NULL);

    /* ************Modification de l'image************** */

    /*On traite l'image*/
    /*La balance des couleurs va enlever 10 en rouge, ajouter 100 en bleu et 20 en vert.*/
    balanceDesCouleurs(imgBalanceCouleurs,-10, 100, 20);

    /* ************Affichage du résultat**************** */

    /*Position de l'image originale dans l'écran.*/
    position.x=0;
    position.y=0;
    /*On copie l'image originale dans l'écran*/
    SDL_BlitSurface(imgOriginale, NULL, ecran, &amp;position);

    /*Position de l'image modifiée*/
    position.x=200;
    position.y=0;
    /*On copie l'image modifiée dans l'écran*/
    SDL_BlitSurface(imgBalanceCouleurs, NULL, ecran, &amp;position);

    SDL_Flip(ecran);/* Force l'affichage. Facultatif ici, mais on ne sait jamais.*/

    /* ************Nettoyage de la mémoire************** */

    /*Une fois les images affichées, on n'a plus besoin d'elles*/
    SDL_FreeSurface(imgOriginale);
    SDL_FreeSurface(imgBalanceCouleurs);

    /*On attend que l'utilisateur décide de quitter le programme*/
    waitAndQuit();

    return EXIT_SUCCESS;

}

/* ********************************************************************* */
/*waitAndQuit : permet d'attendre que l'utilisateur quitte le programme*/
void waitAndQuit()
{
    SDL_Event event;

    while ( event.type!= SDL_QUIT)
        SDL_WaitEvent( &amp;event );

    SDL_Quit();
}

/* ********************************************************************* */
/*balanceDesCouleurs : permet d'ajouter ou d'enlever de la couleur à toute l'image.
Paramètres d'entrée/sortie :
SDL_Surface *surface : la surface à modifier
int rAjout : La quantité de rouge que l'on veut ajouter ou soustraire (entre -255 et +255)
int gAjout : La quantité de vert que l'on veut ajouter ou soustraire (entre -255 et +255)
int bAjout : La quantité de bleu que l'on veut ajouter ou soustraire (entre -255 et +255)
*/
void balanceDesCouleurs(SDL_Surface *surface, int rAjout, int gAjout, int bAjout)
{
    /*x et y sont les index permettant de se déplacer dans l'image*/
    int x,y;
    /*r,g,b,a vont stocker les composantes d'un pixel*/
    Uint8 r,g,b,a;
    /*pixel stocke le code couleur d'un pixel*/
    Uint32 pixel;

    /*On bloque la surface pour pouvoir travailler dessus */
    SDL_LockSurface(surface);
    /*Double boucle pour parcourir l'intégralité de l'image.*/
    for (y=0;y&lt;surface-&gt;h;y++)
    {
        for (x=0;x&lt;surface-&gt;w;x++)
        {
            /*On récupère le code couleur du pixel.*/
            pixel=obtenirPixel(surface,x,y);
            /*On extrait les composantes rouge, vert, bleu et alpha*/
            SDL_GetRGBA(pixel, surface-&gt;format, &amp;r, &amp;g, &amp;b, &amp;a);

            /*On ajoute/soustrait la quantité voulue aux 3 composantes rouge, vert, bleu.*/
            r=addVal( r,rAjout);
            g=addVal( g,gAjout);
            b=addVal( b,bAjout);

            /*On retransforme les 4 composantes en un seul code couleur dans pixel */
            pixel=SDL_MapRGBA(surface-&gt;format, r, g, b, a);
            /*On injecte le code couleur pixel dans le pixel correspondant*/
            definirPixel(surface, x, y, pixel);
        }
    }
    /*On libère la surface, elle peut désormais être réutilisée pour autre chose*/
    SDL_UnlockSurface(surface);
}

/* ********************************************************************* */
/*addVal : ajoute une certaine valeur à une composante
en restant dans l'intervalle [0,255]
Paramètres d'entrée/sortie :
Uint8 composante : la composante à modifier
int valeur : la valeur à ajouter ou enlever
*/
Uint8 addVal(Uint8 composante, int valeur)
{
    int tampon; /*Variable entière qui sert de tampon*/
    tampon=(int)composante + valeur;

    /*On fait en sorte que tampon reste dans l'intervalle [0,255] */
    if (tampon&gt;255) {tampon=255;} else if (tampon&lt;0) {tampon=0;}

    /*Avec l'opérateur cast (Uint8) on tranforme tampon en un entier de type Uint8*/
    return (Uint8)tampon;
}

/* ********************************************************************* */
/*obtenirPixel : permet de récupérer la couleur d'un pixel
Paramètres d'entrée/sortie :
SDL_Surface *surface : la surface sur laquelle on va récupérer la couleur d'un pixel
int x : la coordonnée en x du pixel à récupérer
int y : la coordonnée en y du pixel à récupérer

Uint32 resultat : la fonction renvoie le pixel aux coordonnées (x,y) dans la surface
*/
Uint32 obtenirPixel(SDL_Surface *surface, int x, int y)
{
    /*nbOctetsParPixel représente le nombre d'octets utilisés pour stocker un pixel.
    En multipliant ce nombre d'octets par 8 (un octet = 8 bits), on obtient la profondeur de couleur
    de l'image : 8, 16, 24 ou 32 bits.*/
    int nbOctetsParPixel = surface-&gt;format-&gt;BytesPerPixel;
    /* Ici p est l'adresse du pixel que l'on veut connaitre */
    /*surface-&gt;pixels contient l'adresse du premier pixel de l'image*/
    Uint8 *p = (Uint8 *)surface-&gt;pixels + y * surface-&gt;pitch + x * nbOctetsParPixel;

    /*Gestion différente suivant le nombre d'octets par pixel de l'image*/
    switch(nbOctetsParPixel)
    {
        case 1:
            return *p;

        case 2:
            return *(Uint16 *)p;

        case 3:
            /*Suivant l'architecture de la machine*/
            if(SDL_BYTEORDER == SDL_BIG_ENDIAN)
                return p[0] &lt;&lt; 16 | p[1] &lt;&lt; 8 | p[2];
            else
                return p[0] | p[1] &lt;&lt; 8 | p[2] &lt;&lt; 16;

        case 4:
            return *(Uint32 *)p;

        /*Ne devrait pas arriver, mais évite les erreurs*/
        default:
            return 0; 
    }
}

/* ********************************************************************* */
/*definirPixel : permet de modifier la couleur d'un pixel
Paramètres d'entrée/sortie :
SDL_Surface *surface : la surface sur laquelle on va modifier la couleur d'un pixel
int x : la coordonnée en x du pixel à modifier
int y : la coordonnée en y du pixel à modifier
Uint32 pixel : le pixel à insérer
*/
void definirPixel(SDL_Surface *surface, int x, int y, Uint32 pixel)
{
    /*nbOctetsParPixel représente le nombre d'octets utilisés pour stocker un pixel.
    En multipliant ce nombre d'octets par 8 (un octet = 8 bits), on obtient la profondeur de couleur
    de l'image : 8, 16, 24 ou 32 bits.*/
    int nbOctetsParPixel = surface-&gt;format-&gt;BytesPerPixel;
    /*Ici p est l'adresse du pixel que l'on veut modifier*/
    /*surface-&gt;pixels contient l'adresse du premier pixel de l'image*/
    Uint8 *p = (Uint8 *)surface-&gt;pixels + y * surface-&gt;pitch + x * nbOctetsParPixel;

    /*Gestion différente suivant le nombre d'octets par pixel de l'image*/
    switch(nbOctetsParPixel)
    {
        case 1:
            *p = pixel;
            break;

        case 2:
            *(Uint16 *)p = pixel;
            break;

        case 3:
            /*Suivant l'architecture de la machine*/
            if(SDL_BYTEORDER == SDL_BIG_ENDIAN)
            {
                p[0] = (pixel &gt;&gt; 16) &amp; 0xff;
                p[1] = (pixel &gt;&gt; 8) &amp; 0xff;
                p[2] = pixel &amp; 0xff;
            }
            else
            {
                p[0] = pixel &amp; 0xff;
                p[1] = (pixel &gt;&gt; 8) &amp; 0xff;
                p[2] = (pixel &gt;&gt; 16) &amp; 0xff;
            }
            break;

        case 4:
            *(Uint32 *)p = pixel;
            break;
    }
}</code></pre><p id="r-551118" data-claire-element-id="551118">Je tiens à ajouter une petite précision, pour les perfectionnistes : vous aurez remarqué que lorsque je parcours une image (avec les deux boucles <strong>for</strong> imbriquées), je la parcours selon les l'axe des y d'abord, et je fais varier l'axe des x ensuite.</p><div id="r-551120" data-claire-element-id="551120" data-claire-semantic="question"><p id="r-551119" data-claire-element-id="551119">Pourquoi ne fais t'on pas l'inverse ?</p></div><p id="r-551121" data-claire-element-id="551121">Et bien, vous pouvez sans hésiter inverser, cela ne posera aucun problème. Cependant, dans ce cas précis, pour des raisons d'optimisation liées à la façon dont les images sont stockées en mémoire, il est préférables de faire y d'abord, x ensuite.</p><div id="r-551123" data-claire-element-id="551123" data-claire-semantic="question"><p id="r-551122" data-claire-element-id="551122">Pourquoi ??</p></div><aside id="r-551125" data-claire-element-id="551125" data-claire-semantic="information"><p id="r-551124" data-claire-element-id="551124">La SDL stocke les images sous forme de lignes de pixels collées les unes à la suite des autres. Un peut comme si l'on découpait notre image en n lignes, et que l'on collait ces n lignes les une à la suite des autres.</p></aside><p id="r-551126" data-claire-element-id="551126">Hé hé... Si quelque chose ne vous parait pas clair, relisez les parties précédentes, tout est dit :p !!</p><p id="r-551127" data-claire-element-id="551127">Voila, c'est fini !!</p><p id="r-551128" data-claire-element-id="551128">J'espère que ce mini-tuto vous aura plus, et que vous deviendrez des pro de la manipulation d'image :D :D .</p><p id="r-551129" data-claire-element-id="551129">Bien sur, nous n'avons réalisé qu'une balance des couleurs :( . Et alors o_O ?</p><div id="r-551131" data-claire-element-id="551131" data-claire-semantic="question"><p id="r-551130" data-claire-element-id="551130">Bah... Qu'est-ce que je pourrai réaliser d'autre ??</p></div><p id="r-551132" data-claire-element-id="551132">Alors là, il existe moult et pléthores possibilités de fonctions à réaliser.</p><p id="r-551133" data-claire-element-id="551133"><strong>Quelques exemples :</strong></p><p id="r-551134" data-claire-element-id="551134">Luminosité<br/> Contraste<br/> Rotation<br/> Symétrie<br/> Niveau de gris<br/> Ajout d'un masque alpha en niveau de gris à une image en couleur.<br/> etc.</p><p id="r-551135" data-claire-element-id="551135"><strong>Quelques pistes :</strong></p><p id="r-551136" data-claire-element-id="551136"><strong>Pour la luminosité</strong>, c'est comme la balance des couleurs, sauf qu'on ajoute ou enlève la même valeur pour chaque composante (rouge, vert, bleu). On fait ainsi tendre l'image vers le blanc (255,255,255) ou le noir (0,0,0).</p><p id="r-551137" data-claire-element-id="551137"><strong>Pour le contraste</strong>, il faut calculer la valeur moyenne sur toute l'image pour chaque composante R,V,B, puis ensuite pour chaque pixel le rapprocher (homogénéité) ou l'éloigner (contraste) de cette valeur pour chaque composante, proportionnellement à un coefficient de contraste.</p><p id="r-551138" data-claire-element-id="551138"><strong>Pour les niveaux de gris</strong>, pour chaque pixel on fait la moyenne de ces 3 composantes couleurs, et on leur attribut cette moyenne.</p><p id="r-551139" data-claire-element-id="551139">Voila, désormais c'est définitivement terminé ^^ .</p><p id="r-551140" data-claire-element-id="551140">Ah j'oubliai : si vous réalisez des effets sympas sur des images, suite à ce tutorial (ou non :euh: ), n'hésitez pas à me le signaler dans les commentaires, ça m'intéresse :D .</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel">Modifier une image pixel par pixel</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/un-peu-de-theorie-12">
Un peu de théorie
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/les-bases-techniques-pour-que-ca-fonctionne">
Les bases techniques pour que ça fonctionne
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-de-nouveaux-effets-styles">
TP : De nouveaux effets stylés !
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-balance-des-couleurs">
TP : Balance des couleurs
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/modifier-une-image-pixel-par-pixel/tp-de-nouveaux-effets-styles">
<span class="arrow"></span>
<span class="next">TP : De nouveaux effets stylés !</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/modifier-une-image-pixel-par-pixel.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 08:28:27 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/modifier-une-image-pixel-par-pixel.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:31:18 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/les-listes-chainees-2.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 02:58:55 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-listes-chainees-2.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:38:58 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Les listes chaînées</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/les-listes-chainees-2.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Les listes chaînées</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Leslisteschanes">Les listes chaînées</a><br/><a href="#Gnralitssurleslisteschaines">Généralités sur les listes chainées</a><br/><a href="#DclarationenCd039unelistechaine">Déclaration en C d&#039;une liste chainée</a><br/><a href="#Manipulerleslisteschaines1_2">Manipuler les listes chainées (1/2)</a><br/><a href="#Exercices1_2">Exercices (1/2)</a><br/><a href="#Manipulerleslisteschaines2_2">Manipuler les listes chainées (2/2)</a><br/><a href="#Exercices2_2">Exercices (2/2)</a><br/></div>
<a name="Leslisteschanes"></a><h2>Les listes chaînées</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/generalites-sur-les-listes-chainees">
<span class="next">Généralités sur les listes chainées</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-323099" data-claire-element-id="323099"><strong>Bonjour à tous et à toutes.</strong></p><p id="r-323100" data-claire-element-id="323100"><em>Euh, un tutoriel sur les listes chaînées ? C'est quoi ça ?<br/> Rassurez-vous : tout vous sera expliqué, depuis zéro.</em></p><div id="r-323102" data-claire-element-id="323102" data-claire-semantic="question"><p id="r-323101" data-claire-element-id="323101">A qui s'adresse ce tutoriel ?</p></div><p id="r-323103" data-claire-element-id="323103"><strong>Il s'adresse à toute personne ayant suivi les cours de M@teo jusqu'aux pointeurs. Ce tutoriel accompagné des exercices que je vous proposerai sont à mon avis un excellent entraînement, en ce qui concerne les pointeurs, entre autres, mais fera appel à toutes vos connaissances du langage C.</strong></p><div id="r-323105" data-claire-element-id="323105" data-claire-semantic="question"><p id="r-323104" data-claire-element-id="323104">Et à la fin, que saurai-je faire ?</p></div><p id="r-323106" data-claire-element-id="323106"><strong>Le but de ce tutoriel est de vous initier aux listes chaînées, une autre façon d'implémenter un conteneur, la plus courante étant les tableaux. A la fin de ce cours, vous serez capables de coder votre propre bibliothèque permettant la création et la manipulation de listes simplement chaînées. Les listes doublement chainées seront introduites pour terminer afin que vous puissiez améliorer votre bibliothèque.</strong></p><p id="r-323107" data-claire-element-id="323107">Je suis sûr que vous êtes prêts : nous allons donc commencer !</p>
</div><a name="Gnralitssurleslisteschaines"></a><h2>Généralités sur les listes chainées</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/declaration-en-c-d-une-liste-chainee">
<span class="next">Déclaration en C d&#039;une liste chainée</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-323108" data-claire-element-id="323108">Lorsque vous créez un algorithme utilisant des conteneurs, il existe différentes manières de les implémenter, la façon la plus courante étant les tableaux, que vous connaissez tous. Lorsque vous créez un tableau, les éléments de celui-ci sont placés de façon contiguë en mémoire. Pour pouvoir le créer, il vous faut connaître sa taille. Si vous voulez supprimer un élément au milieu du tableau, il vous faut recopier les éléments temporairement, ré-allouer de la mémoire pour le tableau, puis le remplir à partir de l'élément supprimé. En bref, ce sont beaucoup de manipulations coûteuses en ressources.<br/> Une liste chaînée est différente dans le sens où les éléments de votre liste sont répartis dans la mémoire et reliés entre eux par des pointeurs. Vous pouvez ajouter et enlever des éléments d'une liste chaînée à n'importe quel endroit, à n'importe quel instant, sans devoir recréer la liste entière.</p><p id="r-323109" data-claire-element-id="323109">Nous allons essayer de voir ceci plus en détail sur ces schémas :</p><figure id="r-323111" data-claire-element-id="323112"><img id="r-323110" data-claire-element-id="323110" src="medias/uploads.siteduzero.com_files_39001_40000_39595.jpg" alt="Image utilisateur"/></figure><p id="r-323113" data-claire-element-id="323113">Vous avez sur ce schéma la représentation que l'on pourrait faire d'un tableau et d'une liste chaînée. Chacune de ces représentations possède ses avantages et inconvénients. C'est lors de l'écriture de votre programme que vous devez vous poser la question de savoir laquelle des deux méthodes est la plus intéressante.</p><ul id="r-323120" data-claire-element-id="323120"><li id="r-323115" data-claire-element-id="323115"><p id="r-323114" data-claire-element-id="323114">Dans un tableau, la taille est connue, l'adresse du premier élément aussi. Lorsque vous déclarez un tableau, la variable contiendra l'adresse du premier élément de votre tableau. <br/> Comme le stockage est contigu, et la taille de chacun des éléments connue, il est possible d'atteindre directement la case i d'un tableau.</p></li><li id="r-323117" data-claire-element-id="323117"><p id="r-323116" data-claire-element-id="323116">Pour déclarer un tableau, il faut connaître sa taille.</p></li><li id="r-323119" data-claire-element-id="323119"><p id="r-323118" data-claire-element-id="323118">Pour supprimer ou ajouter un élément à un tableau, il faut créer un nouveau tableau et supprimer l'ancien. Ce n'est en général pas visible par l'utilisateur, mais c'est ce que realloc va souvent faire. L'adresse du premier élément d'un tableau peut changer après un realloc, ce qui est tout à fait logique puisque realloc n'aura pas forcement la possibilité de trouver en mémoire la place nécessaire et contiguë pour allouer votre nouveau tableau. realloc va donc chercher une place suffisante, recopier votre tableau, et supprimer l'ancien.</p></li></ul><ul id="r-323127" data-claire-element-id="323127"><li id="r-323122" data-claire-element-id="323122"><p id="r-323121" data-claire-element-id="323121">Dans une liste chaînée, la taille est inconnue au départ, la liste peut avoir autant d'éléments que votre mémoire le permet. <br/> Il est en revanche impossible d'accéder directement à l'élément i de la liste chainée. <br/> Pour ce faire, il vous faudra traverser les i-1 éléments précédents de la liste.</p></li><li id="r-323124" data-claire-element-id="323124"><p id="r-323123" data-claire-element-id="323123">Pour déclarer une liste chaînée, il suffit de créer le pointeur qui va pointer sur le premier élément de votre liste chaînée, aucune taille n'est donc à spécifier.</p></li><li id="r-323126" data-claire-element-id="323126"><p id="r-323125" data-claire-element-id="323125">Il est possible d'ajouter, de supprimer, d'intervertir des éléments d'une liste chaînée sans avoir à recréer la liste en entier, mais en manipulant simplement leurs pointeurs.</p></li></ul><p id="r-323128" data-claire-element-id="323128">Chaque élément d'une liste chaînée est composé de deux parties :</p><ul id="r-323133" data-claire-element-id="323133"><li id="r-323130" data-claire-element-id="323130"><p id="r-323129" data-claire-element-id="323129">la valeur que vous voulez stocker,</p></li><li id="r-323132" data-claire-element-id="323132"><p id="r-323131" data-claire-element-id="323131">l'adresse de l'élément suivant, s'il existe.<br/> S'il n'y a plus d'élément suivant, alors l'adresse sera NULL, et désignera le bout de la chaîne.</p></li></ul><p id="r-323134" data-claire-element-id="323134">Voilà deux schémas pour expliquer comment se passent l'ajout et la suppression d'un élément d'une liste chaînée. Remarquez le symbole en bout de chaîne qui signifie que l'adresse de l'élément suivant ne pointe sur rien, c'est-à-dire sur NULL.</p><figure id="r-323136" data-claire-element-id="323137"><img id="r-323135" data-claire-element-id="323135" src="medias/uploads.siteduzero.com_files_39001_40000_39596.jpg" alt="Image utilisateur"/></figure><p id="r-323138" data-claire-element-id="323138">Comme vous vous en doutez certainement maintenant, la liste chaînée est un type structuré. Nous en avons terminé avec ces quelques généralités, nous allons pouvoir passer à la définition d'une structure de données nous permettant de créer cette fameuse liste !</p><aside id="r-323140" data-claire-element-id="323140" data-claire-semantic="error"><p id="r-323139" data-claire-element-id="323139">Vous pouvez essayer d'imaginer à quoi va ressembler la structure liste_chainee : si vous avez compris le principe, vous en êtes capables. Je vous invite donc à écrire sur un papier vos idées que vous pourrez ensuite comparer au résultat que je vais fournir un peu plus bas !</p></aside>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2">Les listes chaînées</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/generalites-sur-les-listes-chainees">
Généralités sur les listes chainées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/declaration-en-c-d-une-liste-chainee">
Déclaration en C d&#039;une liste chainée
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-1-2">
Manipuler les listes chainées (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-1-2">
Exercices (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-2-2">
Manipuler les listes chainées (2/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-2-2">
Exercices (2/2)
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/declaration-en-c-d-une-liste-chainee">
<span class="next">Déclaration en C d&#039;une liste chainée</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="DclarationenCd039unelistechaine"></a><h2>Déclaration en C d&#039;une liste chainée</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/generalites-sur-les-listes-chainees">
<span class="arrow"></span>
<span class="next">Généralités sur les listes chainées</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-1-2">
<span class="next">Manipuler les listes chainées (1/2)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-323142" data-claire-element-id="323142">Vous vous demandez sûrement de quel type sera l'élément de la liste chaînée. A ceci je ne peux répondre que... à vous de voir. En effet, vous pouvez créer des listes chaînées de n'importe quel type d'éléments : entiers, caractères, structures, tableaux, voir même d'autres listes chaînées... Il vous est même possible de combiner plusieurs types dans une même liste.<br/> Allez : vous avez assez patienté, voici la déclaration d'une liste simplement chaînée d'entiers :</p><pre id="r-323143" data-claire-element-id="323143"><code data-claire-semantic="c">#include &lt;stdlib.h&gt;
 
typedef struct element element;
struct element
{
    int val;
    struct element *nxt;
};
 
typedef element* llist;</code></pre><p id="r-323144" data-claire-element-id="323144">On crée le type element qui est une structure contenant un entier (val) et un pointeur sur élément (nxt), qui contiendra l'adresse de l'élément suivant. Ensuite, il nous faut créer le type llist (pour <em>linked list</em> = liste chaînée) qui est en fait un pointeur sur le type element. Lorsque nous allons déclarer la liste chaînée, nous devrons déclarer un pointeur sur element, l'initialiser à NULL, pour pouvoir ensuite allouer le premier élément. N'oubliez pas d'inclure stdlib.h afin de pouvoir utiliser la macro NULL. Comme vous allez le constater, nous avons juste crée le type llist afin de simplifier la déclaration.</p><p id="r-323145" data-claire-element-id="323145">Voilà comment déclarer une liste chaînée (vide pour l'instant) :</p><pre id="r-323146" data-claire-element-id="323146"><code data-claire-semantic="c">#include &lt;stdlib.h&gt;
 
typedef struct element element;
struct element
{
    int val;
    struct element *nxt;
};
 
typedef element* llist;
 
 
 
int main(int argc, char **argv)
{
    /* Déclarons 3 listes chaînées de façons différentes mais équivalentes */
    llist ma_liste1 = NULL;
    element *ma_liste2 = NULL;
    struct element *ma_liste3 = NULL;
 
 
    return 0;
}</code></pre><aside id="r-323148" data-claire-element-id="323148" data-claire-semantic="error"><p id="r-323147" data-claire-element-id="323147">Il est important de toujours initialiser la liste chaînée à NULL. Le cas échéant, elle sera considérée comme contenant au moins un élément. C'est une erreur fréquente. A garder en mémoire donc. De manière générale, il est plus sage de toujours initialiser vos pointeurs.</p></aside>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2">Les listes chaînées</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/generalites-sur-les-listes-chainees">
Généralités sur les listes chainées
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/declaration-en-c-d-une-liste-chainee">
Déclaration en C d&#039;une liste chainée
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-1-2">
Manipuler les listes chainées (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-1-2">
Exercices (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-2-2">
Manipuler les listes chainées (2/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-2-2">
Exercices (2/2)
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/generalites-sur-les-listes-chainees">
<span class="arrow"></span>
<span class="next">Généralités sur les listes chainées</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-1-2">
<span class="next">Manipuler les listes chainées (1/2)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Manipulerleslisteschaines1_2"></a><h2>Manipuler les listes chainées (1/2)</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/declaration-en-c-d-une-liste-chainee">
<span class="arrow"></span>
<span class="next">Déclaration en C d&#039;une liste chainée</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-1-2">
<span class="next">Exercices (1/2)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-323150" data-claire-element-id="323150">Maintenant que nous savons comment déclarer une liste chaînée, il serait intéressant d'apprendre à ajouter des éléments dans cette liste, ainsi que de lire ce qu'elle contient. C'est ce que nous allons étudier dans cette première partie sur la manipulation des listes chaînées. Je vous invite à essayer par vous-mêmes de programmer ces quelques fonctions basiques permettant de manipuler les listes. Dans tous les cas (ou presque), nous renverrons la nouvelle liste, c'est-à-dire un pointeur sur element contenant l'adresse du premier élément de la liste.</p><h2 id="r-ajouter-un-element-1" data-claire-element-id="323167">Ajouter un élément</h2><p id="r-323151" data-claire-element-id="323151">Lorsque nous voulons ajouter un élément dans une liste chaînée, il faut savoir où l'insérer. Les deux ajouts génériques des listes chaînées sont les ajouts en tête, et les ajouts en fin de liste. Nous allons étudier ces deux moyens d'ajouter un élément à une liste.</p><h3 id="r-ajouter-en-tete" data-claire-element-id="323158">Ajouter en tête</h3><p id="r-323152" data-claire-element-id="323152">Lors d'un ajout en tête, nous allons créer un élément, lui assigner la valeur que l'on veut ajouter, puis pour terminer, raccorder cet élément à la liste passée en paramètre. Lors d'un ajout en tête, on devra donc assigner à nxt l'adresse du premier élément de la liste passé en paramètre. Visualisons tout ceci sur un schéma :</p><figure id="r-323154" data-claire-element-id="323155"><img id="r-323153" data-claire-element-id="323153" src="medias/uploads.siteduzero.com_files_39001_40000_39597.jpg" alt="Image utilisateur"/></figure><pre id="r-323156" data-claire-element-id="323156"><code data-claire-semantic="c">llist ajouterEnTete(llist liste, int valeur)
{
    /* On crée un nouvel élément */
    element* nouvelElement = malloc(sizeof(element));
 
    /* On assigne la valeur au nouvel élément */
    nouvelElement-&gt;val = valeur;
 
    /* On assigne l'adresse de l'élément suivant au nouvel élément */
    nouvelElement-&gt;nxt = liste;
 
    /* On retourne la nouvelle liste, i.e. le pointeur sur le premier élément */
    return nouvelElement;
}</code></pre><p id="r-323157" data-claire-element-id="323157">C'est l'ajout le plus simple des deux. Il suffit de créer un nouvel élément puis de le relier au début de la liste originale. Si l'original est , (vide) c'est NULL qui sera assigne au champ nxt du nouvel element. La liste contiendra dans ce cas-là un seul élément.</p><h3 id="r-ajouter-en-fin-de-liste" data-claire-element-id="323166">Ajouter en fin de liste</h3><p id="r-323159" data-claire-element-id="323159">Cette fois-ci, c'est un peu plus compliqué. Il nous faut tout d'abord créer un nouvel élément, lui assigner sa valeur, et mettre l'adresse de l'élément suivant à NULL. En effet,, comme cet élément va terminer la liste nous devons signaler qu'il n'y a plus d'élément suivant. Ensuite, il faut faire pointer le dernier élément de liste originale sur le nouvel élément que nous venons de créer. Pour ce faire, il faut créer un pointeur temporaire sur element qui va se déplacer d'élément en élément, et regarder si cet élément est le dernier de la liste. Un élément sera forcément le dernier de la liste si NULL est assigné à son champ nxt.</p><figure id="r-323161" data-claire-element-id="323162"><img id="r-323160" data-claire-element-id="323160" src="medias/uploads.siteduzero.com_files_39001_40000_39598.jpg" alt="Image utilisateur"/></figure><pre id="r-323163" data-claire-element-id="323163"><code data-claire-semantic="c">llist ajouterEnFin(llist liste, int valeur)
{
    /* On crée un nouvel élément */
    element* nouvelElement = malloc(sizeof(element));
 
    /* On assigne la valeur au nouvel élément */
    nouvelElement-&gt;val = valeur;
 
    /* On ajoute en fin, donc aucun élément ne va suivre */
    nouvelElement-&gt;nxt = NULL;
 
    if(liste == NULL)
    {
        /* Si la liste est videé il suffit de renvoyer l'élément créé */
        return nouvelElement;
    }
    else
    {
        /* Sinon, on parcourt la liste à l'aide d'un pointeur temporaire et on
        indique que le dernier élément de la liste est relié au nouvel élément */
        element* temp=liste;
        while(temp-&gt;nxt != NULL)
        {
            temp = temp-&gt;nxt;
        }
        temp-&gt;nxt = nouvelElement;
        return liste;
    }
}</code></pre><p id="r-323164" data-claire-element-id="323164">Comme vous pouvez le constater, nous nous déplaçons le long de la liste chaînée grâce au pointeur temp. Si l'élément pointé par temp n'est pas le dernier (temp-&gt;nxt != NULL), on avance d'un cran (temp = temp-&gt;nxt) en assignant à temp l'adresse de l'élément suivant. Une fois que l'on est au dernier élément, il ne reste plus qu'à le relier au nouvel élément.</p><p id="r-323165" data-claire-element-id="323165">Si vous pensez avoir bien saisi ces deux fonctions, je vous invite à passer à la partie suivante, dans laquelle je vais vous proposer quelques exercices. Le premier sera fondamental puisqu'il nous permettra d'afficher le contenu d'une liste chaînée.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2">Les listes chaînées</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/generalites-sur-les-listes-chainees">
Généralités sur les listes chainées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/declaration-en-c-d-une-liste-chainee">
Déclaration en C d&#039;une liste chainée
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-1-2">
Manipuler les listes chainées (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-1-2">
Exercices (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-2-2">
Manipuler les listes chainées (2/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-2-2">
Exercices (2/2)
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/declaration-en-c-d-une-liste-chainee">
<span class="arrow"></span>
<span class="next">Déclaration en C d&#039;une liste chainée</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-1-2">
<span class="next">Exercices (1/2)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Exercices1_2"></a><h2>Exercices (1/2)</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-1-2">
<span class="arrow"></span>
<span class="next">Manipuler les listes chainées (1/2)</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-2-2">
<span class="next">Manipuler les listes chainées (2/2)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-323169" data-claire-element-id="323169"><strong>Exercice n°1</strong></p><p id="r-323170" data-claire-element-id="323170">Vous allez maintenant pouvoir vous tester. Votre mission, si vous l'acceptez, est de coder la fonction afficherListe. Vous devrez parcourir la liste jusqu'au bout et afficher toutes les valeurs qu'elle contient. Voici son prototype :</p><pre id="r-323171" data-claire-element-id="323171"><code data-claire-semantic="c">void afficherListe(llist liste);</code></pre><p id="r-323172" data-claire-element-id="323172"><strong>Correction</strong></p><p id="r-323173" data-claire-element-id="323173"></p><div id="r-323177" data-claire-element-id="323177"><div id="r-323176" data-claire-element-id="323176"><pre id="r-323174" data-claire-element-id="323174"><code data-claire-semantic="c">void afficherListe(llist liste)
{
    element *tmp = liste;
    /* Tant que l'on n'est pas au bout de la liste */
    while(tmp != NULL)
    {
        /* On affiche */
        printf(&quot;%d &quot;, tmp-&gt;val);
        /* On avance d'une case */
        tmp = tmp-&gt;nxt;
    }
}</code></pre><p id="r-323175" data-claire-element-id="323175">Alors ? Qu'est ce que ça donne ? Si vous avez réussi ce premier exercice, vous êtes sur la bonne voie.<br/> Quelques explications pour ceux qui ont eu quelques difficultés : la seule chose à faire est de se déplacer le long de la liste chaînée grâce au pointeur tmp. Si ce pointeur tmp pointe sur NULL, c'est que l'on a atteint le bout de la chaîne, sinon c'est que nous sommes sur un élément dont il faut afficher la valeur.</p></div></div><p id="r-323178" data-claire-element-id="323178"><strong>Exercice n°2</strong></p><p id="r-323179" data-claire-element-id="323179">Un deuxième exercice utilisant trois fonctions que nous avons vues jusqu'à présent :</p><ul id="r-323186" data-claire-element-id="323186"><li id="r-323181" data-claire-element-id="323181"><p id="r-323180" data-claire-element-id="323180">ajouterEnTete</p></li><li id="r-323183" data-claire-element-id="323183"><p id="r-323182" data-claire-element-id="323182">ajouterEnFin</p></li><li id="r-323185" data-claire-element-id="323185"><p id="r-323184" data-claire-element-id="323184">afficherListe</p></li></ul><p id="r-323187" data-claire-element-id="323187">Vous devez écrire le main permettant de remplir et afficher la liste chaînée ci-dessous. Vous ne devrez utiliser qu'une seule boucle for.</p><pre id="r-323188" data-claire-element-id="323188"><code data-claire-semantic="console">10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10</code></pre><p id="r-323189" data-claire-element-id="323189">Aucune autre directive pour cet exercice qui nécessite peut-être un peu de logique, mais question technique vous devriez être au point.</p><p id="r-323190" data-claire-element-id="323190"><strong>Correction</strong></p><p id="r-323191" data-claire-element-id="323191"></p><div id="r-323195" data-claire-element-id="323195"><div id="r-323194" data-claire-element-id="323194"><pre id="r-323192" data-claire-element-id="323192"><code data-claire-semantic="c">int main(int argc, char **argv)
{
    llist ma_liste = NULL;
    int i;
 
    for(i=1;i&lt;=10;i++)
    {
        ma_liste = ajouterEnTete(ma_liste, i);
        ma_liste = ajouterEnFin(ma_liste, i);
    }
    afficherListe(ma_liste);
 
    supprimerListe(ma_liste); // Libère les ressources, nous verrons cette fonction plus tard.
 
    return 0;
}</code></pre><p id="r-323193" data-claire-element-id="323193">Une simple boucle suffit. Au début, la liste est vide. Vous ajoutez un premier élément égal à 1, puis un deuxième 1. Après un premier passage, votre liste contient deux éléments 1. Au deuxième passage, nous allons ajouter un élément 2 en tête, puis un élément 2 en fin pour obtenir 2 1 1 2. Il suffit alors de répéter l'opération dix fois.</p></div></div><p id="r-323196" data-claire-element-id="323196"><strong>Exercice n°3</strong></p><p id="r-323197" data-claire-element-id="323197">L'exercice suivant est le plus simple des trois, mais il me faut vous le montrer. Écrivez une fonction qui renvoie 1 si la liste est vide, et 0 si elle contient au moins un élément. Son prototype est le suivant :</p><pre id="r-323198" data-claire-element-id="323198"><code data-claire-semantic="c">int estVide(llist liste);</code></pre><p id="r-323199" data-claire-element-id="323199">Vous vous demandez sûrement l'intérêt d'écrire une telle fonction... eh bien quand vous codez une bibliothèque, le mieux est de &quot;masquer&quot; le fonctionnement interne de vos codes. L'utilisateur n'est pas censé savoir qu'une liste vide sera égale à NULL, ni même que le type llist est un pointeur. Lui, il déclare une llist sans savoir comment elle est créée, puis l'utilise (ajoute ou supprime des éléments, trie sa liste, etc...) grâce aux fonctions de la bibliothèque. Dans certains cas, il lui faudra tester si la liste est vide, il utilisera par exemple :</p><pre id="r-323200" data-claire-element-id="323200"><code data-claire-semantic="c">if(estVide(ma_liste))
    {
        printf(&quot;La liste est vide&quot;);
    }
    else
    {
        afficherListe(ma_liste);
    }</code></pre><p id="r-323201" data-claire-element-id="323201">A vous donc pour cette fonction !</p><p id="r-323202" data-claire-element-id="323202"><strong>Correction</strong></p><p id="r-323203" data-claire-element-id="323203"></p><div id="r-323209" data-claire-element-id="323209"><div id="r-323208" data-claire-element-id="323208"><pre id="r-323204" data-claire-element-id="323204"><code data-claire-semantic="c">int estVide(lliste liste)
{
    if(liste == NULL)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}</code></pre><p id="r-323205" data-claire-element-id="323205">Ou bien, en condensé :</p><pre id="r-323206" data-claire-element-id="323206"><code data-claire-semantic="c">int estVide(llist liste)
{
    return (liste == NULL)? 1 : 0;
}</code></pre><p id="r-323207" data-claire-element-id="323207">Alors ? Rien de plus simple, non ? <br/> Si la liste est NULL, il ne contient aucun élément, elle est donc vide. Sinon, c'est qu'elle contient au minimum un élément.</p></div></div><p id="r-323210" data-claire-element-id="323210">Nous voilà au bout de cette première série d'exercices. Dans la section suivante, nous allons voir plein de fonctions plus complexes permettant de manipuler nos listes chaînées !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2">Les listes chaînées</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/generalites-sur-les-listes-chainees">
Généralités sur les listes chainées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/declaration-en-c-d-une-liste-chainee">
Déclaration en C d&#039;une liste chainée
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-1-2">
Manipuler les listes chainées (1/2)
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-1-2">
Exercices (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-2-2">
Manipuler les listes chainées (2/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-2-2">
Exercices (2/2)
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-1-2">
<span class="arrow"></span>
<span class="next">Manipuler les listes chainées (1/2)</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-2-2">
<span class="next">Manipuler les listes chainées (2/2)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Manipulerleslisteschaines2_2"></a><h2>Manipuler les listes chainées (2/2)</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-1-2">
<span class="arrow"></span>
<span class="next">Exercices (1/2)</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-2-2">
<span class="next">Exercices (2/2)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-323212" data-claire-element-id="323212">Cette fois, ça va monter d'un cran niveau difficulté. Nous allons voir tout un tas de fonctions, pour supprimer des éléments, rechercher un élément... Je vous conseille si vous n'avez pas tout compris de revenir un peu en arrière, de faire des essais avec votre compilateur préféré, parce que tout ce que nous allons voir fonctionne toujours sur le même principe. Je considèrerais ce que j'ai précédemment montré comme acquis. Cette partie va se dérouler comme ceci : j'explique l'algorithme général de la fonction puis je donne son code commenté.</p><p id="r-323213" data-claire-element-id="323213">Prêts ? On y va !</p><h2 id="r-supprimer-un-element-en-tete" data-claire-element-id="323216">Supprimer un élément en tête</h2><p id="r-323214" data-claire-element-id="323214">Il s'agit là de supprimer le premier élément de la liste. Pour ce faire, il nous faudra utiliser la fonction free que vous connaissez certainement. Si la liste n'est pas vide, on stocke l'adresse du premier élément de la liste après suppression (i.e. l'adresse du 2ème élément de la liste originale), on supprime le premier élément, et on renvoie la nouvelle liste. Attention quand même à ne pas libérer le premier élément avant d'avoir stocké l'adresse du second, sans quoi il sera impossible de la récupérer.</p><pre id="r-323215" data-claire-element-id="323215"><code data-claire-semantic="c">llist supprimerElementEnTete(llist liste)
{
    if(liste != NULL)
    {
        /* Si la liste est non vide, on se prépare à renvoyer l'adresse de
        l'élément en 2ème position */
        element* aRenvoyer = liste-&gt;nxt;
        /* On libère le premier élément */
        free(liste);
        /* On retourne le nouveau début de la liste */
        return aRenvoyer;
    }
    else
    {
        return NULL;
    }
}</code></pre><h2 id="r-supprimer-un-element-en-fin-de-liste" data-claire-element-id="323219">Supprimer un élément en fin de liste</h2><p id="r-323217" data-claire-element-id="323217">Cette fois-ci, il va falloir parcourir la liste jusqu'à son dernier élément, indiquer que l'avant-dernier élément va devenir le dernier de la liste et libérer le dernier élément pour enfin retourner le pointeur sur le premier élément de la liste d'origine.</p><pre id="r-323218" data-claire-element-id="323218"><code data-claire-semantic="c">llist supprimerElementEnFin(llist liste)
{
    /* Si la liste est vide, on retourne NULL */
    if(liste == NULL)
        return NULL;
 
    /* Si la liste contient un seul élément */
    if(liste-&gt;nxt == NULL)
    {
        /* On le libère et on retourne NULL (la liste est maintenant vide) */
        free(liste);
        return NULL;
    }
 
    /* Si la liste contient au moins deux éléments */
    element* tmp = liste;
    element* ptmp = liste;
    /* Tant qu'on n'est pas au dernier élément */
    while(tmp-&gt;nxt != NULL)
    {
        /* ptmp stock l'adresse de tmp */
        ptmp = tmp;
        /* On déplace tmp (mais ptmp garde l'ancienne valeur de tmp */
        tmp = tmp-&gt;nxt;
    }
    /* A la sortie de la boucle, tmp pointe sur le dernier élément, et ptmp sur
    l'avant-dernier. On indique que l'avant-dernier devient la fin de la liste
    et on supprime le dernier élément */
    ptmp-&gt;nxt = NULL;
    free(tmp);
    return liste;
}</code></pre><h2 id="r-rechercher-un-element-dans-une-liste" data-claire-element-id="323222">Rechercher un élément dans une liste</h2><p id="r-323220" data-claire-element-id="323220">Le but du jeu cette fois est de renvoyer l'adresse du premier élément trouvé ayant une certaine valeur. Si aucun élément n'est trouvé, on renverra NULL. L'intérêt est de pouvoir, une fois le premier élément trouvé, chercher la prochaine occurrence en recherchant à partir de elementTrouve-&gt;nxt. On parcourt donc la liste jusqu'au bout, et dès qu'on trouve un élément qui correspond à ce que l'on recherche, on renvoie son adresse.</p><pre id="r-323221" data-claire-element-id="323221"><code data-claire-semantic="c">llist rechercherElement(llist liste, int valeur)
{
    element *tmp=liste;
    /* Tant que l'on n'est pas au bout de la liste */
    while(tmp != NULL)
    {
        if(tmp-&gt;val == valeur)
        {
            /* Si l'élément a la valeur recherchée, on renvoie son adresse */
            return tmp;
        }
        tmp = tmp-&gt;nxt;
    }
    return NULL;
}</code></pre><h2 id="r-compter-le-nombre-d-occurrences-d-une-valeur" data-claire-element-id="323225">Compter le nombre d'occurrences d'une valeur</h2><p id="r-323223" data-claire-element-id="323223">Pour ce faire, nous allons utiliser la fonction précédente permettant de rechercher un élément. On cherche une première occurrence : si on la trouve, alors on continue la recherche à partir de l'élément suivant, et ce tant qu'il reste des occurrences de la valeur recherchée. Il est aussi possible d'écrire cette fonction sans utiliser la précédente bien entendu, en parcourant l'ensemble de la liste avec un compteur que l'on incrémente à chaque fois que l'on passe sur un élément ayant la valeur recherchée. Cette fonction n'est pas beaucoup plus compliquée, mais il est intéressant d'un point de vue algorithmique de réutiliser des fonctions pour simplifier nos codes.</p><pre id="r-323224" data-claire-element-id="323224"><code data-claire-semantic="c">int nombreOccurences(llist liste, int valeur)
{
    int i = 0;
 
    /* Si la liste est vide, on renvoie 0 */
    if(liste == NULL)
        return 0;
 
    /* Sinon, tant qu'il y a encore un élément ayant la val = valeur */
    while((liste = rechercherElement(liste, valeur)) != NULL)
    {
        /* On incrémente */
        liste = liste-&gt;nxt;
        i++;
    }
    /* Et on retourne le nombre d'occurrences */
    return i;
}</code></pre><h2 id="r-recherche-du-i-eme-element" data-claire-element-id="323228">Recherche du i-ème élément</h2><p id="r-323226" data-claire-element-id="323226">Pour le coup, c'est une fonction relativement simple. Il suffit de se déplacer i fois à l'aide du pointeur tmp le long de la liste chaînée et de renvoyer l'élément à l'indice i. Si la liste contient moins de i élément(s), alors nous renverrons NULL.</p><pre id="r-323227" data-claire-element-id="323227"><code data-claire-semantic="c">llist element_i(llist liste, int indice)
{
    int i;
    /* On se déplace de i cases, tant que c'est possible */
    for(i=0; i&lt;indice &amp;&amp; liste != NULL; i++)
    {
        liste = liste-&gt;nxt;
    }
 
    /* Si l'élément est NULL, c'est que la liste contient moins de i éléments */
    if(liste == NULL)
    {
        return NULL;
    }
    else
    {
        /* Sinon on renvoie l'adresse de l'élément i */
        return liste;
    }
}</code></pre><h2 id="r-recuperer-la-valeur-d-un-element" data-claire-element-id="323231">Récupérer la valeur d'un élément</h2><p id="r-323229" data-claire-element-id="323229">C'est une fonction du même style que la fonction estVide. Elle sert à &quot;masquer&quot; le fonctionnement interne à l'utilisateur. Il suffit simplement de renvoyer à l'utilisateur la valeur d'un élément. Il faudra renvoyer un code d'erreur entier si l'élément n'existe pas (la liste est vide), c'est donc à vous de définir une macro selon l'utilisation que vous voulez faire des listes chaînées. Dans ce code, je considère qu'on ne travaille qu'avec des nombres entiers positifs, on renverra donc -1 pour une erreur. Vous pouvez mettre ici n'importe quelle valeur que vous êtes sûrs de ne pas utiliser dans votre liste. Une autre solution consiste à renvoyer un pointeur sur int au lieu d'un int, vous laissant donc la possibilité de renvoyer NULL.</p><pre id="r-323230" data-claire-element-id="323230"><code data-claire-semantic="c">#define ERREUR -1
int valeur(llist liste)
{
    return ((liste == NULL)?ERREUR:(liste-&gt;val));
}</code></pre><h2 id="r-compter-le-nombre-d-elements-d-une-liste-chaine" data-claire-element-id="323235">Compter le nombre d'éléments d'une liste chaîné</h2><p id="r-323232" data-claire-element-id="323232">C'est un algorithme vraiment simple. Vous parcourez la liste de bout en bout et incrémentez d'un pour chaque nouvel élément que vous trouvez. Cet algorithme n'ayant aucun intérêt au point où nous en sommes, je vais en profiter pour vous faire découvrir un nouveau type d'algorithme. Jusqu'à maintenant, nous n'avons utilisé que des algorithmes itératifs qui consistent à boucler tant que l'on n'est pas au bout. Nous allons voir qu'il existe des algorithmes que l'on appellent récursifs et qui consistent en fait à demander à une fonction de s'appeler elle-même. Attention : il faudrait un big-tuto complet pour tout expliquer à propos des algorithmes récursifs, ce n'est vraiment que pour vous montrer que ce genre de choses existe que je vais les utiliser dans les deux prochains codes.</p><p id="r-323233" data-claire-element-id="323233">Avant tout, je pense qu'un petit point d'explication s'impose. <br/> Pour créer un algorithme récursif, il faut connaître la condition d'arrêt (ou condition de sortie) et la condition de récurrence. Il faut en fait vous imaginer que votre fonction a fait son office pour les n-1 éléments suivants, et qu'il ne reste plus qu'à traiter le dernier élément. Lisez le code suivant. N'ayez pas peur si ceci vous semble obscur, ce n'est pas essentiel pour utiliser les listes chaînées. Maintenant, je suis sûr que vous êtes au point et vous pouvez donc de manière itérative créer à peu près tout ce qui peut se faire.</p><pre id="r-323234" data-claire-element-id="323234"><code data-claire-semantic="c">int nombreElements(llist liste)
{
    /* Si la liste est vide, il y a 0 élément */
    if(liste == NULL)
        return 0;
 
    /* Sinon, il y a un élément (celui que l'on est en train de traiter)
    plus le nombre d'éléments contenus dans le reste de la liste */
    return nombreElements(liste-&gt;nxt)+1;
}</code></pre><h2 id="r-effacer-tous-les-elements-ayant-une-certaine-valeur" data-claire-element-id="323238">Effacer tous les éléments ayant une certaine valeur</h2><p id="r-323236" data-claire-element-id="323236">Pour cette dernière fonction, nous allons encore une fois utiliser un algorithme récursif. Même si la récursivité vous semble être une notion complexe (et ça l'est sûrement), elle simplifie grandement les algorithmes dans certains cas, et dans celui-ci tout particulièrement. Je vous donne le code à titre indicatif, vous pourrez vous même recoder cette fonction avec un algorithme itératif si vous le voulez.</p><pre id="r-323237" data-claire-element-id="323237"><code data-claire-semantic="c">llist supprimerElement(llist liste, int valeur)
{
    /* Liste vide, il n'y a plus rien à supprimer */
    if(liste == NULL)
        return NULL;
 
    /* Si l'élément en cours de traitement doit être supprimé */
    if(liste-&gt;val == valeur)
    {
        /* On le supprime en prenant soin de mémoriser 
        l'adresse de l'élément suivant */
        element* tmp = liste-&gt;nxt;
        free(liste);
        /* L'élément ayant été supprimé, la liste commencera à l'élément suivant
        pointant sur une liste qui ne contient plus aucun élément ayant la valeur recherchée */
        tmp = supprimerElement(tmp, valeur);
        return tmp;
    }
    else
    {
        /* Si l'élement en cours de traitement ne doit pas être supprimé,
        alors la liste finale commencera par cet élément et suivra une liste ne contenant
        plus d'élément ayant la valeur recherchée */
        liste-&gt;nxt = supprimerElement(liste-&gt;nxt, valeur);
        return liste;
    }
}</code></pre>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2">Les listes chaînées</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/generalites-sur-les-listes-chainees">
Généralités sur les listes chainées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/declaration-en-c-d-une-liste-chainee">
Déclaration en C d&#039;une liste chainée
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-1-2">
Manipuler les listes chainées (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-1-2">
Exercices (1/2)
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-2-2">
Manipuler les listes chainées (2/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-2-2">
Exercices (2/2)
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-1-2">
<span class="arrow"></span>
<span class="next">Exercices (1/2)</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-2-2">
<span class="next">Exercices (2/2)</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Exercices2_2"></a><h2>Exercices (2/2)</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-2-2">
<span class="arrow"></span>
<span class="next">Manipuler les listes chainées (2/2)</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-323240" data-claire-element-id="323240"><strong>Exercice n°1</strong></p><p id="r-323241" data-claire-element-id="323241">Voilà... Maintenant, vous êtes des as en matière de liste chaînées, j'en suis sûr. Je vous propose donc quelques exercices. Le premier sera de coder de manière itérative la fonction nombreElements dont je vous rappelle le prototype :</p><pre id="r-323242" data-claire-element-id="323242"><code data-claire-semantic="c">int nombreElements(llist liste);</code></pre><p id="r-323243" data-claire-element-id="323243">C'est un exercice qui ne devrait pas vous poser de problèmes : bonne chance.</p><p id="r-323244" data-claire-element-id="323244"></p><div id="r-323248" data-claire-element-id="323248"><div id="r-323247" data-claire-element-id="323247"><pre id="r-323245" data-claire-element-id="323245"><code data-claire-semantic="c">int nombreElements(llist liste)
{
    int nb = 0;
    element* tmp = liste;
 
    /* On parcours la liste */
    while(tmp != NULL)
    {
        /* On incrémente */
        nb++;
        tmp = tmp-&gt;nxt;
    }
    /* On retourne le nombre d'éléments parcourus */
    return nb;
}</code></pre><p id="r-323246" data-claire-element-id="323246">C'est aussi simple que ça. On parcourt simplement la liste tant que l'on n'est pas arrivé au bout, et on incrémente le compteur nb que l'on renvoie pour finir.</p></div></div><p id="r-323249" data-claire-element-id="323249"><strong>Exercice n°2</strong></p><p id="r-323250" data-claire-element-id="323250">Nous allons maintenant écrire une fonction permettant d'effacer complètement une liste chaînée de la mémoire. Je vous propose d'écrire avec un algorithme itératif dans un premier temps, puis une seconde fois grâce à un algorithme récursif. Dans le premier cas, vous devez parcourir la liste, stocker l'élément suivant, effacer l'élément courant et avancer d'une case. A la fin la liste est vide, nous retournerons NULL.</p><p id="r-323251" data-claire-element-id="323251"></p><div id="r-323255" data-claire-element-id="323255"><div id="r-323254" data-claire-element-id="323254"><pre id="r-323252" data-claire-element-id="323252"><code data-claire-semantic="c">llist effacerListe(llist liste)
{
    element* tmp = liste;
    element* tmpnxt;
 
    /* Tant que l'on n'est pas au bout de la liste */
    while(tmp != NULL)
    {
        /* On stocke l'élément suivant pour pouvoir ensuite avancer */
        tmpnxt = tmp-&gt;nxt;
        /* On efface l'élément courant */
        free(tmp);
        /* On avance d'une case */
        tmp = tmpnxt;
    }
    /* La liste est vide : on retourne NULL */
    return NULL;
}</code></pre><pre id="r-323253" data-claire-element-id="323253"><code data-claire-semantic="c">llist effacerListe(llist liste)
{
    if(liste == NULL)
    {
        /* Si la liste est vide, il n'y a rien à effacer, on retourne 
        une liste vide i.e. NULL */
        return NULL;
    }
    else
    {
        /* Sinon, on efface le premier élément et on retourne le reste de la 
        liste effacée */
        element *tmp;
        tmp = liste-&gt;nxt;
        free(liste);
        return effacerListe(tmp);
    }
}</code></pre></div></div><p id="r-323256" data-claire-element-id="323256">Et voilà : vous en savez maintenant un peu plus sur ce que sont les listes chaînées. Vous pourrez améliorer ceci en utilisant les listes doublement chaînées, qui sont en fait une liste d'éléments qui pointent à la fois sur l'élément suivant, mais aussi sur l'élément précédent, ce qui vous permet de revenir en arrière plus facilement qu'avec les listes simplement chaînées. Vous pouvez compléter votre bibliothèque avec des fonctions de tri, de recherche de minimum, de maximum et bien d'autre choses...</p><p id="r-323257" data-claire-element-id="323257">Passons maintenant à un petit QCM, afin de vérifier que vous avez tout saisi !</p><p id="r-323258" data-claire-element-id="323258">Eh bien il semblerait que vous êtes au point. Comme vous avez pu le constater, le choix d'utiliser ou non les listes chaînées est fait lors de l'implémentation de votre algorithme dans un langage. Vous devrez toujours faire des compromis.</p><p id="r-323259" data-claire-element-id="323259">J'avais parlé d'introduire les listes doublement chaînées, ce que je vais faire maintenant pour vous permettre d'aller plus loin. L'idée est la suivante : un élément ne va plus se composer d'une valeur et d'une adresse, mais d'une valeur et de deux adresses : l'adresse de l'élément suivant mais aussi l'adresse de l'élément précédent. On pourra tirer avantage de cette spécificité pour lire des listes à l'envers. Avoir l'adresse de l'élément précédent peut simplifier les algorithmes de vos fonctions, mais tout aussi bien les compliquer car c'est maintenant deux pointeurs qu'il faut gérer lors d'un ajout ou d'une suppression.</p><p id="r-323260" data-claire-element-id="323260">Nous sommes loin d'avoir codé une bibliothèque complète, mais vos connaissances vous permettent maintenant de continuer seuls et d'implémenter toutes sortes de fonctions.</p><p id="r-323261" data-claire-element-id="323261">Merci d'avoir lu ce tutoriel jusqu'au bout. Si une ou plusieurs erreurs s'y sont glissées (ce n'est pas exclu), prévenez-moi par MP.</p><aside id="r-323263" data-claire-element-id="323263" data-claire-semantic="information"><p id="r-323262" data-claire-element-id="323262"><strong>Remerciements</strong> à <strong>Nicolas</strong> et <strong>Mleg</strong> pour avoir vérifié, testé ce tutoriel et permis de ce fait sa parution.</p></aside><div id="r-323265" data-claire-element-id="323265" data-claire-semantic="question"><p id="r-323264" data-claire-element-id="323264"><strong>Je sais que le sujet des listes chainées est souvent abordé lors de l'entrée dans les études supérieures, aussi je serais ravis d'apprendre qu'un professeur vous a redirigé sur mon tutoriel, si tel est le cas n'hésitez pas à me le faire savoir par message !</strong></p></div><p id="r-323266" data-claire-element-id="323266">A bientôt !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2">Les listes chaînées</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/generalites-sur-les-listes-chainees">
Généralités sur les listes chainées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/declaration-en-c-d-une-liste-chainee">
Déclaration en C d&#039;une liste chainée
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-1-2">
Manipuler les listes chainées (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-1-2">
Exercices (1/2)
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-2-2">
Manipuler les listes chainées (2/2)
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/exercices-2-2">
Exercices (2/2)
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-listes-chainees-2/manipuler-les-listes-chainees-2-2">
<span class="arrow"></span>
<span class="next">Manipuler les listes chainées (2/2)</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/les-listes-chainees-2.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 02:58:59 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-listes-chainees-2.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:38:59 GMT -->
</html>
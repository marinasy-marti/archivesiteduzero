<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/les-piles-et-les-files-4.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 02:56:08 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-piles-et-les-files-4.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:38:37 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Les piles et les files</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/les-piles-et-les-files-4.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Les piles et les files</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Lespilesetlesfiles">Les piles et les files</a><br/><a href="#Quelquesdfinitions">Quelques définitions</a><br/><a href="#Lespiles">Les piles</a><br/><a href="#Lesfiles">Les files</a><br/></div>
<a name="Lespilesetlesfiles"></a><h2>Les piles et les files</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/quelques-definitions-2">
<span class="next">Quelques définitions</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-378264" data-claire-element-id="378264">En plus des tableaux, les piles ainsi que les files constituent un bon moyen de stocker diverses données en langage C. Dans ce tutoriel, nous verrons à quoi cela correspond et comment nous en servir.</p>
</div><a name="Quelquesdfinitions"></a><h2>Quelques définitions</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/les-piles-6">
<span class="next">Les piles</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-378265" data-claire-element-id="378265">Les piles (<em>stack</em>) et les files (<em>queue</em>) constituent des <strong>structures de données</strong>. Elles vont, comme leur nom l'indique, nous permettre de stocker diverses données, comme pourrait le faire un tableau.</p><p id="r-378266" data-claire-element-id="378266">Une pile permet de réaliser ce que l'on nomme une <strong>LIFO</strong> (<strong>L</strong><em>Last <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut</em>), ce qui signifie en clair que les derniers éléments à être ajoutés à la pile seront les premiers à être récupérés. Il est possible de comparer cela à une pile d'assiettes. Lorsqu'on ajoute une assiette en haut de la pile, on retire toujours en premier celle qui se trouve en haut de la pile, c'est-à-dire celle qui a été ajoutée en dernier, sinon tout le reste s'écroule.</p><p id="r-378267" data-claire-element-id="378267">Une file, quant à elle, permet de réaliser une <strong>FIFO</strong> (<strong>F</strong><em>First <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut</em>), ce qui veut dire que les premiers éléments ajoutés à la file seront aussi les premiers à être récupérés.</p><p id="r-378268" data-claire-element-id="378268">Les piles peuvent être utilisées dans des algorithmes d'évaluation d'expressions mathématiques.<br/> Les files peuvent être utilisées afin de mémoriser des données en attente de traitement.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4">Les piles et les files</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/quelques-definitions-2">
Quelques définitions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/les-piles-6">
Les piles
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/les-files-3">
Les files
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/les-piles-6">
<span class="next">Les piles</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lespiles"></a><h2>Les piles</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/quelques-definitions-2">
<span class="arrow"></span>
<span class="next">Quelques définitions</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/les-files-3">
<span class="next">Les files</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-378270" data-claire-element-id="378270">En langage C, l'implémentation des piles est basée sur les <strong>listes chaînées</strong>. Comment, vous ne savez pas ce que sont les listes chaînées ? Ce n'est pas grave, car vous pourrez lire <a href="http://www.siteduzero.com/tuto-3-9440-1-les-listes-chainees.html">l'excellent tutoriel</a> rédigé par lexou qui vous permettra alors de vous initier aux listes chaînées.</p><aside id="r-378272" data-claire-element-id="378272" data-claire-semantic="warning"><p id="r-378271" data-claire-element-id="378271">Afin de pouvoir comprendre correctement ce tutoriel, il est nécessaire d'avoir des connaissances sur les listes chaînées. Ces connaissances, vous pourrez les acquérir grâce au tutoriel donné ci-dessus.</p></aside><p id="r-378273" data-claire-element-id="378273">Vous voilà maintenant avertis, nous allons pouvoir commencer à nous lancer dans l'implémentation de notre pile en langage C.</p><h2 id="r-la-structure-de-la-pile" data-claire-element-id="378286">La structure de la pile</h2><p id="r-378274" data-claire-element-id="378274">Tout d'abord, nous allons commencer par définir notre structure qui constituera notre pile. Pour notre exemple, nous allons créer une pile d'entiers (int). Comme dit plus haut, notre pile sera basée sur une liste chaînée (simple). Chaque élément de la pile pointera vers l'élément précédent. La liste pointera toujours vers le sommet de la pile. Voici donc la structure qui constituera notre pile :</p><pre id="r-378275" data-claire-element-id="378275"><code data-claire-semantic="c">typedef struct pile
{
    int donnee; /* La donnée que notre pile stockera. */
    struct pile *precedent; /* Pointeur vers l'élément précédent de la pile. */
} Pile;</code></pre><p id="r-378276" data-claire-element-id="378276">Pour avoir une idée de ce à quoi ressemblera notre pile, voici un schéma qui pourra vous aider à mieux la visualiser :</p><figure id="r-378278" data-claire-element-id="378279"><img id="r-378277" data-claire-element-id="378277" src="medias/uploads.siteduzero.com_files_61001_62000_61658.png" alt="pile"/></figure><p id="r-378280" data-claire-element-id="378280">Chaque case représente un <strong>élément</strong> de la pile. Comme vous le voyez, les cases sont en quelque sorte <em>emboîtées</em> les unes sur les autres.</p><p id="r-378281" data-claire-element-id="378281">Néanmoins, ce schéma n'est pas complet. En effet, la position du pointeur n'y est pas représentée. Voici le schéma complet final :</p><figure id="r-378283" data-claire-element-id="378284"><img id="r-378282" data-claire-element-id="378282" src="medias/uploads.siteduzero.com_files_61001_62000_61659.png" alt="pile"/></figure><p id="r-378285" data-claire-element-id="378285">Le pointeur est alors représenté par le jeton noir, figurant tout en haut de le pile, car, rappelez-vous, notre pointeur devra toujours pointer vers le sommet de la pile.<br/> Enfin, on peut dire que les piles sont un cas particulier des listes chaînées. En effet, lors de l'ajout d'un nouvel élément, celui-ci se fera en fin de liste. Identiquement, l'élément qui sera effacé en premier sera l'élément se trouvant en fin de liste.</p><h2 id="r-ajout-d-un-nouvel-element-1" data-claire-element-id="378317">Ajout d'un nouvel élément</h2><p id="r-378287" data-claire-element-id="378287">Tout d'abord, nous allons voir comment ajouter un élément dans notre pile. Pour cela, nous allons réaliser une fonction pile_push dont voici le prototype :</p><pre id="r-378288" data-claire-element-id="378288"><code data-claire-semantic="c">void pile_push(Pile **p_pile, int donnee);</code></pre><p id="r-378289" data-claire-element-id="378289">Il faut alors remarquer que la fonction ne renverra pas la nouvelle pile, c'est pour cela que l'on choisit de passer par un pointeur, ce qui permettra de modifier directement notre pile dans la fonction. Mais, comment l'ajout va-t-il se faire ? Vous allez voir, le principe est simple. Voici les étapes qui vont nous permettre d'ajouter notre élément dans la pile :</p><pre id="r-378290" data-claire-element-id="378290"><code>1. On crée un nouvel élément de type Pile.

2. On vérifie que l'élément a bien été créé.

3. On assigne à la donnée de cet élément la donnée que l'on veut ajouter.

4. On fait pointer cet élément sur le sommet de la pile.

5. On fait pointer le sommet de la pile sur cet élément.</code></pre><p id="r-378291" data-claire-element-id="378291">Maintenant que nous avons <em>l'algorithme</em>, voyons son implémentation (réalisation) en langage C.</p><h3 id="r-1-on-cree-un-nouvel-element-de-type-pile" data-claire-element-id="378294">1. On crée un nouvel élément de type Pile</h3><pre id="r-378292" data-claire-element-id="378292"><code data-claire-semantic="c">Pile *p_nouveau = malloc(sizeof *p_nouveau);</code></pre><p id="r-378293" data-claire-element-id="378293">Grâce à malloc, on alloue de la place pour notre nouveau maillon de la pile. Remarquez alors que je n'ai pas mis sizeof Pile dans le malloc mais sizeof *p_nouveau, ce qui revient exactement au même. Cependant, la deuxième forme présente un avantage. En effet, si, par exemple, on modifie le nom de notre structure, il ne sera pas la peine de le modifier dans notre malloc.</p><h3 id="r-2-on-verifie-que-l-element-a-bien-ete-cree" data-claire-element-id="378297">2. On vérifie que l'élément a bien été créé</h3><pre id="r-378295" data-claire-element-id="378295"><code data-claire-semantic="c">if (p_nouveau != NULL)
{
}</code></pre><p id="r-378296" data-claire-element-id="378296">Cette étape consiste tout simplement à vérifier si notre nouvel élément créé est bel et bien utilisable. Il suffit alors de vérifier si l'allocation s'est bien passée, c'est-à-dire si malloc n'a pas retourné NULL.</p><h3 id="r-3-on-assigne-a-la-donnee-de-cet-element-la-donnee-que-l-on-veut-ajouter" data-claire-element-id="378300">3. On assigne à la donnée de cet élément la donnée que l'on veut ajouter</h3><pre id="r-378298" data-claire-element-id="378298"><code data-claire-semantic="c">p_nouveau-&gt;donnee = donnee;</code></pre><p id="r-378299" data-claire-element-id="378299">Ici, on assigne tout simplement à p_nouveau-&gt;donnee (rappelez-vous la structure) la donnée que l'on passe en paramètre, de manière à ce que l'on puisse la stocker dans la pile.</p><h3 id="r-4-on-fait-pointer-cet-element-sur-le-sommet-de-la-pile" data-claire-element-id="378303">4. On fait pointer cet élément sur le sommet de la pile</h3><pre id="r-378301" data-claire-element-id="378301"><code data-claire-semantic="c">p_nouveau-&gt;precedent = *p_pile;</code></pre><p id="r-378302" data-claire-element-id="378302">Par cette étape, on commence à attacher notre nouvel élément créé à la pile.</p><h3 id="r-5-on-fait-pointer-le-sommet-de-la-pile-sur-cet-element" data-claire-element-id="378316">5. On fait pointer le sommet de la pile sur cet élément</h3><pre id="r-378304" data-claire-element-id="378304"><code data-claire-semantic="c">*p_pile = p_nouveau;</code></pre><p id="r-378305" data-claire-element-id="378305">Enfin, on finalise notre attachement en faisant pointer la pile vers notre élément, ce qui nous permet d'avoir un pointeur vers le sommet de la pile.</p><p id="r-378306" data-claire-element-id="378306">En rassemblant toutes les étapes, voici notre fameuse fonction :</p><pre id="r-378307" data-claire-element-id="378307"><code data-claire-semantic="c">void pile_push(Pile **p_pile, int donnee)
{
        Pile *p_nouveau = malloc(sizeof *p_nouveau);
        if (p_nouveau != NULL)
        {
                p_nouveau-&gt;donnee = donnee;
                p_nouveau-&gt;precedent = *p_pile;
                *p_pile = p_nouveau;
        }
}</code></pre><p id="r-378308" data-claire-element-id="378308">Si vous avez du mal à visualiser comment se déroule l'ajout, voici un schéma :</p><figure id="r-378310" data-claire-element-id="378311"><img id="r-378309" data-claire-element-id="378309" src="medias/uploads.siteduzero.com_files_63001_64000_63394.png" alt="Image utilisateur"/></figure><p id="r-378312" data-claire-element-id="378312">Dans ce schéma, on suppose que l'on veut ajouter la valeur 14 à la pile et que la création du nouvel élément s'est bien passée. Ce schéma vous montre les différentes étapes jusqu'à l'étape 4. Ici, nous pointons sur l'avant-dernier élément de la pile, d'où l'étape 5 pour « monter » le pointeur d'un cran comme ceci :</p><figure id="r-378314" data-claire-element-id="378315"><img id="r-378313" data-claire-element-id="378313" src="medias/uploads.siteduzero.com_files_63001_64000_63396.png" alt="Image utilisateur"/></figure><h2 id="r-retrait-d-un-element" data-claire-element-id="378343">Retrait d'un élément</h2><p id="r-378318" data-claire-element-id="378318">Voyons maintenant comment retirer un élément de la pile. L'élément qui sera retiré sera le dernier élément que l'on a ajouté, c'est-à-dire l'élément se trouvant au sommet de la pile. Voici le prototype de notre fonction :</p><pre id="r-378319" data-claire-element-id="378319"><code data-claire-semantic="c">int pile_pop(Pile **p_pile);</code></pre><p id="r-378320" data-claire-element-id="378320">À l'instar de la première fonction, cette fonction modifiera aussi directement la pile grâce à un pointeur. La fonction renverra la valeur de l'élément qu'elle a dépilée. Regardons désormais les différentes étapes nous permettant de retirer un élément :</p><pre id="r-378321" data-claire-element-id="378321"><code>1. Vérifier si la pile n'est pas vide.

2. Si elle ne l'est pas, stocker dans un élément temporaire l'avant-dernier élément de la pile.

3. Stocker dans une variable locale la valeur étant stockée dans le dernier élément de la pile.

4. Supprimer le dernier élément.

5. Faire pointer la pile vers notre élément temporaire.

6. Retourner la valeur dépilée.</code></pre><p id="r-378322" data-claire-element-id="378322">Dans cette fonction, on retrouve une étape en plus, car notre fonction doit retourner une valeur de type int.<br/> Passons maintenant à l'implémentation.</p><h3 id="r-1-verifier-si-la-pile-n-est-pas-vide" data-claire-element-id="378325">1. Vérifier si la pile n'est pas vide</h3><pre id="r-378323" data-claire-element-id="378323"><code data-claire-semantic="c">if (*p_pile != NULL)
{
}</code></pre><p id="r-378324" data-claire-element-id="378324">Ici, il suffit juste de vérifier si la pile n'est pas un pointeur NULL. Si ce n'est pas le cas, la pile n'est pas vide.</p><h3 id="r-2-si-elle-ne-l-est-pas-stocker-dans-un-element-temporaire-l-avant-dernier-element-de-la-pile" data-claire-element-id="378328">2. Si elle ne l'est pas, stocker dans un élément temporaire l'avant-dernier élément de la pile</h3><pre id="r-378326" data-claire-element-id="378326"><code data-claire-semantic="c">Pile *temporaire = (*p_pile)-&gt;precedent;</code></pre><p id="r-378327" data-claire-element-id="378327">Rappelez-vous, nous pointons toujours vers le dernier élément de la pile, donc l'élément précédent est l'avant-dernier élément de la pile.</p><h3 id="r-3-stocker-dans-une-variable-locale-la-valeur-etant-stockee-dans-le-dernier-element-de-la-pile" data-claire-element-id="378331">3. Stocker dans une variable locale la valeur étant stockée dans le dernier élément de la pile</h3><pre id="r-378329" data-claire-element-id="378329"><code data-claire-semantic="c">ret = (*p_pile)-&gt;donnee;</code></pre><p id="r-378330" data-claire-element-id="378330">Nous voulons retourner la valeur de l'élément que nous allons supprimer, il est donc nécessaire de la récupérer avant de supprimer cet élément.<br/> N.B. : la variable ret sera déclarée en haut de la fonction et initialisée à -1.</p><h3 id="r-4-supprimer-le-dernier-element" data-claire-element-id="378334">4. Supprimer le dernier élément</h3><pre id="r-378332" data-claire-element-id="378332"><code data-claire-semantic="c">free(*p_pile), *p_pile = NULL;</code></pre><p id="r-378333" data-claire-element-id="378333">La pile pointe sur le dernier élément, il suffit donc d'utiliser free pour supprimer le dernier élément. De plus, après chaque free, il ne faut pas oublier de remettre le pointeur à NULL.</p><h3 id="r-5-faire-pointer-la-pile-vers-notre-element-temporaire" data-claire-element-id="378337">5. Faire pointer la pile vers notre élément temporaire</h3><pre id="r-378335" data-claire-element-id="378335"><code data-claire-semantic="c">*p_pile = temporaire;</code></pre><p id="r-378336" data-claire-element-id="378336">Afin de « mettre à jour » notre pile, on la fait pointer sur notre élément temporaire qui est l'avant-dernier élément de la pile.</p><h3 id="r-6-retourner-la-valeur-depilee" data-claire-element-id="378342">6. Retourner la valeur dépilée</h3><pre id="r-378338" data-claire-element-id="378338"><code data-claire-semantic="c">return ret;</code></pre><p id="r-378339" data-claire-element-id="378339">Il suffit tout simplement d'utiliser l'instruction return pour retourner la valeur de l'élément que l'on vient de supprimer.</p><p id="r-378340" data-claire-element-id="378340">Voici donc notre fonction complète :</p><pre id="r-378341" data-claire-element-id="378341"><code data-claire-semantic="c">int pile_pop(Pile **p_pile)
{
    int ret = -1;
    if (p_pile != NULL)
    {
        Pile *temporaire = (*p_pile)-&gt;precedent;
        ret = (*p_pile)-&gt;donnee;  
        free(*p_pile), *p_pile = NULL;
        *p_pile = temporaire;
    }
    return ret;
}</code></pre><h2 id="r-vidage-de-la-pile" data-claire-element-id="378356">Vidage de la pile</h2><p id="r-378344" data-claire-element-id="378344">Nous allons maintenant étudier notre dernière fonction ensemble. Il s'agit de la fonction permettant d'effacer la pile. Voici son prototype :</p><pre id="r-378345" data-claire-element-id="378345"><code data-claire-semantic="c">void pile_clear(Pile **p_pile);</code></pre><p id="r-378346" data-claire-element-id="378346">Comme vous l'aurez sans doute deviné, cette fonction modifie aussi directement la pile. Malgré tout, cette fonction se réalise en seulement deux étapes :</p><pre id="r-378347" data-claire-element-id="378347"><code>1. Tant que la pile n'est pas vide.

2. Effacer le dernier élément de la pile.</code></pre><p id="r-378348" data-claire-element-id="378348">Voici le code en langage C…</p><h3 id="r-1-tant-que-la-pile-n-est-pas-vide" data-claire-element-id="378351">1. Tant que la pile n'est pas vide</h3><pre id="r-378349" data-claire-element-id="378349"><code data-claire-semantic="c">while (*p_pile != NULL)
{
}</code></pre><p id="r-378350" data-claire-element-id="378350">Ici, il suffit tout simplement de réaliser une boucle while pour vérifier si la pile est vide ou pas.</p><h3 id="r-2-effacer-le-dernier-element-de-la-pile" data-claire-element-id="378355">2. Effacer le dernier élément de la pile</h3><pre id="r-378352" data-claire-element-id="378352"><code data-claire-semantic="c">pile_pop(p_pile);</code></pre><p id="r-378353" data-claire-element-id="378353">Grâce à la fonction pile_pop que nous venons de créer, on efface le dernier élément de la pile. Ainsi, tous les éléments sont effacés un par un. Voici la fonction finale :</p><pre id="r-378354" data-claire-element-id="378354"><code data-claire-semantic="c">void pile_clear(Pile **p_pile)
{
    while (*p_pile != NULL)
    {
        pile_pop(p_pile);
    }
}</code></pre><h2 id="r-exercice-27" data-claire-element-id="378368">Exercice</h2><h3 id="r-enonce-45" data-claire-element-id="378360">Énoncé</h3><p id="r-378357" data-claire-element-id="378357">Je vous propose maintenant un exercice. Eh oui, c'est un peu à vous de coder. :-° Pour cet exercice, je vous propose de créer une fonction pile_peek retournant la valeur du dernier élément, mais sans le dépiler comme le ferait la fonction pile_pop. Voici le prototype de cette fonction :</p><pre id="r-378358" data-claire-element-id="378358"><code data-claire-semantic="c">int pile_peek(Pile *p_pile);</code></pre><p id="r-378359" data-claire-element-id="378359">Si la pile est vide, la fonction devra retourner -1. Allez, je vous laisse faire.<br/> N.B. : remarquez que pour cette fonction, il n'est pas utile de passer l'adresse de la pile à la fonction, car celle-ci ne modifie pas notre pile. C'est pour cela que nous mettons un seul * au lieu de deux.</p><h3 id="r-solution-53" data-claire-element-id="378367">Solution</h3><p id="r-378361" data-claire-element-id="378361">Maintenant, passons à la solution. J'espère que vous avez au moins essayé l'exercice avant de regarder cette solution. Voici donc le code corrigé et commenté :</p><p id="r-378362" data-claire-element-id="378362"></p><div id="r-378365" data-claire-element-id="378365"><div id="r-378364" data-claire-element-id="378364"><pre id="r-378363" data-claire-element-id="378363"><code data-claire-semantic="c">int pile_peek(Pile *p_pile)
{
    int ret = -1; /* Variable de retour. */
    if (p_pile != NULL) /* Si la pile n'est pas vide. */
    {
        ret = p_pile-&gt;donnee; /* On stocke dans la variable ret la valeur du dernier élément. */
    }
    return ret;
}</code></pre></div></div><p id="r-378366" data-claire-element-id="378366">Voilà, nous en avons fini avec les piles, et nous allons maintenant pouvoir passer aux files.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4">Les piles et les files</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/quelques-definitions-2">
Quelques définitions
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/les-piles-6">
Les piles
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/les-files-3">
Les files
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/quelques-definitions-2">
<span class="arrow"></span>
<span class="next">Quelques définitions</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/les-files-3">
<span class="next">Les files</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesfiles"></a><h2>Les files</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/les-piles-6">
<span class="arrow"></span>
<span class="next">Les piles</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-378370" data-claire-element-id="378370">Après avoir vu les piles et leur fonctionnement en langage C, nous allons maintenant nous intéresser aux files.</p><aside id="r-378372" data-claire-element-id="378372" data-claire-semantic="information"><p id="r-378371" data-claire-element-id="378371">Dans cette partie, je considère que la partie précédente sur les piles a été acquise et entièrement comprise, je ne donnerai donc cette fois-ci pas de schéma explicatif, car le principe est similaire.</p></aside><h2 id="r-la-structure-de-la-file" data-claire-element-id="378376">La structure de la file</h2><p id="r-378373" data-claire-element-id="378373">Comme pour l'étude des piles, nous allons étudier la structure qui constituera notre file. Identiquement aux piles, cette structure sera basée sur les listes chaînées. Cependant, cette fois-ci, on ne pointera plus sur le sommet, mais sur la base de la file. Voici donc la structure :</p><pre id="r-378374" data-claire-element-id="378374"><code data-claire-semantic="c">typedef struct file
{
    int donnee;
    struct file *suivant;
} File;</code></pre><p id="r-378375" data-claire-element-id="378375">Remarquez alors que, cette fois-ci, nous utilisons un pointeur vers l'élément suivant et non plus vers l'élément précédent. Cela s'explique par le fait que nous pointons à la base de la file, c'est-à-dire sur le premier élément de la file.<br/> Lors de l'ajout d'un élément, celui-ci se fera en fin de liste. Le retrait d'un élément se fera en début de liste.</p><h2 id="r-ajout-d-un-element" data-claire-element-id="378408">Ajout d'un élément</h2><p id="r-378377" data-claire-element-id="378377">Dans un premier temps, voyons comment ajouter un élément à une file. Comme dit ci-dessus, l'ajout d'un élément dans une file se fera à la fin de la file. Pour cela, nous allons réaliser une fonction file_enqueue dont voici le prototype :</p><pre id="r-378378" data-claire-element-id="378378"><code data-claire-semantic="c">void file_enqueue(File **p_file, int donnee);</code></pre><p id="r-378379" data-claire-element-id="378379">Là encore, comme vous l'aurez sûrement compris, notre fonction modifiera directement notre file, d'où l'intérêt des deux **.<br/> L'ajout d'un élément dans une file est un peu plus complexe que l'ajout d'un élément dans une pile. En effet, dans le cas où la file n'est pas vide, il faudra d'abord la parcourir entièrement pour pouvoir ajouter notre élément à la fin. Si vous avez une idée du principe, je vous encourage à essayer de coder cette fonction et celles qui suivront tous seuls, cela vous obligera à réfléchir un minimum. ;) <br/> Voici l'algorithme de notre fonction :</p><pre id="r-378380" data-claire-element-id="378380"><code>1. On crée un nouvel élément de type File.

2. On vérifie que le nouvel élément a bien été créé.

3. On fait pointer cet élément vers NULL.

4. On assigne à la donnée de cet élément la donnée que l'on veut ajouter.

5. Si la file est vide, alors on fait pointer la file vers l'élément que l'on vient de créer.

6. Sinon, on crée un élément temporaire de type File pointant vers notre file.

7. On parcourt entièrement la file.

8. On fait pointer l'élément temporaire vers le nouvel élément créé.</code></pre><p id="r-378381" data-claire-element-id="378381">Vous voyez donc qu'il y a quelques étapes en plus par rapport aux piles. <br/> Passons maintenant à l'implémentation.</p><h3 id="r-1-on-cree-un-nouvel-element-de-type-file" data-claire-element-id="378384">1. On crée un nouvel élément de type File</h3><pre id="r-378382" data-claire-element-id="378382"><code data-claire-semantic="c">File *p_nouveau = malloc(sizeof *p_nouveau);</code></pre><p id="r-378383" data-claire-element-id="378383">Inutile de vous réexpliquer cette étape, il s'agit du même principe que pour les piles expliqué plus haut.</p><h3 id="r-2-on-verifie-que-le-nouvel-element-a-bien-ete-cree" data-claire-element-id="378387">2. On vérifie que le nouvel élément a bien été créé</h3><pre id="r-378385" data-claire-element-id="378385"><code data-claire-semantic="c">if (p_nouveau != NULL)
{
}</code></pre><p id="r-378386" data-claire-element-id="378386">On pense toujours à vérifier le retour de malloc.</p><h3 id="r-3-on-fait-pointer-cet-element-vers-null" data-claire-element-id="378390">3. On fait pointer cet élément vers NULL</h3><pre id="r-378388" data-claire-element-id="378388"><code data-claire-semantic="c">p_nouveau-&gt;suivant = NULL;</code></pre><p id="r-378389" data-claire-element-id="378389">L'élément sera ajouté en fin de liste, il faut donc le faire pointer vers NULL.</p><h3 id="r-4-on-assigne-a-la-donnee-de-cet-element-la-donnee-que-l-on-veut-ajouter" data-claire-element-id="378393">4. On assigne à la donnée de cet élément la donnée que l'on veut ajouter</h3><pre id="r-378391" data-claire-element-id="378391"><code data-claire-semantic="c">p_nouveau-&gt;donnee = donnee;</code></pre><p id="r-378392" data-claire-element-id="378392">Inutile de commenter cette étape, je pense que vous l'avez comprise.</p><h3 id="r-5-si-la-file-est-vide-alors-on-fait-pointer-la-file-vers-l-element-que-l-on-vient-de-creer" data-claire-element-id="378396">5. Si la file est vide, alors on fait pointer la file vers l'élément que l'on vient de créer</h3><pre id="r-378394" data-claire-element-id="378394"><code data-claire-semantic="c">if (*p_file == NULL)
{
    *p_file = p_nouveau;
}</code></pre><p id="r-378395" data-claire-element-id="378395">Notre file devra pointer vers le premier élément. Lors de l'ajout, si celle-ci est vide, il faut donc la faire pointer vers l'élément que l'on vient de créer de manière à ce qu'elle pointe vers le début de la liste, c'est-à-dire vers le premier élément.</p><h3 id="r-6-sinon-on-cree-un-element-temporaire-de-type-file-pointant-vers-notre-file" data-claire-element-id="378399">6. Sinon, on crée un élément temporaire de type File pointant vers notre file</h3><pre id="r-378397" data-claire-element-id="378397"><code data-claire-semantic="c">else
{
    File *p_tmp = *p_file;</code></pre><p id="r-378398" data-claire-element-id="378398">Pour pouvoir parcourir entièrement la liste, on crée un élément temporaire étant le début de la file.<br/> N.B. : le <em>else</em> n'est pas refermé car des instructions suivront.</p><h3 id="r-7-on-parcourt-entierement-la-file" data-claire-element-id="378402">7. On parcourt entièrement la file</h3><pre id="r-378400" data-claire-element-id="378400"><code data-claire-semantic="c">while (p_tmp-&gt;suivant != NULL)
{
    p_tmp = p_tmp-&gt;suivant;
}</code></pre><p id="r-378401" data-claire-element-id="378401">Afin que l'élément soit ajouté en fin de la liste, nous nous devons de la parcourir entièrement pour arriver à la fin. De ce fait, nous utilisons une boucle while.</p><h3 id="r-8-on-fait-pointer-l-element-temporaire-vers-le-nouvel-element-cree" data-claire-element-id="378407">8. On fait pointer l'élément temporaire vers le nouvel élément créé</h3><pre id="r-378403" data-claire-element-id="378403"><code data-claire-semantic="c">p_tmp-&gt;suivant = p_nouveau;
}</code></pre><p id="r-378404" data-claire-element-id="378404">Grâce à cette étape, nous rattachons l'élément créé à la liste. L'élément se situe alors à la fin de la liste.<br/> N.B. : l'accolade fermante « } » est la fermeture du <em>else</em> précédemment ouvert.</p><p id="r-378405" data-claire-element-id="378405">Voici donc notre fonction complète :</p><pre id="r-378406" data-claire-element-id="378406"><code data-claire-semantic="c">void file_enqueue(File **p_file, int donnee)
{
    File *p_nouveau = malloc(sizeof *p_nouveau);
    if (p_nouveau != NULL)
    {
        p_nouveau-&gt;suivant = NULL;
        p_nouveau-&gt;donnee = donnee;
        if (*p_file == NULL)
        {
            *p_file = p_nouveau;
        }
        else
        {
            File *p_tmp = *p_file;
            while (p_tmp-&gt;suivant != NULL)
            {
                p_tmp = p_tmp-&gt;suivant;
            }
            p_tmp-&gt;suivant = p_nouveau;
        }
    }
}</code></pre><h2 id="r-retrait-d-un-element-1" data-claire-element-id="378413">Retrait d'un élément</h2><p id="r-378409" data-claire-element-id="378409">Tout comme les piles, nous aurons aussi besoin d'une fonction permettant d'enlever un élément de la file. L'élément qui sera enlevé sera le premier élément de la file. Le prototype de la fonction nous permettant de réaliser cette action est le suivant :</p><pre id="r-378410" data-claire-element-id="378410"><code data-claire-semantic="c">int file_dequeue(File **p_file);</code></pre><p id="r-378411" data-claire-element-id="378411">À partir de maintenant, je ne vais plus vous détailler l'algorithme complet et toutes les étapes de l'implémentation. Je considère qu'après toutes les fonctions que nous venons de réaliser ensemble, vous êtes capables de réfléchir au fonctionnement des fonctions qui vont suivre. C'est pour cela que je vais vous donner directement le code commenté :</p><pre id="r-378412" data-claire-element-id="378412"><code data-claire-semantic="c">int file_dequeue(File **p_file)
{
    int ret = -1;
    /* On teste si la file n'est pas vide. */
    if (*p_file != NULL)
    {
        /* Création d'un élément temporaire pointant vers le deuxième élément de la file. */
        File *p_tmp = (*p_file)-&gt;suivant;
        /* Valeur à retourner */
        ret = (*p_file)-&gt;donnee;
        /* Effacement du premier élément. */
        free(*p_file), *p_file = NULL;
        /* On fait pointer la file vers le deuxième élément. */
        *p_file = p_tmp;
    }
    return ret;
}</code></pre><h2 id="r-vidage-de-la-file" data-claire-element-id="378416">Vidage de la file</h2><p id="r-378414" data-claire-element-id="378414">Pour cette fonction, nous allons, à l'instar des piles, enlever chaque élément de la file un par un tant que la file n'est pas vide. Je vous conseille d'essayer de faire cette fonction tous seuls. Si vous bloquez, inspirez-vous du modèle effectué pour les piles. Voici le code :</p><pre id="r-378415" data-claire-element-id="378415"><code data-claire-semantic="c">void file_clear(File **p_file)
{
    /* Tant que la file n'est pas vide. */
    while (*p_file != NULL)
    {
        /* On enlève l'élément courant. */
        file_dequeue(p_file);
    }
}</code></pre><h2 id="r-exercice-28" data-claire-element-id="378426">Exercice</h2><h3 id="r-enonce-46" data-claire-element-id="378418">Énoncé</h3><p id="r-378417" data-claire-element-id="378417">Afin de terminer ce tutoriel, je vous repropose un petit exercice. Vous vous souvenez de la fonction pile_peek ? Eh bien le but de cet exercice est cette fois-ci de faire une fonction file_qeek retournant la valeur du premier élément de la file sans l'enlever de la liste. Le principe est rigoureusement le même que pour les piles.</p><h3 id="r-solution-54" data-claire-element-id="378425">Solution</h3><p id="r-378419" data-claire-element-id="378419">Normalement, cet exercice n'a pas dû vous poser de problème, car il suffisait de reprendre le principe abordé avec les piles. Voici le code corrigé :</p><p id="r-378420" data-claire-element-id="378420"></p><div id="r-378423" data-claire-element-id="378423"><div id="r-378422" data-claire-element-id="378422"><pre id="r-378421" data-claire-element-id="378421"><code data-claire-semantic="c">int file_qeek(File *p_file)
{
    int ret = -1;
    if (p_file != NULL)
    {
        ret = p_file-&gt;donnee;
    }
    return ret;
}</code></pre></div></div><p id="r-378424" data-claire-element-id="378424">Nous voici donc arrivés au terme de ce tutoriel. J'espère que celui-ci vous a permis d'avancer un peu plus dans l'apprentissage du langage C en découvrant d'autres structures de données que les tableaux. Retenez que les piles et les files sont un très bon moyen pour stocker des données dont on ne connaît le nombre à l'avance.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4">Les piles et les files</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/quelques-definitions-2">
Quelques définitions
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/les-piles-6">
Les piles
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/les-files-3">
Les files
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-piles-et-les-files-4/les-piles-6">
<span class="arrow"></span>
<span class="next">Les piles</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/les-piles-et-les-files-4.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 02:56:09 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-piles-et-les-files-4.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:38:38 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/les-extensions-5.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 06:50:48 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-extensions-5.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:14:37 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Les extensions</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/les-extensions-5.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Les extensions</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Lesextensions">Les extensions</a><br/><a href="#C039estquoilesextensions">C&#039;est quoi les extensions ?</a><br/><a href="#Commentafonctionne">Comment ça fonctionne ?</a><br/><a href="#UtilisationdelaSDLmthodemanuelle">Utilisation de la SDL : méthode manuelle</a><br/><a href="#UtilisationdeGLEWmthodeautomatique">Utilisation de GLEW : méthode automatique</a><br/><a href="#Unexemplecomplet">Un exemple complet</a><br/></div>
<a name="Lesextensions"></a><h2>Les extensions</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/c-est-quoi-les-extensions">
<span class="next">C&#039;est quoi les extensions ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-571662" data-claire-element-id="571662">Bienvenue sur ce tutoriel.</p><p id="r-571663" data-claire-element-id="571663">Peut-être n'avez-vous jamais entendu parler des <strong>extensions</strong> d'OpenGL ? Et bien il est grand temps que vous fassiez leur découverte, car croyez-moi, elles sont indispensables si vous voulez aller plus loin avec <a href="http://www.siteduzero.com/tuto-3-1346-0-creez-des-programmes-en-3d-avec-opengl.html">OpenGL</a>.</p><p id="r-571664" data-claire-element-id="571664">Il nous faudra tout d'abord voir qui sont ces extensions, ce nom peut-être barbare ne doit pas vous faire peur ;) Puis nous apprendrons à les utiliser avec un exemple de code tout simple.</p><p id="r-571665" data-claire-element-id="571665">En avant moussaillons ! :pirate:</p>
</div><a name="C039estquoilesextensions"></a><h2>C&#039;est quoi les extensions ?</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/comment-ca-fonctionne-3">
<span class="next">Comment ça fonctionne ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-571666" data-claire-element-id="571666">Entrons sans plus attendre dans le vif du sujet :)</p><p id="r-571667" data-claire-element-id="571667">Vous ne savez pas ce que c'est, pourtant vous lisez ce tutoriel et tenez à les découvrir. Eh bien soit.</p><h2 id="r-presentation-du-systeme-d-extensions-d-opengl" data-claire-element-id="571677">Présentation du système d'extensions d'OpenGL</h2><p id="r-571668" data-claire-element-id="571668">Comme chacun le sait, OpenGL est une API écrite en langage C proposant de multiples fonctionnalités pour effectuer un rendu 3D simplement.</p><p id="r-571669" data-claire-element-id="571669">Toutefois, certaines fonctionnalités ne sont pas accessibles directement via OpenGL, il va nous falloir passer par un tiers : les extensions.<br/> Une extension est, comme son nom l'indique, une extension, un petit quelque chose en plus. Cependant, il ne s'agit pas d'une fonctionnalité gadget dont on pourrait se passer, mais bien d'une fonction native indispensable pour la réalisation de certaines choses. Ces choses, qui ne seront pas traitées ici, sont entre autres les VBOs, les shaders, le multi-texturing, les occlusion queries, et j'en passe.</p><p id="r-571670" data-claire-element-id="571670">Les extensions permettent donc de gérer certaines fonctionnalités comme celles citées ci-dessus. Vous allez, via les extensions, utiliser ce que vous ne pouviez pas utiliser directement avec votre implémentation d'OpenGL.</p><div id="r-571672" data-claire-element-id="571672" data-claire-semantic="question"><p id="r-571671" data-claire-element-id="571671">Pourquoi doit-on passer par les extensions ? Ça a l'air bien compliqué...</p></div><p id="r-571673" data-claire-element-id="571673">Ça, c'est la question qui tue ^^</p><p id="r-571674" data-claire-element-id="571674">Nous allons nous représenter cela historiquement. À l'origine, OpenGL était en version 1.1, les fonctionnalités supportées alors sont peu nombreuses, OpenGL se résume à la projection d'un triangle à l'écran, bref, rien de très tremblant. Aujourd'hui, OpenGL est en version 2.1, les fonctionnalités supportées sont beaucoup plus nombreuses, l'API a subit de multiples intégrations de fonctionnalités avancées (shaders entre autres, ...) ; chouette, tout le monde est content.</p><p id="r-571675" data-claire-element-id="571675">Cependant, certaines implémentations, notamment sous Windows, sont toujours en version 1.1. Par implémentation, je veux parler des fichiers de développement : .h, .lib ou .a. Effectivement, certains OS ne proposent pas encore d'implémentation plus récente que la 1.1, ainsi il est impossible de pouvoir utiliser les nouveautés des versions supérieures d'OpenGL.</p><p id="r-571676" data-claire-element-id="571676">Afin de bénéficier sur ces OS des améliorations apportées à OpenGL depuis sa version 1.1, nous allons devoir utiliser les extensions.</p><h2 id="r-la-standardisation-d-opengl" data-claire-element-id="571681">La standardisation d'OpenGL</h2><p id="r-571678" data-claire-element-id="571678">Les améliorations apportées à OpenGL depuis sa version 1.1 sont nombreuses et proviennent de plusieurs sources. Ces sources sont principalement les constructeurs de carte graphique. En effet, lorsqu'ils intègrent de nouvelles fonctionnalités à leurs cartes, les constructeurs doivent également, dans le cas d'OpenGL, créer une extension qui permettera de les exploiter.</p><p id="r-571679" data-claire-element-id="571679">Ce sont donc des constructeurs de carte graphique dont proviennent principalement les extensions, mais étant donné qu'il existe plusieurs entreprises de construction de carte graphique, une extension proposée par l'une ne sera pas forcément compatible avec l'autre, il faut donc qu'OpenGL soit standardisé afin que nous, petits programmeurs, puissions faire du code source portable :)</p><p id="r-571680" data-claire-element-id="571680">La standardisation d'OpenGL était assurée jusqu'à maintenant (fin 2006/début 2007) par l'ARB, qui était en fait constituée entre autres des &quot;principaux représentants&quot; des constructeurs de carte graphique. Aujourd'hui, la standardisation a été reléguée à <a href="http://www.khronos.org/">The Khronos Group</a> (<a href="http://fr.wikipedia.org/wiki/Khronos Group">Khronos Group</a>).</p><h2 id="r-support-or-not-support" data-claire-element-id="571685">Support or not support ?</h2><p id="r-571682" data-claire-element-id="571682">Les extensions ne doivent pas être vue comme une méthode destinée à embêter le développeur inutilement, mais plutôt comme une astuce afin de permettre à chacun d'exploiter au maximum les fonctionnalités supportées par sa carte graphique sans attendre la mise à jour des fichiers de développement (qui se fait attendre chez certains OS).</p><p id="r-571683" data-claire-element-id="571683">Toutefois, votre carte graphique ne supporte peut-être pas toutes les extensions que vous lui demanderez de manger. Il est possible de voir lesquelles elle supporte et lesquelles elle ne supporte pas, il nous faudra d'ailleurs impérativement passer par cette étape de vérification afin d'être sûrs de ne pas faire planter notre programme, car l'utilisation d'une extension non supportée conduit à un comportement indéfini (on trouvera le plus souvent des erreurs de segmentation).</p><p id="r-571684" data-claire-element-id="571684">L'étape de la gestion du support est donc primordiale.</p><h2 id="r-et-en-pratique-comment-on-gere-ca" data-claire-element-id="571695">Et en pratique, comment on gère ça ?</h2><p id="r-571686" data-claire-element-id="571686">Nous avons deux possibilités :</p><ul id="r-571691" data-claire-element-id="571691"><li id="r-571688" data-claire-element-id="571688"><p id="r-571687" data-claire-element-id="571687"><strong>Demander l'extension via la SDL :</strong><br/> Comme vous l'avez vu avec Kayl, la SDL offre un contexte OpenGL. Et grâce à cela elle permet aussi de manipuler les extensions d'OpenGL. Nous verrons que cette méthode est manuelle car elle demande un minimum de code.</p></li><li id="r-571690" data-claire-element-id="571690"><p id="r-571689" data-claire-element-id="571689"><strong>Ne rien faire via GLEW :</strong><br/> Vous avez bien lu, vous n'aurez rien à faire. En tout cas beaucoup moins qu'avec la SDL, la bibliothèque GLEW nous mâchera en fait tout le travail que nous faisions avant avec la SDL :soleil: . Lorsqu'on l'utilise pour manier les extensions d'OpenGL, on peut dire qu'on emploi une méthode de feignasses automatique car le code que nous devions écrire auparavant avec la SDL disparaîtra.</p></li></ul><div id="r-571693" data-claire-element-id="571693" data-claire-semantic="question"><p id="r-571692" data-claire-element-id="571692">Hé mais alors pourquoi nous embêter à utiliser la SDL ?!</p></div><p id="r-571694" data-claire-element-id="571694">Il est bon que vous connaissiez toutes les méthodes, parfois on préférera l'une ou l'autre selon nos besoins.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5">Les extensions</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/c-est-quoi-les-extensions">
C&#039;est quoi les extensions ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/comment-ca-fonctionne-3">
Comment ça fonctionne ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-la-sdl-methode-manuelle">
Utilisation de la SDL : méthode manuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-glew-methode-automatique">
Utilisation de GLEW : méthode automatique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/un-exemple-complet-3">
Un exemple complet
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/comment-ca-fonctionne-3">
<span class="next">Comment ça fonctionne ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Commentafonctionne"></a><h2>Comment ça fonctionne ?</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/c-est-quoi-les-extensions">
<span class="arrow"></span>
<span class="next">C&#039;est quoi les extensions ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-la-sdl-methode-manuelle">
<span class="next">Utilisation de la SDL : méthode manuelle</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-un-peu-de-theorie-13" data-claire-element-id="571709">Un peu de théorie</h2><p id="r-571697" data-claire-element-id="571697">Bon, passons aux choses sérieuses : nous voulons bénéficier d'une extension d'OpenGL parce qu'on la trouve super cool.</p><p id="r-571698" data-claire-element-id="571698">Oui, mais ça ressemble à quoi une extension ? C'est une boîte carrée qui contient plein de joujoux ? Presque :p</p><p id="r-571699" data-claire-element-id="571699">Une extension regroupe généralement des <strong>fonctions</strong> ainsi que des <strong>constantes</strong> symboliques qui nous permetteront d'exploiter la fonctionnalité que l'extension représente. Supposons que la gestion des couleurs des sommets soit une extension, alors l'extension serait composée des fonctions <em>glColor*()</em>, ces fonctions ne seraient pas disponibles dans gl.h et leur <strong>adresse mémoire</strong> serait inconnue.<br/> Pour finir, une extension a un <strong>nom</strong>. C'est très important de retenir cela, c'est grâce à ces noms que nous allons voir si une extension est supportée ou non par la carte graphique.</p><p id="r-571700" data-claire-element-id="571700"><strong>Vous devez retenir que :</strong> une extension est caractérisée par un nom qui englobe quelques fonctions et quelques constantes (parfois, seulement l'un ou l'autre).</p><p id="r-571701" data-claire-element-id="571701">Avant d'utiliser une extension, il est nécessaire de la <strong>charger</strong>, c'est-à-dire de récupérer les adresses mémoire des fonctions qui composent l'extension, connaître les prototypes de ces fonctions et aussi connaître les valeurs des constantes qu'elle utilise.</p><div id="r-571703" data-claire-element-id="571703" data-claire-semantic="question"><p id="r-571702" data-claire-element-id="571702">Quoi ? Charger une fonction ?</p></div><p id="r-571704" data-claire-element-id="571704">Je vous conseille fortement la lecture de l'excellent tutoriel de <a href="http://www.siteduzero.com/membres-294-2500.html">mleg</a> sur les <a href="http://www.siteduzero.com/tuto-3-4976-1-les-pointeurs-de-fonctions.html">pointeurs de fonctions</a> afin de vous éclaircir sur ce point.<br/> En effet, la lecture de ce tutoriel est préférable si vous voulez comprendre ce que vous ferez.</p><div id="r-571706" data-claire-element-id="571706" data-claire-semantic="question"><p id="r-571705" data-claire-element-id="571705">Et qu'est-ce qu'on fera ?</p></div><p id="r-571707" data-claire-element-id="571707">Vous chargerez des fonctions dynamiquement :) <br/> En effet, charger une extension revient à rechercher les adresses mémoire des fonctions qui la composent, ces adresses existent réellement si votre carte graphique supporte l'extension demandée et que votre pilote graphique est à jour.<br/> Normalement les adresses de fonctions sont fournies par votre implémentation d'OpenGL, mais si elle est trop ancienne, il vous faudra aller chercher ces adresses vous-même.</p><p id="r-571708" data-claire-element-id="571708">Ne vous inquiétez pas, ce n'est pas aussi dur que ça pourrait en avoir l'air ;)</p><h2 id="r-charger-une-extension" data-claire-element-id="571753">Charger une extension</h2><p id="r-571710" data-claire-element-id="571710">Avant de voir le chargement en lui-même (qui se résume d'ailleurs à une ligne de code :-° ) vous devez tout d'abord posséder l'en-tête <strong>glext.h</strong> nécessaire au bon fonctionnement des extensions. Vous pourrez trouver la dernière version de ce fichier sur le site de Silicon Graphics à <a href="http://oss.sgi.com/projects/ogl-sample/sdk.html">cette adresse</a>.<br/> Vous devrez placer ce fichier dans le répertoire include/GL/ de votre compilateur.</p><aside id="r-571712" data-claire-element-id="571712" data-claire-semantic="information"><p id="r-571711" data-claire-element-id="571711">Notez qu'il est fort probable que vous ayez impérativement besoin de télécharger la dernière version du fichier glext.h même si vous le possédez déjà. Par précaution, je vous conseille de le mettre à jour dès maintenant.</p></aside><p id="r-571713" data-claire-element-id="571713">Ce fichier contient toutes les constantes ainsi que tous les types des fonctions disponibles pour OpenGL 2.1.</p><div id="r-571715" data-claire-element-id="571715" data-claire-semantic="question"><p id="r-571714" data-claire-element-id="571714">Les types des fonctions ?</p></div><p id="r-571716" data-claire-element-id="571716">Oui. Afin de charger une fonction, il va falloir stocker son adresse dans un pointeur de fonction d'un certain type. Ces types sont définis dans glext.h via des typedef.</p><h3 id="r-fonctionnement-34" data-claire-element-id="571727">Fonctionnement</h3><p id="r-571717" data-claire-element-id="571717">Nous y voilà : comment charger une fonction ?</p><p id="r-571718" data-claire-element-id="571718">Nous allons en fait nous y prendre de la même façon que dans le tutoriel de mleg sur les pointeurs de fonctions :</p><ul id="r-571725" data-claire-element-id="571725"><li id="r-571720" data-claire-element-id="571720"><p id="r-571719" data-claire-element-id="571719">créer une variable de stockage de notre fonction du type approprié ;</p></li><li id="r-571722" data-claire-element-id="571722"><p id="r-571721" data-claire-element-id="571721">lui attribuer l'adresse de la fonction qu'elle devra représenter. Nous verrons comment procéder à cela dans la partie suivante ;</p></li><li id="r-571724" data-claire-element-id="571724"><p id="r-571723" data-claire-element-id="571723">utiliser notre pointeur à notre guise dans notre programme OpenGL. Nous devrons prendre garde à rendre ce pointeur accessible par tous les fichiers de notre projet, ça sera donc une variable globale. Nous verrons cela plus bas lors de l'exemple de code.</p></li></ul><p id="r-571726" data-claire-element-id="571726">Le type de notre pointeur, comme je l'ai dit plus haut, est défini dans glext.h. Le problème me direz-vous, c'est que chaque fonction a un prototype différent, donc il y a... un type pour chaque fonction o_O Diantre ! ça fait beaucoup ! :D Rassurez-vous, les noms donnés à ces types sont logiques et clairs, je vais justement vous les présenter.</p><h3 id="r-presentation-de-la-syntaxe-des-types-de-fonctions" data-claire-element-id="571739">Présentation de la syntaxe des types de fonctions</h3><p id="r-571728" data-claire-element-id="571728">Les noms des types des fonctions que l'on peut charger ont une logique similaire à celle des noms de fonctions OpenGL simples.<br/> Voici plusieurs règles :</p><ul id="r-571737" data-claire-element-id="571737"><li id="r-571730" data-claire-element-id="571730"><p id="r-571729" data-claire-element-id="571729">chaque nom est écrit 100% en majuscules ;</p></li><li id="r-571732" data-claire-element-id="571732"><p id="r-571731" data-claire-element-id="571731">chaque nom est préfixé par PFN ;</p></li><li id="r-571734" data-claire-element-id="571734"><p id="r-571733" data-claire-element-id="571733">chaque nom est suffixé par PROC ;</p></li><li id="r-571736" data-claire-element-id="571736"><p id="r-571735" data-claire-element-id="571735">le nom du type est strictement égal au nom de la fonction auquel il correspond.</p></li></ul><p id="r-571738" data-claire-element-id="571738">En fait si vous savez tout cela par coeur, alors il n'y a rien à savoir de plus. Nous verrons un exemple plus bas.</p><h3 id="r-presentation-de-la-syntaxe-des-noms-des-extensions" data-claire-element-id="571743">Présentation de la syntaxe des noms des extensions</h3><p id="r-571740" data-claire-element-id="571740">Il y en a également une pour les noms des extensions.<br/> Voici par exemple un nom d'extension :</p><p id="r-571741" data-claire-element-id="571741">GL_ARB_multitexture</p><p id="r-571742" data-claire-element-id="571742">Premièrement, on remarque le préfixe <em>GL_</em> bien connu des utilisateurs d'OpenGL, ensuite vient un autre préfixe (qui du coup n'en est plus vraiment un :-° ) : <em>ARB</em>. Ce second préfixe est intéressant, il représente en quelque sorte par qui l'extension est certifiée. Il existe également NV (pour nVidia), ATI (pour ATI), EXT (EXTension), SGIS (Silicon Graphics Inc., sans être totalement sûr), et quelques autres. À priori, mais ce n'est pas toujours le cas, une extension NV n'est pas supportée par ATI et vice-versa.<br/> Pour finir, <em>multitexture</em> décrit la fonctionnalité de l'extension, ici il s'agit donc de l'extension permettant de réaliser du multi-texturing.</p><h3 id="r-presentation-de-la-syntaxe-des-fonctions" data-claire-element-id="571752">Présentation de la syntaxe des fonctions</h3><p id="r-571744" data-claire-element-id="571744">Oui, les fonctions aussi ont une syntaxe ;) Cependant rassurez-vous, vous la connaissez normalement déjà, <a href="http://www.siteduzero.com/tuto-3-6094-1-notions-de-base.html#ss_part_1">Kayl a traité ce point dans son tutoriel</a>.</p><div id="r-571746" data-claire-element-id="571746" data-claire-semantic="question"><p id="r-571745" data-claire-element-id="571745">Alors pourquoi tu te la ramène avec un gros titre ? :-°</p></div><p id="r-571747" data-claire-element-id="571747">Pour vous prévenir que les fonctions d'extensions sont suffixées par le second préfixe du nom de l'extension auquel elles appartiennent.</p><div id="r-571749" data-claire-element-id="571749" data-claire-semantic="question"><p id="r-571748" data-claire-element-id="571748">Hein ?!</p></div><p id="r-571750" data-claire-element-id="571750">Les fonctions appartenant à GL_<strong>ARB</strong>_multitexture par exemple contiendrons toutes <strong>ARB</strong> à la fin de leur nom, comme ceci :</p><pre id="r-571751" data-claire-element-id="571751"><code data-claire-semantic="c">glMultiTexCoord2fARB(...);</code></pre>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5">Les extensions</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/c-est-quoi-les-extensions">
C&#039;est quoi les extensions ?
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/comment-ca-fonctionne-3">
Comment ça fonctionne ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-la-sdl-methode-manuelle">
Utilisation de la SDL : méthode manuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-glew-methode-automatique">
Utilisation de GLEW : méthode automatique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/un-exemple-complet-3">
Un exemple complet
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/c-est-quoi-les-extensions">
<span class="arrow"></span>
<span class="next">C&#039;est quoi les extensions ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-la-sdl-methode-manuelle">
<span class="next">Utilisation de la SDL : méthode manuelle</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="UtilisationdelaSDLmthodemanuelle"></a><h2>Utilisation de la SDL : méthode manuelle</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/comment-ca-fonctionne-3">
<span class="arrow"></span>
<span class="next">Comment ça fonctionne ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-glew-methode-automatique">
<span class="next">Utilisation de GLEW : méthode automatique</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-571755" data-claire-element-id="571755">Bien, nous allons commencer à coder sans plus attendre.<br/> J'espère que vous avez bien retenu tout ce que je vous ai dit dans la précédente partie. :p Faites chauffer vos cervelles !</p><p id="r-571756" data-claire-element-id="571756">Souvenez-vous de la première partie, je vous avais dit qu'il existait plusieurs méthodes pour charger une/plusieurs extension(s). Nous allons étudier ici la méthode manuelle, celle qui utilise la SDL. Nous chargerons une simple extension qui servira d'exemple, mais sachez que le chargement d'une extension, ou plus précisément des fonctions qui la composent, fonctionne de la même façon pour toutes les extensions.</p><div id="r-571758" data-claire-element-id="571758" data-claire-semantic="question"><p id="r-571757" data-claire-element-id="571757">Quelle extension allons-nous charger ?</p></div><p id="r-571759" data-claire-element-id="571759">GL_ARB_vertex_buffer_object par exemple :)</p><div id="r-571761" data-claire-element-id="571761" data-claire-semantic="question"><p id="r-571760" data-claire-element-id="571760">C'est quoi cette extension ??</p></div><p id="r-571762" data-claire-element-id="571762">Hélas, cela sort du cadre de ce tutoriel, je peux juste vous dire que c'est une extension qui peut s'utiliser dans un petit code source, d'où mon choix pour celle-ci.</p><h2 id="r-1-verifier-le-support-de-l-extension" data-claire-element-id="571773">1 - Vérifier le support de l'extension</h2><p id="r-571763" data-claire-element-id="571763">Il est possible, via l'appel d'une fonction OpenGL, de connaître toutes les extensions supportées par votre matériel. Souvenez-vous également qu'une extension est représentée par son nom, en demandant à OpenGL de nous fournir la liste des extensions supportées, il va en fait nous renvoyer une énorme chaîne de caractères qui contiendra tous les noms des extensions supportées séparés par des espaces.<br/> Afin d'obtenir cette liste, il nous faut invoquer <em>glGetString()</em> avec comme paramètre GL_EXTENSIONS :</p><pre id="r-571764" data-claire-element-id="571764"><code data-claire-semantic="c">const unsigned char *exts = glGetString(GL_EXTENSIONS);</code></pre><p id="r-571765" data-claire-element-id="571765">Notez bien que la fonction renvoie un <strong>const unsigned char*</strong> (const GLubyte* pour les intimes)</p><p id="r-571766" data-claire-element-id="571766">Nous voici à présent armés d'une énorme chaîne de caractères. Vous pouvez essayer de l'afficher si vous avez envie, voyez ce que j'obtiens personnellement :</p><pre id="r-571767" data-claire-element-id="571767"><code data-claire-semantic="console">GL_ARB_color_buffer_float GL_ARB_depth_texture GL_ARB_draw_buffers GL_ARB_fragment_program GL_ARB_fragment_program_shadow GL_ARB_fragment_shader GL_ARB_half_float_pixel GL_ARB_imaging GL_ARB_multisample GL_ARB_multitexture GL_ARB_occlusion_query GL_ARB_pixel_buffer_object GL_ARB_point_parameters GL_ARB_point_sprite GL_ARB_shadow GL_ARB_shader_objects GL_ARB_shading_language_100 GL_ARB_texture_border_clamp GL_ARB_texture_compression GL_ARB_texture_cube_map GL_ARB_texture_env_add GL_ARB_texture_env_combine GL_ARB_texture_env_dot3 GL_ARB_texture_float GL_ARB_texture_mirrored_repeat GL_ARB_texture_non_power_of_two GL_ARB_texture_rectangle GL_ARB_transpose_matrix GL_ARB_vertex_buffer_object GL_ARB_vertex_program GL_ARB_vertex_shader GL_ARB_window_pos GL_ATI_draw_buffers GL_ATI_texture_float GL_ATI_texture_mirror_once GL_S3_s3tc GL_EXT_texture_env_add GL_EXT_abgr GL_EXT_bgra GL_EXT_blend_color GL_EXT_blend_equation_separate GL_EXT_blend_func_separate GL_EXT_blend_minmax GL_EXT_blend_subtract GL_EXT_compiled_vertex_array GL_EXT_Cg_shader GL_EXT_depth_bounds_test GL_EXT_draw_range_elements GL_EXT_fog_coord GL_EXT_framebuffer_blit GL_EXT_framebuffer_multisample GL_EXT_framebuffer_object GL_EXT_gpu_program_parameters GL_EXT_multi_draw_arrays GL_EXT_packed_depth_stencil GL_EXT_packed_pixels GL_EXT_pixel_buffer_object GL_EXT_point_parameters GL_EXT_rescale_normal GL_EXT_secondary_color GL_EXT_separate_specular_color GL_EXT_shadow_funcs GL_EXT_stencil_two_side GL_EXT_stencil_wrap GL_EXT_texture3D GL_EXT_texture_compression_s3tc GL_EXT_texture_cube_map GL_EXT_texture_edge_clamp GL_EXT_texture_env_combine GL_EXT_texture_env_dot3 GL_EXT_texture_filter_anisotropic GL_EXT_texture_lod GL_EXT_texture_lod_bias GL_EXT_texture_mirror_clamp GL_EXT_texture_object GL_EXT_texture_sRGB GL_EXT_timer_query GL_EXT_vertex_array GL_IBM_rasterpos_clip GL_IBM_texture_mirrored_repeat GL_KTX_buffer_region GL_NV_blend_square GL_NV_copy_depth_to_color GL_NV_depth_clamp GL_NV_fence GL_NV_float_buffer GL_NV_fog_distance GL_NV_fragment_program GL_NV_fragment_program_option GL_NV_fragment_program2 GL_NV_framebuffer_multisample_coverage GL_NV_half_float GL_NV_light_max_exponent GL_NV_multisample_filter_hint GL_NV_occlusion_query GL_NV_packed_depth_stencil GL_NV_pixel_data_range GL_NV_point_sprite GL_NV_primitive_restart GL_NV_register_combiners GL_NV_register_combiners2 GL_NV_texgen_reflection GL_NV_texture_compression_vtc GL_NV_texture_env_combine4 GL_NV_texture_expand_normal GL_NV_texture_rectangle GL_NV_texture_shader GL_NV_texture_shader2 GL_NV_texture_shader3 GL_NV_vertex_array_range GL_NV_vertex_array_range2 GL_NV_vertex_program GL_NV_vertex_program1_1 GL_NV_vertex_program2 GL_NV_vertex_program2_option GL_NV_vertex_program3 GL_NVX_conditional_render GL_SGIS_generate_mipmap GL_SGIS_texture_lod GL_SGIX_depth_texture GL_SGIX_shadow GL_SUN_slice_accum</code></pre><p id="r-571768" data-claire-element-id="571768">C'est gros hein ? :p <br/> Notez qu'il est fort probable que vous en ayez plus ou moins, cela dépend de votre matériel.</p><p id="r-571769" data-claire-element-id="571769">Afin de vérifier si une extension est supportée, rien de plus simple : il suffit de chercher si son nom est présent dans cette chaîne (<em>exts</em>).<br/> Nous allons utiliser pour cela la fonction <em><a href="http://man.developpez.com/man3/strstr.3.php">strstr()</a></em> dont le prototype est disponible dans string.h :</p><pre id="r-571770" data-claire-element-id="571770"><code data-claire-semantic="c">#include &lt;string.h&gt;
 
 
/* recuperation de la liste des extensions supportees */
const unsigned char *exts = glGetString(GL_EXTENSIONS);
 
/* on regarde si exts contient ce qu'on demande... */
if(strstr((const char*)exts, nom_extension_recherchee) == NULL)
{
    /* extension non supportee... :-( */
    fprintf(stderr, &quot;extension '%s' non supportee\n&quot;, nom_extension_recherchee);
}
else
{
    /* OK, extension supportee */
}</code></pre><p id="r-571771" data-claire-element-id="571771">Vous pourrez constater un cast barbare de notre chaîne <em>exts</em> lorsqu'on l'envoie à <em>strstr()</em> dans le if.</p><p id="r-571772" data-claire-element-id="571772">Voilà pour la gestion du support :) Nous emballerons tout cela dans une jolie fonction, un exemple de code complet sera disponible à la fin du tutoriel.</p><h2 id="r-2-charger-les-fonctions-de-l-extension" data-claire-element-id="571806">2 - Charger les fonctions de l'extension</h2><p id="r-571774" data-claire-element-id="571774">L'extension GL_ARB_vertex_buffer_object contient plusieurs fonctions, mais pour l'exemple, nous nous contenterons de n'en charger qu'une seule : <em>glGenBuffersARB()</em>.<br/> Nous allons donc créer un pointeur pour stocker l'adresse de cette fonction :</p><pre id="r-571775" data-claire-element-id="571775"><code data-claire-semantic="c">PFNGLGENBUFFERSARBPROC glGenBuffers;</code></pre><p id="r-571776" data-claire-element-id="571776">Si le type utilisé vous paraît bizarre, rappelez-vous la dernière partie : je vous avait présenté la syntaxe utilisée pour les types des pointeurs de fonction.</p><p id="r-571777" data-claire-element-id="571777">Ici, le nom que j'ai donné au pointeur ne contient pas ARB ; en effet, je trouve que ça serait trop lourd lors de l'utilisation, nous avons le choix des noms de nos fonctions, autant les réduire au maximum.</p><aside id="r-571779" data-claire-element-id="571779" data-claire-semantic="warning"><p id="r-571778" data-claire-element-id="571778">Il est toutefois <strong>fortement déconseillé</strong> de donner des noms différents aux pointeurs que l'on crée, cela risque de troubler au plus haut point quelqu'un qui lirait votre code source. Tenez-vous en aux noms de fonction normaux.</p></aside><p id="r-571780" data-claire-element-id="571780">Bien, maintenant que nous avons notre pointeur, nous allons pouvoir passer à l'étape la plus rigolote : lui attribuer l'adresse de la fonction que l'on recherche.</p><h3 id="r-avec-la-sdl" data-claire-element-id="571794">Avec la SDL</h3><p id="r-571781" data-claire-element-id="571781">C'est là que la SDL intervient, elle offre en effet une fonction permettant de récupérer les adresses mémoire des fonctions des extensions d'OpenGL. Cette fonction s'appelle <em>SDL_GL_GetProcAddress()</em>, voici son prototype :</p><pre id="r-571782" data-claire-element-id="571782"><code data-claire-semantic="c">void* SDL_GL_GetProcAddress(const char *fname);</code></pre><ul id="r-571785" data-claire-element-id="571785"><li id="r-571784" data-claire-element-id="571784"><p id="r-571783" data-claire-element-id="571783"><em><strong>fname</strong></em> : c'est le nom de la fonction dont on souhaite obtenir l'adresse.</p></li></ul><p id="r-571786" data-claire-element-id="571786">Cette fonction renvoie un pointeur directe sur la fonction demandée, ou <em>NULL</em> si la fonction n'est pas supportée par le matériel.<br/> Voici comment nous allons l'utiliser dans notre cas :</p><pre id="r-571787" data-claire-element-id="571787"><code data-claire-semantic="c">glGenBuffers = SDL_GL_GetProcAddress(&quot;glGenBuffersARB&quot;);</code></pre><p id="r-571788" data-claire-element-id="571788">Et voilà, la fonction glGenBuffers est chargée :)</p><aside id="r-571790" data-claire-element-id="571790" data-claire-semantic="warning"><p id="r-571789" data-claire-element-id="571789"><strong>Important :</strong> vous devez d'abord initialiser le contexte OpenGL avant de pouvoir utiliser la fonction <em>SDL_GL_GetProcAddress()</em> ! Avec la SDL, l'initialisation du contexte se fait lors de l'appel de la fonction <em>SDL_SetVideoMode()</em> avec le flag SDL_OPENGL.</p></aside><p id="r-571791" data-claire-element-id="571791">--------------------------</p><aside id="r-571793" data-claire-element-id="571793" data-claire-semantic="information"><p id="r-571792" data-claire-element-id="571792"><strong>Remarque :</strong> Si vous utilisez la SDL, vous n'êtes pas obligés de lire ce passage, il ne s'adresse qu'aux utilisateurs avertis qui préfèrent utiliser directement le gestionnaire de fenêtres de leur OS.</p></aside><h3 id="r-avec-votre-gestionnaire-de-fenetres" data-claire-element-id="571805">Avec votre gestionnaire de fenêtres</h3><p id="r-571795" data-claire-element-id="571795">Si vous utilisez directement le gestionnaire de fenêtres de votre système d'exploitation, sachez qu'il propose aussi une fonction pour charger une fonction d'une extension OpenGL. Que vous utilisiez WGL pour Windows ou GLX pour le gestionnaire de fenêtres X Window (Linux &amp; MacOS), ils proposent chacun un équivalent à la fonction <em>SDL_GL_GetProcAddress()</em>.</p><p id="r-571796" data-claire-element-id="571796">Voici les noms de ces fonctions :</p><ul id="r-571801" data-claire-element-id="571801"><li id="r-571798" data-claire-element-id="571798"><p id="r-571797" data-claire-element-id="571797">WGL : <em>wglGetProcAddress()</em></p></li><li id="r-571800" data-claire-element-id="571800"><p id="r-571799" data-claire-element-id="571799">GLX : <em>glXGetProcAddress()</em></p></li></ul><p id="r-571802" data-claire-element-id="571802">Leur utilisation est identique à <em>SDL_GL_GetProcAddress()</em>, et leur nom est très similaire bref ; rien de très déroutant.</p><p id="r-571803" data-claire-element-id="571803">Note pour les curieux : la SDL utilise en fait ces fonctions, mais son avantage est d'utiliser la bonne selon votre OS, ce qui rend la SDL portable ;)</p><p id="r-571804" data-claire-element-id="571804">--------------------------</p><h2 id="r-3-utilisation" data-claire-element-id="571813">3 - Utilisation</h2><p id="r-571807" data-claire-element-id="571807">Là c'est la fête ! :p</p><p id="r-571808" data-claire-element-id="571808">Nous avons à présent notre fonction glGenBuffers correctement chargée, il ne nous reste plus qu'à l'utiliser à notre convenance :)</p><div id="r-571810" data-claire-element-id="571810" data-claire-semantic="question"><p id="r-571809" data-claire-element-id="571809">Et les constantes symboliques propres à une extension, on les charge pas ?</p></div><p id="r-571811" data-claire-element-id="571811">Je vais vous le dire franchement : charger une constante est ridicule car elles ne varient pas selon l'implémentation d'OpenGL. Toutes les constantes dont vous pourrez avoir besoin sont définies dans glext.h</p><p id="r-571812" data-claire-element-id="571812">Attention toutefois, certaines demanderons à ce que vous les utilisiez avec le suffixe _ARB. Dans notre cas, l'extension que nous avons chargée utilise entre autre la constante GL_ARRAY_BUFFER, mais elle existe aussi sous le nom de GL_ARRAY_BUFFER_ARB. La première est à préférer car elle économise des lignes de code, et d'une manière générale : préférez toujours les noms les plus ergonomiques, les langages de programmation sont déjà assez barbares sans que vous ayez besoin d'en rajouter une couche ;)</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5">Les extensions</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/c-est-quoi-les-extensions">
C&#039;est quoi les extensions ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/comment-ca-fonctionne-3">
Comment ça fonctionne ?
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-la-sdl-methode-manuelle">
Utilisation de la SDL : méthode manuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-glew-methode-automatique">
Utilisation de GLEW : méthode automatique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/un-exemple-complet-3">
Un exemple complet
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/comment-ca-fonctionne-3">
<span class="arrow"></span>
<span class="next">Comment ça fonctionne ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-glew-methode-automatique">
<span class="next">Utilisation de GLEW : méthode automatique</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="UtilisationdeGLEWmthodeautomatique"></a><h2>Utilisation de GLEW : méthode automatique</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-la-sdl-methode-manuelle">
<span class="arrow"></span>
<span class="next">Utilisation de la SDL : méthode manuelle</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/un-exemple-complet-3">
<span class="next">Un exemple complet</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<figure id="r-571816" data-claire-element-id="571817"><img id="r-571815" data-claire-element-id="571815" src="medias/uploads.siteduzero.com_files_66001_67000_66953.gif" alt="Image utilisateur"/></figure><p id="r-571818" data-claire-element-id="571818">Je vais à présent vous proposer une alternative intéressante dans la mesure où celle-ci est beaucoup plus simple à mettre en oeuvre que la technique vue précédemment.</p><p id="r-571819" data-claire-element-id="571819">En effet, jusqu'à maintenant, nous avons dû charger les fonctions d'une extension une par une, cette étape peut s'avérer être une vraie perte de temps.</p><p id="r-571820" data-claire-element-id="571820">Heureusement pour nous, de gentils programmeurs ont décidés de nous faire une jolie bibliothèque qui s'occuperait de ce boulot à notre place : GLEW.</p><div id="r-571822" data-claire-element-id="571822" data-claire-semantic="question"><p id="r-571821" data-claire-element-id="571821">GLEW permet de faire quoi concrètement ?</p></div><p id="r-571823" data-claire-element-id="571823">Elle vient en réalité <strong>remplacer</strong> les opérations de chargement que nous faisons auparavant avec la SDL, elle se charge de les faire à notre place, GLEW est surtout là pour vous faire gagner du temps ! Avec GLEW, plus besoin de charger les fonctions des extensions une par une, elle les charge pour vous automatiquement.</p><div id="r-571825" data-claire-element-id="571825" data-claire-semantic="question"><p id="r-571824" data-claire-element-id="571824">Et comment elle fait pour savoir si on a envie d'une extension ou pas ?</p></div><p id="r-571826" data-claire-element-id="571826">Elle ne le sait pas, elle charge toutes les extensions que votre matériel supporte. Rassurez-vous, cela ne consomme pas plus de mémoire, ce n'est pas un handicap, loin de là ;)</p><p id="r-571827" data-claire-element-id="571827">Attention cependant, vous ne pouvez pas décider de charger les extensions avec GLEW <strong>et</strong> avec la SDL, c'est soit l'un soit l'autre : ce sont deux techniques différentes.<br/> D'ailleurs, l'utilisation de GLEW ne nécessite <strong>pas</strong> de posséder l'en-tête glext.h</p><p id="r-571828" data-claire-element-id="571828">Bon, avant de pouvoir utiliser cette bibliothèque, il faut l'installer.</p><h2 id="r-installation-de-la-bibliotheque-glew" data-claire-element-id="571846">Installation de la bibliothèque GLEW</h2><h3 id="r-sous-linux-23" data-claire-element-id="571842">Sous Linux</h3><p id="r-571829" data-claire-element-id="571829">Vous avez le choix :</p><ul id="r-571841" data-claire-element-id="571841"><li id="r-571833" data-claire-element-id="571833"><p id="r-571830" data-claire-element-id="571830">Si vous utilisez Apt (pour les Debian-like comme Ubuntu), deux simples commandes sont à lancer :</p><pre id="r-571831" data-claire-element-id="571831"><code data-claire-semantic="console">sudo apt-get install libglew-dev</code></pre><pre id="r-571832" data-claire-element-id="571832"><code data-claire-semantic="console">sudo apt-get install libglew1</code></pre></li><li id="r-571835" data-claire-element-id="571835"><p id="r-571834" data-claire-element-id="571834">Si vous préférez compiler GLEW vous-même, dans ce cas rendez-vous sur <a href="http://glew.sourceforge.net/">le site web</a> de GLEW et téléchargez les sources.</p></li><li id="r-571840" data-claire-element-id="571840"><p id="r-571836" data-claire-element-id="571836">Si vous avez un RedHat-like, dans ce cas je vous propose soit de compiler les sources vous-mêmes, soit de maîtriser votre gestionnaire de paquets mieux que moi :-° Si vraiment vous n'y connaissez rien, tentez ces commandes (en root) :</p><pre id="r-571837" data-claire-element-id="571837"><code data-claire-semantic="console">rpm -i libglew-dev</code></pre><pre id="r-571838" data-claire-element-id="571838"><code data-claire-semantic="console">rpm -i libglew1</code></pre><p id="r-571839" data-claire-element-id="571839">ou bien allez lire <a href="http://www.siteduzero.com/tuto-3-2954-1-guide-du-debutant-linux-installer-un-logiciel.html">ce tutoriel</a> sur l'installation de logiciels sous Linux rédigé par <a href="http://www.siteduzero.com/membres-294-227.html">bluestorm</a>.</p></li></ul><h3 id="r-sous-windows-38" data-claire-element-id="571845">Sous Windows</h3><p id="r-571843" data-claire-element-id="571843">Téléchargez <a href="https://sourceforge.net/project/downloading.php?group_id=67586&amp;filename=glew-1.3.6-src.zip">le code source</a> de GLEW. (vous verrez pourquoi plus tard)</p><p id="r-571844" data-claire-element-id="571844">Décompressez l'archive et prenez tous les en-têtes présents dans le dossier include/GL/ (glew.h et wglew.h normalement) et placez-les dans le répertoire include/GL/ de votre compilateur. (C:\Program Files\CodeBlocks\include\GL\ pour Code::Blocks)</p><h2 id="r-creation-d-un-projet-utilisant-glew" data-claire-element-id="571904">Création d'un projet utilisant GLEW</h2><h3 id="r-les-headers-1" data-claire-element-id="571856">Les headers</h3><p id="r-571847" data-claire-element-id="571847">Il est important (et logique) d'inclure avant tout l'en-tête de la bibliothèque GLEW dans nos codes source qui l'utiliseront.</p><p id="r-571848" data-claire-element-id="571848">Les habituelles inclusions pour OpenGL :</p><pre id="r-571849" data-claire-element-id="571849"><code data-claire-semantic="c">#include &lt;GL/gl.h&gt;
#include &lt;GL/glu.h&gt;</code></pre><p id="r-571850" data-claire-element-id="571850">seront donc remplacées par la simple inclusion du fichier glew.h :</p><pre id="r-571851" data-claire-element-id="571851"><code data-claire-semantic="c">#include &lt;GL/glew.h&gt;</code></pre><p id="r-571852" data-claire-element-id="571852">Vous inquiétez pas, ce petit remplacement de fichiers ne nuira pas du tout, glew.h s'occupe de tout ;)</p><aside id="r-571854" data-claire-element-id="571854" data-claire-semantic="warning"><p id="r-571853" data-claire-element-id="571853">Attention : si vous incluez un en-tête d'OpenGL avant glew.h, une erreur de compilation (de pré-compilation plus précisément) se déclenchera. Vous pouvez en revanche inclure gl.h et glu.h après glew.h, cela ne pose pas de problème, mais c'est inutile dans la mesure où glew.h bloque l'inclusion de ces fichiers (il défini __gl_h_ entre autres).</p></aside><p id="r-571855" data-claire-element-id="571855">Passons à présent à la configuration des projets.</p><h3 id="r-sous-linux-24" data-claire-element-id="571858">Sous Linux</h3><p id="r-571857" data-claire-element-id="571857">Rien de plus simple, il vous suffira de rajouter cette commande avec GCC : -lGLEW<br/> Elle permet, comme vous vous en doutez, de lier la bibliothèque GLEW.<br/> Voilà, rien de plus :)</p><h3 id="r-sous-windows-39" data-claire-element-id="571903">Sous Windows</h3><p id="r-571859" data-claire-element-id="571859">La création ainsi que la configuration d'un projet utilisant GLEW sont les mêmes sous Code::Blocks ainsi que sous Dev-C++.</p><p id="r-571860" data-claire-element-id="571860">Pour commencer, créez un simple projet SDL (<em>SDL Application</em> sous Code::Blocks, <em>Window Application</em> sous Dev-C++). Ajoutez vos codes source au projet <strong>ainsi que le fichier glew.c</strong>, présent dans le dossier src/ de l'archive contenant le code source de GLEW.</p><div id="r-571862" data-claire-element-id="571862" data-claire-semantic="question"><p id="r-571861" data-claire-element-id="571861">Quoi ? On va compiler le code source de cette bibliothèque ?</p></div><p id="r-571863" data-claire-element-id="571863">Oui effectivement. C'est en fait la seule solution que j'ai trouvée pour pouvoir utiliser GLEW sous Windows. Mais ne vous inquiétez pas, ce n'est pas une très grosse bibliothèque et par conséquent elle ne mettra pas beaucoup de temps à se compiler ;)</p><p id="r-571864" data-claire-element-id="571864">Ensuite, passons à la configuration du projet. C'est l'étape la plus rigolote.<br/> Comme nous avons inclus le code source de la bibliothèque GLEW directement dans notre projet, il va falloir préciser à GLEW qu'on ne l'utilisera pas sous forme de DLL. Pour cela, il nous faudra définir une macro dans tous les fichiers qui utiliseront glew.h, en gros : dans tous les fichiers du projet.</p><div id="r-571866" data-claire-element-id="571866" data-claire-semantic="question"><p id="r-571865" data-claire-element-id="571865">Simple, on rajoute un #define dans glew.h et c'est terminé !</p></div><p id="r-571867" data-claire-element-id="571867">Non, nous allons faire autrement, car glew.h ne fait <strong>PAS</strong> parti de notre projet, si vous l'avez inclus au projet, enlevez-le.</p><p id="r-571868" data-claire-element-id="571868">Pour définir une macro dans tous les fichiers du projet, nous allons utiliser une commande très simple du compilateur.<br/>Si vous pensez à -D, alors vous avez gagné ;)</p><p id="r-571869" data-claire-element-id="571869">Sous Code::Blocks, il faut aller dans le menu Project -&gt; Build options -&gt; onglet Compiler -&gt; onglet #defines, puis entrer le nom de la macro que l'on souhaite définir dans le champ libre.</p><div id="r-571871" data-claire-element-id="571871" data-claire-semantic="question"><p id="r-571870" data-claire-element-id="571870">Et quelle est le nom de la macro qu'on veut définir d'ailleurs ?</p></div><p id="r-571872" data-claire-element-id="571872">GLEW_STATIC.<br/> Lorsqu'elle est définie, GLEW considère qu'il est utilisé directement au sein d'un projet (notre cas) et adapte donc son code source en fonction de cela.<br/> Voici un petit schéma pour illustrer la procédure sous Code::Blocks :</p><figure id="r-571874" data-claire-element-id="571875"><img id="r-571873" data-claire-element-id="571873" src="medias/uploads.siteduzero.com_files_66001_67000_66954.gif" alt="Image utilisateur"/></figure><p id="r-571876" data-claire-element-id="571876">Pour Dev-C++, la procédure est quelque peu différente, mais le principe reste le même, dans le menu Projet -&gt; Options du projet -&gt; onglet Paramètres :</p><figure id="r-571878" data-claire-element-id="571879"><img id="r-571877" data-claire-element-id="571877" src="medias/uploads.siteduzero.com_files_66001_67000_66955.gif" alt="Image utilisateur"/></figure><p id="r-571880" data-claire-element-id="571880">Notez qu'ici j'ai rajouté -D devant le nom de notre macro GLEW_STATIC, c'est parce que Dev-C++, contrairement à Code::Blocks, ne le rajoute pas automatiquement.</p><div id="r-571882" data-claire-element-id="571882" data-claire-semantic="question"><p id="r-571881" data-claire-element-id="571881">Et à quoi il sert ce -D ?</p></div><p id="r-571883" data-claire-element-id="571883">C'est une commande du compilateur, comme -Wall ou comme -lSDL ;) Ça veut dire en quelque sorte #define. Vous pouvez aussi donner une valeur à une macro que vous définissez, comme ceci : -DMA_CONSTANTE=2</p><div id="r-571885" data-claire-element-id="571885" data-claire-semantic="question"><p id="r-571884" data-claire-element-id="571884">Et le linker ?</p></div><p id="r-571886" data-claire-element-id="571886">On y touche pas, on garde celui que Kayl a montré dans son tutoriel, à savoir :</p><table id="r-571899" data-claire-element-id="571899"><thead id="r-571892" data-claire-element-id="571892"><tr id="r-571891" data-claire-element-id="571891"><th id="r-571888" data-claire-element-id="571888"><p id="r-571887" data-claire-element-id="571887">Code::Blocks</p></th><th id="r-571890" data-claire-element-id="571890"><p id="r-571889" data-claire-element-id="571889">Dev-C++</p></th></tr></thead><tbody id="r-571898" data-claire-element-id="571898"><tr id="r-571897" data-claire-element-id="571897"><td id="r-571894" data-claire-element-id="571894"><p id="r-571893" data-claire-element-id="571893">mingw32<br/> SDLmain<br/> SDL<br/> opengl32<br/> glu32</p></td><td id="r-571896" data-claire-element-id="571896"><p id="r-571895" data-claire-element-id="571895">-lmingw32<br/> -lSDLmain<br/> -lSDL<br/> -lopengl32<br/> -lglu32</p></td></tr></tbody></table><aside id="r-571901" data-claire-element-id="571901" data-claire-semantic="information"><p id="r-571900" data-claire-element-id="571900">Notez que GLU (glu32) est facultatif, liez-le uniquement si vous l'utilisez.</p></aside><p id="r-571902" data-claire-element-id="571902">Et voilà, votre projet est maintenant prêt à utiliser GLEW. En parlant d'utiliser GLEW, vous ne savez toujours pas comment il s'utilise, eh bien nous allons voir ça ;)</p><h2 id="r-glew-cote-programmation" data-claire-element-id="571932">GLEW côté programmation</h2><p id="r-571905" data-claire-element-id="571905">GLEW est une bibliothèque très simple d'utilisation comme nous allons le voir ;) En fait, elle ne &quot;s'utilise&quot; pas vraiment, il suffit juste de l'initialiser et alors vous pourrez utiliser les extensions d'OpenGL librement sans vous soucier de leur chargement.</p><h3 id="r-initialisation-de-glew" data-claire-element-id="571923">Initialisation de GLEW</h3><p id="r-571906" data-claire-element-id="571906">Etape très importante, c'est ici que serons effectués des &quot;GetProcAddress&quot; comme nous en avons fait avec la SDL. Si vous n'initialisez pas GLEW, votre programme plantera.</p><p id="r-571907" data-claire-element-id="571907">Pour initialiser GLEW, rien de particulier : une petite fonction est faite pour ça :</p><pre id="r-571908" data-claire-element-id="571908"><code data-claire-semantic="c">GLenum glewInit(void);</code></pre><aside id="r-571910" data-claire-element-id="571910" data-claire-semantic="information"><p id="r-571909" data-claire-element-id="571909">Le type de la valeur de retour (GLenum) est un entier non signé, il est défini comme ceci : typedef unsigned int GLenum;</p></aside><p id="r-571911" data-claire-element-id="571911">Comme toute initialisation, celle de GLEW peut échouer, d'où la valeur de retour.</p><p id="r-571912" data-claire-element-id="571912">La valeur de retour, parlons-en justement, c'est en fait un code d'erreur qui peut être analysé pour savoir si un problème est survenu ou non.<br/> Nous allons récupérer ce code d'erreur dans une variable, nous analyserons ensuite cette variable pour savoir si elle représente un code d'erreur, si elle en représente un, nous la donnerons à manger à une fonction de GLEW qui nous retournera un message. (sous forme de chaîne de caractères)</p><pre id="r-571913" data-claire-element-id="571913"><code data-claire-semantic="c">GLenum code;
 
/* initialisation de GLEW */
code = glewInit();
if(code != GLEW_OK)
{
    fprintf(stderr, &quot;impossible d'initialiser GLEW : %s\n&quot;,
                    glewGetErrorString(code));
}</code></pre><p id="r-571914" data-claire-element-id="571914">Deux choses sont à noter :</p><ul id="r-571919" data-claire-element-id="571919"><li id="r-571916" data-claire-element-id="571916"><p id="r-571915" data-claire-element-id="571915">premièrement, la constante utilisée pour savoir si <em>code</em> représente un code d'erreur ou non. GLEW_OK représente donc une valeur de retour qui sera employée si aucune erreur est survenue lors de l'initialisation ;</p></li><li id="r-571918" data-claire-element-id="571918"><p id="r-571917" data-claire-element-id="571917">deuxièmement, la fonction <em>glewGetErrorString()</em>, qui retourne un message d'erreur d'après un code donné. Cette fonction renvoie un <strong>const unsigned char*</strong>.</p></li></ul><aside id="r-571921" data-claire-element-id="571921" data-claire-semantic="warning"><p id="r-571920" data-claire-element-id="571920"><strong>Important :</strong> tout comme avec le chargement manuel des extensions (via <em>SDL_GL_GetProcAddress()</em>), le contexte doit avoir été créé avant que vous puissiez initialiser les extensions via la fonction <em>glewInit()</em>. Donc, appelez <em>glewInit()</em> après <em>SDL_SetVideoMode()</em>, sinon <em>glewInit()</em> vous renverra un code d'erreur (Missing GL Version).</p></aside><p id="r-571922" data-claire-element-id="571922">Voilà pour l'initialisation.</p><h3 id="r-utilisation-de-glew" data-claire-element-id="571931">Utilisation de GLEW</h3><p id="r-571924" data-claire-element-id="571924">Rien de particulier à faire, sachez juste qu'à présent vous avez accès à toutes les fonctions de toutes les extensions supportées par votre matériel :)</p><p id="r-571925" data-claire-element-id="571925">En parlant d'extension supportée, si vous utilisez GLEW, préférez la fonction <strong>glewIsSupported()</strong> pour vérifier si une extension est supportée :</p><pre id="r-571926" data-claire-element-id="571926"><code data-claire-semantic="c">GLboolean glewIsSupported(const char *name);</code></pre><ul id="r-571929" data-claire-element-id="571929"><li id="r-571928" data-claire-element-id="571928"><p id="r-571927" data-claire-element-id="571927"><em><strong>name</strong></em> : nom de l'extension recherchée.</p></li></ul><p id="r-571930" data-claire-element-id="571930">Cette fonction renvoie GL_TRUE (qui vaudra 1 généralement) si l'extension est supportée, GL_FALSE (0) sinon. Notez que cette fonction attend le nom d'une extension sous forme d'une chaîne de caractères, &quot;GL_ARB_multitexture&quot; par exemple.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5">Les extensions</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/c-est-quoi-les-extensions">
C&#039;est quoi les extensions ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/comment-ca-fonctionne-3">
Comment ça fonctionne ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-la-sdl-methode-manuelle">
Utilisation de la SDL : méthode manuelle
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-glew-methode-automatique">
Utilisation de GLEW : méthode automatique
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/un-exemple-complet-3">
Un exemple complet
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-la-sdl-methode-manuelle">
<span class="arrow"></span>
<span class="next">Utilisation de la SDL : méthode manuelle</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/un-exemple-complet-3">
<span class="next">Un exemple complet</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Unexemplecomplet"></a><h2>Un exemple complet</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-glew-methode-automatique">
<span class="arrow"></span>
<span class="next">Utilisation de GLEW : méthode automatique</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-571934" data-claire-element-id="571934">Maintenant que je vous ai rempli le cerveau, voyons s'il n'y a pas eu de fuites durant le remplissage :D <br/> La gestion des extensions est rarement chose aisée pour un débutant, le besoin de quelques exemples de code se fait ressentir.</p><p id="r-571935" data-claire-element-id="571935">Les exemples présenterons un petit gestionnaire d'extensions très simple.</p><p id="r-571936" data-claire-element-id="571936">Ce gestionnaire devra pouvoir utiliser GLEW ou la SDL pour charger les extensions, au choix. Ce choix se fera lors de la compilation via le <strong>préprocesseur</strong>.</p><div id="r-571938" data-claire-element-id="571938" data-claire-semantic="question"><p id="r-571937" data-claire-element-id="571937">Que fera ce gestionnaire ?</p></div><p id="r-571939" data-claire-element-id="571939">Il englobera tout ce que nous avons appris jusqu'à maintenant :</p><ul id="r-571946" data-claire-element-id="571946"><li id="r-571941" data-claire-element-id="571941"><p id="r-571940" data-claire-element-id="571940">chargement des extensions avec la SDL ;</p></li><li id="r-571943" data-claire-element-id="571943"><p id="r-571942" data-claire-element-id="571942">initialisation de GLEW ;</p></li><li id="r-571945" data-claire-element-id="571945"><p id="r-571944" data-claire-element-id="571944">vérification du support d'une extension via GLEW ou manuellement.</p></li></ul><p id="r-571947" data-claire-element-id="571947">Bien entendu, il n'utilisera <strong>pas</strong> GLEW et SDL en même temps (c'est impossible), il utilisera soit l'un, soit l'autre.</p><aside id="r-571949" data-claire-element-id="571949" data-claire-semantic="information"><p id="r-571948" data-claire-element-id="571948">Une version complète de ce gestionnaire sera disponible en téléchargement à la fin du tutoriel, alors ne vous embêtez pas à tout copier/coller ;)</p></aside><h2 id="r-presentation-de-l-interface-h" data-claire-element-id="571968">Présentation de l'interface (.h)</h2><p id="r-571950" data-claire-element-id="571950">Notre gestionnaire restera très simple, il n'est là qu'à titre d'exemple pour vous.<br/> Nous nous contenterons de lui attribuer deux fonctions :</p><ul id="r-571955" data-claire-element-id="571955"><li id="r-571952" data-claire-element-id="571952"><p id="r-571951" data-claire-element-id="571951"><em>InitExtensions()</em> : cette fonction sera chargée d'initialiser le gestionnaire ;</p></li><li id="r-571954" data-claire-element-id="571954"><p id="r-571953" data-claire-element-id="571953"><em>CheckExtension()</em> : cette fonction aura pour but de vérifier si une extension est supportée.</p></li></ul><p id="r-571956" data-claire-element-id="571956">Voici à quoi pourrait ressembler l'en-tête de notre gestionnaire :</p><p id="r-571957" data-claire-element-id="571957"><strong>initexts.h</strong> :</p><pre id="r-571958" data-claire-element-id="571958"><code data-claire-semantic="c">#ifndef __INITEXTS_H__
#define __INITEXTS_H__
 
 
#ifdef USE_GLEW
 #include &lt;GL/glew.h&gt;
#else
 #include &lt;GL/gl.h&gt;
 #include &lt;GL/glext.h&gt;
#endif
 
 
#ifndef USE_GLEW
extern PFNGLGENBUFFERSARBPROC glGenBuffers;
#endif
 
 
/* charge les extensions */
GLenum InitExtensions();
 
/* verifie la presence d'une extension */
int CheckExtension(const char *name);
 
 
#endif /* guard */</code></pre><p id="r-571959" data-claire-element-id="571959">Souvenez-vous, je vous avait dit que notre gestionnaire devait être compatible avec GLEW <strong>et</strong> SDL pour le chargement des extensions. Cet en-tête s'adaptera à une utilisation de GLEW pour peu que l'on définisse la macro USE_GLEW. À l'inverse, cet en-tête est compatible avec une utilisation de la SDL si USE_GLEW n'est pas définie.</p><p id="r-571960" data-claire-element-id="571960">Tout d'abord, remarquez que ce code se charge d'inclure les bons en-têtes des bibliothèques, glew.h si USE_GLEW est définie, gl.h + glext.h sinon. (on pourrait rajouter glu.h, mais comme je n'utilise aucune fonction GLU je ne l'ai pas mis) Avec cette conception, tous nos fichiers sources qui voudrons utiliser OpenGL et ses extensions n'auront qu'à inclure cet en-tête, tout est dedans :)</p><p id="r-571961" data-claire-element-id="571961">Ensuite, vient une variable <strong>extern</strong>. C'est un pointeur sur une fonction d'une extension, déclaré avec le mot clé <strong>extern</strong>.</p><div id="r-571963" data-claire-element-id="571963" data-claire-semantic="question"><p id="r-571962" data-claire-element-id="571962">C'est quoi ce mot clé ? o_O</p></div><p id="r-571964" data-claire-element-id="571964">Ah, oui, il me semble que M@teo21 n'en parle pas dans son cours, et bien je vous invite à cliquer sur ces deux petits liens :<br/> - <a href="http://c.developpez.com/cours/bernard-cassagne/node114.php">http://c.developpez.com/cours/bernard- [...] e/node114.php</a><br/> - <a href="http://www.ai.univ-paris8.fr/~jalb/langimp/staticextern.htm">http://www.ai.univ-paris8.fr/~jalb/lan [...] ticextern.htm</a></p><p id="r-571965" data-claire-element-id="571965">A la suite de ce pointeur vous pourrez, en suivant le même modèle, rajouter d'autres pointeurs vers des fonctions d'extensions dont vous pourrez avoir besoin. Ici, je n'ai mis qu'un pointeur pour simplifier l'exemple.</p><p id="r-571966" data-claire-element-id="571966">Pour finir, nous avons les prototypes de nos fonctions, <em>Init()</em> et <em>Check()</em> (dorénavant je les appellerai comme cela, c'est beaucoup plus court).</p><p id="r-571967" data-claire-element-id="571967">Bien, maintenant que nous avons vu l'interface de notre gestionnaire, voyons à quoi pourrait ressembler le code source de nos deux fonctions.</p><h2 id="r-le-code-source-c" data-claire-element-id="571987">Le code source (.c)</h2><p id="r-571969" data-claire-element-id="571969">Tout d'abord, c'est ce code source qui contiendra nos véritables pointeurs de fonction. Donc, après l'inclusion des en-têtes nécessaires, je vais déclarer nos pointeurs (en l'occurrence, nous en avons qu'un, <em>glGenBuffers()</em> ) :</p><p id="r-571970" data-claire-element-id="571970"><strong>initexts.c</strong> (début) <strong>:</strong></p><pre id="r-571971" data-claire-element-id="571971"><code data-claire-semantic="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
 
#include &quot;initexts.h&quot;
 
 
#ifndef USE_GLEW
PFNGLGENBUFFERSARBPROC glGenBuffers;
#endif</code></pre><p id="r-571972" data-claire-element-id="571972">Encore une fois, le préprocesseur est présent. En effet, si nous utilisons GLEW, celui-ci se chargera de nous fournir les pointeurs de fonction automatiquement (jetez un oeil au fichier glew.h :D ), en revanche si nous chargons nos fonctions manuellement, il va nous falloir déclarer nos pointeurs nous-mêmes (comme nous l'avons vu dans la 3eme partie de ce tutoriel).</p><h3 id="r-fonction-initextensions" data-claire-element-id="571980">Fonction InitExtensions()</h3><p id="r-571973" data-claire-element-id="571973">Bien, voyons maintenant le code source de notre fonction <em>Init()</em>. Celle-ci devra s'occuper de rendre nos pointeurs de fonction opérationnels (valides quoi). Pour une utilisation des extensions avec la SDL, nous placerons dans la fonction Init des <em>SDL_GL_GetProcAddress()</em>. Avec GLEW c'est plus simple, nous n'aurons qu'à l'initialiser et le tour sera joué :</p><p id="r-571974" data-claire-element-id="571974"><strong>initexts.c</strong> (suite) <strong>:</strong></p><pre id="r-571975" data-claire-element-id="571975"><code data-claire-semantic="c">GLenum InitExtensions()
{
    GLenum code = 0;
    
    #ifndef USE_GLEW
    /* chargement des fonctions d'extension(s) */
    glGenBuffers = SDL_GL_GetProcAddress(&quot;glGenBuffersARB&quot;);
    #else
    /* initialisation de GLEW */
    code = glewInit();
    if(code != GLEW_OK)
    {
        fprintf(stderr, &quot;impossible d'initialiser les extensions&quot;
                        &quot; avec GLEW : %s\n&quot;, glewGetErrorString(code));
        code = 1;
    }
    else
        code = 0;
    #endif
    
    return (code);
}</code></pre><p id="r-571976" data-claire-element-id="571976">Notre fonction d'initialisation peut bien sûr échouer, c'est pour cela qu'elle retourne une valeur, nous n'aurons ensuite qu'à la tester pour savoir si <em>Init()</em> a réussi ou pas.</p><p id="r-571977" data-claire-element-id="571977">A part ça rien de particulier, pour GLEW un simple appel à <em>glewInit()</em>, et pour la SDL on charge simplement toutes nos fonctions. Notez que pour rajouter des fonctions au chargement avec la SDL nous ferons comme ceci :</p><pre id="r-571978" data-claire-element-id="571978"><code data-claire-semantic="c">glGenBuffers = SDL_GL_GetProcAddress(&quot;glGenBuffersARB&quot;);
glNomPointeur = SDL_GL_GetProcAddress(&quot;glNomFonction&quot;);
/* etc ... */</code></pre><p id="r-571979" data-claire-element-id="571979">Voilà pour la fonction d'initialisation. Vous comprenez à présent pourquoi l'usage de GLEW est recommandé : cela vous permet d'économiser des lignes de code (et donc du temps), car avec la SDL vous allez devoir charger manuellement chaque fonction d'extension, GLEW le fait tout seul par le simple appel à sa fonction d'initialisation.</p><h3 id="r-fonction-checkextension" data-claire-element-id="571986">Fonction CheckExtension()</h3><p id="r-571981" data-claire-element-id="571981">Rien de sorcier là non plus. Avec la SDL, nous allons procéder de la même façon que je l'ai indiqué dans la 3eme partie de ce tutoriel, nous allons récupérer la liste des extensions supportées, rechercher l'extension demandée dans cette liste, puis si elle s'y trouve, l'extension est supportée, sinon elle ne l'est pas.</p><p id="r-571982" data-claire-element-id="571982">Pour GLEW, nous utiliserons simplement la fonction <em>glewIsSupported()</em> :</p><p id="r-571983" data-claire-element-id="571983"><strong>initexts.c</strong> (fin) <strong>:</strong></p><pre id="r-571984" data-claire-element-id="571984"><code data-claire-semantic="c">int CheckExtension(const char *name)
{
    #ifndef USE_GLEW
    const unsigned char *exts = glGetString(GL_EXTENSIONS);
    
    if(strstr((const char*)exts, name) == NULL)
    #else
    if(!glewIsSupported(name))
    #endif
    {
        fprintf(stderr, &quot;extension '%s' non supportee\n&quot;, name);
        return 0;
    }
    else
        return 1;
}</code></pre><p id="r-571985" data-claire-element-id="571985">La fonction <em>Check()</em> renvoie un booléen, ainsi nous n'aurons qu'à le tester directement dans un if.</p><h2 id="r-exemple-d-utilisation-19" data-claire-element-id="571992">Exemple d'utilisation</h2><p id="r-571988" data-claire-element-id="571988">Si vous vous souvenez de ce que je vous ai dit, vous devriez savoir qu'il est obligatoire d'initialiser les extensions uniquement après la création du contexte OpenGL, donc, avec la SDL, après l'appel de la fonction <em>SDL_SetVideoMode()</em>.</p><p id="r-571989" data-claire-element-id="571989">Notre fonction <em>Init()</em> devra donc être appelée <strong>après</strong><em>SDL_SetVideoMode()</em> :</p><p id="r-571990" data-claire-element-id="571990"><strong>main.c</strong> (exemple) <strong>:</strong></p><pre id="r-571991" data-claire-element-id="571991"><code data-claire-semantic="c">SDL_Init(SDL_INIT_VIDEO);
SDL_SetVideoMode(640, 480, 32, SDL_OPENGL);
 
if(InitExtensions() &gt; 0)
{
    SDL_Quit();
    exit(EXIT_FAILURE);
}
 
/* maintenant on peut appeler CheckExtension pour savoir
   si une extension qu'on voudra utiliser est supportee */
 
if(CheckExtension(&quot;GL_ARB_super_extension&quot;))
{
    /* utilisation */
}
else
{
    /* ... */
}</code></pre><h2 id="r-telechargements-5" data-claire-element-id="572024">Téléchargements</h2><p id="r-571993" data-claire-element-id="571993">Voici un programme complet afin que vous puissiez tester si vous avez correctement mis en place les extensions.</p><p id="r-571994" data-claire-element-id="571994">Par défaut, les projets utilisent la SDL pour le chargement des extensions, pour tester GLEW, vous n'aurez qu'à définir USE_GLEW :</p><ul id="r-572001" data-claire-element-id="572001"><li id="r-571996" data-claire-element-id="571996"><p id="r-571995" data-claire-element-id="571995">Avec Code::Blocks ou Dev-C++ : procédez de la même façon que lorsque vous avez défini GLEW_STATIC (voir Création d'un projet utilisant GLEW).</p></li><li id="r-572000" data-claire-element-id="572000"><p id="r-571997" data-claire-element-id="571997">Avec le Makefile : dans le Makefile, ajoutez à la variable CFLAGS la commande -DUSE_GLEW :</p><pre id="r-571998" data-claire-element-id="571998"><code data-claire-semantic="bash">CFLAGS=-O2 `sdl-config --cflags` -DUSE_GLEW</code></pre><p id="r-571999" data-claire-element-id="571999">puis recompilez.</p></li></ul><p id="r-572002" data-claire-element-id="572002">Voici la liste des téléchargements (l'exécutable Linux utilise la glibc 2.4) :</p><ul id="r-572009" data-claire-element-id="572009"><li id="r-572004" data-claire-element-id="572004"><p id="r-572003" data-claire-element-id="572003"><a href="http://yno.goldzoneweb.info/sdz/glexts_dev.zip">Télécharger les sources et le projet Dev-C++. (400 ko)</a></p></li><li id="r-572006" data-claire-element-id="572006"><p id="r-572005" data-claire-element-id="572005"><a href="http://yno.goldzoneweb.info/sdz/glexts_cb.zip">Télécharger les sources et le projet Code::Blocks. (344 ko)</a></p></li><li id="r-572008" data-claire-element-id="572008"><p id="r-572007" data-claire-element-id="572007"><a href="http://yno.goldzoneweb.info/sdz/glexts.tar.gz">Télécharger les sources et le Makefile Linux. (6.3 ko)</a></p></li></ul><div id="r-572011" data-claire-element-id="572011" data-claire-semantic="question"><p id="r-572010" data-claire-element-id="572010">La compilation échoue ! Que faire ?</p></div><ul id="r-572020" data-claire-element-id="572020"><li id="r-572013" data-claire-element-id="572013"><p id="r-572012" data-claire-element-id="572012">Vérifiez que vous avez bien mis à jour le fichier glext.h, <a href="http://oss.sgi.com/projects/ogl-sample/sdk.html">voici le lien pour le télécharger</a>.</p></li><li id="r-572015" data-claire-element-id="572015"><p id="r-572014" data-claire-element-id="572014">Essayez d'inclure glew.h avant SDL.h</p></li><li id="r-572017" data-claire-element-id="572017"><p id="r-572016" data-claire-element-id="572016">Sous Windows : avez-vous bien les fichiers glew.h et wglew.h dans le dossier include/GL/ de votre compilateur ?</p></li><li id="r-572019" data-claire-element-id="572019"><p id="r-572018" data-claire-element-id="572018">Sous Linux : avez-vous bien le fichier libGLEW.so dans le répertoire /usr/lib/ (ou /usr/local/lib/) ?</p></li></ul><p id="r-572021" data-claire-element-id="572021">Si aucune de ces solutions ne convient, je vous invite à venir exposer votre problème sur <a href="http://www.siteduzero.com/forum-81-126-c-c.html">le forum C</a> avec le tag [GLEW] dans le titre du sujet. Par la même occasion, j'en profite pour faire un peu de pub à un très bon tutoriel sur <a href="http://www.siteduzero.com/tuto-3-17635-1-comment-bien-demander-de-l-aide-sur-internet.html">comment bien demander de l'aide sur internet ?</a>, rédigé par <a href="http://www.siteduzero.com/membres-294-2402.html">iKs</a>.</p><p id="r-572022" data-claire-element-id="572022">Et voilà, maintenant vous savez tout sur les extensions d'OpenGL :)</p><p id="r-572023" data-claire-element-id="572023">Bien sûr, vous ne connaissez peut-être pas d'extension à utiliser pour le moment, mais au moins maintenant lorsque vous apprendrez à vous servir d'une extension, vous saurez la charger correctement.</p><h2 id="r-quelques-liens-1" data-claire-element-id="572041">Quelques liens</h2><p id="r-572025" data-claire-element-id="572025">Avant de nous quitter, je vous propose une liste de quelques liens qui risquent de vous être bien utiles.</p><ul id="r-572034" data-claire-element-id="572034"><li id="r-572027" data-claire-element-id="572027"><p id="r-572026" data-claire-element-id="572026"><a href="http://glew.sourceforge.net/">Site officiel de la bibliothèque GLEW.</a></p></li><li id="r-572029" data-claire-element-id="572029"><p id="r-572028" data-claire-element-id="572028"><a href="http://www.khronos.org/">Site officiel de Khronos.</a></p></li><li id="r-572031" data-claire-element-id="572031"><p id="r-572030" data-claire-element-id="572030"><a href="http://jeux.developpez.com/faq/opengl/?page=extensions">Présentation des extensions d'OpenGL par Developpez.com</a></p></li><li id="r-572033" data-claire-element-id="572033"><p id="r-572032" data-claire-element-id="572032"><a href="http://oss.sgi.com/projects/ogl-sample/sdk.html">Télécharger la dernière version du fichier glext.h</a></p></li></ul><p id="r-572035" data-claire-element-id="572035">Voilà, c'est la fin de ce tutoriel, j'espère qu'il vous aura plu :)</p><div id="r-572037" data-claire-element-id="572037"><p id="r-572036" data-claire-element-id="572036"><em>Merci à <a href="http://www.siteduzero.com/membres-294-23709.html">Nab</a> pour son beta-test de l'utilisation de GLEW sous Windows</em> ;)</p></div><div id="r-572040" data-claire-element-id="572040"><p id="r-572038" data-claire-element-id="572039"><em><a href="http://creativecommons.org/licenses/by-sa/2.0/fr/"><img id="r-572039" data-claire-element-id="572038" src="../../licensebuttons.net/l/by-sa/2.0/fr/88x31.png" alt="Image utilisateur"/></a>Cette création est mise à disposition sous un <a href="http://creativecommons.org/licenses/by-sa/2.0/fr/">contrat Creative Commons</a>.</em></p></div>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5">Les extensions</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/c-est-quoi-les-extensions">
C&#039;est quoi les extensions ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/comment-ca-fonctionne-3">
Comment ça fonctionne ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-la-sdl-methode-manuelle">
Utilisation de la SDL : méthode manuelle
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-glew-methode-automatique">
Utilisation de GLEW : méthode automatique
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/un-exemple-complet-3">
Un exemple complet
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-extensions-5/utilisation-de-glew-methode-automatique">
<span class="arrow"></span>
<span class="next">Utilisation de GLEW : méthode automatique</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/les-extensions-5.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 06:50:51 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-extensions-5.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:14:37 GMT -->
</html>
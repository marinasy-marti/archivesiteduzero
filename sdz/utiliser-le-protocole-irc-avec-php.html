<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/utiliser-le-protocole-irc-avec-php.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 11:22:15 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/utiliser-le-protocole-irc-avec-php.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:49:50 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Utiliser le protocole IRC avec PHP</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/utiliser-le-protocole-irc-avec-php.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Utiliser le protocole IRC avec PHP</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#UtiliserleprotocoleIRCavecPHP">Utiliser le protocole IRC avec PHP</a><br/><a href="#IRCkzako">IRC, kézako ?</a><br/><a href="#Constructionthoriqueduprogramme">Construction théorique du programme</a><br/><a href="#PratiqueCodage">Pratique — Codage</a><br/><a href="#Petitrcapitulatif">Petit récapitulatif</a><br/></div>
<a name="UtiliserleprotocoleIRCavecPHP"></a><h2>Utiliser le protocole IRC avec PHP</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/irc-kezako">
<span class="next">IRC, kézako ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-568053" data-claire-element-id="568053">PHP, en plus de permettre de rendre son site Web interactif, permet de faire des programmes (voir le tutoriel sur <a href="http://www.siteduzero.com/tutoriel-3-311-creer-de-vrais-programmes-en-php.html">PHP-CLI</a> de gnomnain). Mais il permet aussi de dialoguer avec d'autres serveurs ! Vous pouvez donc faire avec PHP beaucoup de choses, comme un indexeur de pages (<em>via</em> cURL), un lecteur de news RSS… mais vous pouvez aussi dialoguer avec un serveur IRC facilement ! C'est ce que l'on va voir dans ce tutoriel.</p>
</div><a name="IRCkzako"></a><h2>IRC, kézako ?</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/construction-theorique-du-programme">
<span class="next">Construction théorique du programme</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568054" data-claire-element-id="568054">IRC, pour <em>Internet Relay Chat</em>, est un des premiers (peut-être même <strong>le</strong> premier) protocole de communication instantanée informatique au monde. Il a été créé en 1988 ; c'est un protocole public contrairement à d'autres (MSN, Yahoo! Messenger et d'autres), qui est aussi <em>relativement</em> simple si on le compare aux autres protocoles existants. Ici, pas de cryptage (enfin si, mais c'est optionnel et on ne le verra pas ici), pas de trucs compliqués, IRC est un protocole simple.</p><p id="r-568055" data-claire-element-id="568061"><em><a href="http://www.mirc.com/"><img id="r-568056" data-claire-element-id="568055" src="medias/uploads.siteduzero.com_thb_163001_164000_163521.jpg" alt="Image utilisateur"/></a><a href="http://www.xchat.org/"><img id="r-568057" data-claire-element-id="568056" src="medias/uploads.siteduzero.com_thb_163001_164000_163523.png" alt="Image utilisateur"/></a><a href="http://konversation.kde.org/"><img id="r-568058" data-claire-element-id="568057" src="medias/uploads.siteduzero.com_thb_163001_164000_163524.png" alt="Image utilisateur"/></a><a href="https://addons.mozilla.org/fr/firefox/addon/16"><img id="r-568059" data-claire-element-id="568058" src="medias/uploads.siteduzero.com_thb_163001_164000_163526.png" alt="Image utilisateur"/></a><a href="http://www.irssi.org/"><img id="r-568060" data-claire-element-id="568059" src="medias/uploads.siteduzero.com_thb_163001_164000_163527.png" alt="Image utilisateur"/></a><a href="http://www.miranda-im.org/"><img id="r-568061" data-claire-element-id="568060" src="medias/uploads.siteduzero.com_thb_163001_164000_163529.png" alt="Image utilisateur"/></a>Cliquez sur les images pour accéder aux sites des clients</em></p><p id="r-568062" data-claire-element-id="568062">De nombreux clients existent pour IRC et dans à peu près n'importe quel langage de programmation supportant l'accès au réseau. Le plus connu est mIRC, mais il en existe plein d'autres, comme notamment XChat, tinyIRC (un client qui tient uniquement dans 150 Ko !), Konversation sous Linux, ChatZilla, qui est un client dans un simple plugin pour Firefox, ou même Irssi, un client en console très performant (voir <a href="http://www.siteduzero.com/tutoriel-3-38486-irssi-le-client-du-futur.html">le tutoriel</a> à ce sujet). On trouve même des clients qui combinent IRC et d'autres protocoles (MSN, ICQ, Jabber), comme par exemple Miranda IM sous Windows, ou Pidgin sous Linux.</p><p id="r-568063" data-claire-element-id="568063">Mais le client que vous devriez voir est <a href="http://www.mibbit.com/">Mibbit</a>, un client écrit en PHP et en AJAX (avec un truc en Java derrière quand même).</p><p id="r-568064" data-claire-element-id="568064">Pour plus d'informations sur le protocole IRC, je vous conseille d'aller voir le document le décrivant et qui nous servira durant tout le tutoriel (gardez-le ouvert) : la <a href="http://abcdrfc.free.fr/rfc-vf/rfc1459.html">RFC 1459</a> (ici en français).</p><div id="r-568066" data-claire-element-id="568066" data-claire-semantic="question"><p id="r-568065" data-claire-element-id="568065">Et PHP dans tout ça ?</p></div><p id="r-568067" data-claire-element-id="568067">PHP permet tout simplement de dialoguer avec un serveur IRC, comme n'importe quel client ! Vous pouvez ainsi créer différents programmes en PHP pour intéragir avec IRC, comme principalement les <strong><em>bots</em></strong>. Mais faites attention, les <em>bots</em> IRC (PHP, Python et dans d'autres langages) sont légion sur Internet, donc vous vous ferez peut-être mal voir étant donné que vous (re)développez un truc déjà développé X fois…</p><p id="r-568068" data-claire-element-id="568068">On en arrive à notre fil rouge, que je vais utiliser pour vous apprendre à utiliser IRC avec PHP durant ce tutoriel : la création d'un <em>bot</em>. Oui, je sais que j'ai dit que c'était mal, mais le problème c'est que développer un autre truc comme par exemple un client, c'est beaucoup plus dur, donc je vous montre comment faire un <em>bot</em>. Maintenant, après ce tutoriel, libre à vous de faire un <em>bot</em>, ou de faire autre chose.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php">Utiliser le protocole IRC avec PHP</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/irc-kezako">
IRC, kézako ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/construction-theorique-du-programme">
Construction théorique du programme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/pratique-codage">
Pratique — Codage
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/petit-recapitulatif-1">
Petit récapitulatif
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/construction-theorique-du-programme">
<span class="next">Construction théorique du programme</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Constructionthoriqueduprogramme"></a><h2>Construction théorique du programme</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/irc-kezako">
<span class="arrow"></span>
<span class="next">IRC, kézako ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/pratique-codage">
<span class="next">Pratique — Codage</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568070" data-claire-element-id="568070">Bon, maintenant, qu'est-ce que l'on va faire comme <em>bot</em> ? Eh bien, je vous propose un <em>bot</em> relativement simple à faire : un <em>bot</em><strong>bot de quiz</strong>. Réaliser ce genre de <em>bot</em> est relativement facile, car il ne fait que poser des questions et vérifier les réponses…</p><h2 id="r-i-cahier-des-charges" data-claire-element-id="568082">I. Cahier des charges</h2><p id="r-568071" data-claire-element-id="568071">Voici ce que fera notre <em>bot</em> :</p><ul id="r-568080" data-claire-element-id="568080"><li id="r-568073" data-claire-element-id="568073"><p id="r-568072" data-claire-element-id="568072">poser des questions ;</p></li><li id="r-568075" data-claire-element-id="568075"><p id="r-568074" data-claire-element-id="568074">comprendre les réponses, et dire qui a bien répondu (en premier) ;</p></li><li id="r-568077" data-claire-element-id="568077"><p id="r-568076" data-claire-element-id="568076">empêcher le lancement de deux questions en même temps ;</p></li><li id="r-568079" data-claire-element-id="568079"><p id="r-568078" data-claire-element-id="568078"><em>auto-rejoin on kick</em> (si on le vire du canal, on le fait revenir immédiatement).</p></li></ul><p id="r-568081" data-claire-element-id="568081">Voilà, c'est tout. Ce n'est pas beaucoup, mais je juge que c'est déjà bien pour un premier <em>bot</em>.</p><h2 id="r-ii-solutions-pour-le-cahier-des-charges" data-claire-element-id="568166">II. Solutions pour le cahier des charges</h2><h3 id="r-1-structuration-de-la-base-de-donnees-de-questions" data-claire-element-id="568093">1. Structuration de la « base de données » de questions</h3><p id="r-568083" data-claire-element-id="568083">Pour stocker les questions du <em>bot</em>, nous allons utiliser un unique fichier pour toutes les questions. Nous n'utiliserons pas de BDD, car c'est relativement lent et gourmand en mémoire ; et pour juste une liste de questions, nous n'allons pas nous embêter à faire du SQL. On structurera le fichier de sorte à pouvoir extraire les questions dans un <em>array</em>.</p><p id="r-568084" data-claire-element-id="568084">Je vous propose dans ce tutoriel un type de structuration pour vos questions, mais vous pouvez en choisir un autre.</p><p id="r-568085" data-claire-element-id="568085">Tout d'abord, dans notre fichier, les questions seront séparées par ligne. Donc à une ligne correspondra un composé question-réponse.<br/> Ensuite, la question sera séparée de la réponse par une chaîne de caractères définie au préalable. Pour ce <em>bot</em>, je vais choisir cette chaîne de caractères :</p><pre id="r-568086" data-claire-element-id="568086"><code>&lt;|#()#|&gt;</code></pre><aside id="r-568088" data-claire-element-id="568088" data-claire-semantic="warning"><p id="r-568087" data-claire-element-id="568087">Bien sûr, cette chaîne de caractères ne devra se trouver ni dans la question, ni dans la réponse.</p></aside><p id="r-568089" data-claire-element-id="568089">Voici donc un exemple de fichier de questions que vous pouvez utiliser avec ce <em>bot</em> :</p><pre id="r-568090" data-claire-element-id="568090"><code>Quel est le nom du premier langage de programmation encore utilisé actuellement ?&lt;|#()#|&gt;FORTRAN
Que veut dire PHP ?&lt;|#()#|&gt;PHP Hypertext Preprocessor
Quelle est la propriété CSS pour définir la bordure d'un bloc ?&lt;|#()#|&gt;border
Quand a été créé le Site du Zéro ?&lt;|#()#|&gt;1999
Quelle est la Réponse à la Grande Question de la Vie, de l'Univers et du Reste ?&lt;|#()#|&gt;42
Qui a créé Linux ?&lt;|#()#|&gt;Linus Torvalds
Qui est à l'initiative du projet de système d'exploitation libre GNU ?&lt;|#()#|&gt;Richard Stallman</code></pre><aside id="r-568092" data-claire-element-id="568092" data-claire-semantic="information"><p id="r-568091" data-claire-element-id="568091">Pour mon fichier de questions, j'aurais pu utiliser une structure XML, mais c'est assez dur de naviguer dans les nœuds XML et surtout trop compliqué pour le petit <em>bot</em> que l'on va faire. C'est déjà assez compliqué avec le protocole IRC, on ne va pas rajouter en plus le XML (mais si vous voulez le faire, libre à vous).</p></aside><h3 id="r-2-structuration-globale-du-programme" data-claire-element-id="568165">2. Structuration globale du programme</h3><p id="r-568094" data-claire-element-id="568094">Maintenant, on passe à la construction (théorique) globale du programme, on mettra les différentes étapes de fonctionnement du <em>bot</em> (regroupées en catégories).</p><p id="r-568095" data-claire-element-id="568095">Lecture des questions sur le fichier</p><p id="r-568096" data-claire-element-id="568096">Ici, l'étape est plus que simple et sera effectuée <strong>avant</strong> la connexion au serveur IRC :</p><ol id="r-568103" data-claire-element-id="568103"><li id="r-568098" data-claire-element-id="568098"><p id="r-568097" data-claire-element-id="568097">on ouvre le fichier des questions et on le lit ;</p></li><li id="r-568100" data-claire-element-id="568100"><p id="r-568099" data-claire-element-id="568099">on extrait chaque couple question/réponse ;</p></li><li id="r-568102" data-claire-element-id="568102"><p id="r-568101" data-claire-element-id="568101">on sépare la question et la réponse.</p></li></ol><p id="r-568104" data-claire-element-id="568104">Comme vous le voyez, rien de plus simple. Si vous n'y arrivez pas, retournez consulter le <a href="http://www.siteduzero.com/tutoriel-3-14577-lire-et-ecrire-dans-un-fichier.html">tutoriel sur la manipulation des fichiers, de M@teo21</a>.</p><p id="r-568105" data-claire-element-id="568105">Connexion au serveur IRC</p><p id="r-568106" data-claire-element-id="568106">Alors pour IRC, la connexion se passe en plusieurs étapes :</p><ol id="r-568117" data-claire-element-id="568117"><li id="r-568108" data-claire-element-id="568108"><p id="r-568107" data-claire-element-id="568107">on ouvre la connexion au serveur (au hasard, irc.epiknet.org sur le port 6667) ;</p></li><li id="r-568110" data-claire-element-id="568110"><p id="r-568109" data-claire-element-id="568109">on indique le pseudonyme <em>(nick)</em> du <em>bot</em>, avec la commande <code>NICK</code> ;</p></li><li id="r-568112" data-claire-element-id="568112"><p id="r-568111" data-claire-element-id="568111">on indique le « vrai nom » du bot <em>(username)</em><em>via</em> la commande <code>USER</code> ;</p></li><li id="r-568114" data-claire-element-id="568114"><p id="r-568113" data-claire-element-id="568113">le serveur nous envoie une requête de <code>PING</code> ;</p></li><li id="r-568116" data-claire-element-id="568116"><p id="r-568115" data-claire-element-id="568115">on rejoint le canal où le <em>bot</em> doit être (au hasard, #sdz-quiz).</p></li></ol><p id="r-568118" data-claire-element-id="568118">Cette démarche n'est pas propre à PHP, mais au protocole IRC. Si vous essayez de vous connecter directement au serveur IRC (avec Telnet par exemple), vous verrez que vous devez exécuter ces mêmes étapes.</p><p id="r-568119" data-claire-element-id="568119">D'ailleurs, en réalité il y a une étape « 4,5 » qui correspond à la reception du <code>MOTD</code>, mais ici le <code>MOTD</code> ne nous intéresse pas, donc on ne le met pas dans la description théorique.</p><p id="r-568120" data-claire-element-id="568120">Lorsque le <em>bot</em> est au repos (pas de question posée)</p><ol id="r-568147" data-claire-element-id="568147"><li id="r-568122" data-claire-element-id="568122"><p id="r-568121" data-claire-element-id="568121">On voit s'il y a un nouveau message.</p></li><ol id="r-568132" data-claire-element-id="568132"><li id="r-568124" data-claire-element-id="568124"><p id="r-568123" data-claire-element-id="568123">Si oui, on regarde si c'est une demande de question.</p></li><ol id="r-568129" data-claire-element-id="568129"><li id="r-568126" data-claire-element-id="568126"><p id="r-568125" data-claire-element-id="568125">S'il y en a une, on passe en « mode question ».</p></li><li id="r-568128" data-claire-element-id="568128"><p id="r-568127" data-claire-element-id="568127">Sinon, on ne fait rien.</p></li></ol><li id="r-568131" data-claire-element-id="568131"><p id="r-568130" data-claire-element-id="568130">Si non, on passe.</p></li></ol><li id="r-568134" data-claire-element-id="568134"><p id="r-568133" data-claire-element-id="568133">On regarde si le serveur nous a envoyé un <code>PING</code>.</p></li><ol id="r-568139" data-claire-element-id="568139"><li id="r-568136" data-claire-element-id="568136"><p id="r-568135" data-claire-element-id="568135">Si oui, on renvoie un <code>PONG</code>.</p></li><li id="r-568138" data-claire-element-id="568138"><p id="r-568137" data-claire-element-id="568137">Si non, on ne fait rien.</p></li></ol><li id="r-568141" data-claire-element-id="568141"><p id="r-568140" data-claire-element-id="568140">On regarde si on a été <em>kické</em> (éjecté) du canal.</p></li><ol id="r-568146" data-claire-element-id="568146"><li id="r-568143" data-claire-element-id="568143"><p id="r-568142" data-claire-element-id="568142">Si oui, on retourne dans le salon.</p></li><li id="r-568145" data-claire-element-id="568145"><p id="r-568144" data-claire-element-id="568144">Si non, on ne fait rien</p></li></ol></ol><p id="r-568148" data-claire-element-id="568148">Ça a l'air long, mais ne vous inquiétez pas, ça se résume par peu de lignes de code.</p><p id="r-568149" data-claire-element-id="568149">Quand on a demandé une question (« mode question »)</p><ol id="r-568162" data-claire-element-id="568162"><li id="r-568151" data-claire-element-id="568151"><p id="r-568150" data-claire-element-id="568150">On regarde s'il y a un message.</p></li><ol id="r-568161" data-claire-element-id="568161"><li id="r-568153" data-claire-element-id="568153"><p id="r-568152" data-claire-element-id="568152">Si oui, on vérifie si c'est la réponse à la question.</p></li><ol id="r-568158" data-claire-element-id="568158"><li id="r-568155" data-claire-element-id="568155"><p id="r-568154" data-claire-element-id="568154">Si oui, on affiche « Bravo ! » ou un message du genre.</p></li><li id="r-568157" data-claire-element-id="568157"><p id="r-568156" data-claire-element-id="568156">Si non, on ne fait rien.</p></li></ol><li id="r-568160" data-claire-element-id="568160"><p id="r-568159" data-claire-element-id="568159">Si non, alors on ne fait rien.</p></li></ol></ol><p id="r-568163" data-claire-element-id="568163">Pour le reste du mode de fonctionnement, on le fait à l'image du mode au repos (à partir du 2.).</p><p id="r-568164" data-claire-element-id="568164">Voilà pour le mode de fonctionnement, maintenant on passe à la création, où tout le mode pratique de la connexion à IRC avec PHP va vous être expliqué !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php">Utiliser le protocole IRC avec PHP</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/irc-kezako">
IRC, kézako ?
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/construction-theorique-du-programme">
Construction théorique du programme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/pratique-codage">
Pratique — Codage
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/petit-recapitulatif-1">
Petit récapitulatif
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/irc-kezako">
<span class="arrow"></span>
<span class="next">IRC, kézako ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/pratique-codage">
<span class="next">Pratique — Codage</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="PratiqueCodage"></a><h2>Pratique — Codage</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/construction-theorique-du-programme">
<span class="arrow"></span>
<span class="next">Construction théorique du programme</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/petit-recapitulatif-1">
<span class="next">Petit récapitulatif</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568168" data-claire-element-id="568168">Maintenant, on va (enfin) coder le <em>bot</em> en lui-même. Au départ, on va coder chaque partie séparément, puis nous rassemblerons le tout pour former le <em>bot</em> final.</p><h2 id="r-preparation-26" data-claire-element-id="568172">Préparation</h2><p id="r-568169" data-claire-element-id="568169">Tout d'abord, nous allons nous préparer pour créer le <em>bot</em>. Je vous conseille de créer un dossier rien que pour le <em>bot</em>, même si à la fin, il n'y aura que deux fichiers. Pourquoi ? Tout simplement pour éviter de se perdre dans une masse de fichiers.</p><p id="r-568170" data-claire-element-id="568170">Maintenant, créez un fichier appelé bot.php (le <em>bot</em>), et un fichier questions.txt (les questions), dans lequel vous mettrez vos questions (si vous n'avez pas d'idée pour tester, prenez le fichier d'exemple que j'ai mis plus haut).</p><p id="r-568171" data-claire-element-id="568171">Voilà, on est prêts à commencer !</p><h2 id="r-le-codage" data-claire-element-id="568254">Le codage</h2><p id="r-568173" data-claire-element-id="568173">Alors, comme je l'ai dit plus haut, on va le faire par étapes, puis à la fin rassembler le tout. Je vous conseille d'avoir gardé ouverte la RFC 1459 (le lien est en haut du tuto), car je vais y faire pas mal de références.</p><aside id="r-568175" data-claire-element-id="568175" data-claire-semantic="information"><p id="r-568174" data-claire-element-id="568174">Note : ici, je ne vais pas faire de connexion avec un mot de passe. Ce sera à vous de le faire plus tard, si vous en avez besoin (ce n'est pas très difficile de toute façon).</p></aside><p id="r-568176" data-claire-element-id="568176"><cite>Citation : Informations utiles pour le bot</cite></p><blockquote id="r-568178" data-claire-element-id="568178"><p id="r-568177" data-claire-element-id="568177">Serveur : irc.epiknet.org port 6667<br/> Nom du bot : QuizBot<br/> Canal : #quiz-sdz<br/> Nom d'utilisateur <em>(username)</em> : Quiz</p></blockquote><p id="r-568179" data-claire-element-id="568179">Le nom d'utilisateur ne nous sera pas très utile.</p><h3 id="r-1-construction-de-la-liste-des-questions-reponses" data-claire-element-id="568183">1. Construction de la liste des questions-réponses</h3><p id="r-568180" data-claire-element-id="568180">Ici, rien de plus simple, on récupère la totalité du fichier dans une variable, <em>via</em><code data-claire-semantic="html+php">file_get_contents() </code>, puis on sépare questions et réponses, et éventuellement on retire le dernier élément si celui-ci est vide (c'est relatif aux fichiers, certains éditeurs insèrent une ligne en sauvegardant) :</p><pre id="r-568181" data-claire-element-id="568181"><code data-claire-semantic="html+php">&lt;?php
$file = file_get_contents('questions.txt'); // On lit le fichier des questions dans une chaîne
$questions = explode(&quot;\n&quot;,$file); // On sépare chaque ligne (\n est le caractère signifiant une nouvelle ligne)

// On sépare la question et la réponse
for($i=0;isset($questions[$i]);$i++)
	$questions[$i] = explode('&lt;|#()#|&gt;',$questions[$i]);
// Si le dernier élément est vide (bug relatif aux fichiers), on le supprime
if(!$questions[count($questions)-1])
	unset($questions[count($questions)-1]);
?&gt;</code></pre><p id="r-568182" data-claire-element-id="568182">Ici, après le traitement, on pourra trouver les questions dans l'<em>array</em> bi-dimensionnel <code data-claire-semantic="html+php">$questions </code> : la question no X sera à <code data-claire-semantic="html+php">$questions[X][0] </code> et la réponse correspondante <code data-claire-semantic="html+php">$questions[X][1] </code>.</p><h3 id="r-2-connexion" data-claire-element-id="568199">2. Connexion</h3><p id="r-568184" data-claire-element-id="568184">Tout d'abord, pour se connecter au serveur IRC, on doit ouvrir la connexion au serveur, et pour cela, rien ne vaut une bonne vieille commande <code data-claire-semantic="html+php">fsockopen() </code>. Bien sûr, on vérifie que l'on est bien connectés au serveur, sinon cela ne marchera pas :</p><pre id="r-568185" data-claire-element-id="568185"><code data-claire-semantic="html+php">&lt;?php
set_time_limit(0);
$socket = fsockopen('irc.epiknet.org','6667');

// Vérification de la bonne connexion :
if(!$socket)
{
	// Si on n'a pas réussi, on affiche un message d'erreur et on quitte.
	echo 'Impossible de se connecter';
	exit;
}
?&gt;</code></pre><aside id="r-568187" data-claire-element-id="568187" data-claire-semantic="information"><p id="r-568186" data-claire-element-id="568186">Ici, le <code data-claire-semantic="html+php">set_time_limit(0) </code> permet d'indiquer à PHP que l'on souhaite que le script tourne indéfiniment (en effet, si le bot tourne 30 secondes et s'arrête, ce n'est pas très utile).</p></aside><p id="r-568188" data-claire-element-id="568188">Ensuite, on passe aux étapes 2. et 3. : le renseignement du pseudonyme <em>(nickname)</em> et du nom d'utilisateur. Si l'on lit la RFC 1459, le nom d'utilisateur n'est pas pris en compte lorsque l'on veut se connecter, mais il faut quand même le renseigner.</p><p id="r-568189" data-claire-element-id="568189">Il reste encore un problème : comment envoie-t-on des données au serveur ? Eh bien, c'est plus que simple : lorsque l'on arrive à se connecter, la commande <code data-claire-semantic="html+php">fsockopen() </code> nous renvoie un pointeur de fichier ! Il suffit donc d'effectuer des fonctions <code data-claire-semantic="html+php">fputs() </code> pour envoyer des données sur le serveur, et des fonctions <code data-claire-semantic="html+php">fgets() </code> pour lire les données du serveur.</p><p id="r-568190" data-claire-element-id="568190">Par contre, toujours selon la RFC 1459, il faut envoyer une certaine chaîne de caractères pour indiquer la fin d'un message : c'est la chaîne composée des caractères CR et LF, représentés en PHP par <code data-claire-semantic="html+php"></code> , utilisables uniquement entre guillemets :</p><pre id="r-568191" data-claire-element-id="568191"><code data-claire-semantic="html+php">&lt;?php
// On renseigne l'USER : ici, je mets un peu n'importe quoi, vu que le serveur ne prend en compte que le premier argument (mais qu'il a besoin de 4 arguments).
fputs($socket,&quot;USER QuizBot QuizBot Quiz Quiz\r\n&quot;);
// On donne le NICK.
fputs($socket,&quot;NICK QuizBot\r\n&quot;);
?&gt;</code></pre><p id="r-568192" data-claire-element-id="568192">Maintenant, on arrive aux étapes 4. et 5., où on doit attendre que le serveur nous envoie un <code>PING</code> et y répondre par un <code>PONG</code>, puis attendre la fin du <code>MOTD</code>. Pour ce faire, nous allons utiliser une boucle.</p><p id="r-568193" data-claire-element-id="568193">Pour le <code>PING</code>, la RFC nous dit que le serveur nous envoie une ligne du style « PING: 215613202 » à laquelle nous devrons répondre « PONG: 215613202 ».</p><p id="r-568194" data-claire-element-id="568194">Ensuite, le <code>MOTD</code> ne nous intéressant pas des masses, nous allons simplement l'ignorer.</p><pre id="r-568195" data-claire-element-id="568195"><code data-claire-semantic="html+php">&lt;?php
$continuer = 1; // On initialise une variable permettant de savoir si on doit continuer la boucle.
while($continuer) // Boucle principale.
{

	$donnees = fgets($socket, 1024); // Le 1024 permet de limiter la quantité de caractères à recevoir du serveur.
	$retour = explode(':',$donnees); // On sépare les différentes données.
	// On regarde si c'est un PING, et, le cas échéant, on envoie notre PONG :
	if(rtrim($retour[0]) == 'PING')
	{
		fputs($socket,'PONG :'.$retour[1]);
		$continuer = 0;
	}
	 if($donnees)
		echo $donnees;
}
?&gt;</code></pre><p id="r-568196" data-claire-element-id="568196">Normalement, on est correctement connectés au serveur, il ne reste plus qu'à joindre le canal :</p><pre id="r-568197" data-claire-element-id="568197"><code data-claire-semantic="html+php">&lt;?php
fputs($socket,&quot;JOIN #quiz-sdz\r\n&quot;); // On rejoint le canal #quiz-sdz.</code></pre><p id="r-568198" data-claire-element-id="568198">Voilà, nous sommes maintenant connectés au canal du quiz, on va pouvoir faire le programme principal !</p><h3 id="r-3-le-programme-principal" data-claire-element-id="568215">3. Le programme principal</h3><p id="r-568200" data-claire-element-id="568200">Tout d'abord, on va devoir mettre une variable indiquant si une question a été posée ou non. J'ai choisi le nom <code data-claire-semantic="html+php">$questionPosee </code>, mais vous pouvez utiliser autre chose. Quand le mode question sera activé, la variable contiendra le numéro de la question (on pourra donc accéder à la question par <code data-claire-semantic="html+php">$questions[$questionPosee] </code>), et quand le mode question sera désactivé, elle vaudra -1 (comme le numéro des questions commence à 0 (<em>array</em> oblige), on met -1 sinon on risque des bugs) :</p><pre id="r-568201" data-claire-element-id="568201"><code data-claire-semantic="html+php">&lt;?php
$questionPosee = -1;</code></pre><p id="r-568202" data-claire-element-id="568202">Ensuite, nous devons faire tenir notre programme dans une boucle infinie, sinon il s'ouvrira et se refermera instantanément ! (Enfin presque, car il se connectera à IRC entre-temps.)</p><pre id="r-568203" data-claire-element-id="568203"><code data-claire-semantic="html+php">&lt;?php
// Boucle principale du programme.
while(1)
{
	// Ici, nous mettrons nos commandes.
}</code></pre><p id="r-568204" data-claire-element-id="568204">Maintenant, il faut lire sur le <em>socket</em> les messages envoyés par le serveur (ou pas), avec notre commande <code data-claire-semantic="html+php">fgets() </code>, que l'on place dans la boucle. Ensuite, on vérifie si le serveur nous a envoyé quelque chose, donc on met une condition d'existence. Si le serveur nous a envoyé quelque chose, on le traite.</p><p id="r-568205" data-claire-element-id="568205">Il faut savoir qu'une ligne de commande IRC ressemble à ceci :<br/>:linkboss!<a class="__cf_email__" href="http://www.cloudflare.com/email-protection" data-cfemail="98e6f4f1f6f3faf7ebebd8ebeef6acacb5a9b5afa0b5aaaaa0b5a9aea8b5a9aea8b6fefae0b6e8eaf7e0f9fcb6f6fdec">[email&nbsp;protected]</a><script type="text/javascript">
/* <![CDATA[ */
(function(){try{var s,a,i,j,r,c,l,b=document.getElementsByTagName("script");l=b[b.length-1].previousSibling;a=l.getAttribute('data-cfemail');if(a){s='';r=parseInt(a.substr(0,2),16);for(j=2;a.length-j;j+=2){c=parseInt(a.substr(j,2),16)^r;s+=String.fromCharCode(c);}s=document.createTextNode(s);l.parentNode.replaceChild(s,l);}}catch(e){}})();
/* ]]> */
</script> PRIVMSG #quiz-sdz :!question. On verra plus tard comment traiter cette ligne, mais pour l'instant il s'agit de la recevoir. Nous utiliserons donc <code data-claire-semantic="html+php">fgets() </code> :</p><pre id="r-568206" data-claire-element-id="568206"><code data-claire-semantic="html+php">&lt;?php
$donnees = fgets($socket,1024);</code></pre><p id="r-568207" data-claire-element-id="568207">Maintenant, nous avons lu sur le serveur les données qu'il faut. Mais il faut savoir que le serveur peut ne rien envoyer, et contrairement aux <em>sockets</em> serveur (en PHP tout du moins, et avec les paramètres par défaut), la lecture n'arrête pas le script ! Donc, avant de procéder à tout traitement, il faut d'abord vérifier que le serveur a bien envoyé quelque chose :</p><pre id="r-568208" data-claire-element-id="568208"><code data-claire-semantic="html+php">&lt;?php
if($donnees)
{
	echo $donnees;
	// Ici on traite ce que nous a envoyé le serveur.
}</code></pre><p id="r-568209" data-claire-element-id="568209">Ici le <code data-claire-semantic="html+php">echo $donnees; </code> permet juste d'afficher les messages du serveur, histoire de voir ce qu'il nous envoie (pratique pour le <em>debug</em> et pour savoir si tout a bien marché).</p><p id="r-568210" data-claire-element-id="568210">Maintenant, avant de continuer, on va régler un petit problème inhérent aux programmes en console : la consommation du processeur. En effet, si on laisse le programme comme cela, il consommera la totalité du processeur disponible, ralentissant tout votre ordinateur. Pour remédier à ce problème on place avant la fin de la boucle principale un petit code qui fait « dormir » le programme un petit peu de temps. Bien sûr, ça n'a aucune influence sur le temps de réaction, car il fait s'arrêter le programme moins d'une milliseconde (rappel : pour que l'on discerne deux évènements différents, au niveau de l'œil, il faut qu'entre ces deux évènements se passent environ 41 ms, donc on ne ressentira rien, mais on soulagera le processeur).<br/> Pour arriver à faire cela, nous allons recourir à une petite fonction à placer en fin de boucle :</p><pre id="r-568211" data-claire-element-id="568211"><code data-claire-semantic="html+php">&lt;?php
usleep(100);</code></pre><p id="r-568212" data-claire-element-id="568212">Cette fonction fait dormir le programme pendant le nombre de <strong>microsecondes</strong> renseigné en paramètre. Notez que ce sont des <strong>microsecondes</strong>, donc avec <code data-claire-semantic="html+php">usleep(100) </code>, le programme dormira non pas 100 ms (soit 0,1 s), mais 100 µs (soit 0,1 ms !), donc le programme sera très peu ralenti même si votre processeur verra grandement la différence (on passe de 100 % du processeur à 3 % du processeur !).</p><p id="r-568213" data-claire-element-id="568213">Nous sommes maintenant prêts à traiter les données. Je vous rappelle donc le code source courant, commenté de nouveau pour une meilleure compréhension :</p><pre id="r-568214" data-claire-element-id="568214"><code data-claire-semantic="html+php">&lt;?php
$questionPosee = -1; // Initialisation de la question posée à -1.

// Boucle principale du programme.
while(1)
{
	$donnees = fgets($socket,1024); // On lit les données du serveur.
	if($donnees) // Si le serveur nous a envoyé quelque chose.
	{
		echo $donnees;
		// Ici on traite ce que nous a envoyé le serveur.
	}
	usleep(100); // On fait « dormir » le programme afin d'économiser l'utilisation du processeur.
}</code></pre><h3 id="r-4-traitement-des-donnees" data-claire-element-id="568253">4. Traitement des données</h3><p id="r-568216" data-claire-element-id="568216">Pour traiter les données, nous allons utiliser des <code data-claire-semantic="html+php">explode() </code>. Je sais qu'il y a d'autres manières de traiter un signal (RegEx, fonctions de traitement) mais je préfère les <em>explode</em> car il donnent un accès rapide aux différentes informations. Nous allons donc scinder les données par espace, vu que pour le protocole IRC, les différentes infos sont séparées par des espaces, exceptés les textes contenant des espaces qui sont placés en fin de commande, après une <strong>double point</strong> « : ».</p><p id="r-568217" data-claire-element-id="568217">Nous allons tout d'abord scinder par espace, puis par un double point « : ».</p><pre id="r-568218" data-claire-element-id="568218"><code data-claire-semantic="html+php">&lt;?php
$commande = explode(' ',$donnees);
$message = explode(':',$donnees);</code></pre><p id="r-568219" data-claire-element-id="568219">Maintenant, on va tester les différentes commandes pouvant être envoyées par le serveur.</p><p id="r-568220" data-claire-element-id="568220">Rappel : la commande originale :linkboss!<a class="__cf_email__" href="http://www.cloudflare.com/email-protection" data-cfemail="3e40525750555c514d4d7e4d48500a0a130f130906130c0c06130f080e130f080e10585c46104e4c51465f5a10505b4a">[email&nbsp;protected]</a><script type="text/javascript">
/* <![CDATA[ */
(function(){try{var s,a,i,j,r,c,l,b=document.getElementsByTagName("script");l=b[b.length-1].previousSibling;a=l.getAttribute('data-cfemail');if(a){s='';r=parseInt(a.substr(0,2),16);for(j=2;a.length-j;j+=2){c=parseInt(a.substr(j,2),16)^r;s+=String.fromCharCode(c);}s=document.createTextNode(s);l.parentNode.replaceChild(s,l);}}catch(e){}})();
/* ]]> */
</script> PRIVMSG #sdz-quiz :!question est maintenant scindée en deux <em>arrays</em> :</p><pre id="r-568221" data-claire-element-id="568221"><code>Array
(
        [0] =&gt; :linkboss!<a class="__cf_email__" href="http://www.cloudflare.com/email-protection" data-cfemail="07796b6e696c656874744774716933332a362a303f2a35353f2a3631372a3631372961657f297775687f666329696273">[email&nbsp;protected]</a><script type="text/javascript">
/* <![CDATA[ */
(function(){try{var s,a,i,j,r,c,l,b=document.getElementsByTagName("script");l=b[b.length-1].previousSibling;a=l.getAttribute('data-cfemail');if(a){s='';r=parseInt(a.substr(0,2),16);for(j=2;a.length-j;j+=2){c=parseInt(a.substr(j,2),16)^r;s+=String.fromCharCode(c);}s=document.createTextNode(s);l.parentNode.replaceChild(s,l);}}catch(e){}})();
/* ]]> */
</script>
        [1] =&gt; PRIVMSG
        [2] =&gt; #quiz-sdz
        [3] =&gt; :!question
)

Array
(
        [0] =&gt;  
        [1] =&gt; linkboss!<a class="__cf_email__" href="http://www.cloudflare.com/email-protection" data-cfemail="453b292c2b2e272a36360536332b7171687468727d6877777d68747375687473756b23273d6b35372a3d24216b2b2031">[email&nbsp;protected]</a><script type="text/javascript">
/* <![CDATA[ */
(function(){try{var s,a,i,j,r,c,l,b=document.getElementsByTagName("script");l=b[b.length-1].previousSibling;a=l.getAttribute('data-cfemail');if(a){s='';r=parseInt(a.substr(0,2),16);for(j=2;a.length-j;j+=2){c=parseInt(a.substr(j,2),16)^r;s+=String.fromCharCode(c);}s=document.createTextNode(s);l.parentNode.replaceChild(s,l);}}catch(e){}})();
/* ]]> */
</script> PRIVMSG #quiz-sdz
        [2] =&gt; !question
)</code></pre><p id="r-568222" data-claire-element-id="568222">Mais avant d'aller plus loin, on va d'abord devoir traiter le cas du <code>PING</code>. En effet, selon la RFC, le serveur nous envoie régulièrement une commande <code>PING</code> afin de vérifier si on ne s'est pas déconnecté en route. Il faudra donc renvoyer un <code>PONG</code> si l'on ne veut pas que notre serveur IRC nous déconnecte comme un rustre. Par contre cette commande différant un peu des autres, il n'y a pas de :linkboss!~link… car c'est le serveur qui l'envoie et donc <code>PING</code> se retrouvera dans <code data-claire-semantic="html+php">$commande[0] </code>.</p><p id="r-568223" data-claire-element-id="568223">Donc nous devrons rajouter une condition dans notre boucle :</p><pre id="r-568224" data-claire-element-id="568224"><code data-claire-semantic="html+php">&lt;?php
if($commande[0] == 'PING')
{
	fputs($socket,&quot;PONG &quot;.$commande[1].&quot;\r\n&quot;);
}</code></pre><p id="r-568225" data-claire-element-id="568225">Maintenant, le <em>bot</em> est vraiment prêt à traiter les commandes sans risquer de se faire déconnecter intempestivement. Je sais que selon la partie précédente, on traitait le <code>PING</code> après les questions, mais je préfère faire le gros en dernier, donc la gestion des questions-réponses, on va faire ça en dernier.</p><p id="r-568226" data-claire-element-id="568226">Nous allons commencer par vérifier si un opérateur ne nous a pas <em>kickés</em> (expulsés) du canal, auquel cas on le rejoint. Pour cela, il suffit de guetter une commande <code>KICK</code> et de vérifier si l'argument du <code>KICK</code> est notre pseudo ou pas. Si ça l'est, c'est qu'on a été kické, et donc on fait une commande <code>JOIN</code>. En réalité, ça ressemble à ça :</p><pre id="r-568227" data-claire-element-id="568227"><code data-claire-semantic="html+php">&lt;?php
if($commande[1] == 'KICK')
{
        if($commande[3] == 'QuizBot')
        {
                fputs($socket,&quot;JOIN #quiz-sdz\r\n&quot;);
        }
}</code></pre><p id="r-568228" data-claire-element-id="568228">Maintenant, nous pouvons traiter les messages.</p><p id="r-568229" data-claire-element-id="568229">Pour commencer, les messages sont envoyés avec la commande <code>PRIVMSG</code>. Il faut donc détecter qu'un client envoie un <code>PRIVMSG</code>. Nous allons donc utiliser le code suivant :</p><pre id="r-568230" data-claire-element-id="568230"><code data-claire-semantic="html+php">&lt;?php
if($commande[1] == 'PRIVMSG')
{
        // Ici, on traite le message.
}
?&gt;</code></pre><p id="r-568231" data-claire-element-id="568231">Maintenant, traitons les commandes. Avec ce <em>bot</em>, les commandes, pour qu'elles soient reconnues, seront préfixées par le caractère « ! ». C'est le caractère le plus utilisé par les <em>bots</em>, donc je ne vais pas « déroger à la règle », même s'il n'y a pas vraiment de règle. Donc tout d'abord, nous allons tester si le premier caractère du message (contenu dans <code data-claire-semantic="html+php">$message[2] </code>) est un « ! ».</p><pre id="r-568232" data-claire-element-id="568232"><code data-claire-semantic="html+php">&lt;?php
if($message[2][0] == '!')
{
        // Maintenant on traite les commandes.
}</code></pre><p id="r-568233" data-claire-element-id="568233">J'ai mis <code data-claire-semantic="html+php">$message[2][0] </code> pour me référer au premier caractère du message.<br/> Ensuite, nous allons traiter les commandes. En fait, ce ne sont pas les commandes qu'on va tester, c'est <strong>la</strong> commande. En effet, il n'y a qu'une commande dans le bot : « !question », qui pose une question. Ensuite, on vérifie si une question est posée, et si oui, on ne fait rien (après, si vous le voulez, vous pourrez mettre un message d'erreur). Après, si aucune question n'est posée, on choisit une question au hasard, dans la liste des questions (<em>via </em>la fonction <code data-claire-semantic="html+php">rand() </code>) puis on la pose (et l'on oublie pas de régler la variable <code data-claire-semantic="html+php">$questionPosee </code>).</p><pre id="r-568234" data-claire-element-id="568234"><code data-claire-semantic="html+php">&lt;?php
if(trim($message[2]) == '!question')
{
        if($questionPosee == -1)
        {
                $questionPosee = rand(0,count($questions)-1);
                fputs($socket,&quot;PRIVMSG #quiz-sdz :Question : &quot;.$questions[$questionPosee][0].&quot;\r\n&quot;);
        }
}</code></pre><p id="r-568235" data-claire-element-id="568235">Maintenant, nous allons faire la partie concernant la vérification de la réponse. Mais attention, cette réponse doit être vérifiée uniquement si une question est posée. En conséquence, nous devons ajouter une condition avant toute chose :</p><pre id="r-568236" data-claire-element-id="568236"><code data-claire-semantic="html+php">&lt;?php
if($questionPosee != -1)
{
        // On vérifie la réponse.
}</code></pre><p id="r-568237" data-claire-element-id="568237">Ensuite, on doit vérifier si la réponse donnée est la bonne, mais en faisant attention à <strong>ne pas</strong> prendre en compte les majuscules et les accents. Pour les majuscules, rien de plus simple, une bête fonction <code data-claire-semantic="html+php">strtolower() </code> qui rendra toute la chaîne entrée par le client en minuscule. Mais pour les accents, il n'existe malheureusement pas de fonction toute faite qui nous élimine tous les accents d'une chaîne. Bon, je suis gentil, je vous donne la fonction toute faite, car nous n'avons pas vraiment à nous concentrer sur ça (mais libre à vous de décortiquer le code). Voici donc le code :</p><pre id="r-568238" data-claire-element-id="568238"><code data-claire-semantic="html+php">&lt;?php
function normaliser($string)
{ 
        $a = 'âäàéèëêîïûüç';
        $b = 'aaaeeeeiiuuc'; 
        $string = utf8_decode($string);     
        $string = strtr($string, utf8_decode($a), $b); 
        $string = strtolower($string); 
        return utf8_encode($string); 
}</code></pre><aside id="r-568240" data-claire-element-id="568240" data-claire-semantic="information"><p id="r-568239" data-claire-element-id="568239">Remarquez que j'ai inclus le <code data-claire-semantic="html+php">strtolower() </code> dans cette fonction. La combinaison des deux (retrait des accents et mise en minuscules) s'appelle la <strong>normalisation</strong>. Il vous suffira de copier-coller cette fonction en début de script, puis de mettre <code data-claire-semantic="html+php">normaliser($variable) </code> pour que la variable perde ses majuscules et ses accents. :) Notez aussi que cette fonction supporte l'UTF-8.</p></aside><aside id="r-568242" data-claire-element-id="568242" data-claire-semantic="information"><p id="r-568241" data-claire-element-id="568241">Dans cette fonction, je n'ai mis que les accents principaux. Pour une version plus complète, voyez sur la page <a href="http://fr3.php.net/manual/fr/function.strtr.php#85556">de documentation PHP de la fonction <code data-claire-semantic="html+php">strtr() </code></a> sur l'une des notes d'utilisateurs.</p></aside><p id="r-568243" data-claire-element-id="568243">Maintenant, nous pouvons vérifier la réponse entrée par le client, et si elle est bonne, afficher un message du genre « Bravo machin ! » puis remettre la variable <code data-claire-semantic="html+php">$questionPosee </code> à -1. Nous obtenons donc le code suivant :</p><pre id="r-568244" data-claire-element-id="568244"><code data-claire-semantic="html+php">&lt;?php
if(normaliser(trim($message[2])) == normaliser(trim($questions[$questionPosee][1])))
{
        $pseudo = explode('!',$commande[0]); // On prend le pseudo de la personne qui a entré la bonne réponse.
        $pseudo = substr($pseudo[0],1); // On enlève le double point au début du pseudo.
        fputs($socket,&quot;PRIVMSG #quiz-sdz :Bravo $pseudo ! La réponse était bien : &quot;.$questions[$questionPosee][1].&quot; !&quot;);
        $questionPosee = -1; // On réinitialise la question.
}</code></pre><p id="r-568245" data-claire-element-id="568245">J'ai rajouté deux lignes de codes juste après la condition, il s'agit du traitement de la ligne pour obtenir le pseudo du client ayant entré la bonne réponse. Si vous lisez les rendus d'<em>explode</em> du message (un peu plus haut dans cette sous-partie) vous verrez facilement comment on obtient le pseudo seul (et en plus vous avez la solution :D ).</p><p id="r-568246" data-claire-element-id="568246">Voilà, c'est tout ! Le <em>bot</em> est fini !<br/> Bon, je récapitule le code source en commentant ce que je n'ai pas commenté.</p><pre id="r-568247" data-claire-element-id="568247"><code data-claire-semantic="html+php">&lt;?php

// Fonction normalisant le test, c'est-à-dire retirant les majuscules et les accents.
function normaliser($string)
{ 
        $a = 'âäàéèëêîïûüç';
        $b = 'aaaeeeeiiuuc'; 
        $string = utf8_decode($string);     
        $string = strtr($string, utf8_decode($a), $b); 
        $string = strtolower($string); 
        return utf8_encode($string); 
}

set_time_limit(0); // On met la durée maximale du script à l'infini.

$file = file_get_contents('questions.txt'); // On lit le fichier des questions dans une chaîne.
$questions = explode(&quot;\n&quot;,$file); // On sépare chaque ligne (\n est le caractère signifiant une nouvelle ligne).

// On sépare la question et la réponse.
for($i=0;isset($questions[$i]);$i++)
	$questions[$i] = explode('&lt;|#()#|&gt;',$questions[$i]);
// On retire le dernier élément si celui-ci est vide (réglage d'un bug relatif aux fichiers).
if($questions[count($questions)-1])
	unset($questions[count($questions)-1]);

$socket = fsockopen('irc.epiknet.org','6667'); // On ouvre la connexion au serveur en tant que pointeur de fichier.

// Vérification de la bonne connexion :
if(!$socket)
{
	// Si on n'a pas réussi, on affiche un message d'erreur et on quitte.
	echo 'Impossible de se connecter';
	exit;
}

// On renseigne l'USER : ici, je mets un peu n'importe quoi, vu que le serveur ne prend en compte que le premier argument (mais qu'il a besoin de 4 arguments).
fputs($socket,&quot;USER QuizBot QuizBot Quiz Quiz\r\n&quot;);
// On donne le NICK :
fputs($socket,&quot;NICK QuizBot\r\n&quot;);

$continuer = 1; // On initialise une variable permettant de savoir si l'on doit continuer la boucle.
while($continuer) // Boucle principale.
{

	$donnees = fgets($socket, 1024); // Le 1024 permet de limiter la quantité de caractères à recevoir du serveur.
	$retour = explode(':',$donnees); // On sépare les différentes données.
	// On regarde si c'est un PING, et, le cas échéant, on envoie notre PONG.
	if(rtrim($retour[0]) == 'PING')
	{
		fputs($socket,'PONG :'.$retour[1]);
		$continuer = 0;
	}
	 if($donnees) // Si le serveur a envoyé des données, on les affiche.
		echo $donnees;
}

fputs($socket,&quot;JOIN #quiz-sdz\r\n&quot;); // On rejoint le canal #quiz-sdz.

$questionPosee = -1; // Initialisation de la question posée à -1.

// Boucle principale du programme :
while(1)
{
	$donnees = fgets($socket,1024); // On lit les données du serveur.
	if($donnees) // Si le serveur nous a envoyé quelque chose.
	{
		echo $donnees;
		$commande = explode(' ',$donnees);
		$message = explode(':',$donnees);
		if($commande[0] == 'PING') // Si c'est un PING, on renvoie un PONG.
		{
			fputs($socket,&quot;PONG &quot;.$commande[1].&quot;\r\n&quot;);
		}
		if($commande[1] == 'KICK') // S’il y a une expulsion du canal.
		{
      if($commande[3] == 'QuizBot') // Si c'est le bot qui est expulsé, on rejoint le canal
			{
				fputs($socket,&quot;JOIN #quiz-sdz\r\n&quot;);
			}
		}
		if($commande[1] == 'PRIVMSG') // Si c'est un message.
		{
      if($message[2][0] == '!') // Si c'est une commande.
			{
       	if(trim($message[2]) == '!question') // Si on demande une question.
				{
      	  if($questionPosee == -1) // Si aucune question n'est posée, on en choisit une au hasard.
        	  $questionPosee = rand(0,count($questions)-1);
          fputs($socket,&quot;PRIVMSG #quiz-sdz :Question : &quot;.$questions[$questionPosee][0].&quot;\r\n&quot;); // On envoie la question courante.
				}
			}
			if($questionPosee != -1) // Si une question est posée (ici on analyse tous les messages).
			{
        if(normaliser(trim($message[2])) == normaliser(trim($questions[$questionPosee][1]))) // Si la réponse est bonne.
				{
      	  $pseudo = explode('!',$commande[0]); // On prend le pseudo de la personne qui a entré la bonne réponse.
      	  $pseudo = substr($pseudo[0],1); // On enlève le double point au début du pseudo.
      	  fputs($socket,&quot;PRIVMSG #quiz-sdz :Bravo $pseudo ! La réponse était bien : &quot;.$questions[$questionPosee][1].&quot; !\r\n&quot;);
      	  $questionPosee = -1; // On réinitialise la question posée.
				}
			}
		}
	}
	usleep(100); // On fait « dormir » le programme afin d'économiser l'utilisation du processeur.
}
// Ça y est, c'est fini. :D</code></pre><p id="r-568248" data-claire-element-id="568248">Maintenant, vous pouvez crâner avec « votre » <em>bot</em>, et vous amuser à poser des questions.</p><p id="r-568249" data-claire-element-id="568249">Pour ceux que ça intéresse, voici le code d'un autre <em>bot</em> de quiz un peu plus évolué, gérant les classements, ainsi que les quiz à plusieurs questions. Globalement, le principe de fonctionnement reste le même, mais il y a quelques variables en plus. Je vous laisse la corvée le plaisir de l'étudier tout seul.</p><p id="r-568250" data-claire-element-id="568250"></p><div id="r-568252" data-claire-element-id="568252"><pre id="r-568251" data-claire-element-id="568251"><code data-claire-semantic="html+php">&lt;?php
set_time_limit(0);
$server='irc.quakenet.org';
$port='6667';
$name='QuizdeBot';
$user='QuizdeBot';
$chan = '#LeelaBot';
$operators = array();
$voice = array();
$users_online = array();
$admins = array('linkboss');

$socket = fsockopen( $server , $port , $errno, $errstr, 1); // Connexion au serveur.


if (!$socket) exit(); // Si la connexion n'a pas eu lieu, on arrête le script (exit()).
 fputs($socket , &quot;USER $name $chan $user .\r\n&quot; );

 fputs($socket , &quot;NICK $name\r\n&quot; ); // Pseudo du bot.
  
 stream_set_timeout($socket, 0);

 $continuer = 1;
 
/********************************************/
while($continuer) // Boucle pour la connexion.
{

	$donnees = fgets($socket, 1024);
	$retour = explode(':',$donnees);
	if(rtrim($retour[0]) == 'PING')
		fputs($socket,'PONG :'.$retour[1]);
	 if($donnees)
		echo $donnees;

	if(preg_match('#:(.+):End Of /MOTD Command.#i',$donnees))
		$continuer = 0;
}
fputs($socket , &quot;JOIN $chan\r\n&quot; );


$file = file_get_contents('questions.txt'); // On lit le fichier des questions dans une chaîne.
$questions = explode(&quot;\n&quot;,$file); // On sépare chaque ligne (\n est le caractère signifiant une nouvelle ligne).

// On sépare la question et la réponse :
for($i=0;isset($questions[$i]);$i++)
	$questions[$i] = explode(' \ ',$questions[$i]);

shuffle($questions);
$i = 0;
$newquestions = array();
foreach($questions as $question)
{
	$newquestions[$i] = $question;
	$i++;
}
$questions = $newquestions;
array_pop($questions);

print_r($questions);
$continuer = 1;
$quiz = 0;
$questionEnCours = -1;
while($continuer)
{
	$donnees = fgets($socket, 1024);
	if($donnees)
	{
		$array = explode(':',$donnees);
		$msg=$array[2];
		$pseudo= explode('!',$array[1]);
		$pseudo = $pseudo[0];
		$infos = explode(' ',$array[1]);
		$chan = $infos[2];
		$cmd = explode(' ',$array[2]);
		if(rtrim($array[0]) == 'PING')
		{
			fputs($socket,'PONG :'.$array[1]);
			echo $donnees;
		}
		elseif(rtrim($infos[1]) == 'PRIVMSG')
		{
			print_r($cmd);
			if(rtrim($cmd[0]) == '.quiz')
			{
				if($quiz == 0)
				{
					$quiz = 1;
					$questionEnCours = 0;
					$questionPosee = 0;
					$highscore = array();
					$questionTime = time()+15;
					fputs($socket,&quot;PRIVMSG $chan :Un quiz a été lancé ! Tentez de répondre aux questions pour être le meilleur !\r\n&quot;);
					fputs($socket,&quot;PRIVMSG $chan :Vous disposez de 30 secondes pour répondre. Au total 100 questions\r\n&quot;);
					fputs($socket,&quot;PRIVMSG $chan :Utilisez un espace pour séparer les milliers des nombres. Accents obligatoires.\r\n&quot;);
					fputs($socket,&quot;PRIVMSG $chan :Départ dans 15 secondes...\r\n&quot;);
				}
				else
					fputs($socket,&quot;NOTICE $pseudo :Un quiz est déjà lancé -_-\r\n&quot;);
					
				
			}
			if(rtrim($cmd[0]) == '.question')
			{
				if($questionPosee == 1)
				{
					fputs($socket,&quot;NOTICE $pseudo :Question $questionNombre : &quot;.$questions[$questionEnCours][0].&quot;\r\n&quot;);
				}
				else
				{
					fputs($socket,&quot;NOTICE $pseudo :Il n'y a aucune question posée...\r\n&quot;);
				}
			}
			if(rtrim($cmd[0]) == '.classement')
			{
				if($quiz == 1)
				{
					$classement = '';
					arsort($highscore);
					$nicks = array_keys($highscore);
					$i = 0;
					for($i = 0;$i &lt; count($highscore);$i++)
					{
						$place = $i+1;
						$classement .= &quot;$place. &quot;.$nicks[$i].&quot; (&quot;.$highscore[$nicks[$i]].&quot;) &quot;;
					}
					fputs($socket,&quot;NOTICE $pseudo :Classement : $classement\r\n&quot;);
				}
				else
				{
					fputs($socket,&quot;NOTICE $pseudo :Il n'y a aucun quiz de lancé...\r\n&quot;);
				}
			}
			if(rtrim($cmd[0]) == '.stopquiz' &amp;&amp; in_array($pseudo,$admins))
			{
				fputs($socket,&quot;PRIVMSG $chan :Le quiz est terminé ! Classement : \r\n&quot;);
				$classement = '';
				arsort($highscore);
				$nicks = array_keys($highscore);
				print_r($nicks);
				print_r($highscore);
				$i = 0;
				for($i = 0;$i &lt; count($highscore);$i++)
				{
					$place = $i+1;
					$classement .= &quot;$place. &quot;.$nicks[$i].&quot; (&quot;.$highscore[$nicks[$i]].&quot;) &quot;;
				}
				fputs($socket,&quot;PRIVMSG $chan :$classement\r\n&quot;);
				$quiz = 0;
			}
			
			if(rtrim($cmd[0]) == '.help')
			{
				fputs($socket,&quot;NOTICE $pseudo :Liste des commandes : .quiz (pour lancer un quiz), .classement (pour voir le classement actuel), .question (pour réafficher la question courante), .help (affiche cette aide).\r\n&quot;);
			}
			elseif($questionPosee == 1 &amp;&amp; time &lt;= $questionTime &amp;&amp; strtolower(rtrim(join(' ', $cmd))) == strtolower($questions[$questionEnCours][1]))
			{
				fputs($socket,&quot;PRIVMSG $chan :Bravo $pseudo ! La réponse était bien : &quot;.$questions[$questionEnCours][1].&quot;.\r\n&quot;);
				$questionPosee = 0;
				if($highscore[$pseudo])
					$highscore[$pseudo]++;
				else
					$highscore[$pseudo] = 1;
				print_r($highscore);
				$questionTime = time()+15;
				$questionEnCours++;
				if(count($questions) &gt; $questionEnCours || $questionEnCours &gt; 99)
					fputs($socket,&quot;PRIVMSG $chan :Prochaine question dans 15 secondes...\r\n&quot;);
			}
		}
	}
	if($quiz == 1)
				{
					if($questionPosee == 0 &amp;&amp; time() &gt;= $questionTime)
					{
						$questionNombre = $questionEnCours+1;
						fputs($socket,&quot;PRIVMSG $chan :Question $questionNombre : &quot;.$questions[$questionEnCours][0].&quot;\r\n&quot;);
						$questionPosee = 1;
						$questionTime = time()+30;
					}
					
					if($questionEnCours &gt;= count($questions) || $questionEnCours &gt; 99)
					{
						fputs($socket,&quot;PRIVMSG $chan :Le quiz est terminé ! Classement : \r\n&quot;);
						$classement = '';
						arsort($highscore);
						$nicks = array_keys($highscore);
						print_r($nicks);
						print_r($highscore);
						$i = 0;
						for($i = 0;$i &lt; count($highscore);$i++)
						{
							$place = $i+1;
							$classement .= &quot;$place. &quot;.$nicks[$i].&quot; (&quot;.$highscore[$nicks[$i]].&quot;) &quot;;
						}
						fputs($socket,&quot;PRIVMSG $chan :$classement\r\n&quot;);
						$quiz = 0;
					}
					if($questionPosee == 1 &amp;&amp; time() &gt; $questionTime)
					{
						fputs($socket,&quot;PRIVMSG $chan :Le temps est écoulé ! la bonne réponse était : &quot;.$questions[$questionEnCours][1].&quot;\r\n&quot;);
						$questionTime = time()+15;
						$questionPosee = 0;
						$questionEnCours++;
						$unanswered++;
						if(count($questions) &gt; $questionEnCours)
						fputs($socket,&quot;PRIVMSG $chan :Prochaine question dans 15 secondes...\r\n&quot;);
					}
				}
				usleep(100);
}</code></pre></div>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php">Utiliser le protocole IRC avec PHP</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/irc-kezako">
IRC, kézako ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/construction-theorique-du-programme">
Construction théorique du programme
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/pratique-codage">
Pratique — Codage
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/petit-recapitulatif-1">
Petit récapitulatif
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/construction-theorique-du-programme">
<span class="arrow"></span>
<span class="next">Construction théorique du programme</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/petit-recapitulatif-1">
<span class="next">Petit récapitulatif</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Petitrcapitulatif"></a><h2>Petit récapitulatif</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/pratique-codage">
<span class="arrow"></span>
<span class="next">Pratique — Codage</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-568256" data-claire-element-id="568256">Petit récapitulatif de tout ce qui a été vu sur le protocole IRC dans ce chapitre :</p><ul id="r-568269" data-claire-element-id="568269"><li id="r-568258" data-claire-element-id="568258"><p id="r-568257" data-claire-element-id="568257">pour ouvrir une connexion avec un serveur IRC, on utilise (la plupart du temps) <code data-claire-semantic="html+php">fsockopen() </code> sur le port 6667 d'un serveur IRC ;</p></li><li id="r-568260" data-claire-element-id="568260"><p id="r-568259" data-claire-element-id="568259">pour mettre son pseudo, il suffit d'utiliser la commande <code>NICK &lt;pseudo&gt;</code> ;</p></li><li id="r-568262" data-claire-element-id="568262"><p id="r-568261" data-claire-element-id="568261">pour régler votre <em>user</em>, on utilise la commande <code>USER &lt;user&gt; &lt;user&gt; &lt;user&gt; &lt;user&gt;</code> (mettre 4 fois le même paramètre marche, mais uniquement le premier est pris en compte) ;</p></li><li id="r-568264" data-claire-element-id="568264"><p id="r-568263" data-claire-element-id="568263">quand le serveur nous envoie un <code>PING &lt;quelque_chose&gt;</code>, lui répondre par <code>PONG &lt;la_chose_envoyee&gt;</code> ;</p></li><li id="r-568266" data-claire-element-id="568266"><p id="r-568265" data-claire-element-id="568265">pour envoyer un message, utiliser la commande <code>PRIVMSG &lt;canal/pseudo&gt; :&lt;message&gt;</code> ;</p></li><li id="r-568268" data-claire-element-id="568268"><p id="r-568267" data-claire-element-id="568267"><strong>ne pas oublier</strong> de mettre <code data-claire-semantic="html+php"></code> à la fin des commandes.</p></li></ul><p id="r-568270" data-claire-element-id="568270">Et puis quelques trucs en plus que nous n'avons pas vus dans ce tutoriel :</p><ul id="r-568287" data-claire-element-id="568287"><li id="r-568272" data-claire-element-id="568272"><p id="r-568271" data-claire-element-id="568271">pour envoyer un message en privé à quelqu'un, vous pouvez utiliser (et privilégier) la commande <code>NOTICE &lt;pseudo&gt; :&lt;message&gt;</code> au lieu du <code>PRIVMSG</code> ;</p></li><li id="r-568274" data-claire-element-id="568274"><p id="r-568273" data-claire-element-id="568273">pour quitter un canal, vous pouvez utiliser la commande <code>PART &lt;canal&gt; : &lt;raison&gt;</code>. Notez que la raison est optionnelle (si vous n'en mettez pas, ne mettez pas de double point) ;</p></li><li id="r-568276" data-claire-element-id="568276"><p id="r-568275" data-claire-element-id="568275">pour vous déconnecter d'un serveur, utilisez la commande <code>QUIT</code> ;</p></li><li id="r-568278" data-claire-element-id="568278"><p id="r-568277" data-claire-element-id="568277">pour joindre plusieurs canaux, utilisez la commande <code>JOIN &lt;canal&gt;</code> autant de fois que c'est nécessaire ;</p></li><li id="r-568280" data-claire-element-id="568280"><p id="r-568279" data-claire-element-id="568279">pour changer de pseudo, il suffit d'utiliser la commande <code>NICK</code> une seconde fois ;</p></li><li id="r-568282" data-claire-element-id="568282"><p id="r-568281" data-claire-element-id="568281">pour obtenir la liste des clients dans un canal, utilisez la commande <code>NAMES &lt;canal&gt;</code> ;</p></li><li id="r-568284" data-claire-element-id="568284"><p id="r-568283" data-claire-element-id="568283">pour expulser quelqu'un d'un canal, utilisez la commande <code>KICK &lt;canal&gt; &lt;pseudo&gt; : &lt;raison&gt;</code>. Ici aussi, la raison est facultative (n'oubliez pas d'enlever le double point).</p></li><li id="r-568286" data-claire-element-id="568286"><p id="r-568285" data-claire-element-id="568285">pour tous les autres détails relatifs à IRC, référez-vous à la RFC 1459 et à la RFC 2812 (Google est votre ami).</p></li></ul><p id="r-568288" data-claire-element-id="568288">Voilà, maintenant, vous savez utiliser IRC avec PHP. Les applications possibles sont nombreuses (<em>bots</em>, clients, serveurs…), alors programmez bien. ;)</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php">Utiliser le protocole IRC avec PHP</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/irc-kezako">
IRC, kézako ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/construction-theorique-du-programme">
Construction théorique du programme
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/pratique-codage">
Pratique — Codage
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/petit-recapitulatif-1">
Petit récapitulatif
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/utiliser-le-protocole-irc-avec-php/pratique-codage">
<span class="arrow"></span>
<span class="next">Pratique — Codage</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/utiliser-le-protocole-irc-avec-php.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 11:22:19 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/utiliser-le-protocole-irc-avec-php.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:49:51 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/les-variables-leur-vrai-visage.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 06:50:45 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-variables-leur-vrai-visage.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:14:35 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Les variables : leur vrai visage</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/les-variables-leur-vrai-visage.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Les variables : leur vrai visage</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Lesvariablesleurvraivisage">Les variables : leur vrai visage</a><br/><a href="#Rappels">Rappels</a><br/><a href="#Lammoireuneaffairedebytes">La mémoire une affaire de bytes</a><br/><a href="#S039assemblerpourmieuxrgner">S&#039;assembler pour mieux régner</a><br/><a href="#Variablesetnombresrelatifs">Variables et nombres relatifs</a><br/><a href="#Variablesetnombresrels">Variables et nombres réels</a><br/></div>
<a name="Lesvariablesleurvraivisage"></a><h2>Les variables : leur vrai visage</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/rappels-12">
<span class="next">Rappels</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-740973" data-claire-element-id="740973">Ce tutoriel n'est que purement théorique, mais vous allez voir que c'est un sujet vraiment intéressant lorsqu'on programme.</p><div id="r-740975" data-claire-element-id="740975" data-claire-semantic="question"><p id="r-740974" data-claire-element-id="740974">Tu veux en venir où au juste ?</p></div><p id="r-740976" data-claire-element-id="740976">Nous allons voir comment votre ordinateur stocke et gère les variables à l'intérieur de la mémoire vive. Pourquoi ? Parce qu'un programmeur qui sait ce qu'il fait en vaut deux ! <br/> Pour mes exemples, j'utiliserai le C / C++ mais ce qui va suivre est valable quel que soit le langage dans lequel vous programmez...</p>
</div><a name="Rappels"></a><h2>Rappels</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/la-memoire-une-affaire-de-bytes">
<span class="next">La mémoire une affaire de bytes</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-740977" data-claire-element-id="740977">Attention, pour comprendre ce qui va suivre, vous devez impérativement avoir lu et compris les cours de M@teo sur la mémoire (avec les schémas...).<br/> Bon, pour ceux qui auraient des trous de mémoire (ho ho, je ne l'ai même pas fait exprès :p !), je vais faire quelques petits rappels afin que vous soyez tous au point...<br/> D'abord, je vous rappelle qu'il existe différents types de mémoire sur un ordinateur classique (dans 99 % des cas quoi).</p><p id="r-740978" data-claire-element-id="740978">1. Les registres : une mémoire ultrarapide située directement dans le processeur. <br/> 2. La mémoire cache : elle fait le lien entre les registres et la mémoire vive. <br/> 3. La mémoire vive : c'est la mémoire avec laquelle nous allons travailler le plus souvent. <br/> 4. Le disque dur : que vous connaissez sûrement, c'est là qu'on enregistre les fichiers.</p><p id="r-740979" data-claire-element-id="740979">Nous, nous n'allons nous occuper uniquement de la mémoire vive. Mais ne vous inquiétez pas, il y a de quoi faire, et les autres mémoires fonctionnent toutes sur le même principe.</p><p id="r-740980" data-claire-element-id="740980">Pour voir comment fonctionne la mémoire vive (RAM), reprenons les petits schémas de M@teo :</p><figure id="r-740982" data-claire-element-id="740983"><img id="r-740981" data-claire-element-id="740981" src="../../user.oc-static.com/files/7001_8000/7210.png" alt="Image utilisateur"/></figure><p id="r-740984" data-claire-element-id="740984">Vous voyez donc que la RAM se découpe en deux parties :</p><p id="r-740985" data-claire-element-id="740985">- il y a les adresses : une adresse est un nombre qui permet à l'ordinateur de se repérer dans la mémoire vive. On commence à l'adresse 0 (au tout début de la mémoire) et on finit à l'adresse 3 448 765 900 126 et des poussières... Le nombre d'adresses dépend de la taille de votre RAM ;<br/> - à chaque adresse, on peut stocker une valeur (un nombre) : votre ordinateur stocke dans la mémoire vive ces nombres pour pouvoir s'en souvenir par la suite. On ne peut stocker qu'un nombre par adresse !</p><p id="r-740986" data-claire-element-id="740986">Moi, je vais employer le mot « case mémoire » pour désigner ET l'adresse mémoire ET la valeur correspondant à cette adresse. <br/> Un exemple : la première case mémoire ayant pour adresse 0 contient la valeur...145.</p><figure id="r-740988" data-claire-element-id="740989"><img id="r-740987" data-claire-element-id="740987" src="medias/uploads.siteduzero.com_files_40001_41000_40892.jpg" alt="Image utilisateur"/></figure><p id="r-740990" data-claire-element-id="740990">La taille de votre mémoire vive dépend donc du nombre de cases mémoire qu'elle contient. Évidemment, plus il y aura de cases mémoire plus votre mémoire pourra stocker de valeurs, de nombres (donc plus elle sera volumineuse ;) ).<br/> À noter qu'une case mémoire peut aussi être désignée par le mot « byte » (« octet » en français).</p><p id="r-740991" data-claire-element-id="740991">Ainsi, vous voyez comment la RAM peut stocker que des nombres.</p><div id="r-740993" data-claire-element-id="740993" data-claire-semantic="question"><p id="r-740992" data-claire-element-id="740992">Bon, pour les nombres, OK, mais pour les caractères, comment ça se passe ?</p></div><p id="r-740994" data-claire-element-id="740994">Mettez-vous bien ça dans le crâne : pour votre ordinateur, une lettre c'est un nombre !<br/> En effet, il existe des codages qui ont pour fonction d'associer un numéro à chaque lettre. Le premier codage est l'<a href="http://fr.wikipedia.org/wiki/ASCII">ASCII</a> (<em>American Standard Code for Information Interchange</em>). Ce codage étant très incomplet (du fait qu'il ne reprenait que les caractères de base comme l'alphabet de <em>A</em> à <em>Z</em> et de <em>a</em> à <em> z</em>, les nombre de 0 à 9 ainsi que les caractères comme les parenthèses, virgules...), un autre codage, l'<a href="http://fr.wikipedia.org/wiki/ISO_8859-1">ISO_8859-1</a> a été mis au point. Ce dernier reprend le codage ASCII en ajoutant des caractères spéciaux (é, à, è, î, ï, ù...). Enfin, je citerais encore, l'<a href="http://fr.wikipedia.org/wiki/UTF-8">UTF-8</a> qui rajoute encore d'autres caractères spéciaux, ou encore l'Unicode... Bon, il existe bien évidemment d'autres codages mais je ne vais pas tous les citer, car on s'éloigne de notre sujet...<br/> D'ailleurs, ce n'est pas la peine de les retenir, retenez juste que l'on associe un numéro à chaque lettre à l'aide de codages spécifiques, ça sera largement suffisant !</p><p id="r-740995" data-claire-element-id="740995">Voilà pour ces quelques rappels, j'espère que tout cela est clair pour vous, car la suite découle directement de ces principes de base. ;)</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage">Les variables : leur vrai visage</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/rappels-12">
Rappels
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/la-memoire-une-affaire-de-bytes">
La mémoire une affaire de bytes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/s-assembler-pour-mieux-regner">
S&#039;assembler pour mieux régner
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-relatifs">
Variables et nombres relatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-reels">
Variables et nombres réels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/la-memoire-une-affaire-de-bytes">
<span class="next">La mémoire une affaire de bytes</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lammoireuneaffairedebytes"></a><h2>La mémoire une affaire de bytes</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/rappels-12">
<span class="arrow"></span>
<span class="next">Rappels</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/s-assembler-pour-mieux-regner">
<span class="next">S&#039;assembler pour mieux régner</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-740997" data-claire-element-id="740997">Bon, maintenant que nous avons le principe de base de la mémoire RAM d'un ordinateur, nous allons voir ça plus en détail...<br/> Vous vous souvenez des fameuses cases mémoire (<em>bytes</em>) dont je vous avais parlées. :-° <br/> Eh bien, nous allons « zoomer » dessus. :magicien:</p><p id="r-740998" data-claire-element-id="740998">Une case mémoire, sur un ordinateur correspond (dans 99 % des cas) à un octet.</p><div id="r-741000" data-claire-element-id="741000" data-claire-semantic="question"><p id="r-740999" data-claire-element-id="740999">Un octet... :euh:</p></div><p id="r-741001" data-claire-element-id="741001">Le mot octet signifie huit (comme octobre ^^ ). Oui, mais huit quoi ? Eh bien huit bits !<br/> Oulah un nouveau mot ! Ne vous affolez pas ! Vous allez voir, c'est très simple ! Le mot bit vient de l'anglais <em>binairy digit</em>.<br/> Un bit est une « entité », un « chiffre » pouvant valoir 0 (le bit est négatif) ou 1 (le bit est positif).<br/> Bien, retournons à nos octets, ils contiennent huit bits, c'est-à-dire une séquence de 8 chiffres compris entre 0 et 1 ! Je crois qu'un petit schéma s'impose. Voici à quoi ressemble une case mémoire (qui contient huit bits) :</p><figure id="r-741003" data-claire-element-id="741004"><img id="r-741002" data-claire-element-id="741002" src="medias/uploads.siteduzero.com_files_40001_41000_40894.jpg" alt="Image utilisateur"/></figure><p id="r-741005" data-claire-element-id="741005">Comme vous le voyez, chaque case mémoire contient un octet c'est-à-dire huit bits, trop facile non ? :p</p><div id="r-741007" data-claire-element-id="741007" data-claire-semantic="question"><p id="r-741006" data-claire-element-id="741006">Mais, dans ce cas, l'ordinateur ne peut stocker que des 0 et des 1, pas d'autres chiffres ! :o</p></div><p id="r-741008" data-claire-element-id="741008">Exact, l'ordinateur n'utilise que des zéros et des uns, c'est ce qu'on appelle la base binaire. Il n'y a pas « d'autres nombres ». Bon, je crois que tout ceci mérite plus amples explications...<br/> Nous, nous utilisons le système décimal, basé sur dix chiffres, de 0 à 9. Eh bien l'ordinateur utilise un système binaire, basé sur deux chiffres, de 0 à 1. Pour pouvoir stocker, par exemple le nombre (décimal) 145, l'ordinateur le traduit en binaire, ce qui donne : 10010001. Dites-vous bien que 145 en décimal c'est EXACTEMENT la même chose que d'écrire 10010001 en binaire ! Ainsi, avec ses 0 et ses 1, l'ordinateur peut stocker tous les nombres qu'il veut (enfin que l'ON veut) ! Reprenons notre petit schéma :</p><figure id="r-741010" data-claire-element-id="741011"><img id="r-741009" data-claire-element-id="741009" src="medias/uploads.siteduzero.com_files_40001_41000_40895.jpg" alt="Image utilisateur"/></figure><p id="r-741012" data-claire-element-id="741012">Voici comment serait stocké le nombre 145 dans la mémoire RAM de votre ordinateur.</p><p id="r-741013" data-claire-element-id="741013">Et que vaudrait le nombre binaire 11111111 en décimal ? <br/> À vos calculatrices...<br/> Réponse : 255.<br/> Donc, une série de huit 1 à la suite donne 255 en décimal.<br/> Je vais vous demander de reprendre vos calculatrices et de taper 2^8.<br/> Réponse : 256.<br/> Et 256 - 1 : 255 (sans calculette ça :p ) !<br/> Eh bien, figurez-vous que ce n'est pas un hasard. Nous découvrons là qu'avec n bits, on peut stocker 2^n nombres compris entre 0 et 2^n - 1.</p><div id="r-741015" data-claire-element-id="741015" data-claire-semantic="question"><p id="r-741014" data-claire-element-id="741014">Comment fais-tu ça ? :o</p></div><p id="r-741016" data-claire-element-id="741016">C'est très simple !<br/> Avec deux chiffres compris entre 0 et 1, je peux obtenir 2^2 soit 4 combinaisons différentes :</p><p id="r-741017" data-claire-element-id="741017">00 -&gt; 0<br/> 01 -&gt; 1<br/> 10 -&gt; 2<br/> 11 -&gt; 3</p><p id="r-741018" data-claire-element-id="741018">Sur le même principe, avec 8 chiffres compris entre 0 et 1, je peux obtenir 2^8 soit 256 combinaisons différentes ! Ces « combinaisons » sont aussi appelées états.<br/> D'ailleurs, si vous voulez tester tous ces états en détail, <a href="http://pierre.dalbianco.free.fr/octet.html">rendez-vous sur ce lien</a>, vous pourrez d'ailleurs y voir l'algorithme de base permettant la conversion binaire &gt; décimal, en consultant la source de la page (comme il s'agit d'une page Web, l'algorithme est en JavaScript, mais le principe reste le même pour le C...).</p><p id="r-741019" data-claire-element-id="741019"><em>J'attire votre attention sur le fait que mes schémas ne montrent que la valeur de la variable. J'ai donc volontairement laissé l'adresse des variables de côté pour ne pas vous embrouiller avec tous ces nombres mais rassurez-vous, chaque variable a effectivement une adresse.</em></p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage">Les variables : leur vrai visage</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/rappels-12">
Rappels
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/la-memoire-une-affaire-de-bytes">
La mémoire une affaire de bytes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/s-assembler-pour-mieux-regner">
S&#039;assembler pour mieux régner
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-relatifs">
Variables et nombres relatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-reels">
Variables et nombres réels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/rappels-12">
<span class="arrow"></span>
<span class="next">Rappels</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/s-assembler-pour-mieux-regner">
<span class="next">S&#039;assembler pour mieux régner</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="S039assemblerpourmieuxrgner"></a><h2>S&#039;assembler pour mieux régner</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/la-memoire-une-affaire-de-bytes">
<span class="arrow"></span>
<span class="next">La mémoire une affaire de bytes</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-relatifs">
<span class="next">Variables et nombres relatifs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-741021" data-claire-element-id="741021">Dans la partie précédente, nous avons vu comment, à partir d'un octet, nous pouvions obtenir 256 chiffres différents. Mais en général, nous ne nous limitons pas au nombre 255 (l'équivalent d'un <em><strong>unsigned char</strong></em> en C). Alors, comment faire pour stocker des nombres plus grands ? La réponse, je pense que vous l'aurez devinée, est d'assembler les <em>bytes</em> pour former de plus grands nombres. Alors la question qui se pose maintenant, c'est comment « assembler », « réunir » plusieurs <em>bytes</em> ?<br/> Rien de plus simple, il suffit que ces <em>bytes</em> soient les uns à la suite des autres, l'ordinateur n'aura plus qu'à lire le nombre produit d'un seul tenant :</p><figure id="r-741023" data-claire-element-id="741024"><img id="r-741022" data-claire-element-id="741022" src="medias/uploads.siteduzero.com_files_40001_41000_40895.jpg" alt="Image utilisateur"/></figure><figure id="r-741026" data-claire-element-id="741027"><img id="r-741025" data-claire-element-id="741025" src="medias/uploads.siteduzero.com_files_40001_41000_40894.jpg" alt="Image utilisateur"/></figure><p id="r-741028" data-claire-element-id="741028">Voici par exemple le nombre (décimal) 37120, tel qu'il serait stocké dans la mémoire RAM de votre ordinateur... Vous constaterez que les <em>bytes</em> ainsi réunis doivent impérativement se suivre, puis on lit le nombre de haut en bas, comme suit : 1001000100000000.<br/> Vous pouvez, sur le même modèle faire suivre 2 (<em><strong>unsigned short</strong></em>, nombre compris entre 0 et 2^(8*2)), 4 <em>bytes</em> (<strong>unsigned long</strong>, compris entre 0 et 2^(8*4))...<br/> Voici un tableau, présentant les principaux types d'entiers en C / C++ avec le nombre de <em>bytes</em> nécessaire, pour un système travaillant avec des regroupements de 8 bits, donc avec des octets, en <strong>règle générale</strong> :</p><p id="r-741029" data-claire-element-id="741029"><strong>bool</strong> &gt; 1 octet &gt; true ou false ;<br/><strong>unsigned char</strong> &gt; 1 octet &gt; de 0 à 255 ;<br/><strong>unsigned wchar_t</strong> &gt; 2 octets &gt; de 0 à 65 535 ;<br/><strong>unsigned short</strong> &gt; 2 octets &gt; de 0 à 65 535 ;<br/><strong>unsigned int</strong> &gt; 4 octets &gt; de 0 à 4 294 967 295 ;<br/><strong>unsigned long</strong> &gt; 4 octets &gt; de 0 à 4 294 967 295.</p><div id="r-741031" data-claire-element-id="741031" data-claire-semantic="question"><p id="r-741030" data-claire-element-id="741030">Comment sais-tu ça ?</p></div><p id="r-741032" data-claire-element-id="741032">Rien de plus simple, il existe une fonction en C permettant de retourner la taille occupée par une variable, il s'agit de la fonction <em><strong>sizeof(variable)</strong></em>. Ainsi, vous pouvez vous-mêmes tester la taille occupée par chacun des types des variables en C / C++. ;) <br/> D'ailleurs, la taille des variables pouvant changer (surtout pour les <em><strong>int</strong></em>) selon l'ordinateur et / ou le compilateur que vous utilisez, je vous invite à vérifier par vous-mêmes la taille occupée par chaque type, à l'aide de la fonction <em><strong>sizeof()</strong></em>.</p><div id="r-741034" data-claire-element-id="741034" data-claire-semantic="question"><p id="r-741033" data-claire-element-id="741033">OK pour les valeurs mais, une variable possède une adresse non...</p></div><p id="r-741035" data-claire-element-id="741035">Bien sûr, jusqu'à maintenant, j'ai laissé les adresses mémoire de côté pour ne pas trop vous embrouiller, mais cette adresse existe bien, elle permet d'ailleurs à l'ordinateur où chercher ses variables lorsqu'il en a besoin. <br/> C'est d'ailleurs pour cela qu'un <em>byte</em> ne peut pas être « cassé » en plusieurs <em>bytes</em> ; en effet, il ne peut pas y avoir plusieurs chiffres à la même adresse !</p><aside id="r-741037" data-claire-element-id="741037" data-claire-semantic="warning"><p id="r-741036" data-claire-element-id="741036">- Lorsqu'une variable occupe plusieurs <em>bytes</em>, (lorsqu'il s'agit, par exemple d'un <em><strong>int</strong></em>), l'adresse désignant la variable est la première du groupe de <em>bytes</em> en partant du haut.<br/> - Ne pas confondre ces variables qui occupent plus d'une case mémoire avec les tableaux ! En effet, lorsqu'il s'agit d'un tableau, les <em>bytes</em> sont aussi les uns à la suite des autres mais l'ordinateur les lit comme UNE SUITE DE PLUSIEURS NOMBRES. Alors que dans le cas d'un <em><strong>long</strong></em> (ou d'un <em><strong>short</strong></em>, ou d'un <em><strong>int</strong></em>...), l'ordinateur lira ce groupe de <em>bytes</em> comme UN SEUL ET UNIQUE NOMBRE !</p></aside>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage">Les variables : leur vrai visage</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/rappels-12">
Rappels
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/la-memoire-une-affaire-de-bytes">
La mémoire une affaire de bytes
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/s-assembler-pour-mieux-regner">
S&#039;assembler pour mieux régner
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-relatifs">
Variables et nombres relatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-reels">
Variables et nombres réels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/la-memoire-une-affaire-de-bytes">
<span class="arrow"></span>
<span class="next">La mémoire une affaire de bytes</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-relatifs">
<span class="next">Variables et nombres relatifs</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Variablesetnombresrelatifs"></a><h2>Variables et nombres relatifs</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/s-assembler-pour-mieux-regner">
<span class="arrow"></span>
<span class="next">S&#039;assembler pour mieux régner</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-reels">
<span class="next">Variables et nombres réels</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-741039" data-claire-element-id="741039">Jusqu'à maintenant, nous n'avons vu le fonctionnement de la RAM qu'avec des nombres entiers et positifs (non signés). Mais un ordinateur sait aussi stocker et gérer des nombres négatifs. Mais comment fait-il ?<br/> Eh bien l'ordinateur utilise tout simplement une ruse, une sorte de moyen mnémotechnique pour stocker ce genre de nombres. Mais d'abord, comment sait-il qu'un nombre est relatif ? C'est très simple, on utilise les préfixes <em><strong>signed</strong></em> (facultatif) ou <em><strong>unsigned</strong></em>. Donc, l'ordinateur sait qu'il a affaire à un relatif (positif ou négatif) grâce à la déclaration des variables. Mais cela ne nous dit pas comment il sait qu'un nombre possède une virgule à tel endroit ou que tel autre nombre est négatif.</p><p id="r-741040" data-claire-element-id="741040">Avant de rentrer dans des explications barbares, j'aimerais que vous soyez tous au point sur ce qu'est le <strong>poids des bits</strong>. Rassurez-vous, ça n'a rien d'extrêmement compliqué. En fait, le bit de poids fort est le bit situé à l'extrême gauche du nombre binaire, et le bit de poids faible est le bit le plus à droite (toute connotation politique est totalement fortuite :p ). D'une manière générale, le poids du bit correspond à sa place dans le nombre. Ainsi le bit de poids 0 est le premier bit, celui de poids 1 est le second et ainsi de suite... Bon, un exemple pour être au point : <em>bit de poids fort -&gt;</em><strong>10010101</strong><em>&lt;- bit de poids faible (de poids 0)</em>. Le bit de poids 1 vaut 0, celui de poids 2 vaut 1...</p><p id="r-741041" data-claire-element-id="741041">Bien, maintenant que ce principe est acquis, voyons comment sont stockés :</p><p id="r-741042" data-claire-element-id="741042"><strong>- des nombres signés positions ou nuls :</strong><br/> Ces nombres seront stockés comme un entier positif à la seule différence que le bit de poids fort doit valoir 0. Ainsi, d'une manière générale le plus grand entier relatif positif codé sur n bits sera 2^(n - 1) -1.</p><p id="r-741043" data-claire-element-id="741043"><strong>- des nombres signés négatifs :</strong><br/> pour ces nombres-là, on se sert de la technique du <em>complément à deux</em>, dont voici le principe : <br/> 1. on prend l'opposé du nombre à stocker (rappel : l'opposé d'un nombre négatif est un nombre positif) ;<br/> 2. on le représente en binaire sur n - 1 bits : donc sur 7 bits s'il s'agit d'un octet (comme on le fait pour les nombres signés positifs ou nuls) ;<br/> 3. on complémente chaque bit (on inverse tous les 0 et les 1) ;<br/> 4. on ajoute 1.</p><p id="r-741044" data-claire-element-id="741044">Un exemple : prenons le nombre -9, et voyons comment il serait stocké sur un octet.<br/> 1. On prend l'opposé de -9, c'est-à-dire 9.<br/> 9 en binaire s'écrit : 1001.<br/> 2. On le représente sur n - 1 bits : (0)0001001. <br/> 3. On complémente : (1)1110110.<br/> 4. On rajoute 1 : (1)1110111.</p><p id="r-741045" data-claire-element-id="741045">Et voilà ! Vous remarquerez que je mets le bit de poids fort entre parenthèses, pour indiquer qu'il ne fait pas vraiment partie du nombre, il sert en fait à indiquer le signe : 0 si le nombre est positif ou nul, 1 s'il est négatif.<br/> Pour stocker des nombres plus grands (ou plus petits), les nombres peuvent être stockés sur plusieurs <em>bytes</em>, comme vu dans la partie précédente.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage">Les variables : leur vrai visage</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/rappels-12">
Rappels
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/la-memoire-une-affaire-de-bytes">
La mémoire une affaire de bytes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/s-assembler-pour-mieux-regner">
S&#039;assembler pour mieux régner
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-relatifs">
Variables et nombres relatifs
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-reels">
Variables et nombres réels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/s-assembler-pour-mieux-regner">
<span class="arrow"></span>
<span class="next">S&#039;assembler pour mieux régner</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-reels">
<span class="next">Variables et nombres réels</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Variablesetnombresrels"></a><h2>Variables et nombres réels</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-relatifs">
<span class="arrow"></span>
<span class="next">Variables et nombres relatifs</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-741047" data-claire-element-id="741047">Nous avons vu, dans la partie précédente, comment notre ordinateur pouvait stocker des nombres relatifs (c'est-à-dire pouvant être positifs ou négatifs). Mais nous ne nous arrêterons pas en si bon chemin ! Voyons maintenant quelle méthode utiliser pour stocker des nombres réels (à virgule). Comme pour les nombres relatifs, l'ordinateur se sert des déclarations de variables, pour différencier un nombre réel d'un nombre entier ; en effet, nous utilisons des types de variables différents pour chaque type de nombre que nous souhaitons utiliser (réel relatif, réel non signé, entier...).</p><p id="r-741048" data-claire-element-id="741048">Mais avant toutes choses, qu'est-ce qu'un nombre réel ? <br/> Il s'agit d'un nombre possédant une virgule et pouvant s'écrire, sous la forme : <br/>X.XXX...*10^n où X est bien entendu compris entre 0 et 9 pour <strong>le système décimal</strong>,<br/> et sous la forme :<br/>1.XXX...*2^n où X est compris entre 0 et 1 pour <strong>le système binaire.</strong></p><p id="r-741049" data-claire-element-id="741049">Et sans plus attendre, voici la méthode utilisée pour représenter des nombres réels sur 32 bits (<strong>float</strong>) : <br/><em>seeeeeeeemmmmmmmmmmmmmmmmmmmmmm</em>.</p><p id="r-741050" data-claire-element-id="741050">Comme vous le découvrez, cette méthode se propose de coder le nombre sur 32 bits en définissant trois composantes : <br/> - le signe <strong>s</strong> représenté par un seul bit, le bit de poids fort ;<br/> - l'exposant <strong>e</strong> codé sur les 8 bits consécutifs au signe ;<br/> - la mantisse <strong>m</strong> (les bits situés après la virgule) sur les 23 bits restants.</p><p id="r-741051" data-claire-element-id="741051">Mais ce n'est pas tout ! En effet, certaines conditions sont à respecter pour les exposants :<br/> - l'exposant 00000000 est interdit (en effet, n^0 vaudra toujours 1) ;<br/> - l'exposant 11111111 est interdit. En effet, on s'en sert pour signaler des erreurs, on appelle alors cette configuration de nombre NaN, ce qui signifie <em>Not a Number</em> ;<br/> - il faut rajouter 127 (01111111) à l'exposant pour une conversion de décimal vers un nombre réel binaire.</p><p id="r-741052" data-claire-element-id="741052">Un exemple pour que ça soit plus clair, prenons le nombre 525.5 :</p><ul id="r-741057" data-claire-element-id="741057"><li id="r-741054" data-claire-element-id="741054"><p id="r-741053" data-claire-element-id="741053">525.5 est positif donc le premier bit sera 0 ;</p></li><li id="r-741056" data-claire-element-id="741056"><p id="r-741055" data-claire-element-id="741055">sa représentation en binaire est la suivante : 1000001101.1. :-°</p></li></ul><p id="r-741058" data-claire-element-id="741058">Ne faites pas cette tête, c'est pourtant très simple, il suffit de représenter le nombre comme une somme : <br/><em>valeur du bit</em> * 2^(<em>poids du bit</em>) :<br/>525.5 = 1000001101.1<br/> = 1*2^9 + 0*2^8 + 0*2^7 + 0*2^6 + 0*2^5 + 0*2^4 + 1*2^3 + 1*2^2 + 0*2^1 + 1*2^0 + (.)1* 2^-1<br/> = 512 + 0 + 0 + 0 + 0 + 0 + 8 + 4 + 0 + 1 + 0.5<br/> = 525.5 &gt; on retombe donc bien sur nos pieds !</p><p id="r-741059" data-claire-element-id="741059">- En normalisant, on trouve : 1.0000011011*2^9.<br/> - On ajoute 127 à l'exposant qui vaut 9 ce qui donne 136, soit en binaire : 10001000. <br/> - La mantisse est composée de la partie décimale de 525.5 en base binaire, c'est-à-dire 0000011011. <br/> - Comme la mantisse doit occuper 23 bits, il est nécessaire d'ajouter des zéros pour la compléter : <br/> 00000110110000000000000.<br/> Pourquoi je rajoute des zéros à droite et non pas à gauche ? Parce que 1.0000011011 vaut 1.00000110110000000000000 !<br/> - Et pour finir, je mets le signe, l'exposant et la mantisse à la suite.<br/> Ainsi, voici le nombre 525.5 tel qu'il serait stocké dans la mémoire RAM de votre ordinateur :</p><p id="r-741060" data-claire-element-id="741060">01000100000000110110000000000000<br/><em>s</em><em>eeeeeeee</em><em>mmmmmmmmmmmmmmmmmmmmmm</em>.<br/> Bien entendu, on procède de la même manière pour les nombres négatifs (cette fois-ci, seul le signe change).</p><p id="r-741061" data-claire-element-id="741061">Mais voilà, cette méthode n'est vraie que pour une variable de 32 bits (ce qui correspond à un <em><strong>float</strong></em>) !</p><div id="r-741063" data-claire-element-id="741063" data-claire-semantic="question"><p id="r-741062" data-claire-element-id="741062">Quoi ? Parce qu'en plus il y a une méthode pour chaque type ! :colere:</p></div><p id="r-741064" data-claire-element-id="741064">Mais non du calme ! Rassurez-vous, la méthode est EXACTEMENT la même pour tous les types, tout ce qui change, c'est le nombre de bits représentant l'exposant et le signe :</p><p id="r-741065" data-claire-element-id="741065"><strong>float</strong> &gt; 4 octets &gt; 1s 8e 23m &gt; 6 chiffres après la virgule ;<br/><strong>double</strong> &gt; 8 octets &gt; 1s 11e 52m &gt; 15 chiffres après la virgule ;<br/><strong>long double</strong> &gt; 10 octets &gt; 1s 15e 64m &gt; 17 chiffres après la virgule <em>(en règle générale).</em></p><p id="r-741066" data-claire-element-id="741066">Vous comprenez donc pourquoi tous les types de variables pouvant contenir des nombres réels occupent tous au moins 4 octets (soit 32 bits).</p><aside id="r-741068" data-claire-element-id="741068" data-claire-semantic="information"><p id="r-741067" data-claire-element-id="741067">Le format que je vous ai présenté a en fait un nom, le format IEEE, (veuillez lire <em>Institute of Electrical and Electronics Engineers</em>). En réalité, l'IEEE est une institution américaine de portée internationale qui est devenue une référence scientifique et technique dans l'ingénierie électronique, l'informatique, les communications et la mécanique (rien que ça :p !).</p></aside><p id="r-741069" data-claire-element-id="741069">Voilà j'espère que ça vous a plu, vous savez maintenant ce que vous faites concrètement, lorsque vous stockez ou que vous utilisez une variable. ;)</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage">Les variables : leur vrai visage</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/rappels-12">
Rappels
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/la-memoire-une-affaire-de-bytes">
La mémoire une affaire de bytes
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/s-assembler-pour-mieux-regner">
S&#039;assembler pour mieux régner
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-relatifs">
Variables et nombres relatifs
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-reels">
Variables et nombres réels
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-variables-leur-vrai-visage/variables-et-nombres-relatifs">
<span class="arrow"></span>
<span class="next">Variables et nombres relatifs</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/les-variables-leur-vrai-visage.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 06:50:48 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-variables-leur-vrai-visage.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:14:36 GMT -->
</html>
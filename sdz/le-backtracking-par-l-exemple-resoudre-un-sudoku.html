<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/le-backtracking-par-l-exemple-resoudre-un-sudoku.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 07:02:40 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/le-backtracking-par-l-exemple-resoudre-un-sudoku.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:16:34 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Le backtracking par l&#039;exemple : résoudre un sudoku</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Le backtracking par l&#039;exemple : résoudre un sudoku</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Lebacktrackingparl039exemplersoudreunsudoku">Le backtracking par l&#039;exemple : résoudre un sudoku</a><br/><a href="#Dfinition">Définition</a><br/><a href="#Analyseducas">Analyse du cas</a><br/><a href="#Codagedelasolution">Codage de la solution</a><br/><a href="#Pourallerplusloin">Pour aller plus loin</a><br/></div>
<a name="Lebacktrackingparl039exemplersoudreunsudoku"></a><h2>Le backtracking par l&#039;exemple : résoudre un sudoku</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/definition-57">
<span class="next">Définition</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-419520" data-claire-element-id="419520">Le backtracking (retour sur trace) est une méthode communément employée pour résoudre des problèmes en programmation.</p><p id="r-419521" data-claire-element-id="419521">Nous allons l'étudier à travers un exemple concret : la résolution d'une grille de sudoku par ordinateur.</p><p id="r-419522" data-claire-element-id="419522">Pour pouvoir comprendre certaines parties de ce tutoriel, il est hautement souhaitable d'être à l'aise avec la notion de récursivité. Si ce n'est pas le cas pour vous, je vous invite à lire cet excellent <a href="http://www.siteduzero.com/tutoriel-3-36703-la-recursivite.html">tutoriel sur la récursivité</a> de <a href="http://www.siteduzero.com/membres-294-227.html">bluestorm</a>.</p>
</div><a name="Dfinition"></a><h2>Définition</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/analyse-du-cas">
<span class="next">Analyse du cas</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-419523" data-claire-element-id="419523">Avant de commencer, permettez moi de citer la définition tirée de Wikipédia :</p><p id="r-419524" data-claire-element-id="419524"><cite>Citation : Wikipédia</cite></p><blockquote id="r-419526" data-claire-element-id="419526"><p id="r-419525" data-claire-element-id="419525">Le retour sur trace, appelé aussi backtracking en anglais, consiste à revenir légèrement en arrière sur des décisions prises afin de sortir d'un blocage. La méthode des essais et erreurs constitue un exemple simple de backtracking.<br/> Le terme est surtout utilisé en programmation, où il désigne une stratégie pour trouver des solutions à des problèmes de satisfaction de contraintes.</p></blockquote><p id="r-419527" data-claire-element-id="419527">Concrètement, le backtracking peut s'apparenter à un parcours en profondeur d'un arbre avec une contrainte sur les noeuds : dés que la condition n'est plus remplie sur le noeud courant, on stoppe la descente sur ce noeud.</p><p id="r-419528" data-claire-element-id="419528">Je sais que tout cela doit vous paraitre assez abstrait, alors qu'il s'agit d'une technique fort simple de programmation. C'est pourquoi, je vous propose d'écrire avec moi un code mettant en application ce concept : résolution d'un sudoku par force brute :) .</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku">Le backtracking par l&#039;exemple : résoudre un sudoku</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/definition-57">
Définition
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/analyse-du-cas">
Analyse du cas
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/codage-de-la-solution">
Codage de la solution
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/pour-aller-plus-loin-34">
Pour aller plus loin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/analyse-du-cas">
<span class="next">Analyse du cas</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Analyseducas"></a><h2>Analyse du cas</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/definition-57">
<span class="arrow"></span>
<span class="next">Définition</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/codage-de-la-solution">
<span class="next">Codage de la solution</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-419530" data-claire-element-id="419530">Supposons que nous devons écrire un programme qui permette de résoudre des grilles de sudoku.</p><p id="r-419531" data-claire-element-id="419531">On pourrait tenter de faire une programme &quot;intelligent&quot;, qui remplisse la grille de façon logique. Seulement si cela est assez simple pour les sudokus faciles, il en va autrement avec les grilles plus rétives :( ... En effet, les méthodes de résolution dans ce cas seront plutôt complexes à écrire, ce qui nous amène a se demander s'il ne serait pas plus judicieux de passer directement par un brute-force.</p><p id="r-419532" data-claire-element-id="419532">C'est là que le problème de la complexité se pose : un brute-force est-il envisageable en pratique ? Pour N cases vides dans la grille, nous avons 9N combinaisons possibles. Un brute-force naïf semble donc assez mal parti...</p><p id="r-419533" data-claire-element-id="419533">C'est là qu'intervient le principe du retour sur trace. Si nous remplissons la grille au fur et à mesure, en vérifiant constamment qu'elle reste toujours potentiellement valide, on arrive assez vite à des situations de blocage ou il ne sert à rien de continuer. Dans un tel cas, on reviendra en arrière en évitant de continuer une exploration inutile. Avec cette manière de faire - appelée backtracking, le nombre de combinaisons à explorer est considérablement réduit, et le brute-force sera une solution parfaitement envisageable pour résoudre une grille de sudoku. :)</p><div id="r-419535" data-claire-element-id="419535" data-claire-semantic="question"><p id="r-419534" data-claire-element-id="419534">Facile à dire ! Mais concrètement, on fait comment pour revenir sur ses pas, comme tu dis ? Je viens d'essayer de coder un truc, mais c'est le gros bordel...</p></div><p id="r-419536" data-claire-element-id="419536">Effectivement, l'écriture d'un tel code n'est pas forcement évidente dés le début. Sachez surtout que nous pouvons nous servir de la récursivité pour en simplifier l'écriture. C'est d'ailleurs ce que nous allons faire dans la prochaine partie ;) !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku">Le backtracking par l&#039;exemple : résoudre un sudoku</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/definition-57">
Définition
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/analyse-du-cas">
Analyse du cas
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/codage-de-la-solution">
Codage de la solution
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/pour-aller-plus-loin-34">
Pour aller plus loin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/definition-57">
<span class="arrow"></span>
<span class="next">Définition</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/codage-de-la-solution">
<span class="next">Codage de la solution</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Codagedelasolution"></a><h2>Codage de la solution</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/analyse-du-cas">
<span class="arrow"></span>
<span class="next">Analyse du cas</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/pour-aller-plus-loin-34">
<span class="next">Pour aller plus loin</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-419538" data-claire-element-id="419538">Pour des raisons de commodité et rester accessible au plus grand nombre, j'ai choisi le langage C99/C++ pour illustrer la solution. Mais n'importe quelle personne ayant déjà codé devrait pouvoir suivre sans problème.</p><h2 id="r-1e-etape-structurer-les-donnees" data-claire-element-id="419544">1e étape : structurer les données</h2><figure id="r-419540" data-claire-element-id="419541"><img id="r-419539" data-claire-element-id="419539" src="medias/uploads.siteduzero.com_files_271001_272000_271361.jpg" alt="Image utilisateur"/></figure><p id="r-419542" data-claire-element-id="419542">Avant tout, nous allons prendre un exemple de grille pour pouvoir tester notre code. Pour une bête grille de sudoku, un simple tableau en 2 dimensions fera l'affaire. Voici un tableau correspondant à la grille ci-contre (les cases vides étant représentées par des zéros) :</p><pre id="r-419543" data-claire-element-id="419543"><code data-claire-semantic="cpp">int grille[9][9] =
    {
        {9,0,0,1,0,0,0,0,5},
        {0,0,5,0,9,0,2,0,1},
        {8,0,0,0,4,0,0,0,0},
        {0,0,0,0,8,0,0,0,0},
        {0,0,0,7,0,0,0,0,0},
        {0,0,0,0,2,6,0,0,9},
        {2,0,0,3,0,0,0,0,6},
        {0,0,0,2,0,0,9,0,0},
        {0,0,1,9,0,4,5,7,0}
    };</code></pre><h2 id="r-2e-etape-fonctions-auxiliaires" data-claire-element-id="419548">2e étape : fonctions auxiliaires</h2><p id="r-419545" data-claire-element-id="419545">Nous allons avoir besoin de fonctions pour tester si une valeur est bien absente d'une ligne, d'une colonne ou encore d'un bloc de la grille. Mieux vaut s'en occuper tout de suite, avant de passer au vif du sujet ;) .</p><p id="r-419546" data-claire-element-id="419546">La méthode la plus simple est de parcourir respectivement la ligne/colonne/bloc, et de retourner FAUX si la valeur est trouvée, sinon on retourne VRAI:</p><pre id="r-419547" data-claire-element-id="419547"><code data-claire-semantic="cpp">bool absentSurLigne (int k, int grille[9][9], int i)
{
    for (int j=0; j &lt; 9; j++)
        if (grille[i][j] == k)
            return false;
    return true;
}

bool absentSurColonne (int k, int grille[9][9], int j)
{
    for (int i=0; i &lt; 9; i++)
        if (grille[i][j] == k)
            return false;
    return true;
}

bool absentSurBloc (int k, int grille[9][9], int i, int j)
{
    int _i = i-(i%3), _j = j-(j%3);  // ou encore : _i = 3*(i/3), _j = 3*(j/3);
    for (i=_i; i &lt; _i+3; i++)
        for (j=_j; j &lt; _j+3; j++)
            if (grille[i][j] == k)
                return false;
    return true;
}</code></pre><h2 id="r-3e-etape-backtracking" data-claire-element-id="419578">3e étape : backtracking</h2><p id="r-419549" data-claire-element-id="419549">Cette fois, nous sommes enfin arrivés à la partie vraiment intéressante ;) !</p><p id="r-419550" data-claire-element-id="419550">Procédons étape par étape. Nous allons tout d'abord définir le prototype de la fonction de résolution.</p><h3 id="r-prototype-de-la-fonction-1" data-claire-element-id="419557">Prototype de la fonction</h3><p id="r-419551" data-claire-element-id="419551">Cette fonction doit recevoir une grille en entrée et la résoudre. Doit-elle retourner quelque chose ?</p><p id="r-419552" data-claire-element-id="419552">Oui, car nous devons constamment vérifier que le choix fait en amont ne provoque pas de blocage en aval. On va donc utiliser le retour de la fonction pour nous indiquer si la grille est valide ou non.</p><p id="r-419553" data-claire-element-id="419553">Enfin, comme notre fonction doit être récursive, nous allons ajouter un paramètre pour savoir quelle case nous sommes en train de traiter. Une case (i,j) dans un tableau peut être représentée par un nombre <code>(i*LARGEUR_TABLEAU) + j</code>, que nous nommerons <code data-claire-semantic="c">position</code>.</p><p id="r-419554" data-claire-element-id="419554">Ce qui nous donne au final comme prototype :</p><pre id="r-419555" data-claire-element-id="419555"><code data-claire-semantic="cpp">bool estValide (int grille[9][9], int position);</code></pre><p id="r-419556" data-claire-element-id="419556">Passons maintenant à l'intérieur de la fonction ;) .</p><h3 id="r-cas-simples" data-claire-element-id="419565">Cas simples</h3><p id="r-419558" data-claire-element-id="419558">Nous allons commencer par gérer les cas simples :</p><ul id="r-419563" data-claire-element-id="419563"><li id="r-419560" data-claire-element-id="419560"><p id="r-419559" data-claire-element-id="419559">Si on a terminé de parcourir la grille, c'est qu'elle est valide, on retourne VRAI.</p></li><li id="r-419562" data-claire-element-id="419562"><p id="r-419561" data-claire-element-id="419561">Si la case est déjà remplie, on passe directement à la case suivante.</p></li></ul><pre id="r-419564" data-claire-element-id="419564"><code data-claire-semantic="cpp">bool estValide (int grille[9][9], int position)
{
    // Si on est à la 82e case (on sort du tableau)
    if (position == 9*9)
        return true;

    // On récupère les coordonnées de la case
    int i = position/9, j = position%9;

    // Si la case n'est pas vide, on passe à la suivante (appel récursif)
    if (grille[i][j] != 0)
        return estValide(grille, position+1);

    // A implémenter : backtracking
}</code></pre><h3 id="r-backtracking" data-claire-element-id="419572">Backtracking</h3><p id="r-419566" data-claire-element-id="419566">Il ne reste plus qu'à gérer le retour sur trace (eh oui, je vous ai laissé le plus dur pour la fin :p ).</p><p id="r-419567" data-claire-element-id="419567">Considérons le problème : il nous faut énumérer tous les chiffres possibles, puis tester chaque solution éventuelle pour vérifier si elle nous amène à une solution correcte, ou bien à un blocage.</p><aside id="r-419569" data-claire-element-id="419569" data-claire-semantic="warning"><p id="r-419568" data-claire-element-id="419568">Mais attention ! Pour que les tests sur la grille puissent fonctionner, il faut veiller à actualiser la grille au cours de le descente récursive. Et c'est là que beaucoup se font piéger : il ne suffit pas d'enregistrer le choix effectué dans la grille avant de passer à l'appel suivant, mais il faut aussi réinitialiser la case à zéro en cas d'échec. Sans quoi, la fonction a de grandes chances de se retrouver avec une grille invalide...</p></aside><p id="r-419570" data-claire-element-id="419570">Voici le code avec actualisation de la grille :</p><pre id="r-419571" data-claire-element-id="419571"><code data-claire-semantic="cpp">// énumération des valeurs possibles
    for (int k=1; k &lt;= 9; k++)
    {
        // Si la valeur est absente, donc autorisée
        if (absentSurLigne(k,grille,i) &amp;&amp; absentSurColonne(k,grille,j) &amp;&amp; absentSurBloc(k,grille,i,j))
        {
            // On enregistre k dans la grille
            grille[i][j] = k;
            // On appelle récursivement la fonction estValide(), pour voir si ce choix est bon par la suite
            if ( estValide (grille, position+1) )
                return true;  // Si le choix est bon, plus la peine de continuer, on renvoie true :)
        }
    }
    // Tous les chiffres ont été testés, aucun n'est bon, on réinitialise la case
    grille[i][j] = 0;
    // Puis on retourne false :(
    return false;</code></pre><h3 id="r-code-complet-3" data-claire-element-id="419577">Code complet</h3><p id="r-419573" data-claire-element-id="419573">Allez, je vous donne un code complet pour tester chez vous :) :</p><p id="r-419574" data-claire-element-id="419574"></p><div id="r-419576" data-claire-element-id="419576"><pre id="r-419575" data-claire-element-id="419575"><code data-claire-semantic="cpp">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;


// Fonction d'affichage
void affichage (int grille[9][9])
{
    for (int i=0; i&lt;9; i++)
    {
        for (int j=0; j&lt;9; j++)
        {
            printf( ((j+1)%3) ? &quot;%d &quot; : &quot;%d|&quot;, grille[i][j]);
        }
        putchar('\n');
        if (!((i+1)%3))
            puts(&quot;------------------&quot;);
    }
    puts(&quot;\n\n&quot;);
}

bool absentSurLigne (int k, int grille[9][9], int i)
{
    for (int j=0; j &lt; 9; j++)
        if (grille[i][j] == k)
            return false;
    return true;
}

bool absentSurColonne (int k, int grille[9][9], int j)
{
    for (int i=0; i &lt; 9; i++)
        if (grille[i][j] == k)
            return false;
    return true;
}

bool absentSurBloc (int k, int grille[9][9], int i, int j)
{
    int _i = i-(i%3), _j = j-(j%3);  // ou encore : _i = 3*(i/3), _j = 3*(j/3);
    for (i=_i; i &lt; _i+3; i++)
        for (j=_j; j &lt; _j+3; j++)
            if (grille[i][j] == k)
                return false;
    return true;
}

bool estValide (int grille[9][9], int position)
{
    if (position == 9*9)
        return true;

    int i = position/9, j = position%9;

    if (grille[i][j] != 0)
        return estValide(grille, position+1);

    for (int k=1; k &lt;= 9; k++)
    {
        if (absentSurLigne(k,grille,i) &amp;&amp; absentSurColonne(k,grille,j) &amp;&amp; absentSurBloc(k,grille,i,j))
        {
            grille[i][j] = k;

            if ( estValide (grille, position+1) )
                return true;
        }
    }
    grille[i][j] = 0;

    return false;
}

int main (void)
{
    int grille[9][9] =
    {
        {9,0,0,1,0,0,0,0,5},
        {0,0,5,0,9,0,2,0,1},
        {8,0,0,0,4,0,0,0,0},
        {0,0,0,0,8,0,0,0,0},
        {0,0,0,7,0,0,0,0,0},
        {0,0,0,0,2,6,0,0,9},
        {2,0,0,3,0,0,0,0,6},
        {0,0,0,2,0,0,9,0,0},
        {0,0,1,9,0,4,5,7,0}
    };

    printf(&quot;Grille avant\n&quot;);
    affichage(grille);

    estValide(grille,0);

    printf(&quot;Grille apres\n&quot;);
    affichage(grille);
}</code></pre></div>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku">Le backtracking par l&#039;exemple : résoudre un sudoku</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/definition-57">
Définition
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/analyse-du-cas">
Analyse du cas
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/codage-de-la-solution">
Codage de la solution
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/pour-aller-plus-loin-34">
Pour aller plus loin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/analyse-du-cas">
<span class="arrow"></span>
<span class="next">Analyse du cas</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/pour-aller-plus-loin-34">
<span class="next">Pour aller plus loin</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Pourallerplusloin"></a><h2>Pour aller plus loin</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/codage-de-la-solution">
<span class="arrow"></span>
<span class="next">Codage de la solution</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-analyse-et-critique-du-code" data-claire-element-id="419616">Analyse et critique du code</h2><p id="r-419580" data-claire-element-id="419580">Le code ci-dessus est-il parfait ? Non, car on pourrait lui reprocher plusieurs points :</p><h3 id="r-pire-des-cas" data-claire-element-id="419587">Pire des cas</h3><figure id="r-419582" data-claire-element-id="419583"><img id="r-419581" data-claire-element-id="419581" src="medias/uploads.siteduzero.com_files_271001_272000_271358.jpg" alt="Image utilisateur"/></figure><p id="r-419584" data-claire-element-id="419584">Même si le code que nous avons écrit fournira en général la solution assez rapidement (moins d'une demi seconde chez moi), les performances dépendent totalement de la grille passée en entrée. Certaines grilles spécialement conçues peuvent lui demander beaucoup plus de travail, ce qui montre bien que la complexité dans le pire des cas n'est pas si bonne que cela.</p><p id="r-419585" data-claire-element-id="419585">L'image ci-contre (source - <a href="http://en.wikipedia.org/wiki/Algorithmics_of_Sudoku">Wikipédia</a>) est un exemple d'une telle grille. Le programme ci-dessus met chez moi environ 20 secondes pour la résoudre. La raison est que la bonne solution vient vers la fin de la descente récursive, et le nombre d'essais/erreurs est ainsi multiplié.</p><p id="r-419586" data-claire-element-id="419586">Pour pallier à cet inconvénient, essayons de réfléchir si l'on peut améliorer l'exploration des possibilités de manière à ce que la bonne solution sorte au plus tôt. La réponse est oui :) !</p><h3 id="r-optimisation-3" data-claire-element-id="419606">Optimisation</h3><p id="r-419588" data-claire-element-id="419588">Considérons quelques points :</p><ul id="r-419595" data-claire-element-id="419595"><li id="r-419590" data-claire-element-id="419590"><p id="r-419589" data-claire-element-id="419589">On peut ici effectuer le backtracking dans n'importe quel ordre, le choix que nous avons fait de parcourir linéairement la grille est arbitraire.</p></li><li id="r-419592" data-claire-element-id="419592"><p id="r-419591" data-claire-element-id="419591">Le nombre de valeurs possibles pour chaque case vide n'est pas identique.</p></li><li id="r-419594" data-claire-element-id="419594"><p id="r-419593" data-claire-element-id="419593">Plus on remplit de cases (autrement dit : plus on s'enfonce dans la récursion), plus augmentent les chances de créer un blocage.</p></li></ul><p id="r-419596" data-claire-element-id="419596">Il apparait que si nous effectuons le backtracking depuis les cases avec un minimum de solutions vers les cases avec un maximum de solutions, nous minimisons sensiblement l'exploration des possibilités. Cette méthode garantit aussi que le backtracking sera toujours effectué de façon optimale, et nous évitons ainsi le pire des cas mentionné plus haut.</p><p id="r-419597" data-claire-element-id="419597">Concrètement, on peut implémenter cette méthode en créant une liste de cases vides, qui enregistre les coordonnées et le nombre de valeurs possibles de chaque case. On triera la liste en ordre croissant, puis on la passe en argument de notre fonction de backtracking.</p><aside id="r-419599" data-claire-element-id="419599" data-claire-semantic="information"><p id="r-419598" data-claire-element-id="419598">Cette optimisation est en réalité incomplète. En effet, ici on se contente de trier la liste des cases à parcourir avant de procéder au backtracking. Une optimisation plus efficace serait de réorganiser l'ordre des cases à parcourir au cours de la descente récursive : on augmente encore considérablement les chances de tirer la bonne solution au plus tôt. Mais en pratique, ce n'est pas évident à réaliser correctement, c'est à dire en évitant que le coût des opérations ajoutées ne soit supérieur au gain escompté. C'est pourquoi nous n'aborderons pas ce point ici.</p></aside><p id="r-419600" data-claire-element-id="419600">Voici un code possible :</p><p id="r-419601" data-claire-element-id="419601"><strong><em>Implémentation des listes &quot;maison&quot;</em></strong></p><div id="r-419603" data-claire-element-id="419603"><pre id="r-419602" data-claire-element-id="419602"><code data-claire-semantic="cpp">////////////////////////////////////////////
//    implémentation de la liste
////////////////////////////////////////////

typedef struct _list
{
    int i, j;
    int nbValeursPossibles;
    struct _list *next;
} LIST;

// retourne un nouvel élément initialisé
static LIST* new_elem (int i, int j, int n)
{
    LIST* ret = (LIST*) malloc(sizeof* ret);
    if (ret != NULL)
        ret-&gt;i = i, ret-&gt;j = j, ret-&gt;nbValeursPossibles = n, ret-&gt;next = NULL;
    return ret;
}

// supprime intégralement une liste chainée
void liste_delete (LIST** list)
{
    LIST* tmp;
    while ( (tmp = *list) != NULL)
        *list = (*list)-&gt;next, free(tmp);
}

// ajoute en tête
void liste_cons (LIST** list, int i, int j, int n)
{
    LIST* elem = new_elem (i, j, n);
    if (elem != NULL)
        elem-&gt;next = *list, *list = elem;
}

// insertion dans une liste triée
void insertion (LIST** list, LIST* elem)
{
    if (*list == NULL)
        *list = elem, elem-&gt;next = NULL;
    else if ((*list)-&gt;nbValeursPossibles &lt; elem-&gt;nbValeursPossibles)
        insertion (&amp;(*list)-&gt;next, elem);
    else
        elem-&gt;next = *list, *list = elem;
}

// tri insertion sur liste chainée
LIST* list_sort (LIST* list)
{
    LIST *curr, *list2 = NULL, *tmp;
    for (curr = list; curr != NULL; curr = tmp)
    {
        tmp = curr-&gt;next;
        insertion (&amp;list2, curr);
    }
    return list2;
}</code></pre></div><p id="r-419604" data-claire-element-id="419604"><strong><em>Code optimisé</em></strong></p><pre id="r-419605" data-claire-element-id="419605"><code data-claire-semantic="cpp">bool absentDeLigne (int k, int grille[9][9], int i)
{
    for (int j=0; j &lt; 9; j++)
        if (grille[i][j] == k)
            return false;
    return true;
}

bool absentDeColonne (int k, int grille[9][9], int j)
{
    for (int i=0; i &lt; 9; i++)
        if (grille[i][j] == k)
            return false;
    return true;
}

bool absentDeBloc (int k, int grille[9][9], int i, int j)
{
    int _i = i-(i%3), _j = j-(j%3);  // ou encore : _i = 3*(i/3), _j = 3*(j/3);
    for (i=_i; i &lt; _i+3; i++)
        for (j=_j; j &lt; _j+3; j++)
            if (grille[i][j] == k)
                return false;
    return true;
}

bool estValide (int grille[9][9], LIST* position)
{
    // Si la liste est vide (fin de liste)
    if (position == NULL)
        return true;

    int i = position-&gt;i, j = position-&gt;j;

    for (int k=1; k &lt;= 9; k++)
    {
        if ( absentDeLigne(k,grille,i) &amp;&amp; absentDeColonne(k,grille,j) &amp;&amp; absentDeBloc(k,grille,i,j) )
        {
            grille[i][j] = k;

            if ( estValide(grille, position-&gt;next) )
                return true;
        }
    }
    grille[i][j] = 0;

    return false;
}

// Calcule le nombre de valeurs possibles pour une case vide
int nb_possibles (int grille[9][9], int i, int j)
{
    int ret = 0;
    for (int k=0; k &lt; 9; k++)
        if ( absentDeLigne(k,grille,i) &amp;&amp; absentDeColonne(k,grille,j) &amp;&amp; absentDeBloc(k,grille,i,j) )
            ret++;
    return ret;
}

bool resolution (int grille[9][9])
{
    // crée et remplit une liste pour les cases vides à visiter
    LIST* positions = NULL;
    for (int i=0; i &lt; 9; i++)
        for (int j=0; j &lt; 9; j++)
            if ( grille[i][j] == 0 )
                liste_cons ( &amp;positions, i, j, nb_possibles2(grille, i, j) );

    // Trie la liste (ordre croissant)
    positions = list_sort (positions);

    // Appelle la fonction de backtracking récursive estValide()
    bool ret = estValide (grille, positions);
    // Détruit la liste
    liste_delete (&amp;positions);
    // retourne le resultat
    return ret;
}</code></pre><h3 id="r-2eme-optimisation" data-claire-element-id="419615">2eme optimisation</h3><p id="r-419607" data-claire-element-id="419607">Un autre point que l'on pourrait reprocher à notre code, c'est sa méthode couteuse pour tester si le nombre à insérer est absent de la ligne/colonne/bloc. En effet, cette fonction est dite &quot;critique&quot;, car étant au coeur de la récursion, elle est appelée de très nombreuses fois. On a donc fort intérêt à l'optimiser...</p><p id="r-419608" data-claire-element-id="419608">Dans notre code, la méthode employée requiert au pire des cas un parcours de toute les cases de ces dernières, ce qui représente tout de même 27 cases. On peut améliorer sensiblement en mémorisant les valeurs présentes dans chaque ligne/colonne/bloc.</p><p id="r-419609" data-claire-element-id="419609">Si nous construisons au départ une liste des valeurs possibles pour chaque ligne/colonne/bloc, en utilisant des tableaux pour matérialiser ces listes, nous bénéficions d'un temps de lecture/écriture en O(1). Le test de possibilité d'insertion d'une valeur se fait alors en 3 opérations, ce qui est un gain considérable. Même en prenant en compte l'actualisation des listes au cours de la descente récursive, sachant que l'on fera bien plus de tests que d'actualisations, cette solution sera meilleure que celle proposée plus haut.</p><aside id="r-419611" data-claire-element-id="419611" data-claire-semantic="information"><p id="r-419610" data-claire-element-id="419610">En combinant cette optimisation avec l'autre ci-dessus, on peut s'affranchir de la plupart des opérations sur la grille, et c'est tant mieux ;) ! Il ne nous reste plus qu'a écrire la bonne valeur une fois trouvée.</p></aside><p id="r-419612" data-claire-element-id="419612">Exemple :</p><p id="r-419613" data-claire-element-id="419613"><strong><em>Code avec optimisation 1 et 2</em></strong></p><pre id="r-419614" data-claire-element-id="419614"><code data-claire-semantic="cpp">// Variables globales (tableaux) pour la mémorisation
bool existeSurLigne[9][9];
bool existeSurColonne[9][9];
bool existeSurBloc[9][9];


bool estValide (int grille[9][9], LIST* position)
{
    if (position == NULL)
        return true;

    int i = position-&gt;i, j = position-&gt;j;

    for (int k=0; k &lt; 9; k++)
    {
        // Vérifie dans les tableaux si la valeur est déjà présente
        if ( !existeSurLigne[i][k] &amp;&amp; !existeSurColonne[j][k] &amp;&amp; !existeSurBloc[3*(i/3)+(j/3)][k] )
        {
            // Ajoute k aux valeurs enregistrées
            existeSurLigne[i][k] = existeSurColonne[j][k] = existeSurBloc[3*(i/3)+(j/3)][k] = true;

            if ( estValide(grille, position-&gt;next) )
            {
                // Ecrit le choix valide dans la grille
                grille[i][j] = k+1;
                return true;
            }
            // Supprime k des valeurs enregistrées
            existeSurLigne[i][k] = existeSurColonne[j][k] = existeSurBloc[3*(i/3)+(j/3)][k] = false;
        }
    }

    return false;
}

// Calcule le nombre de valeurs possibles pour une case vide
int nb_possibles (int grille[9][9], int i, int j)
{
    int ret = 0;
    for (int k=0; k &lt; 9; k++)
        if ( !existeSurLigne[i][k] &amp;&amp; !existeSurColonne[j][k] &amp;&amp; !existeSurBloc[3*(i/3)+(j/3)][k] )
            ret++;
    return ret;
}

bool resolution (int grille[9][9])
{
    // Initialise les tableaux
    for (int i=0; i &lt; 9; i++)
        for (int j=0; j &lt; 9; j++)
            existeSurLigne[i][j] = existeSurColonne[i][j] = existeSurBloc[i][j] = false;

    // Enregistre dans les tableaux toutes les valeurs déjà présentes 
    int k;
    for (int i=0; i &lt; 9; i++)
        for (int j=0; j &lt; 9; j++)
            if ( (k = grille[i][j]) != 0)
                existeSurLigne[i][k-1] = existeSurColonne[j][k-1] = existeSurBloc[3*(i/3)+(j/3)][k-1] = true;

    // crée et remplit une liste pour les cases vides à visiter
    LIST* positions = NULL;
    for (int i=0; i &lt; 9; i++)
        for (int j=0; j &lt; 9; j++)
            if ( grille[i][j] == 0 )
                liste_cons ( &amp;positions, i, j, nb_possibles(grille, i, j) );

    // Trie la liste (ordre croissant)
    positions = list_sort (positions);

    // Appelle la fonction de backtracking récursive estValide()
    bool ret = estValide (grille, positions);
    // Détruit la liste
    liste_delete (&amp;positions);
    // retourne le resultat
    return ret;
}</code></pre><h2 id="r-concernant-la-resolution-logicielle-de-sudokus" data-claire-element-id="419623">Concernant la résolution logicielle de sudokus</h2><p id="r-419617" data-claire-element-id="419617">Le code fourni ici pourrait, avec de légères modification, servir à vérifier que le nombre de solutions d'un sudoku ne dépasse pas 1. Pour cela, il suffit de retourner non pas si la grille est valide ou non, mais plutôt le nombre de solutions possibles. Je vous laisse trouver tout seul comment faire ;) .</p><p id="r-419618" data-claire-element-id="419618">Aussi, pensez qu'un backtracking appliqué à une grille vide fournit une grille remplie (la première possible). En assignant à chaque case une liste de valeurs ordonnée aléatoirement pour l'énumération des possibilités, on peut obtenir une grille remplie aléatoirement. Mais cela n'est pas l'objet de ce tuto ;) ...</p><p id="r-419619" data-claire-element-id="419619">Bien entendu, il est possible de mettre en place des algorithmes plus sophistiqués pour résoudre un sudoku. Vous pouvez évidement vous inspirer des méthodes de résolution utilisées par les vrais joueurs pour cela (exemples : <a href="http://fr.wikipedia.org/wiki/Sudoku%23M.C3.A9thodes_de_r.C3.A9solution_utilis.C3.A9es_par_les_joueurs">ici</a> et <a href="http://www.sudopedia.org/wiki/Solving_Technique">là</a>).</p><aside id="r-419621" data-claire-element-id="419621" data-claire-semantic="information"><p id="r-419620" data-claire-element-id="419620">En pratique, un backtracking tel que présenté ici n'est pas la meilleure méthode de brute-force pour le sudoku, et sera par exemple impraticable pour des grilles extrêmes (25x25). Faites un tour <a href="http://en.wikipedia.org/wiki/Algorithmics_of_Sudoku">ici</a> pour avoir un aperçu des autres approches connues.</p></aside><p id="r-419622" data-claire-element-id="419622">Enfin, pour les curieux, sachez que le problème de savoir s'il existe une solution pour une grille de sudoku est classé <a href="http://fr.wikipedia.org/wiki/Problème_NP-complet">NP-complet</a>, ce qui revient à dire qu'aucune méthode n'est connue à ce jour pour trouver efficacement la réponse pour une grille N2*N2 avec N un peu grand (même s'il n'existe pas non plus de preuve que ce soit impossible :p ).</p><h2 id="r-conclusion-38" data-claire-element-id="419627">Conclusion</h2><p id="r-419624" data-claire-element-id="419624">Comme vous avez pu le voir, cette méthode du retour sur trace permet de résoudre certains types de problèmes assez facilement et efficacement. Et nous avons vu par ailleurs que cette technique reste quand même assez limitée.</p><p id="r-419625" data-claire-element-id="419625">Décider si une solution de ce type est adaptée à un problème n'est pas toujours aussi évident que pour le problème du sudoku. L'étape de modélisation d'un problème reste très importante, et seule une bonne modélisation du problème permettra de savoir si le backtracking est une solution potentielle ou non.</p><p id="r-419626" data-claire-element-id="419626">Pour vous familiariser avec le backtracking et ses subtilités, vous pouvez aller voir ces autres grands classiques : <a href="http://fr.wikipedia.org/wiki/Problème_des_huit_dames">problème des N reines</a>, <a href="http://fr.wikipedia.org/wiki/Perles_de_Dijkstra">perles de Dijkstra</a>...</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku">Le backtracking par l&#039;exemple : résoudre un sudoku</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/definition-57">
Définition
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/analyse-du-cas">
Analyse du cas
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/codage-de-la-solution">
Codage de la solution
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/pour-aller-plus-loin-34">
Pour aller plus loin
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/le-backtracking-par-l-exemple-resoudre-un-sudoku/codage-de-la-solution">
<span class="arrow"></span>
<span class="next">Codage de la solution</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/le-backtracking-par-l-exemple-resoudre-un-sudoku.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 07:02:40 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/le-backtracking-par-l-exemple-resoudre-un-sudoku.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:16:34 GMT -->
</html>
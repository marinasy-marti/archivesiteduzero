<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/les-flags-4.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 05:46:00 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-flags-4.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:01:36 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Les flags</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/les-flags-4.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Les flags</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#Lesflags">Les flags</a><br/><a href="#Qu039est-cequedesflags">Qu&#039;est-ce que des flags ?</a><br/><a href="#Lesoprateursbitbit">Les opérateurs bit à bit</a><br/><a href="#Lesflagsc039esttoutsimple">Les flags, c&#039;est tout simple</a><br/></div>
<a name="Lesflags"></a><h2>Les flags</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-flags-4/qu-est-ce-que-des-flags">
<span class="next">Qu&#039;est-ce que des flags ?</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-566051" data-claire-element-id="566051">Si vous avez lu le tutoriel sur le <a href="http://www.siteduzero.com/tuto-3-8-0-apprenez-a-programmer-en-c-c.html">C/C++</a> de <a href="http://www.siteduzero.com/membres-294-3.html">M@teo21</a> jusqu'à la partie III sur la <a href="http://www.libsdl.org/">SDL</a>, vous avez probablement rencontré ces paramètres étranges que l'on utilise pour initier la SDL nommés &quot;flags&quot; sans trop savoir ce qu'ils sont en réalité. Vous vous êtes sans doute déjà posé la question : &quot;Mais comment diable fonctionnent les flags ? &quot;.</p><p id="r-566052" data-claire-element-id="566052">Peut-être aussi n'avez-vous tout simplement jamais entendu parler de flags auparavant et vous aimeriez savoir ce que c'est. Et bien c'est justement ce que ce tuto va expliquer.</p><p id="r-566053" data-claire-element-id="566053">Mettez vos lunettes, on commence !</p>
</div><a name="Qu039est-cequedesflags"></a><h2>Qu&#039;est-ce que des flags ?</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-flags-4/les-operateurs-bit-a-bit-1">
<span class="next">Les opérateurs bit à bit</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<div id="r-566055" data-claire-element-id="566055" data-claire-semantic="question"><p id="r-566054" data-claire-element-id="566054">Mais qu'est-ce que des flags (drapeaux) ?</p></div><p id="r-566056" data-claire-element-id="566056">Voilà une bonne question. Il s'agit de paramètres que l'on peut passer comme bon nous semble à une fonction. Ils servent généralement à spécifier qu'on veut qu'une fonction agisse de telle ou telle manière sans toutefois être obligé de lui passer des tas de paramètres. On sépare des flags par des barres verticales (|).</p><p id="r-566057" data-claire-element-id="566057">Prenons par exemple la fonction SDL_Init() qui permet d'initialiser la <a href="http://www.libsdl.org/">SDL</a>. Cette fonction ne prend que des flags en paramètre et pour chacun, une section de la SDL est initialisée. Notez que les flags ne sont pas propres à la SDL, mais elle nous servira de bon exemple.</p><pre id="r-566058" data-claire-element-id="566058"><code data-claire-semantic="c">//...
SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_CDROM);
//Ici, les modules vidéo, audio et cd-rom seraient initialisés.</code></pre><p id="r-566059" data-claire-element-id="566059">Les 3 constantes <em><strong>SDL_INIT_VIDEO</strong></em>, <em><strong>SDL_INIT_AUDIO</strong></em> et <em><strong>SDL_INIT_CDROM</strong></em> auraient pu être passées dans n'importe quel ordre ou, tout simplement, ne pas être passées en paramètre et cela n'aurait posé aucun problème. Il en aurait tout de même fallu au moins une parmi toutes celles offertes, sinon la SDL n'aurait pas été initialisée.</p><aside id="r-566061" data-claire-element-id="566061" data-claire-semantic="information"><p id="r-566060" data-claire-element-id="566060">En réalité, la fonction SDL_Init() peut prendre 8 flags différents.</p></aside><div id="r-566063" data-claire-element-id="566063" data-claire-semantic="question"><p id="r-566062" data-claire-element-id="566062">Mais... comment se fait-il que des paramètres soient facultatifs, ce n'est pas permis qu'en C++ ?</p></div><p id="r-566064" data-claire-element-id="566064">C'est vrai, on ne peut pas donner de valeur par défaut à des paramètres en C. Mais les flags ne sont pas des paramètres avec des valeurs par défaut. Ce n'est qu'un seul et unique paramètre. Jetez un oeil sur le prototype de SDL_Init().</p><pre id="r-566065" data-claire-element-id="566065"><code data-claire-semantic="c">int SDL_Init(Uint32 flags);</code></pre><p id="r-566066" data-claire-element-id="566066">Surprenant n'est-ce pas ? <br/> Cela nous amène donc à nous demander ce que sont réellement ces barres qui délimitent les flags. C'est ce que nous allons voir.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-flags-4">Les flags</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-flags-4/qu-est-ce-que-des-flags">
Qu&#039;est-ce que des flags ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-flags-4/les-operateurs-bit-a-bit-1">
Les opérateurs bit à bit
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-flags-4/les-flags-c-est-tout-simple">
Les flags, c&#039;est tout simple
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-flags-4/les-operateurs-bit-a-bit-1">
<span class="next">Les opérateurs bit à bit</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesoprateursbitbit"></a><h2>Les opérateurs bit à bit</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-flags-4/qu-est-ce-que-des-flags">
<span class="arrow"></span>
<span class="next">Qu&#039;est-ce que des flags ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-flags-4/les-flags-c-est-tout-simple">
<span class="next">Les flags, c&#039;est tout simple</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<aside id="r-566069" data-claire-element-id="566069" data-claire-semantic="warning"><p id="r-566068" data-claire-element-id="566068">Avant de continuer, il faut un minimum de compréhension du système binaire. Je vous invite donc à lire <a href="http://www.siteduzero.com/tuto-3-7922-1-les-variables-leur-vrai-visage.html">ce tutoriel</a> écrit par <a href="http://www.siteduzero.com/membres-294-20303.html">Sheirkus</a>.</p></aside><p id="r-566070" data-claire-element-id="566070">Voilà qu'on entre dans le coeur du sujet : les opérateurs bit à bit (bitwise en anglais). Ces opérateurs sont en fait : &quot;^&quot;, &quot;&amp;&quot; et &quot;|&quot;.<br/> Eh oui ! Le symbole &amp; est de nouveau utilisé, il a donc 3 fonctionnalités : donner l'adresse d'une variable, identifier les références et celle que nous allons voir.</p><aside id="r-566072" data-claire-element-id="566072" data-claire-semantic="information"><p id="r-566071" data-claire-element-id="566071">Il existe d'autres opérateurs bit à bit, nous les verrons plus bas, par contre, ils ne sont pas nécessaire au bon fonctionnement des flags.</p></aside><p id="r-566073" data-claire-element-id="566073">Si nos trois nouveaux copains sont des opérateurs au même titre que le signe d'addition (+) et de soustraction (-), il est possible de leur faire faire des calculs. Vous savez ce que donne (38 | 22) ? La réponse est 54. Quoi ? Vous ne voyez pas le lien ? o_O <br/> C'est normal ! ^^</p><p id="r-566074" data-claire-element-id="566074">En fait, ces trois symboles sont des opérateurs qui permettent de faire du calcul au niveau des bits d'une variable. Ils vont comparer chacun des bits de deux nombres binaire et renvoyer le bit en fonction de l'opérateur utilisé (Un ordinateur ne connaît que le binaire, alors pour lui (38 | 22), c'est (100110 | 10110)).</p><p id="r-566075" data-claire-element-id="566075">Voici ce que font chacun des opérateurs :</p><ul id="r-566082" data-claire-element-id="566082"><li id="r-566077" data-claire-element-id="566077"><p id="r-566076" data-claire-element-id="566076">&amp; veut dire <strong>ET</strong> (comme pour &amp;&amp; dans une condition).</p></li><li id="r-566079" data-claire-element-id="566079"><p id="r-566078" data-claire-element-id="566078">| est un <strong>OU</strong>inclusif, ce qui veut dire que ça peut être un ou l'autre ou les deux (comme pour || dans une condition).</p></li><li id="r-566081" data-claire-element-id="566081"><p id="r-566080" data-claire-element-id="566080">^ est un <strong>OU</strong>exclusif, ce qui veut dire que ça peut être un ou l'autre mais pas les deux.</p></li></ul><p id="r-566083" data-claire-element-id="566083">Le principe de leur fonctionnement est le même que les conditions, les opérateurs testent si la valeur vaut 1. Laissons les exemples parler d'eux-mêmes.</p><ul id="r-566102" data-claire-element-id="566102"><li id="r-566085" data-claire-element-id="566085"><p id="r-566084" data-claire-element-id="566084">0|0 = 0</p></li><li id="r-566087" data-claire-element-id="566087"><p id="r-566086" data-claire-element-id="566086">1|0 = 1</p></li><li id="r-566089" data-claire-element-id="566089"><p id="r-566088" data-claire-element-id="566088">1|1 = 1</p></li><li id="r-566091" data-claire-element-id="566091"><p id="r-566090" data-claire-element-id="566090">0&amp;0 = 0</p></li><li id="r-566093" data-claire-element-id="566093"><p id="r-566092" data-claire-element-id="566092">1&amp;0 = 0</p></li><li id="r-566095" data-claire-element-id="566095"><p id="r-566094" data-claire-element-id="566094">1&amp;1 = 1</p></li><li id="r-566097" data-claire-element-id="566097"><p id="r-566096" data-claire-element-id="566096">0^0 = 0</p></li><li id="r-566099" data-claire-element-id="566099"><p id="r-566098" data-claire-element-id="566098">1^0 = 1</p></li><li id="r-566101" data-claire-element-id="566101"><p id="r-566100" data-claire-element-id="566100">1^1 = 0</p></li></ul><p id="r-566103" data-claire-element-id="566103">Maintenant, prenons deux valeurs hexadécimales : 0xAA et 0x55 qui, en binaire, deviennent respectivement <strong>10101010</strong> et <strong>01010101</strong>. Si nous appliquons ce principe sur ces nombres binaires qui contiennent plusieurs bits, le nombre renvoyé sera comparé ainsi.</p><figure id="r-566105" data-claire-element-id="566106"><img id="r-566104" data-claire-element-id="566104" src="medias/uploads.siteduzero.com_files_61001_62000_61896.jpg" alt="Image utilisateur"/></figure><p id="r-566107" data-claire-element-id="566107">Donc, si on écrit (0xAA | 0x55), le nombre renvoyé sera 0xFF (ou 255) puisque c'est l'équivalent de 11111111 en binaire. (0xAA &amp; 0x55) vaudra 0 (qui est la même chose que 00000000). <br/> Pas si difficile hein ?</p><p id="r-566108" data-claire-element-id="566108">Pour corser les choses, prenons 2 nombres au hasard et testons les. Disons 138 et 92.<br/> 138 = 10001010<br/> 92 = 1011100<br/> Pour calculer (138 | 92), on fait comme ceci :</p><figure id="r-566110" data-claire-element-id="566111"><img id="r-566109" data-claire-element-id="566109" src="medias/uploads.siteduzero.com_files_61001_62000_61897.jpg" alt="Image utilisateur"/></figure><p id="r-566112" data-claire-element-id="566112">Le nombre binaire qui en résulte est 11011110 qui vaut 222 en décimal. Nous pouvons donc affirmer que (138 | 92) = 222. Voyons avec les 2 autres opérateurs.</p><p id="r-566113" data-claire-element-id="566113">(138 &amp; 92) = 00001000 = 8.<br/> (138 ^ 92) = 11010110 = 214.</p><p id="r-566114" data-claire-element-id="566114">Sceptique ? Essayez de compiler ce petit code.</p><pre id="r-566115" data-claire-element-id="566115"><code data-claire-semantic="c">#include &lt;stdio.h&gt;

int main (void)
{
   printf (&quot;%d / %d / %d&quot;, (138 | 92), (138 &amp; 92), (138 ^ 92));

   return 0;
}</code></pre><p id="r-566116" data-claire-element-id="566116">Vous obtiendrez bel et bien :</p><figure id="r-566118" data-claire-element-id="566119"><img id="r-566117" data-claire-element-id="566117" src="medias/uploads.siteduzero.com_files_61001_62000_61898.jpg" alt="Image utilisateur"/></figure><p id="r-566120" data-claire-element-id="566120">Et maintenant, l'intérêt avec les flags ? Mais tout, voyons ! C'est ce que nous verrons plus bas, mais avant, une petite parenthèse sur deux autres opérateurs.</p><h2 id="r-les-operateurs-de-decalage-et" data-claire-element-id="566140">Les opérateurs de décalage (<strong>&lt;&lt; </strong>et <strong>&gt;&gt;</strong>).</h2><p id="r-566121" data-claire-element-id="566121">Les opérateurs de décalage sont, eux aussi, des opérateurs bit à bit, mais leur fonctionnement est bien différent. Ils ont pour effet de décaler de <strong>n</strong> position chacun des chiffres d'un nombre binaire dans un certain sens.</p><ul id="r-566126" data-claire-element-id="566126"><li id="r-566123" data-claire-element-id="566123"><p id="r-566122" data-claire-element-id="566122">&lt;&lt; décale les chiffres vers la gauche<strong>.</strong> décale les chiffres vers la gauche.</p></li><li id="r-566125" data-claire-element-id="566125"><p id="r-566124" data-claire-element-id="566124">&gt;&gt; décale les chiffres vers la droite<strong>.</strong> décale les chiffres vers la droite.</p></li></ul><p id="r-566127" data-claire-element-id="566127">Lors d'un décalage vers la gauche, des 0 sont insérés à la droite du nombre. Lors d'un décalage vers la droite, les chiffres qui sortent du nombre à droite sont perdus et des 0 sont insérés à gauche. Pour faire un décalage de 1 chiffre vers la droite du nombre 10, on doit écrire (10 &gt;&gt; 1) qui est l'équivalent de (1010 &gt;&gt; 1). Voici un dessin qui représente l'opération.</p><figure id="r-566129" data-claire-element-id="566130"><img id="r-566128" data-claire-element-id="566128" src="medias/uploads.siteduzero.com_files_62001_63000_62570.jpg" alt="Image utilisateur"/></figure><p id="r-566131" data-claire-element-id="566131">Le nombre renvoyé ici est 5 (101). Un décalage vers la gauche de 1 (10 &lt;&lt; 1 ) aurait donné 20 (10100). On peut constater qu'un décalage vers la gauche multiplie un nombre par 2n et un décalage vers la droite divise un nombre par 2n.</p><aside id="r-566133" data-claire-element-id="566133" data-claire-semantic="warning"><p id="r-566132" data-claire-element-id="566132">Attention ! Si une valeur est stockée dans une variable, il faut tenir compte de la taille de celle-ci ainsi que son signe (positif ou négatif).</p></aside><p id="r-566134" data-claire-element-id="566134">Eh oui ! Ça ne pouvait pas être aussi simple ! Une variable a toujours une limite en taille. Un <strong>unsigned char</strong>, par exemple, est écrit sur 8 bits. Si on y stocke un nombre et qu'on le décale vers la gauche, les bits de poids fort (à gauche) seront <strong>PERDUS</strong> s'ils sortent du nombre.</p><p id="r-566135" data-claire-element-id="566135">Si on attribue la valeur 128 (10000000) à une variable de type <strong>unsigned char</strong> (8 bits non-signés). Un décalage de 1 chiffre vers la gauche de cette variable donnera 0 (00000000).</p><p id="r-566136" data-claire-element-id="566136">Ça devient encore plus compliqué si on décale une variable de type <strong>signé</strong>. Il faut tenir compte du premier bit qui détermine le signe du nombre. Si on attribue la valeur 127 (1111111) à une variable de type <strong>char</strong> (8 bit signés). Un décalage de 1 vers la gauche sera équivalent à -2 ou, en binaire, (1)1111110.</p><p id="r-566137" data-claire-element-id="566137">Mais encore ! Un décalage vers la droite n'affecte pas le bit qui détermine le signe d'un nombre, même s'il est stocké dans une variable signée. (-127 &gt;&gt; 1) = -64 = (1)1000000.</p><p id="r-566138" data-claire-element-id="566138">Il faut une bonne maîtrise du fonctionnement de la mémoire et du système binaire pour travailler les opérateurs de décalage, c'est pourquoi j'ai conseillé de lire <a href="http://www.siteduzero.com/tuto-3-7922-1-les-variables-leur-vrai-visage.html">ce tutoriel</a> écrit par <a href="http://www.siteduzero.com/membres-294-20303.html">Sheirkus</a>.</p><p id="r-566139" data-claire-element-id="566139">Et si on retournait à notre sujet ? C'est à dire les flags !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-flags-4">Les flags</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-flags-4/qu-est-ce-que-des-flags">
Qu&#039;est-ce que des flags ?
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-flags-4/les-operateurs-bit-a-bit-1">
Les opérateurs bit à bit
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-flags-4/les-flags-c-est-tout-simple">
Les flags, c&#039;est tout simple
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-flags-4/qu-est-ce-que-des-flags">
<span class="arrow"></span>
<span class="next">Qu&#039;est-ce que des flags ?</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/les-flags-4/les-flags-c-est-tout-simple">
<span class="next">Les flags, c&#039;est tout simple</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lesflagsc039esttoutsimple"></a><h2>Les flags, c&#039;est tout simple</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-flags-4/les-operateurs-bit-a-bit-1">
<span class="arrow"></span>
<span class="next">Les opérateurs bit à bit</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-566142" data-claire-element-id="566142">Maintenant que nous avons vu comment fonctionnent les opérateurs bit à bit (bitwise), il ne reste plus qu'à les utiliser pour passer des flags à une fonction.</p><p id="r-566143" data-claire-element-id="566143">Pour commencer, comme je l'ai mentionné au début du tuto, les flags sont des constantes. Il faut les définir avec des valeurs précises dans le header où le prototype de la fonction en question se trouve. Appelons cette fonction fonctionTest(). Donc, dans le header on fait comme ceci.</p><pre id="r-566144" data-claire-element-id="566144"><code data-claire-semantic="c">#ifndef DEF_FICHIER
#define DEF_FICHIER

#define NO_FLAG 0
//Lorsqu'on ne passe pas de flag en paramètre, on envoie 0. Je vais détailler plus loin.
#define FLAG_A (valeur)
#define FLAG_B (valeur)
#define FLAG_C (valeur)
//etc.

void fonctionTest(unsigned long flags);
#endif</code></pre><p id="r-566145" data-claire-element-id="566145">Dans mon exemple, j'ai déclaré <strong>flags</strong> comme étant un <strong>unsigned long</strong> qui est un entier non-signé écrit sur 4 octets (32 bits). Il est important de déclarer le paramètre qui prend les flags comme étant un type <strong>non-signé</strong>. Un <strong>unsigned long</strong>, étant écrit sur 32 bits, permettra de stocker un maximum de 32 flags. Un <strong>unsigned short</strong> permetterait d'en stocker un maximum de 16. Un <strong>unsigned char</strong>, un maximum de 8, etc. À vous de voir quel type vous allez utiliser.</p><aside id="r-566147" data-claire-element-id="566147" data-claire-semantic="warning"><p id="r-566146" data-claire-element-id="566146">Dépendemment du système sur lequel vous travaillez, il est possible que les types de variables aient des tailles qui varient. Par conséquent, il faut toujours vérifier la documentation de son compilateur en fonction de son système pour connaître la taille d'un type <strong>int</strong> par exemple (qui peut être 8, 16, 32 ou 64 bits).</p></aside><div id="r-566149" data-claire-element-id="566149" data-claire-semantic="question"><p id="r-566148" data-claire-element-id="566148">Et quelles valeurs on donne à nos flags ?</p></div><p id="r-566150" data-claire-element-id="566150">J'y arrivais justement. Il faut donner une valeur dont le nombre, une fois converti en binaire, ne contient qu'un seul 1. On peut donc les définir de cette manière :</p><ul id="r-566163" data-claire-element-id="566163"><li id="r-566152" data-claire-element-id="566152"><p id="r-566151" data-claire-element-id="566151">1 = 0x1 = 1</p></li><li id="r-566154" data-claire-element-id="566154"><p id="r-566153" data-claire-element-id="566153">2 = 0x2 = 10</p></li><li id="r-566156" data-claire-element-id="566156"><p id="r-566155" data-claire-element-id="566155">4 = 0x4 = 100</p></li><li id="r-566158" data-claire-element-id="566158"><p id="r-566157" data-claire-element-id="566157">8 = 0x8 = 1000</p></li><li id="r-566160" data-claire-element-id="566160"><p id="r-566159" data-claire-element-id="566159">16 = 0x10 = 10000</p></li><li id="r-566162" data-claire-element-id="566162"><p id="r-566161" data-claire-element-id="566161">32 = 0x20 = 100000</p></li></ul><aside id="r-566165" data-claire-element-id="566165" data-claire-semantic="information"><p id="r-566164" data-claire-element-id="566164">Notez que les valeurs décimales sont toutes des puissances de 2.</p></aside><p id="r-566166" data-claire-element-id="566166">Vous pouvez choisir des valeurs selon la base de votre choix, j'utiliserai la base décimale pour mon exemple.</p><aside id="r-566168" data-claire-element-id="566168" data-claire-semantic="warning"><p id="r-566167" data-claire-element-id="566167">Certains compilateurs acceptent le préfixe &quot;0b&quot; pour écrire des nombres directement en binaire (Par exemple : 0b10100101). Cette notation n'est toutefois pas un standard C et ne sera ainsi pas reconnue par tous les compilateurs.</p></aside><p id="r-566169" data-claire-element-id="566169">Et maintenant, attribuons nos valeurs à nos flags, ce qui nous donne notre header final.</p><pre id="r-566170" data-claire-element-id="566170"><code data-claire-semantic="c">#ifndef DEF_FICHIER
#define DEF_FICHIER

#define NO_FLAG 0
#define FLAG_A 1
#define FLAG_B 2
#define FLAG_C 4
#define FLAG_D 8

void fonctionTest(unsigned int flags);
#endif</code></pre><p id="r-566171" data-claire-element-id="566171">Vous commencez à comprendre la technique ? En écrivant (FLAG_B | FLAG_D), on obtient l'équivalent de 1010 en binaire. 1010 équivaut à 10 en décimal, mais nous n'avons plus à nous préoccuper de cette valeur.</p><p id="r-566172" data-claire-element-id="566172">Dernier soucis, extraire les flags du nombre passé en paramètre. On le fait en comparant le nombre reçu (unsigned int flags) et le flag en question avec l'opérateur &amp; tout simplement. <br/> Un autre dessin s'impose.</p><figure id="r-566174" data-claire-element-id="566175"><img id="r-566173" data-claire-element-id="566173" src="medias/uploads.siteduzero.com_files_61001_62000_61899.jpg" alt="Image utilisateur"/></figure><p id="r-566176" data-claire-element-id="566176">Lorsqu'un flag n'est pas passé en paramètre, la comparaison renvoie 0, tout simplement. Voilà !</p><p id="r-566177" data-claire-element-id="566177">On écrit donc dans le fichier source autant de conditions qu'on a de flags pour les tester tous. Chaque condition doit tester si la comparaison entre un flag et le paramètre de la fonction avec l'opérateur <strong>&amp;</strong> renvoie une valeur différente de 0.</p><pre id="r-566178" data-claire-element-id="566178"><code data-claire-semantic="c">//Fichier test.c
#include &quot;test.h&quot;

void fonctionTest(unsigned int flags)
{
     if (flags != 0)
     {
        if ((flags &amp; FLAG_A) !=0 )
        //On sait que FLAG_A est passé en paramètre.
        
        if ((flags &amp; FLAG_B) !=0 )
        //On sait que FLAG_B est passé en paramètre.
        
        if ((flags &amp; FLAG_C) !=0 )
        //On sait que FLAG_C est passé en paramètre.
        
        if ((flags &amp; FLAG_D) !=0 )
        //On sait que FLAG_D est passé en paramètre.
     }
     else
     //NO_FLAG est passé en paramètre avec aucun autre flag.
}</code></pre><p id="r-566179" data-claire-element-id="566179">Il ne restera plus qu'à inclure votre header dans tous les fichiers utilisant votre fonction et ce sera possible de l'appeler ainsi :</p><pre id="r-566180" data-claire-element-id="566180"><code data-claire-semantic="c">//...
fonctionTest(FLAG_C | FLAG_A);
//...</code></pre><p id="r-566181" data-claire-element-id="566181">En C++, on peut tout simplement ne donner aucun flag à la fonction en donnant la valeur 0 par défaut au paramètre &quot;flags&quot;. Ça évite de s'encombrer d'un flag ayant la valeur 0.</p><pre id="r-566182" data-claire-element-id="566182"><code data-claire-semantic="cpp">void fonctionTest(unsigned int flags=0);</code></pre><p id="r-566183" data-claire-element-id="566183">C'est tout.</p><p id="r-566184" data-claire-element-id="566184">Et voilà qui termine le tuto sur les flags. J'espère que vous avez apprécié, mais surtout : j'espère que vous avez compris. Je vous invite donc maintenant à jeter un oeil au fichier SDL.h et regarder la déclaration de la fonction SDL_Init(). Tous les flags y sont déclarés.</p><p id="r-566185" data-claire-element-id="566185">Ce n'était pas si difficile n'est-ce pas ?</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/les-flags-4">Les flags</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-flags-4/qu-est-ce-que-des-flags">
Qu&#039;est-ce que des flags ?
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/les-flags-4/les-operateurs-bit-a-bit-1">
Les opérateurs bit à bit
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/les-flags-4/les-flags-c-est-tout-simple">
Les flags, c&#039;est tout simple
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/les-flags-4/les-operateurs-bit-a-bit-1">
<span class="arrow"></span>
<span class="next">Les opérateurs bit à bit</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/les-flags-4.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 05:46:04 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/les-flags-4.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:01:38 GMT -->
</html>
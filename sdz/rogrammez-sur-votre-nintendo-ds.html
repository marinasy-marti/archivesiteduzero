<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/rogrammez-sur-votre-nintendo-ds.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 02:52:19 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/rogrammez-sur-votre-nintendo-ds.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:37:46 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Programmez sur votre Nintendo DS !</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/programmez-sur-votre-nintendo-ds.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Programmez sur votre Nintendo DS !</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#ProgrammezsurvotreNintendoDS">Programmez sur votre Nintendo DS !</a><br/><a href="#LesbasesdePAlib">Les bases de PAlib</a><br/><a href="#Lestechniquesavances">Les techniques avancées</a><br/><a href="#Annexes">Annexes</a><br/></div>
<a name="ProgrammezsurvotreNintendoDS"></a><h2>Programmez sur votre Nintendo DS !</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-bases-de-palib">
<span class="next">Les bases de PAlib</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<figure id="r-445165" data-claire-element-id="445166"><img id="r-445164" data-claire-element-id="445164" src="medias/uploads.siteduzero.com_files_105001_106000_105356.jpg" alt="Image utilisateur"/></figure><p id="r-445167" data-claire-element-id="445167">Programmer sur ordinateur c'est chouette..<br/> .. Mais sur Nintendo DS ?</p><p id="r-445168" data-claire-element-id="445168">La bibliothèque PAlib permet d'écrire des programmes en C / C++ pour votre Nintendo DS. Elle permet de tout faire (gestion des écrans, touches, stylet, son, image, etc.).</p><p id="r-445169" data-claire-element-id="445169">Le hic ? Bien qu'elle soit facile d'accès, les tutoriels sur le Net sont soit bancals soit très mal expliqués. Voilà pourquoi nous, <a href="http://www.siteduzero.com/membres-294-5480.html">Gambit2099</a> et <a href="http://www.siteduzero.com/membres-294-63161.html">snake_48</a>, nous sommes associés pour vous faire découvrir cette lib !</p><p id="r-445170" data-claire-element-id="445170">En avant ! ^^</p>
</div><a name="LesbasesdePAlib"></a><h2>Les bases de PAlib</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-techniques-avancees">
<span class="next">Les techniques avancées</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-445171" data-claire-element-id="445171">Parce qu'il faut bien commencer quelque part, cette partie vous expliquera les notions de base de PAlib. Il n'y aura pas que du hello world, sinon ça ne serait pas marrant, avouez :D .</p><p id="r-445172" data-claire-element-id="445172">Note : vous devez avoir lu et compris les deux premières parties du <a href="http://www.siteduzero.com/tutoriel-3-14189-apprenez-a-programmer-en-c.html">cours sur le C de M@teo21</a> ! La partie consacrée à la SDL est facultative mais ça peut toujours aider.</p><h2 id="r-avant-propos-8" data-claire-element-id="445189">Avant propos</h2><p id="r-445173" data-claire-element-id="445173">Vous vous doutiez sûrement que les outils nécessaires à la programmation sur DS ne se trouvaient pas déjà sur votre ordinateur et qu'il ne suffisait pas de dire abracadabra pour que vous puissiez utiliser vos programmes sur votre DS :p . C'est pourquoi dans ce chapitre nous allons vous expliquer en détail ce dont vous avez besoin.</p><p id="r-445174" data-claire-element-id="445174">Vous n'apprendrez donc &quot;rien&quot; dans ce chapitre mais ne vous inquiétez pas ça arrivera plus vite que vous ne le pensez :-° .</p><h3 id="r-parlons-hardware" data-claire-element-id="445185">Parlons hardware</h3><p id="r-445175" data-claire-element-id="445175">À ce stade-ci deux chemins qui s'offrent à vous :</p><ul id="r-445180" data-claire-element-id="445180"><li id="r-445177" data-claire-element-id="445177"><p id="r-445176" data-claire-element-id="445176">vous programmez des applications et jeux pour Nintendo DS mais vous ne les utilisez que sur votre PC avec un émulateur ;</p></li><li id="r-445179" data-claire-element-id="445179"><p id="r-445178" data-claire-element-id="445178">ou alors vous décidez de mettre vos programmes directement dans votre DS pour pouvoir les utiliser partout :) .</p></li></ul><p id="r-445181" data-claire-element-id="445181">Le deuxième choix semble le plus intéressant, cela va de soi ! Toutefois, renseignez-vous sur son utilisation, car vous pouvez rapidement tomber dans l'illégalité. Voilà pourquoi nous n'expliquerons pas ici comment fonctionne un <strong>linker</strong> (tel que la R4, M3, etc.).</p><aside id="r-445183" data-claire-element-id="445183" data-claire-semantic="information"><p id="r-445182" data-claire-element-id="445182">En choisissant la sage voie, vous ne pourrez jamais tester la gestion des fichiers, ni le <em>Wifi</em> dans vos programmes.</p></aside><p id="r-445184" data-claire-element-id="445184">C'était juste à titre d'information, rien de plus. ;)</p><h3 id="r-installation-des-outils-necessaires" data-claire-element-id="445188">Installation des outils nécessaires</h3><p id="r-445186" data-claire-element-id="445186">Bien ! Après vous avoir expliqué les deux possibilités qui s'offraient à vous, il est enfin temps d'installer PAlib et tout le nécessaire pour enfin programmer pour notre chère NDS. En avant :pirate: !</p><p id="r-445187" data-claire-element-id="445187">Pour ce faire, nous allons utiliser un auxiliaire de programmation utilisant le <strong>BATCH</strong> pour sa compilation. Il est donc <strong>important d'avoir un ordinateur sous WINDOWS</strong>. Pour les utilisateurs de Linux, ne vous inquiétez pas, on va arriver à votre cas ;) ! Pour ceux qui utilisent autre chose, il faudra, bien entendu, vous adapter au tutoriel.</p><h2 id="r-l-auxiliaire-de-programmation" data-claire-element-id="445191">L'auxiliaire de programmation</h2><p id="r-445190" data-claire-element-id="445190">Nous utiliserons <a href="http://sourceforge.net/project/showfiles.php?group_id=114505&amp;amp%3Bpackage_id=160396">DevkitPro</a> pour ce tutoriel. Téléchargez la dernière version (à l'heure où j'écris ces lignes c'est la version 1.5.0).</p><h2 id="r-la-bibliotheque-palib" data-claire-element-id="445195">La bibliothèque : PALib</h2><p id="r-445192" data-claire-element-id="445192">Pour information, PA veut dire <em>Programmer's Arsenal</em> et <em>Lib</em> veut dire <em>Library</em> (qui signifie &quot;bibliothèque&quot;) tout simplement. Il nous sera très utile : c'est la bibliothèque que nous utiliserons pour la programmation sur DS. <a href="http://www.palib-dev.com/downloads.html">Télécharger PALib</a>.<br/> Actuellement c'est la version la plus récente est la 100707, selon le site elle serait maintenue jusqu'à ce qu'un autre développeur reprenne le projet...</p><aside id="r-445194" data-claire-element-id="445194" data-claire-semantic="information"><p id="r-445193" data-claire-element-id="445193">Ce tutoriel a été conçu au départ avec la version 080823 que vous pourrez télécharger <a href="http://www.mediafire.com/?ilyywfz3wyi">ici</a>, puis a été repris avec la 100707, donc il se peut qu'il y ait des incohérences voire des codes qui ne compilent pas...</p></aside><h2 id="r-l-installation-4" data-claire-element-id="445226">L'installation</h2><p id="r-445196" data-claire-element-id="445196">Ça y est, nous allons enfin installer les éléments nous permettant de programmer !</p><aside id="r-445198" data-claire-element-id="445198" data-claire-semantic="information"><p id="r-445197" data-claire-element-id="445197">Si vous êtes sous Vista, faites <strong>clic droit-&gt;propriété-&gt;Windows Xp (service pack 2)</strong> pour chaque installateur.</p></aside><p id="r-445199" data-claire-element-id="445199">Tout d'abord lancez l'installateur devkitpro pour qu'il aille rechercher les fichiers nécessaires à l'installation.<br/> Lors de celle-ci vous pouvez laisser le chemin par défaut (C:\devkitPro ; ce qui est conseillé si vous n'êtes pas très à l'aise avec les changements de répertoire et de variables d'environnement qui risquent d'arriver), et au choix des composants à installer vous pouvez ne cocher que les cases correspondant à la DS (si vous avez peur de faire une bêtise, laissez tout coché ce n'est pas gênant :) ).</p><aside id="r-445201" data-claire-element-id="445201" data-claire-semantic="warning"><p id="r-445200" data-claire-element-id="445200">Vous devez impérativement laisser cochées &quot;PAlib&quot;, &quot;Examples&quot;, &quot;Other tools&quot;, &quot;shortcuts&quot;. Vous pouvez cocher la doc. Les émulateurs sont facultatifs puisque nous allons télécharger un émulateur plus tard, VisualHAM est un IDE, mais nous ne l'utiliserons pas. Et il est toujours bon d'avoir des bibliothèques supplémentaires, je vous recommande de cocher &quot;Additional Libs&quot;.</p></aside><p id="r-445202" data-claire-element-id="445202">Si vous avez téléchargé DevkitArm 20, alors remplacez la nouvelle version par l'ancienne (présente dans votre dossier devkitpro).</p><p id="r-445203" data-claire-element-id="445203">Ensuite il faut installer <strong>.Net framework </strong>pour que PAlib fonctionne correctement, il se peut qu'il soit déjà installé sur votre ordinateur, mais si vous hésitez <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=0856eacb-4362-4b0d-8edd-aab15c5e04f5&amp;amp%3BDisplayLang=en">téléchargez-le ici</a> et (ré)installez-le ! Ne vous inquiétez pas si vous avez une erreur disant qu'il n'a pas pu l'installer, la raison est souvent qu'il est déjà installé.</p><p id="r-445204" data-claire-element-id="445204">Il nous reste plus que PALib ! Installez-la <strong>dans le même le dossier devkitpro</strong>, c'est très important.</p><aside id="r-445206" data-claire-element-id="445206" data-claire-semantic="information"><p id="r-445205" data-claire-element-id="445205">Si vous utilisez une version ultérieure à 080823 vous serez confrontés à une archive et non à un installateur. Par conséquent vous devrez tout décompresser dans le dossier <em>C:\devkitPro\PAlib</em> (au besoin, créez ce sous-dossier).</p></aside><p id="r-445207" data-claire-element-id="445207">Pour vérifier que tout a bien été installé rendez-vous dans <strong>C:\devkitPro\palib\examples\Text\Normal</strong>, choisissez un dossier (HelloWorld par exemple) et double cliquez sur build.bat. Une fenêtre de console devrait apparaître (le projet HelloWorld se compile en fait), s'il n'y a pas d'erreur vous devriez trouver un fichier HelloWorld.nds et HelloWorld.ds.gba dans le répertoire :) !</p><aside id="r-445209" data-claire-element-id="445209" data-claire-semantic="error"><p id="r-445208" data-claire-element-id="445208">En cas d'erreur semblable à celle-ci vers la fin du texte affiché par build.bat :</p></aside><p id="r-445210" data-claire-element-id="445210"><cite>Citation</cite></p><blockquote id="r-445212" data-claire-element-id="445212"><p id="r-445211" data-claire-element-id="445211">make[1]: *** [/c/devkitPro/palib/examples/Text/Normal/HelloWorld/HelloWorld.elf]<br/> Error 1<br/> make: *** [build] Error 2</p></blockquote><p id="r-445213" data-claire-element-id="445213">Il vous faudra remplacer DevkitArm que vous avez par un DevkitARM antérieur.</p><p id="r-445214" data-claire-element-id="445214">Si vous avez une erreur qui s'apparente à celle-ci :</p><p id="r-445215" data-claire-element-id="445215"><cite>Citation</cite></p><blockquote id="r-445217" data-claire-element-id="445217"><p id="r-445216" data-claire-element-id="445216">arm-eabi-gcc.exe: CreateProcess: No such file or directory</p></blockquote><p id="r-445218" data-claire-element-id="445218">Il faudra modifier la valeur de la variable Path. Pour y accéder sous Vista, faites Démarrer -&gt; Panneau de configuration -&gt; Système -&gt; Paramètres Système Avancés (colonne à gauche). Cliquez sur le bouton &quot;Variable d'environnement&quot;, puis sur &quot;PATH&quot; et &quot;Modifier...&quot;. Une fenêtre apparaîtra et, à la fin du texte éditable, mettez un point-virgule et ajoutez ce code :</p><p id="r-445219" data-claire-element-id="445219"><cite>Citation</cite></p><blockquote id="r-445221" data-claire-element-id="445221"><p id="r-445220" data-claire-element-id="445220">C:\devkitPro\devkitARM\arm-eabi\bin;C:\devkitpro\devkitARM\bin;\msys\bin;c:\devkitpro\msys\bin;c:\devkitpro\devkitarm;C:\devkitPro\devkitARM\libexec\gcc\arm-eabi\4.1.1;</p></blockquote><p id="r-445222" data-claire-element-id="445222">Vous pouvez remplacer C:\ par le chemin jusqu'à devkitpro (exemple : C:\bidule\).</p><p id="r-445223" data-claire-element-id="445223">Si votre compilateur se met à vous injurier comme ce n'est pas permis, c'est peut-être que la libnds ne correspond pas à PALib. Il faudra donc la changer en remplaçant le dossier &quot;libnds&quot; de devkitpro par le contenu de <a href="http://infonetjv.free.fr/files/libnds.zip">libnds</a> (si le lien est mort vous pouvez recomposer le dossier à l'aide de : <a href="http://sourceforge.net/project/showfiles.php?group_id=114505&amp;amp%3Bpackage_id=151608&amp;amp%3Brelease_id=549081">libnds, le dossier</a> ; <a href="http://sourceforge.net/project/downloading.php?group_id=114505&amp;amp%3Buse_mirror=dfn&amp;amp%3Bfilename=libfat-nds-20070127.tar.bz2&amp;amp%3B59357982">libfat, à ajouter dans le même dossier</a> et <a href="http://sourceforge.net/project/downloading.php?group_id=114505&amp;amp%3Buse_mirror=dfn&amp;amp%3Bfilename=dswifi-0.3.4.tar.bz2&amp;amp%3B57819533">dswifi, toujours dans le même dossier</a>).</p><p id="r-445224" data-claire-element-id="445224"><strong>Il se peut que la compilation se fasse avec beaucoup de warnings, ignorez-les.</strong></p><p id="r-445225" data-claire-element-id="445225">Si vous avez un autre type d'erreur, recommencez l'installation à zéro, ou cherchez sur le Web une solution (n'oubliez pas les forums du site) :) .</p><h2 id="r-l-emulateur-2" data-claire-element-id="445231">L'émulateur</h2><p id="r-445227" data-claire-element-id="445227">Un émulateur est une application servant à visualiser un jeu (de DS ou autre). Il vous servira beaucoup pour tester vos jeux, c'est plus pratique que de prendre chaque fois sa DS :p . Sauf comme expliqué plus tôt, les émulateurs ne gèrent pas / gèrent mal les fichiers et le <em>Wifi</em>.</p><p id="r-445228" data-claire-element-id="445228">Nous vous conseillons un excellent émulateur : <em>No$GBA</em> que vous pouvez télécharger <a href="http://nocash.emubase.de/gba.htm">ici</a> (plus bas choisissez &quot;Download windows version&quot; et non DOS).</p><p id="r-445229" data-claire-element-id="445229">Sinon pour votre gouverne sachez qu'il en existe pleins d'autres : <em>PicoDriveDS</em>, <em>Spec DS</em>, <em>DeSmuMe</em>, <em>DSEMU</em>, <em>SnezziDS</em>, <em>GeoS</em><em>IDeaS</em>, <em>Dualis</em>, <em>NDS NeoPop</em>, etc.</p><p id="r-445230" data-claire-element-id="445230">Malgré le nombre d'émulateurs, nous vous conseillons no$gba qui est actuellement l'un des émulateurs DS (et GBA) les plus performants.</p><h2 id="r-l-editeur-2" data-claire-element-id="445290">L'éditeur</h2><p id="r-445232" data-claire-element-id="445232">Il est évident qu'il nous en faut un. Et bien que Bloc-Note pourrait suffire, pour une meilleure lisibilité du code (on parlera d'indentation et de coloration syntaxique du code), nous vous conseillons d'utiliser un éditeur plus évolué. En premier choix, nous vous proposons <a href="http://downloads.sourceforge.net/notepad-plus/npp.4.8.1.bin.zip?modtime=1204505956&amp;amp%3Bbig_mirror=0">Notepad++ (version zip)</a> / <a href="http://downloads.sourceforge.net/notepad-plus/npp.4.8.1.Installer.exe?modtime=1204505972&amp;amp%3Bbig_mirror=0">Notepad++ (version installateur, plus complet que le zip)</a>. <br/> Toutefois vous pouvez continuer sous votre IDE préféré si ça vous chante, de toute façon nous ne compilerons pas avec eux, mais comme dit plus haut avec un fichier .bat. Si vous prenez un IDE, pensez bien à changer de Makefile !</p><p id="r-445233" data-claire-element-id="445233">Tiens d'ailleurs ça me fait penser qu'il est enfin temps de se jeter dans le vif du sujet, allons-y ! :pirate:</p><h3 id="r-creation-d-un-projet-2" data-claire-element-id="445250">Création d'un projet</h3><p id="r-445234" data-claire-element-id="445234">Juste avant de nous lancer dans la programmation nous devons créer un projet ! Voici les étapes (très simples) :</p><ul id="r-445245" data-claire-element-id="445245"><li id="r-445236" data-claire-element-id="445236"><p id="r-445235" data-claire-element-id="445235">pour commencer, créez un dossier &quot;projets&quot; dans le répertoire de devkitpro ;</p></li><li id="r-445238" data-claire-element-id="445238"><p id="r-445237" data-claire-element-id="445237">ensuite, dans ce dossier, créez un dossier NomDeMonProjet (ne mettez pas d'espace) ;</p></li><li id="r-445240" data-claire-element-id="445240"><p id="r-445239" data-claire-element-id="445239">puis allez dans le dossier palib/template et copiez son contenu à l'exception des dossiers data, include et source ;</p></li><li id="r-445242" data-claire-element-id="445242"><p id="r-445241" data-claire-element-id="445241">retournez dans votre dossier et collez ces fichiers ;</p></li><li id="r-445244" data-claire-element-id="445244"><p id="r-445243" data-claire-element-id="445243">rajoutez-y un dossier nommé &quot;source&quot; (il est important de garder le nom &quot;source&quot; sinon, au moment de la compilation, votre fichier source ne sera pas trouvé o_O ).</p></li></ul><p id="r-445246" data-claire-element-id="445246">Et voilà, il ne vous restera plus qu'à renouveler cette action pour créer un nouveau projet !<br/> A partir de là il suffit de créer un fichier <strong>main</strong>.c (ou .cpp si vous programmez en C++) dans le dossier <strong>source</strong>.</p><div id="r-445248" data-claire-element-id="445248" data-claire-semantic="question"><p id="r-445247" data-claire-element-id="445247">Comment compiler un projet ?</p></div><p id="r-445249" data-claire-element-id="445249">Il faut lancer <strong>build.bat</strong> (en double-cliquant dessus, ça suffit). Tiens en parlant de programme, ça vous dirait qu'on s'y mette ? Alors allons-y !! :D</p><h3 id="r-et-sous-linux" data-claire-element-id="445251">Et sous Linux ?</h3><h3 id="r-l-installation-5" data-claire-element-id="445276">L'installation</h3><p id="r-445252" data-claire-element-id="445252">Téléchargez le <a href="http://www.zshare.net/download/58040819072daaab/">devkitpro pour Linux </a>(tout est réuni dans un gros fichier).<br/> Décompressez-le dans votre dossier personnel (soit /home/nomdutilisateur/) :</p><pre id="r-445253" data-claire-element-id="445253"><code data-claire-semantic="console">tar -jxvf devkitpro-pour-linux.tar.bz2</code></pre><p id="r-445254" data-claire-element-id="445254">Normalement, le chemin vers le devkitpro est donc /home/NOMDUTILISATEUR/devkitpro/. Allez donc dans ce dossier et décompressez-y les fichiers devkitARM-r21-linux.tar.bz2 et PAlib.tar.bz2 comme nous venons de le faire.</p><pre id="r-445255" data-claire-element-id="445255"><code data-claire-semantic="console">tar -jxvf devkitARM-r21-linux.tar.bz2
tar -jxvf PAlib.tar.bz2</code></pre><p id="r-445256" data-claire-element-id="445256">Vous devriez avoir cette arboresence :</p><pre id="r-445257" data-claire-element-id="445257"><code>/
|--home
        |--NOMDUTILISATEUR        
                |--devkitpro
                        |-devkitARM
                        |-libnds
                        |-Other Libs
                        |-PAlib</code></pre><p id="r-445258" data-claire-element-id="445258">Modifiez maintenant le fichier .bashrc (situé dans votre dossier personnel) en y ajoutant les 3 lignes suivantes :</p><pre id="r-445259" data-claire-element-id="445259"><code data-claire-semantic="bash">export DEVKITPRO=/home/NOMDUTILISATEUR/devkitpro 
export DEVKITARM=$DEVKITPRO/devkitARM
export PAPATH=$DEVKITPRO/PAlib/lib</code></pre><aside id="r-445261" data-claire-element-id="445261" data-claire-semantic="warning"><p id="r-445260" data-claire-element-id="445260">N'oubliez pas d'adapter la première ligne en fonction de votre nom d'utilisateur !</p></aside><p id="r-445262" data-claire-element-id="445262">Exécutez la commande suivante dans un terminal pour appliquer les changements :</p><pre id="r-445263" data-claire-element-id="445263"><code data-claire-semantic="console">source .bashrc</code></pre><p id="r-445264" data-claire-element-id="445264">Pour vérifier que les changements ont été appliqués, exécutez ensuite cette commande :</p><pre id="r-445265" data-claire-element-id="445265"><code data-claire-semantic="console">env | grep PAPATH</code></pre><p id="r-445266" data-claire-element-id="445266">Si vous voyez quelque chose s'afficher à l'écran (un chemin, comme PAPATH=/home/rayman3640/devkitpro/PAlib/lib<br/>), alors les changements ont été appliqués. Sinon, redémarrez votre terminal et réessayez.</p><p id="r-445267" data-claire-element-id="445267">Maintenant, il ne reste plus qu'à tester ! Le mieux est de compiler un exemple.<br/> Allez dans le dossier du devkitpro, puis dans /PAlib/examples/Text/Normal/HelloWorld.<br/> Exécutez cette commande :</p><pre id="r-445268" data-claire-element-id="445268"><code data-claire-semantic="console">make</code></pre><p id="r-445269" data-claire-element-id="445269">Vous pouvez obtenir ceci :</p><pre id="r-445270" data-claire-element-id="445270"><code data-claire-semantic="console">bash: make : commande introuvable</code></pre><p id="r-445271" data-claire-element-id="445271">Cela signifie que make n'est pas installé. Pour l'installer, exécutez donc cette commande avant de réessayer :</p><pre id="r-445272" data-claire-element-id="445272"><code data-claire-semantic="console">sudo apt-get install build-essential</code></pre><p id="r-445273" data-claire-element-id="445273">Si vous obtenez quelque chose comme ceci après avoir exécuté make (noté que j'ai légèrement raccourci le code) :</p><pre id="r-445274" data-claire-element-id="445274"><code data-claire-semantic="console">arm-eabi-g++ -g -mthumb-interwork -mno-fpu -L/home/rayman3640/devkitpro/PAlib/lib/lib -Wl 
Nintendo DS rom tool 1.36 - Oct 23 2007 23:03:47
by Rafael Vuijk, Dave Murphy, Alexei Karpenko
built ... HelloWorld.ds.gba
dsbuild 1.21 - Oct 23 2007
using default loader</code></pre><p id="r-445275" data-claire-element-id="445275">Alors vous avez réussi ! :)</p><h3 id="r-l-emulateur-3" data-claire-element-id="445289">L'émulateur</h3><p id="r-445277" data-claire-element-id="445277">Sous Linux, le choix d'émulateurs est un peu plus réduit. Je vous recommande desMuMe, car il en existe une version pour Linux. Sur certaines distributions, il est possible de l'installer via un dépôt (c'est le cas notamment d'Ubuntu). Si votre distribution utilise des paquets DEB, essayez comme ceci :</p><pre id="r-445278" data-claire-element-id="445278"><code data-claire-semantic="console">apt-get install desmume</code></pre><p id="r-445279" data-claire-element-id="445279">Si votre distribution utilisez des paquets RPM, essayez ceci :</p><pre id="r-445280" data-claire-element-id="445280"><code data-claire-semantic="console">yum install desmume</code></pre><p id="r-445281" data-claire-element-id="445281">Sinon, allez dans le dossier du devkitpro puis dans /PAlib/emulators/desmume-linux et exécutez ces commandes pour installer desMuMe :</p><pre id="r-445282" data-claire-element-id="445282"><code data-claire-semantic="console">chmod +x desmume-gtk-0.7.0.x86.package</code></pre><pre id="r-445283" data-claire-element-id="445283"><code data-claire-semantic="console">./desmume-gtk-0.7.0.x86.package</code></pre><p id="r-445284" data-claire-element-id="445284">Enfin, il est possible d'utiliser no$gba (qui se trouve dans le dossier /PAlib/emulators/no$gba/ avec Wine en faisant :</p><pre id="r-445285" data-claire-element-id="445285"><code data-claire-semantic="console">wine no\$gba.exe</code></pre><p id="r-445286" data-claire-element-id="445286">Vous pouvez même essayer d'utiliser les autres émulateurs du dossier avec Wine, mais desMuMe et no$gba sont meilleurs ;) .</p><p id="r-445287" data-claire-element-id="445287"><strong>Un grand merci à <a href="http://www.siteduzero.com/membres-294-29484.html">Rastagong</a> d'avoir complété notre tutoriel :) !</strong></p><p id="r-445288" data-claire-element-id="445288">Nous voilà fin prêts pour attaquer la programmation :lol: !</p><h2 id="r-notre-premier-programme-3" data-claire-element-id="445293">Notre premier programme</h2><p id="r-445291" data-claire-element-id="445291">Maintenant, nous allons enfin commencer à programmer :) .</p><h3 id="r-le-code-par-defaut" data-claire-element-id="445292">Le code par défaut</h3><h2 id="r-dernieres-preparations" data-claire-element-id="445295">Dernières préparations</h2><p id="r-445294" data-claire-element-id="445294">Il faut que vous créiez un fichier main.c (fichier C) <strong>ou</strong> main.cpp (fichier C++), selon le langage de programmation que vous avez choisi, dans le dossier &quot;source&quot;. Si vous n'avez pas nommé le fichier main ou que vous ne l'avez pas mis dans le dossier source, alors il ne sera pas trouvé lors de la compilation.</p><h2 id="r-le-code-de-base-4" data-claire-element-id="445301">Le code de base</h2><p id="r-445296" data-claire-element-id="445296">Alors le voici, vous l'attendiez tous le code qu'il faut retenir par coeur :D .</p><pre id="r-445297" data-claire-element-id="445297"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
 
int main (int argc, char **argv)
{
    PA_Init();
    
    while (1)
    {
        PA_WaitForVBL();
    }
    
    return 0;
}</code></pre><div id="r-445299" data-claire-element-id="445299" data-claire-semantic="question"><p id="r-445298" data-claire-element-id="445298">:euh: Heu...</p></div><p id="r-445300" data-claire-element-id="445300">Pas de panique, je vais tout vous expliquer :D .</p><h2 id="r-explications-33" data-claire-element-id="445312">Explications</h2><pre id="r-445302" data-claire-element-id="445302"><code data-claire-semantic="c">#include &lt;PA9.h&gt;</code></pre><p id="r-445303" data-claire-element-id="445303">Inclusion du header de PAlib, je suppose que vous l'aviez deviné. ;) .</p><pre id="r-445304" data-claire-element-id="445304"><code data-claire-semantic="c">PA_Init();</code></pre><p id="r-445305" data-claire-element-id="445305">Cette ligne est très importante ! Elle initialise PAlib (donc l'utilisation de ses fonctions), c'est pourquoi il ne faut surtout pas l'oublier :p .</p><pre id="r-445306" data-claire-element-id="445306"><code data-claire-semantic="c">while (1)</code></pre><p id="r-445307" data-claire-element-id="445307">Boucle blanche (ou plus communément appelée boucle infinie), c'est ici que nous mettrons nos instructions. Elle s'exécutera jusqu'à ce que l'on appuie sur le bouton power.</p><pre id="r-445308" data-claire-element-id="445308"><code data-claire-semantic="c">PA_WaitForVBL();</code></pre><p id="r-445309" data-claire-element-id="445309">En parlant de rafraîchissement ! Cette fonction permet de synchroniser le rafraîchissement de l'écran à 60 frames par secondes (abrégé fps) dans la boucle. Il y a 60 frames par secondes, donc on peut en déduire que les écrans de la Nintendo DS ont une fréquence de 60 Hz. N'oubliez surtout pas de la mettre sinon il se peut que votre programme soit rafraîchi beaucoup trop vite, et là c'est le plantage :-° .</p><h3 id="r-hello-world-13" data-claire-element-id="445311">Hello world !</h3><p id="r-445310" data-claire-element-id="445310">On va y aller doucement pour les textes, sinon, on va vite se mélanger les pinceaux :lol: .</p><h2 id="r-l-initialisation-du-texte" data-claire-element-id="445322">L'initialisation du texte</h2><p id="r-445313" data-claire-element-id="445313">Il faut initialiser le texte avec la fonction PA_LoadDefaultText.</p><pre id="r-445314" data-claire-element-id="445314"><code data-claire-semantic="c">void PA_LoadDefaultText ( u8 ecran, u8 background ) ;</code></pre><p id="r-445315" data-claire-element-id="445315">Voici ce qu'il faut donner comme arguments à cette fonction :</p><ul id="r-445320" data-claire-element-id="445320"><li id="r-445317" data-claire-element-id="445317"><p id="r-445316" data-claire-element-id="445316"><strong>ecran</strong> : c'est l'écran où vous voulez afficher du texte (généralement, on initialise les deux pour être tranquille) ;<br/> - 0 : écran tactile<br/> - 1 : écran du haut</p></li><li id="r-445319" data-claire-element-id="445319"><p id="r-445318" data-claire-element-id="445318"><strong>background</strong> : C'est la surface sur laquelle vous voulez écrire votre texte (il y en a 4).<br/> - 0 : haute couche<br/> - 1 : la suivante (plus on descend, moins on est prioritaire et plus on on a de risques d'être recouvert :) )<br/> - 2 : la suivante<br/> - 3 : la dernière couche (celle qui a le plus de chance d'être recouverte)</p></li></ul><p id="r-445321" data-claire-element-id="445321">Pour le background, cela marche de la même façon que les calques sous Photoshop.</p><h2 id="r-le-texte-10" data-claire-element-id="445354">Le texte !</h2><p id="r-445323" data-claire-element-id="445323">Il existe la fonction <code data-claire-semantic="c">u16 PA_OutputSimpleText(u8 ecran, u16 colonne, u16 ligne, const char *texte) </code> mais elle n'est pas comparable à <strong>printf</strong>. En effet, cette fonction sert à créer un texte statique. Autrement dit, on ne peut pas afficher de variables (<strong>&quot;%d&quot;</strong>, <strong>&quot;%f&quot;</strong>, <strong>&quot;%c&quot;</strong>, <strong>&quot;%s&quot;</strong>, etc...). C'est pour cette raison que nous la laissons tomber pour privilégier la fonction :</p><pre id="r-445324" data-claire-element-id="445324"><code data-claire-semantic="c">void PA_OutputText(u8 ecran, u16 x, u16 y, const char *texte, ...) ;</code></pre><p id="r-445325" data-claire-element-id="445325">Cette fonction présente deux avantages : elle permet de créer un texte dynamique (grâce à l'affichage de variables modélisées par l'argument <strong>...</strong>), et elle nous fait de la place sur le disque dur comparée à sa frangine :p .</p><aside id="r-445327" data-claire-element-id="445327" data-claire-semantic="warning"><p id="r-445326" data-claire-element-id="445326">Attention les formateurs de sortie %ld (pour les <code data-claire-semantic="cpp">long </code>) et %c (pour les caractères) ne sont pas supportés ! Je suppose que beaucoup d'autres ne doivent pas l'être, mais pas de panique les principaux sont au rendez-vous. :) . Néanmoins, si cela vous perturbe, vous pouvez créer une chaîne de caractères, et via un <em>sprintf</em> écrire tout le texte que vous voulez, puis l'utiliser dans <em>PA_OutputText</em>.</p></aside><p id="r-445328" data-claire-element-id="445328">Alors, analysons cette fonction :</p><ul id="r-445342" data-claire-element-id="445342"><li id="r-445330" data-claire-element-id="445330"><p id="r-445329" data-claire-element-id="445329"><strong>u8 ecran</strong> : on choisit l'écran sur lequel écrire<br/> - 0 : écran tactile <br/> - 1 : écran du haut</p></li><li id="r-445335" data-claire-element-id="445335"><p id="r-445331" data-claire-element-id="445331"><strong>u16 x</strong> :</p><aside id="r-445333" data-claire-element-id="445333" data-claire-semantic="information"><p id="r-445332" data-claire-element-id="445332">Pour le texte, on n'utilise pas les pixels, mais ce que l'on appelle des <em>tiles</em> (&quot;tuiles&quot; en français). Un <em>tile</em> correspond à un carré de 8*8 pixels. Et un écran NDS contient 24 lignes de 8 pixels et 32 colonnes de 8 pixels (256*192 pixels). A vous de trouver le meilleur endroit pour le rendu de votre texte.</p></aside><p id="r-445334" data-claire-element-id="445334">- valeur comprise entre 0 et 31 (puisque 256 / 8 = 32, n'oubliez pas de réfléchir en <em>tiles</em> !).<br/> Note : 31 n'est pas trop recommandé puisque votre texte est censé faire plus d'un caractère.. Et si vous dépassez, le texte sera remis à la ligne.</p></li><li id="r-445337" data-claire-element-id="445337"><p id="r-445336" data-claire-element-id="445336"><strong>u16 y</strong> :<br/> - valeur comprise entre 0 et 23 (192 / 8 = 24)<br/> Ici si vous dépassez, votre texte ne sera pas affiché...</p></li><li id="r-445339" data-claire-element-id="445339"><p id="r-445338" data-claire-element-id="445338"><strong>char *text</strong> : votre chaîne.</p></li><li id="r-445341" data-claire-element-id="445341"><p id="r-445340" data-claire-element-id="445340"><strong>...</strong> : toutes vos variables.</p></li></ul><p id="r-445343" data-claire-element-id="445343">Ce qui donnerait :</p><pre id="r-445344" data-claire-element-id="445344"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
 
int main(int argc, char **argv)
{
    const char *pseudo=&quot;PODS&quot;;
 
    PA_Init();
 
    PA_LoadDefaultText(1,0);//on initialise l'écran du haut à la première couche
    PA_LoadDefaultText(0,3);//on initialise l'écran tactile à une couche peu profonde (on peut se le permettre ici, on n'affichera qu'un texte)
 
    //Le texte ne changeant pas, pas besoin de le mettre dans la boucle
    PA_OutputText(1, 2,  2, &quot;Hello World !&quot;);
    PA_OutputText(0,5,5,&quot;Mon pseudo est %s.&quot;,pseudo);
 
    while(1)
    {
        PA_WaitForVBL();
        //Boucle infinie (inutile de l'utiliser puisqu'il n'y aura pas de changement)
    }
    return 0;
}</code></pre><p id="r-445345" data-claire-element-id="445345">Avec No$GBA :</p><figure id="r-445347" data-claire-element-id="445348"><img id="r-445346" data-claire-element-id="445346" src="medias/uploads.siteduzero.com_files_259001_260000_259174.png" alt="Image utilisateur"/></figure><aside id="r-445350" data-claire-element-id="445350" data-claire-semantic="information"><p id="r-445349" data-claire-element-id="445349">Si vous avez tout le texte d'un écran à mettre à jour, il existe cette fonction : <strong>void PA_ClearTextBg(ecran)</strong> :</p></aside><pre id="r-445351" data-claire-element-id="445351"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
 
int main(int argc, char **argv)
{
    int compteur=0;
 
    PA_Init();
 
    PA_LoadDefaultText(0,0);
 
    for(compteur = 0; compteur &lt; 2147483647; compteur++)//On limite à la taille d'un int, c'est suicidaire mais en même temps ce n'est qu'un exemple
    {
        PA_OutputText(0,0,0,&quot;%d&quot;,compteur);
        PA_WaitForVBL();
        PA_ClearTextBg(0);
        /* Il faudrait attendre plus longtemps pour éviter que le texte ne clignote, mais comme je l'ai dit ce n'est qu'un exemple ;) */
    }
    return 0;
}</code></pre><p id="r-445352" data-claire-element-id="445352">Tadaaaa, nous y sommes arrivés :D !</p><p id="r-445353" data-claire-element-id="445353">Nous allons voir comment utiliser le stylet et les touches...</p><h2 id="r-les-evenements-13" data-claire-element-id="445501">Les événements</h2><p id="r-445355" data-claire-element-id="445355">Essayez de créer un jeu sans gérer l'appui des touches et le stylet... Difficile, hein ? :D Nous allons donc nous attaquer à cette tâche qui, comme nous allons le voir, est trop très facile !</p><h3 id="r-configurer-l-emulateur" data-claire-element-id="445357">Configurer l'émulateur</h3><p id="r-445356" data-claire-element-id="445356">On va d'abord configurer les touches de <em>no$gba</em>, de <em>DeSmuMe</em> et de <em>iDeaS</em>. Si vous avez un autre émulateur, il faudra vous débrouiller ! :p</p><h3 id="r-pour-no-gba" data-claire-element-id="445363">Pour <em>no$gba</em></h3><p id="r-445358" data-claire-element-id="445358">Faites F11 ou Options-&gt;Controls Setup.<br/> Regardez la colonne de droite. Cliquez dans l'espace blanc à droite de la commande (ex : Up) et appuyez sur la touche de clavier désirée pour appeler cette commande.</p><figure id="r-445360" data-claire-element-id="445361"><img id="r-445359" data-claire-element-id="445359" src="medias/uploads.siteduzero.com_files_154001_155000_154824.jpg" alt="Image utilisateur"/></figure><p id="r-445362" data-claire-element-id="445362"><em>Configuration de snake_48 :-°</em></p><h3 id="r-pour-desmume" data-claire-element-id="445365">Pour <em>DeSmuMe</em></h3><p id="r-445364" data-claire-element-id="445364">Faites Config-&gt;Control Config.<br/> Cliquez dans le menu déroulant à droite de la commande et appuyez sur la touche de clavier désirée pour appeler cette commande.</p><h3 id="r-pour-ideas" data-claire-element-id="445367">Pour <em>iDeaS</em></h3><p id="r-445366" data-claire-element-id="445366">Faites Ctrl+K ou Options-&gt;Key Config.<br/> Appuyez sur le bouton correspondant à la commande et appuyez sur la touche du clavier désirée pour l'appeler.</p><h3 id="r-les-touches" data-claire-element-id="445416">Les touches</h3><p id="r-445368" data-claire-element-id="445368">Les touches sont représentées par la structure nommée &quot;Pad&quot;. Cette structure en renferme d'autres :</p><ul id="r-445375" data-claire-element-id="445375"><li id="r-445370" data-claire-element-id="445370"><p id="r-445369" data-claire-element-id="445369">Newpress : nouvel appui (elle était dure, la traduction :p ) ;</p></li><li id="r-445372" data-claire-element-id="445372"><p id="r-445371" data-claire-element-id="445371">Held : touche enfoncée ;</p></li><li id="r-445374" data-claire-element-id="445374"><p id="r-445373" data-claire-element-id="445373">Released : touche relâchée.</p></li></ul><p id="r-445376" data-claire-element-id="445376">Et chacune de ces structures-membres ont des membres correspondant aux touches :</p><ul id="r-445403" data-claire-element-id="445403"><li id="r-445378" data-claire-element-id="445378"><p id="r-445377" data-claire-element-id="445377">Up</p></li><li id="r-445380" data-claire-element-id="445380"><p id="r-445379" data-claire-element-id="445379">Down</p></li><li id="r-445382" data-claire-element-id="445382"><p id="r-445381" data-claire-element-id="445381">Left</p></li><li id="r-445384" data-claire-element-id="445384"><p id="r-445383" data-claire-element-id="445383">Right</p></li><li id="r-445386" data-claire-element-id="445386"><p id="r-445385" data-claire-element-id="445385">A</p></li><li id="r-445388" data-claire-element-id="445388"><p id="r-445387" data-claire-element-id="445387">B</p></li><li id="r-445390" data-claire-element-id="445390"><p id="r-445389" data-claire-element-id="445389">X</p></li><li id="r-445392" data-claire-element-id="445392"><p id="r-445391" data-claire-element-id="445391">Y</p></li><li id="r-445394" data-claire-element-id="445394"><p id="r-445393" data-claire-element-id="445393">L</p></li><li id="r-445396" data-claire-element-id="445396"><p id="r-445395" data-claire-element-id="445395">R</p></li><li id="r-445398" data-claire-element-id="445398"><p id="r-445397" data-claire-element-id="445397">Start</p></li><li id="r-445400" data-claire-element-id="445400"><p id="r-445399" data-claire-element-id="445399">Select</p></li><li id="r-445402" data-claire-element-id="445402"><p id="r-445401" data-claire-element-id="445401">Anykey : n'importe quelle touche</p></li></ul><p id="r-445404" data-claire-element-id="445404">Ces membres renvoient 0 ou 1 en fonction de la structure-membre qu'on appelle et, bien sûr, de l'action du joueur ;) . On peut ainsi avoir ceci :</p><pre id="r-445405" data-claire-element-id="445405"><code data-claire-semantic="c">/*Mettre le début du code*/
while(1)
{
    if(Pad.Newpress.A==1) //Si l'utilisateur fait un NOUVEL appui sur A
    /* instruction */
 
    else if(Pad.Held.R==1) //Si l'utilisateur laisse son doigt appuyé sur la touche R
    /* instruction */
 
    else if(Pad.Released.X==1) //Si l'utilisateur relâche la touche X
    /* instruction */
 
    PA_WaitForVBL();
}
/*Mettre la fin du code*/</code></pre><aside id="r-445407" data-claire-element-id="445407" data-claire-semantic="information"><p id="r-445406" data-claire-element-id="445406">On peut remplacer :</p></aside><pre id="r-445408" data-claire-element-id="445408"><code data-claire-semantic="c">if(Pad.Newpress.A==1)</code></pre><p id="r-445409" data-claire-element-id="445409">Par :</p><pre id="r-445410" data-claire-element-id="445410"><code data-claire-semantic="c">if(Pad.Newpress.A)</code></pre><p id="r-445411" data-claire-element-id="445411">Ainsi que :</p><pre id="r-445412" data-claire-element-id="445412"><code data-claire-semantic="c">if(Pad.Newpress.Y==0)</code></pre><p id="r-445413" data-claire-element-id="445413">Par :</p><pre id="r-445414" data-claire-element-id="445414"><code data-claire-semantic="c">if(!Pad.Newpress.Y)</code></pre><p id="r-445415" data-claire-element-id="445415">Mais je pense que l'utilisation des booléens est déjà acquise pour la plupart ;) .</p><h3 id="r-le-stylet" data-claire-element-id="445426">Le stylet !</h3><p id="r-445417" data-claire-element-id="445417">Vous vous demandiez tous &quot;Comment gère-t-on le stylet ?&quot;, eh bien ouvrez grand vos yeux !</p><figure id="r-445419" data-claire-element-id="445420"><img id="r-445418" data-claire-element-id="445418" src="medias/uploads.siteduzero.com_files_109001_110000_109559.gif" alt="Image utilisateur"/></figure><p id="r-445421" data-claire-element-id="445421">Le stylet est appelé par la structure &quot;Stylus&quot;.<br/> Celle-ci contient cinq membres : X et Y (vous avez sûrement deviné que ceci renvoie les coordonnées du stylet), Newpress, Held et Released :</p><pre id="r-445422" data-claire-element-id="445422"><code data-claire-semantic="c">/*Mettre le début du code*/
PA_LoadDefaultText(0,0);
while(1)
{
    PA_OutputText(0,0,0,&quot;( %d ; %d )    &quot;, Stylus.X, Stylus.Y);
    PA_WaitForVBL();
}
/*Mettre la fin du code*/</code></pre><p id="r-445423" data-claire-element-id="445423">Avouez tout de même qu'on ne pouvait pas faire plus simple :D !</p><aside id="r-445425" data-claire-element-id="445425" data-claire-semantic="warning"><p id="r-445424" data-claire-element-id="445424">Si vous affichez ce code et que le stylet n'a pas touché l'écran vous vous retrouverez avec de fausses valeurs ! C'est pour cela que la suite est importante ;) .</p></aside><h3 id="r-le-ds-motion-pak" data-claire-element-id="445469">Le DS Motion Pak</h3><div id="r-445428" data-claire-element-id="445428" data-claire-semantic="question"><p id="r-445427" data-claire-element-id="445427">Le DS Motion quoi ? o_O</p></div><p id="r-445429" data-claire-element-id="445429">Vous avez très bien lu, le <em>DS Motion Pak</em> (non il ne manque pas un &quot;c&quot; :p ).<br/> Qu'est-ce que c'est ? Il s'agit d'un accéléromètre (un appareil qui mesure les mouvements de l'objet sur lequel il est fixé) pour votre Nintendo DS. Il se met dans le SLOT 2 (port GBA) et ressemble à ceci (cliquez pour agrandir) :</p><p id="r-445430" data-claire-element-id="445431"><a href="medias/uploads.siteduzero.com_files_181001_182000_181272.png"><img id="r-445431" data-claire-element-id="445430" src="medias/uploads.siteduzero.com_thb_181001_182000_181272.png" alt="Image utilisateur"/></a></p><p id="r-445432" data-claire-element-id="445432">Il existe une version qui se met dans le SLOT 1 (port NDS),que je n'utiliserai pas dans ce tutoriel, appelé <em>DS Motion Card</em> (pour ceux qui mettent leurs <em>homebrews</em> sur un linker GBA) :</p><p id="r-445433" data-claire-element-id="445434"><a href="medias/uploads.siteduzero.com_files_181001_182000_181274.jpg"><img id="r-445434" data-claire-element-id="445433" src="medias/uploads.siteduzero.com_thb_181001_182000_181274.jpg" alt="Image utilisateur"/></a></p><p id="r-445435" data-claire-element-id="445435">Bien sûr, ce n'est pas gratuit &gt;_ . En effet, il faut compter 30 à 40 € pour l'un ou l'autre.<br/> Mais je ne regrette pas l'achat. On peut contrôler des éléments, et tout ça sans bouton (donc ça nous libère des possibilités pour créer un jeu certes moins compatible, mais plus poussé). De plus, ça met une ambiance à la Wii ^^ . Un conseil, évitez de vous faire filmer quand vous jouez à un jeu nécessitant le Motion :-° ...</p><p id="r-445436" data-claire-element-id="445436">Maintenant que les présentations sont faites, je vais vous annoncer une bonne nouvelle : PALib implémente totalement le Motion !</p><p id="r-445437" data-claire-element-id="445437">Tout d'abord, il faut initialiser le système Motion avec <code data-claire-semantic="c">void PA_MotionInit(void); </code>.<br/> Ensuite, il faut savoir si le DS Motion Pak est inséré. Pour ça il existe la fonction <code data-claire-semantic="c">u8 PA_CheckDSMotion(); </code>. Cette fonction retourne 0 si le DS Motion Pak n'est pas inséré ou 1 s'il l'est.</p><div id="r-445439" data-claire-element-id="445439" data-claire-semantic="question"><p id="r-445438" data-claire-element-id="445438">Et comment faire pour récupérer les données de l'accéléromètre ?</p></div><p id="r-445440" data-claire-element-id="445440">Il existe une variable <em>Motion</em> de type <em>motion_struct</em>.<br/> Voici ses attributs :</p><ul id="r-445467" data-claire-element-id="445467"><li id="r-445442" data-claire-element-id="445442"><p id="r-445441" data-claire-element-id="445441">X : la rotation dans les X. Cette valeur varie entre <strong>-128</strong> (droite) et <strong>128</strong> (gauche).</p></li><li id="r-445444" data-claire-element-id="445444"><p id="r-445443" data-claire-element-id="445443">Y : la rotation dans les Y. Cette valeur varie environ entre <strong>-134</strong> (console verticale, vous ne voyez pas les écrans) et <strong>114</strong> (console verticale, écrans vers vous).</p></li><li id="r-445446" data-claire-element-id="445446"><p id="r-445445" data-claire-element-id="445445">Z.</p></li><li id="r-445448" data-claire-element-id="445448"><p id="r-445447" data-claire-element-id="445447">Vx.</p></li><li id="r-445450" data-claire-element-id="445450"><p id="r-445449" data-claire-element-id="445449">Vy.</p></li><li id="r-445452" data-claire-element-id="445452"><p id="r-445451" data-claire-element-id="445451">Vz.</p></li><li id="r-445454" data-claire-element-id="445454"><p id="r-445453" data-claire-element-id="445453">AccelX.</p></li><li id="r-445456" data-claire-element-id="445456"><p id="r-445455" data-claire-element-id="445455">AccelY.</p></li><li id="r-445458" data-claire-element-id="445458"><p id="r-445457" data-claire-element-id="445457">AccelZ.</p></li><li id="r-445460" data-claire-element-id="445460"><p id="r-445459" data-claire-element-id="445459">Zrot.</p></li><li id="r-445462" data-claire-element-id="445462"><p id="r-445461" data-claire-element-id="445461">Vzrot.</p></li><li id="r-445464" data-claire-element-id="445464"><p id="r-445463" data-claire-element-id="445463">Angle.</p></li><li id="r-445466" data-claire-element-id="445466"><p id="r-445465" data-claire-element-id="445465">Force.</p></li></ul><p id="r-445468" data-claire-element-id="445468">Sachez que dans tous les codes utilisant <em>Motion</em>, seuls les membres <em>X</em> et <em>Y</em> sont utilisés. Vous pouvez cependant tester les membres avec <em>PA_OutputText</em> en tournant et en déplaçant votre Nintendo DS dans tous les sens :D !</p><h3 id="r-attendre-un-evenement" data-claire-element-id="445481">Attendre un événement</h3><p id="r-445470" data-claire-element-id="445470">Vous avez sûrement vu les fausses valeurs indiquées pour les coordonnées du stylet lorsque l'on n'a pas encore touché l'écran.<br/> On va utiliser <code data-claire-semantic="c">PA_WaitFor(evenement) </code> prenant pour argument l'événement à attendre.</p><aside id="r-445472" data-claire-element-id="445472" data-claire-semantic="warning"><p id="r-445471" data-claire-element-id="445471">Sachez que la macro fait déjà un appel à <em>PA_WaitForVBL();</em> donc si vous en faites encore un après, vous ralentirez considérablement (de 2 fois) votre application.</p></aside><p id="r-445473" data-claire-element-id="445473">Voici un petit exemple :</p><pre id="r-445474" data-claire-element-id="445474"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
 
int main(int argc, char ** argv)
{
    PA_Init();
        
    PA_LoadDefaultText(1,0);
 
    while(1)
    {
        PA_WaitFor(Stylus.Held); //Si on appuie ou si on reste appuyé
        PA_OutputText(1,0,0,&quot;( %d ; %d )&quot;, Stylus.X, Stylus.Y);
        PA_ClearTextBg(1);
    }
    return 0;
}</code></pre><div id="r-445476" data-claire-element-id="445476" data-claire-semantic="question"><p id="r-445475" data-claire-element-id="445475">On se retrouve quand même avec de fausses valeurs ! o_O Comment faut-il faire ?</p></div><p id="r-445477" data-claire-element-id="445477">Bonne question ^^ , en fait il est toujours bon de mettre 3 ou 4 rafraîchissements (<code data-claire-semantic="c">PA_WaitForVBL(); </code>) avant le la boucle principale, pour &quot;dérouiller&quot; en quelque sorte la NDS :</p><pre id="r-445478" data-claire-element-id="445478"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

int main(int argc, char ** argv)
{	
    PA_Init();

    PA_LoadDefaultText(1,0);

    PA_WaitForVBL();PA_WaitForVBL();PA_WaitForVBL();

    while(1)
    {
        PA_WaitFor(Stylus.Held);
        PA_ClearTextBg(1);
        PA_OutputText(1,0,0,&quot;( %d ; %d )&quot;, Stylus.X, Stylus.Y);
    }
    return 0;
}</code></pre><p id="r-445479" data-claire-element-id="445479">Mais vous pouvez aussi initialiser le stylet comme ceci par exemple :</p><pre id="r-445480" data-claire-element-id="445480"><code data-claire-semantic="c">Stylus.X=0;
Stylus.Y=0;</code></pre><h3 id="r-exercice-38" data-claire-element-id="445483">Exercice</h3><p id="r-445482" data-claire-element-id="445482">Pour vous faire pratiquer avant le TP, je vous propose un petit exercice :) .</p><h3 id="r-presentation-120" data-claire-element-id="445496">Présentation</h3><ul id="r-445494" data-claire-element-id="445494"><li id="r-445485" data-claire-element-id="445485"><p id="r-445484" data-claire-element-id="445484">Votre programme doit récupérer les dernières coordonnées du stylet (utilisez simplement des conditions).</p></li><li id="r-445487" data-claire-element-id="445487"><p id="r-445486" data-claire-element-id="445486">Il doit les afficher si l'on appuie sur la touche B.</p></li><li id="r-445493" data-claire-element-id="445493"><p id="r-445488" data-claire-element-id="445488">Si l'utilisateur n'a pas encore utilisé le stylet, on affiche :</p><pre id="r-445489" data-claire-element-id="445489"><code data-claire-semantic="console">Utilise le stylet !</code></pre><p id="r-445490" data-claire-element-id="445490">sinon :</p><pre id="r-445491" data-claire-element-id="445491"><code data-claire-semantic="console">x : 10, y : 211</code></pre><p id="r-445492" data-claire-element-id="445492">par exemple.</p></li></ul><p id="r-445495" data-claire-element-id="445495">À vous de jouer ! ;)</p><h3 id="r-correction-147" data-claire-element-id="445500">Correction</h3><div id="r-445498" data-claire-element-id="445498"><pre id="r-445497" data-claire-element-id="445497"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
 
int main(int argc, char ** argv)
{
    PA_Init();
        
    PA_InitText(1,0);
 
    while(1)
    {
        if(Pad.Held.B)
        {
            PA_OutputText(1,0,0,&quot;Utilise le stylet !&quot;);
            if(Stylus.Held)
            {
                PA_ClearTextBg(1); //On efface l'écran
                PA_OutputText(1,0,0,&quot;x : %d, y: %d&quot;,Stylus.X,Stylus.Y);
            }
        }
        PA_WaitForVBL();
        PA_ClearTextBg(1); //On efface l'écran
    }
    return 0;
}</code></pre></div><p id="r-445499" data-claire-element-id="445499">C'était pas si dur, et un jeu est composé de beaucoup d'événements !</p><h2 id="r-tp-plus-ou-moins-votre-premier-jeu-1" data-claire-element-id="445504">TP: Plus ou Moins, votre premier jeu</h2><p id="r-445502" data-claire-element-id="445502">Hé hé ! Si vous pensiez vous être débarrassés de ce maudit TP après la première partie du cours de M@teo21, détrompez-vous ! Il est de retour et désormais il compte bien s'attaquer à votre Nintendo DS ! :D</p><h3 id="r-preparatifs-6" data-claire-element-id="445503">Préparatifs</h3><h2 id="r-gestion-du-nombre-aleatoire" data-claire-element-id="445516">Gestion du nombre aléatoire</h2><p id="r-445505" data-claire-element-id="445505">Cette fois-ci nous n'allons pas utiliser time.h puisque ça ne fonctionnera pas avec la DS, il faut utiliser une autre fonction qui utilise l'horloge interne de la console, <strong>sans que vous ayez besoin de connaître les éléments qui permettent de récupérer l'heure</strong>. Nous allons juste utiliser des fonctions qui nous facilitent la vie en récupérant déjà l'heure.</p><p id="r-445506" data-claire-element-id="445506">Tout d'abord dire à la console que nous allons lui demander un nombre aléatoire :</p><pre id="r-445507" data-claire-element-id="445507"><code data-claire-semantic="c">u32 PA_InitRand ();</code></pre><p id="r-445508" data-claire-element-id="445508">Et utiliser la fonction qui renvoie le nombre:</p><pre id="r-445509" data-claire-element-id="445509"><code data-claire-semantic="c">u32 PA_RandMax (u32 max);</code></pre><p id="r-445510" data-claire-element-id="445510">Cette fonction renvoie un nombre en 0 et max INCLUS.</p><p id="r-445511" data-claire-element-id="445511">Voilà une autre fonction utile :</p><pre id="r-445512" data-claire-element-id="445512"><code data-claire-semantic="c">u32 PA_RandMinMax (u32 min, u32 max);</code></pre><p id="r-445513" data-claire-element-id="445513">Vous remarquerez que la fonction renvoie et demande des u32 (32 bits), nos variables pourront être de type int ou long, il n'y a pas de soucis de ce coté. ;)</p><aside id="r-445515" data-claire-element-id="445515" data-claire-semantic="information"><p id="r-445514" data-claire-element-id="445514">Cette fonction marchera aussi si vous testez votre programme sur votre ordinateur à l'aide d'un émulateur ;) .</p></aside><h2 id="r-la-gestion-du-clavier" data-claire-element-id="445602">La gestion du clavier</h2><p id="r-445517" data-claire-element-id="445517">Ne vous êtes-vous pas demandés comment diable l'utilisateur rentrera-t-il son nombre ? La solution : utiliser le clavier de la Nintendo DS bien sûr ;) !</p><h3 id="r-initialisation-du-clavier" data-claire-element-id="445522">Initialisation du clavier</h3><p id="r-445518" data-claire-element-id="445518">Il faut d'abord initialiser le clavier avec :</p><pre id="r-445519" data-claire-element-id="445519"><code data-claire-semantic="c">void PA_InitKeyboard(numero_bg);</code></pre><aside id="r-445521" data-claire-element-id="445521" data-claire-semantic="information"><p id="r-445520" data-claire-element-id="445520">Vous n'avez pas besoin de préciser l'écran puisque vous devez utiliser le stylet pour appuyer sur les touches du clavier.</p></aside><h3 id="r-apparition-du-clavier" data-claire-element-id="445530">Apparition du clavier</h3><p id="r-445523" data-claire-element-id="445523">Sachez que le clavier part du bas pour venir à la position voulue. Il faut juste que vous rentriez les coordonnées idéales du clavier pour voir une belle animation.<br/> On utilisera :</p><pre id="r-445524" data-claire-element-id="445524"><code data-claire-semantic="c">void PA_KeyboardIn (s16 x, s16 y);</code></pre><p id="r-445525" data-claire-element-id="445525">Mais le clavier vient du bas et un seul mouvement est possible (du bas vers le haut).<br/> Je vais vous donner une fonction toute faite pour faire un déplacement comme vous le voulez :</p><pre id="r-445526" data-claire-element-id="445526"><code data-claire-semantic="c">//PROTOTYPE
void defiler_clavier(int,int,int,int,int);
//FONCTION
void defiler_clavier(int x,int y,int x1,int y1,int nvbl)
{
    /*Le clavier va de (x;y) à (x1;y1) avec nvbl VBL pour chaque étape du déplacement*/
    int i=0;
    PA_ScrollKeyboardXY(x,y); //On met le clavier à la position (x;y)
    while(1)
    {
        /*On se rapproche des coordonnées (x1;y1)*/
        if(x&lt;x1)
            x++;
        else if(x&gt;x1)
            x--;
        if(y&lt;y1)
            y++;
        else if(y&gt;y1)
            y--;
        if(x==x1 &amp;&amp; y==y1)
            break;
        PA_ScrollKeyboardXY(x,y); //On replace le clavier à la nouvelle position
        /*On attend en fonction du nombre de VBL donné par la variable nvbl*/
        for(i=0;i&lt;nvbl;i++)
            PA_WaitForVBL();
    }
}</code></pre><p id="r-445527" data-claire-element-id="445527">Le clavier passera de (x;y) à (x1;y1) et à chaque tour de boucle, il y aura <em>nvbl</em> PA_WaitForVBL.</p><aside id="r-445529" data-claire-element-id="445529" data-claire-semantic="information"><p id="r-445528" data-claire-element-id="445528">Souvenez-vous que 1 VBL=\frac {1}{60} s, car la fréquence de la Nintendo DS est de 60 Hz.</p></aside><h3 id="r-traitement-du-clavier" data-claire-element-id="445562">Traitement du clavier</h3><p id="r-445531" data-claire-element-id="445531">Ça, c'est une toute autre histoire ! :p <br/> Il faut opérer en ce sens :</p><ul id="r-445551" data-claire-element-id="445551"><li id="r-445536" data-claire-element-id="445536"><p id="r-445532" data-claire-element-id="445532">créer un entier qui va contenir le nombre progressivement entré par l'utilisateur (caractère par caractère).</p><div id="r-445534" data-claire-element-id="445534" data-claire-semantic="question"><p id="r-445533" data-claire-element-id="445533">Mais comment allons nous ajouter des chiffres ou en retirer ?</p></div><p id="r-445535" data-claire-element-id="445535">Bonne question... A chaque fois qu'on ajoute un chiffre, il doit aller tout à droite (à la place des unités). Donc on multiplie le nombre par 10 et on y ajoute tout simplement le chiffre entré. Pour retirer le dernier chiffre (lorsqu'on appuie sur Backspace) il suffira de diviser le nombre par 10 car le résultat sera tronqué à l'unité.</p></li><li id="r-445538" data-claire-element-id="445538"><p id="r-445537" data-claire-element-id="445537">créer une variable de type <em>int</em> contenant le nombre de tentatives ;</p></li><li id="r-445540" data-claire-element-id="445540"><p id="r-445539" data-claire-element-id="445539">créer une variable <em>s32</em> qui contiendra le nombre de lettres ;</p></li><li id="r-445542" data-claire-element-id="445542"><p id="r-445541" data-claire-element-id="445541">créer une variable <em>char</em> qui contiendra la lettre actuelle ;</p></li><aside id="r-445544" data-claire-element-id="445544" data-claire-semantic="information"><p id="r-445543" data-claire-element-id="445543">Vous aurez sûrement besoin de &lt;string.h&gt;.</p></aside><p id="r-445545" data-claire-element-id="445545">&lt;/puce&gt;</p><li id="r-445550" data-claire-element-id="445550"><p id="r-445546" data-claire-element-id="445546">coder la boucle en reconnaissant la lettre entrée et en l'analysant :</p><pre id="r-445547" data-claire-element-id="445547"><code data-claire-semantic="c">char lettre=0;
/*INITIALISATIONS A METTRE*/
while(1)
{
    lettre=PA_CheckKeyboard();
    if(lettre&gt;='0' &amp;&amp; lettre&lt;='9')
        PA_OutputText(1,0,3,&quot;%d&quot;,lettre-'0');
    else if(lettre==PA_BACKSPACE)
        //ON EFFACE LE DERNIER CARACTÈRE, PENSEZ A FAIRE UNE FONCTION
    else if(lettre=='\n')
        //ON VALIDE
    /*RESTE DE LA BOUCLE*/
}</code></pre><aside id="r-445549" data-claire-element-id="445549" data-claire-semantic="information"><p id="r-445548" data-claire-element-id="445548">Si l'utilisateur appuie sur 0, <em>lettre</em> vaudra 48 ; sur 1, <em>lettre</em> vaudra 49 et ainsi de suite... C'est pour cela qu'il faut soustraire 48 à notre numéro de touche.</p></aside></li></ul><p id="r-445552" data-claire-element-id="445552">Bon, côté interface, on écrira tout sur l'écran supérieur.<br/> En premier, la console affichera :</p><pre id="r-445553" data-claire-element-id="445553"><code data-claire-semantic="console">Entrez un nombre entre 1 et 100 inclus :</code></pre><p id="r-445554" data-claire-element-id="445554">Au-dessous, (ligne 3) vous écrirez l'entrée du joueur.<br/> Si le nombre entré est plus petit que le nombre à trouver, on effacera l'écran supérieur pour écrire :</p><pre id="r-445555" data-claire-element-id="445555"><code data-claire-semantic="console">Le nombre %s est trop petit. Veuillez attendre 2 secondes...</code></pre><p id="r-445556" data-claire-element-id="445556">Où %s est la chaîne entrée par l'utilisateur.<br/> Si le nombre est trop grand, on écrira :</p><pre id="r-445557" data-claire-element-id="445557"><code data-claire-semantic="console">Le nombre %s est trop grand. Veuillez attendre 2 secondes...</code></pre><p id="r-445558" data-claire-element-id="445558">Et si le nombre est trouvé, on écrira :</p><pre id="r-445559" data-claire-element-id="445559"><code data-claire-semantic="console">Bravo ! Vous avez réussi à trouver le nombre %s en %d tentative%s ! Veuillez attendre 2 secondes...</code></pre><p id="r-445560" data-claire-element-id="445560">Où %d est le nombre de tentatives et le 2ème %s est le résultat d'une ternaire pour savoir si on met le pluriel ou pas.<br/> N'oubliez pas de faire l'attente pour les 2 secondes.<br/> Au passage, on effacera l'écran à chaque tour de boucle (si on efface le dernier caractère, la mise à jour sera automatique). Et si le joueur a trouvé le nombre, on quitte la boucle (utiliser <code data-claire-semantic="c">while(1) </code> avec un <code data-claire-semantic="c">break </code> lorsque l'objectif est atteint, afin d'attendre que l'utilisateur appuie sur Entrée). Et, après celle-ci, on affichera :</p><pre id="r-445561" data-claire-element-id="445561"><code data-claire-semantic="console">Bravo ! Vous avez réussi à trouver le nombre %s en %d tentative%s !</code></pre><h3 id="r-disparition-du-clavier" data-claire-element-id="445566">Disparition du clavier</h3><p id="r-445563" data-claire-element-id="445563">La simple fonction</p><pre id="r-445564" data-claire-element-id="445564"><code data-claire-semantic="c">void  PA_KeyboardOut (void);</code></pre><p id="r-445565" data-claire-element-id="445565">nous &quot;rangera&quot; automatiquement notre clavier ;) . Si vous ne voulez pas l'utiliser, vous pouvez utiliser notre fonction <em>defiler_clavier</em>.</p><h3 id="r-customisation-du-clavier" data-claire-element-id="445584">Customisation du clavier :)</h3><p id="r-445567" data-claire-element-id="445567">Vous pouvez personnaliser votre clavier. Vous devez créer d'abord un fichier image qui contiendra votre clavier. Ce fichier mesurera 256*1024 pixels. Aux coordonnées (0;0) dessinez votre clavier qui doit mesurer 208x96 pixels. La contrainte est que les touches doivent être de même dimensions que le clavier par défaut (il y a un exemple ci-dessous pour que vous puissiez bien voir les dimensions). Aux coordonnées (0;512) dessinez votre clavier (quand le joueur appuiera sur la touche Shift ou Caps).<br/> Voici un exemple de clavier :</p><table id="r-445583" data-claire-element-id="445583"><tbody id="r-445582" data-claire-element-id="445582"><tr id="r-445581" data-claire-element-id="445581"><td id="r-445569" data-claire-element-id="445570"><img id="r-445570" data-claire-element-id="445569" src="medias/uploads.siteduzero.com_files_121001_122000_121537.png" alt="Keyboard personnalisé^^"/><img id="r-445568" data-claire-element-id="445568" src="medias/uploads.siteduzero.com_files_121001_122000_121537.png" alt="Keyboard personnalisé^^"/></td><td id="r-445580" data-claire-element-id="445580"><p id="r-445571" data-claire-element-id="445571">Il s'agit de l'image <em>devkitPro\PAlibExamples\Input\Keyboard\KeyboardCustom\source\gfx</em> ^^ .<br/> Bien sûr, il faut l'ajouter à votre dossier gfx comme ceci :</p><p id="r-445572" data-claire-element-id="445572"><cite>Citation</cite></p><blockquote id="r-445576" data-claire-element-id="445576"><p id="r-445573" data-claire-element-id="445573">#TranspColor Magenta</p><p id="r-445574" data-claire-element-id="445574">#Sprites :</p><p id="r-445575" data-claire-element-id="445575">#Backgrounds : <br/> clavier.png 16colors</p></blockquote><p id="r-445577" data-claire-element-id="445577">Pour utiliser un clavier personnalisé, on utilise</p><pre id="r-445578" data-claire-element-id="445578"><code data-claire-semantic="c">void PA_InitCustomKeyboard(numero_bg, fichier_contenant_votre_clavier);</code></pre><p id="r-445579" data-claire-element-id="445579">Voilà, vous savez tout à présent sur les claviers ;) .</p></td></tr></tbody></table><h3 id="r-correction-148" data-claire-element-id="445589">Correction</h3><p id="r-445585" data-claire-element-id="445585">Voici une correction parmi d'autres :) :</p><div id="r-445587" data-claire-element-id="445587"><pre id="r-445586" data-claire-element-id="445586"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

void defiler_clavier(int,int,int,int,int);

int main(int argc, char ** argv)
{
    int nombre,entre=0,i,compteur=0;
    char lettre;

    /*INITIALISATIONS*/
    PA_Init();

    PA_LoadDefaultText(1,0);
    PA_InitRand(); //On initialise le Rand
    PA_InitKeyboard(2); //On initialise le clavier sur le fond 2

    defiler_clavier(50,48,25,96,1); //Un défilement du clavier pour le faire apparaître, vous pouvez le changer
    nombre=PA_RandMinMax(1,100); //La variable nombre contient un nombre compris entre 1 et 100 inclus

    while(1) //Tant que le nombre entré par le joueur est différent de la variable nombre
    {
        PA_OutputText(1,0,0,&quot;Entrez un nombre entre 1 et 100 inclus :&quot;);
        lettre=PA_CheckKeyboard(); //On récupère la valeur numérique de l'entrée de l'utilisateur
        if(lettre&gt;='0'&amp;&amp;lettre&lt;='9'&amp;&amp;entre&lt;100) //Il faut que la touche pressée soit comprise entre 0 et 9 (et rien d'autre), et que le nombre entré soit inférieur à 100, car le nombre maximum est 100
        {
            entre*=10; //On décale tous les chiffres d'un cran vers la gauche (une dizaine)
            entre+=lettre-'0'; //On ajoute les nouvelles &quot;unités&quot;
        }
        else if(lettre==PA_BACKSPACE) //Si on appuie sur Backspace
            entre/=10; //On décale tous les chiffres d'un cran vers la droite
        else if(lettre=='\n') //Si on appuie sur l'équivalent de la touche Entrée
        {
            compteur++; //Le compteur de tentatives est augmenté
            PA_ClearTextBg(1); //On efface le texte de l'écran supérieur (celui où sont écrits tous les textes à afficher)
            if(entre&lt;nombre)
            {
                PA_OutputText(1,0,0,&quot;Le nombre %d est trop petit. Veuillez attendre 2 secondes...&quot;,entre);
                entre=0;
            }
            else if(entre&gt;nombre)
            {
                PA_OutputText(1,0,0,&quot;Le nombre %d est trop grand. Veuillez attendre 2 secondes...&quot;,entre);
                entre=0;
            }
            else
                break;
            for(i=0;i&lt;120;i++)
                PA_WaitForVBL(); //On attend 2 secondes
        }
        if(entre!=0) //On écrit pas le nombre s'il est &quot;vide&quot;
            PA_OutputText(1,0,3,&quot;%d&quot;,entre); //On laisse le nombre affiché
        PA_WaitForVBL();
        PA_ClearTextBg(1); //On efface l'écran supérieur
    }
    PA_OutputText(1,0,0,&quot;Bravo ! Vous avez réussi à trouver le nombre %d en %d tentative%s !&quot;,entre,compteur-1,compteur-1&lt;2?&quot;&quot;:&quot;s&quot;); //Ternaire pour vérifier si, en fonction de compteur-1, on doit mettre du singulier ou du pluriel. Et je mets compteur-1 car je fais cadeau de la bonne tentative
    PA_KeyboardOut(); //On range notre clavier

    while(1)
        PA_WaitForVBL();

    return 0;
}

void defiler_clavier(int x,int y,int x1,int y1,int nvbl)
{
    /*Le clavier va de (x;y) à (x1;y1) avec nvbl VBL pour chaque étape du déplacement*/
    int i=0;
    PA_ScrollKeyboardXY(x,y); //On met le clavier à la position (x;y)
    while(1)
    {
        /*On se rapproche des coordonnées (x1;y1)*/
        if(x&lt;x1)
            x++;
        else if(x&gt;x1)
            x--;
        if(y&lt;y1)
            y++;
        else if(y&gt;y1)
            y--;
        if(x==x1&amp;&amp;y==y1)
            break;
        PA_ScrollKeyboardXY(x,y); //On replace le clavier à la nouvelle position
        /*On attend en fonction du nombre de VBL donné par la variable nvbl*/
        for(i=0;i&lt;nvbl;i++)
            PA_WaitForVBL();
    }
}</code></pre></div><p id="r-445588" data-claire-element-id="445588"><strong>Merci à <a href="http://www.siteduzero.com/membres-294-245415.html">daminator</a> pour son optimisation du code !</strong></p><h3 id="r-ameliorations-24" data-claire-element-id="445601">Améliorations</h3><p id="r-445590" data-claire-element-id="445590">On peut :</p><ul id="r-445596" data-claire-element-id="445596"><li id="r-445592" data-claire-element-id="445592"><p id="r-445591" data-claire-element-id="445591">créer plusieurs niveaux de jeu ;</p></li><li id="r-445595" data-claire-element-id="445595"><p id="r-445593" data-claire-element-id="445593">créer une aide qui réagit en fonction du nombre à trouver et du nombre entré par l'utilisateur comme ceci, par exemple :</p><pre id="r-445594" data-claire-element-id="445594"><code data-claire-semantic="console">Le nombre à trouver se trouve entre %d et %d.</code></pre></li></ul><p id="r-445597" data-claire-element-id="445597">On va créer plusieurs niveaux de jeu ^^ . Ce sera utile pour la suite... Ça déborde un peu sur la deuxième partie mais ce n'est pas grave, on va faire un menu très léger. On a 3 choix : un nombre entre 1 et 100 ; entre 1 et 500 et enfin entre 1 et 1000.<br/> Le choix courant sera en rouge par exemple, et les autres seront écrits dans la couleur par défaut.<br/> Bien sûr, il faudra créer une variable <em>max</em> qui sera affichée pour <code data-claire-semantic="console">Entrez un nombre entre 1 et [...] inclus</code>.<br/> Le mieux est de créer 2 boucles (une pour le menu, l'autre pour le jeu).<br/> Voilà, vous avez assez de renseignements pour le coder tout seul ^^ .<br/> Mais voici mon amélioration ^^ :</p><div id="r-445599" data-claire-element-id="445599"><pre id="r-445598" data-claire-element-id="445598"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

void defiler_clavier(int,int,int,int,int);

int main(int argc, char ** argv)
{
    int nombre,entre=0,i,compteur=0,max,menu=0;
    char lettre;

    PA_Init();

    PA_LoadDefaultText(1,0);
    PA_InitRand();

    //Boucle de menu
    while(!Pad.Held.A&amp;&amp;!Pad.Held.Start)
    {
        switch(menu)
        {
            case 0:
                PA_OutputText(1,5,9,&quot;%c11 -&gt; Entre 1 et 100&quot;);
                PA_OutputText(1,5,11,&quot;2 -&gt; Entre 1 et 500&quot;);
                PA_OutputText(1,5,13,&quot;3 -&gt; Entre 1 et 1000&quot;);
                break;
            case 1:
                PA_OutputText(1,5,9,&quot;1 -&gt; Entre 1 et 100&quot;);
                PA_OutputText(1,5,11,&quot;%c12 -&gt; Entre 1 et 500&quot;);
                PA_OutputText(1,5,13,&quot;3 -&gt; Entre 1 et 1000&quot;);
                break;
            default:
                PA_OutputText(1,5,9,&quot;1 -&gt; Entre 1 et 100&quot;);
                PA_OutputText(1,5,11,&quot;2 -&gt; Entre 1 et 500&quot;);
                PA_OutputText(1,5,13,&quot;%c13 -&gt; Entre 1 et 1000&quot;);
                break;
        }
        menu+=Pad.Newpress.Down-Pad.Newpress.Up;
        if(menu&lt;0)
            menu=2;
        else if(menu&gt;2)
            menu=0;
        PA_WaitForVBL();
        PA_ClearTextBg(1);
    }

    switch(menu)
    {
        case 0:
            nombre=PA_RandMinMax(1,100);
            max=100;
            break;
        case 1:
            nombre=PA_RandMinMax(1,500);
            max=500;
            break;
        default: //Il est bon de mettre un defalut, car si le choix n'est pas 3 (un bug ou alors un problème dans le code), une valeur est quand-même attribuée à nombre et à max. De plus, pour être désolé de ce problème, la valeur par défaut est celle comprise entre 1 et 1000 ! *rire sadique*
            nombre=PA_RandMinMax(1,1000);
            max=1000;
            break;
    }

    PA_InitKeyboard(2);
    defiler_clavier(50,48,25,96,1);

    //Boucle du jeu
    while(1)
    {
        PA_OutputText(1,0,0,&quot;Entrez un nombre entre 1 et %d inclus :&quot;,max);
        lettre=PA_CheckKeyboard();
        if(lettre&gt;='0'&amp;&amp;lettre&lt;='9'&amp;&amp;entre&lt;=max)
        {
            entre*=10;
            entre+=lettre-'0';
        }
        else if(lettre==PA_BACKSPACE)
            entre/=10;
        else if(lettre=='\n') 
        {
            compteur++;
            PA_ClearTextBg(1);
            if(entre&lt;nombre)
            {
                PA_OutputText(1,0,0,&quot;Le nombre %d est trop petit. Veuillez attendre 2 secondes...&quot;,entre);
                entre=0;
            }
            else if(entre&gt;nombre)
            {
                PA_OutputText(1,0,0,&quot;Le nombre %d est trop grand. Veuillez attendre 2 secondes...&quot;,entre);
                entre=0;
            }
            else
                break;
            for(i=0;i&lt;120;i++)
                PA_WaitForVBL();
        }
        if(entre!=0)
            PA_OutputText(1,0,3,&quot;%d&quot;,entre);
        PA_WaitForVBL();
        PA_ClearTextBg(1); //On efface l'écran supérieur
    }
    PA_OutputText(1,0,0,&quot;Bravo ! Vous avez réussi à trouver le nombre %d en %d tentative%s !&quot;,entre,compteur-1,compteur-1&lt;2?&quot;&quot;:&quot;s&quot;);
    PA_KeyboardOut(); //On range notre clavier

    while(1)
        PA_WaitForVBL();

    return 0;
}

void defiler_clavier(int x,int y,int x1,int y1,int nvbl)
{
    int i=0;
    PA_ScrollKeyboardXY(x,y);
    while(1)
    {
        if(x&lt;x1)
            x++;
        else if(x&gt;x1)
            x--;
        if(y&lt;y1)
            y++;
        else if(y&gt;y1)
            y--;
        if(x==x1&amp;&amp;y==y1)
            break;
        PA_ScrollKeyboardXY(x,y);
        for(i=0;i&lt;nvbl;i++)
            PA_WaitForVBL();
    }
}</code></pre></div><p id="r-445600" data-claire-element-id="445600">Voilà, vous avez assez de bases maintenant pour faire de petits jeux en console sur votre Nintendo DS !</p><h2 id="r-la-2d-de-base" data-claire-element-id="445741">La 2D de base</h2><p id="r-445603" data-claire-element-id="445603">Les jeux de DS sont autre chose que des écrans noirs :lol: . Nous allons donc apprendre, à ce stade, à créer des arrière-plans et des sprites.</p><div id="r-445605" data-claire-element-id="445605" data-claire-semantic="question"><p id="r-445604" data-claire-element-id="445604">Et pourquoi pas des Coca-Cola ? :-°</p></div><p id="r-445606" data-claire-element-id="445606">Les sprites ne se boivent pas, mais ce sont des images comme celle du personnage principal d'un jeu, par exemple.</p><h3 id="r-outils-necessaires" data-claire-element-id="445611">Outils nécessaires</h3><p id="r-445607" data-claire-element-id="445607">On va travailler en 2D.<br/> Pour cela, rendez-vous dans <strong>devkitpro\PAlib\Tools\PAGfx</strong> et copiez <em>PAGfx.exe</em>.</p><p id="r-445608" data-claire-element-id="445608">Allez dans le dossier de votre jeu et créez-y un répertoire nommé <strong>gfx</strong> et copiez-y l'exécutable. Dans ce même dossier, créez un fichier nommé <em>PAGfx.ini</em>, il contiendra les instructions pour convertir vos images.</p><aside id="r-445610" data-claire-element-id="445610" data-claire-semantic="information"><p id="r-445609" data-claire-element-id="445609">Si vous êtes sous Linux, il faut aller dans <strong>devkitpro\PAlib\Tools\PAGfx - Linux</strong> et décompresser <em>PAGfx - Linux.tar.gz</em>.</p></aside><h3 id="r-syntaxe-du-fichier-pagfx-ini" data-claire-element-id="445626">Syntaxe du fichier <em>PAGfx.ini</em></h3><p id="r-445612" data-claire-element-id="445612">Ce fichier doit être composé de 3 parties commençant par un dièse (<strong>#</strong>) :</p><ul id="r-445619" data-claire-element-id="445619"><li id="r-445614" data-claire-element-id="445614"><p id="r-445613" data-claire-element-id="445613">Couleur transparente (#TranspColor NomDeLaCouleur). La couleur transparente que nous utiliserons toujours est Magenta (#TranspColor Magenta). Sa valeur RGB est 255 ; 0 ; 255.</p></li><li id="r-445616" data-claire-element-id="445616"><p id="r-445615" data-claire-element-id="445615">Sprites (dessins) : #Sprites :. Pour ajouter des sprites, il suffit d'aller à la ligne après cette démarquation et de faire cette syntaxe : <br/><strong>nom_du_sprite.extension 256colors nom_du_futur_fichier_contenant_le_sprite</strong>. Nom_du_sprite.extension est votre image. 256colors est le maximum pour des sprites, pour avoir un rendu excellent. Nom_du_futur_fichier_contenant_le_sprite est le fichier que PAGfx.exe créera. Vous pouvez mettre plusieurs sprites dedans.</p></li><li id="r-445618" data-claire-element-id="445618"><p id="r-445617" data-claire-element-id="445617">Arrière-plans (#Backgrounds :). Pour ajouter des arrière-plans, il suffit d'aller à la ligne après cette démarquation et de faire cette syntaxe : <strong>nom_de_l_arriere_plan.extension type_d_arriere_plan</strong>. Nom_de_l_arriere_plan.extension est l'image que vous avez créée. Type_d_arriere_plan déterminera le code source (que nous apprendrons plus tard) :<br/> -<strong>EasyBg</strong> : arrière-plan aux dimensions de l'écran (256*192) ou plus, peut subir un défilement<br/> -<strong>LargeMap</strong> : arrière-plan aux grandes dimensions (les plus courantes sont 1024*1024), surtout utilisé pour les DualBackgrounds (arrière-plan sur les deux écrans simultanément o_O )<br/> -<strong>TileBg</strong> : arrière-plan principalement utilisé pour les polices, composé d'une multitude de &quot;tuiles&quot; (tiles) de 8*8<br/> -<strong>RotBg</strong> : arrière-plan utilisé pour être tourné dans tous les sens, pour subir des zooms, voire même de la 3D :) .</p></li></ul><p id="r-445620" data-claire-element-id="445620">Exemple de PAGfx.ini :</p><p id="r-445621" data-claire-element-id="445621"><cite>Citation</cite></p><blockquote id="r-445625" data-claire-element-id="445625"><p id="r-445622" data-claire-element-id="445622">#TranspColor Magenta</p><p id="r-445623" data-claire-element-id="445623">#Sprites :<br/> hero.PNG 256colors sprites<br/> jouer.PNG 256colors sprites<br/> njeu.PNG 256colors sprites<br/> fleche.PNG 256colors sprites<br/> oui.PNG 256colors sprites<br/> non.PNG 256colors sprites</p><p id="r-445624" data-claire-element-id="445624">#Backgrounds :<br/> newfont.GIF TileBg<br/> fontscreen1.GIF TileBg<br/> bg_menu.PNG LargeMap<br/> bg1.PNG LargeMap<br/> confirmer.PNG EasyBg</p></blockquote><h3 id="r-les-arriere-plans" data-claire-element-id="445630">Les arrière-plans</h3><p id="r-445627" data-claire-element-id="445627">On va s'attaquer aux arrière-plans. :pirate: <br/> Après avoir utilisé PAGfx, il faut coder (on est bien là pour ça :lol: ).<br/> Au code minimal, il faut rajouter, dans la partie des includes :</p><pre id="r-445628" data-claire-element-id="445628"><code data-claire-semantic="c">#include &quot;all_gfx.h&quot;</code></pre><p id="r-445629" data-claire-element-id="445629">Ce simple header permet d'inclure les images que vous avez faites auparavant.</p><h3 id="r-code-pour-easybg" data-claire-element-id="445642">Code pour EasyBg</h3><p id="r-445631" data-claire-element-id="445631">Voici la fonction PA_LoadBackground :</p><pre id="r-445632" data-claire-element-id="445632"><code data-claire-semantic="c">void PA_LoadBackground(u8 ecran,u8 numero_bg,const PA_BgStruct* nom_bg);</code></pre><aside id="r-445634" data-claire-element-id="445634" data-claire-semantic="information"><p id="r-445633" data-claire-element-id="445633">Nom_bg est le nom de votre image sans l'extension.</p></aside><pre id="r-445635" data-claire-element-id="445635"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &quot;all_gfx.h&quot;
 
int main (int argc, char **argv)
{
    PA_Init();
    
    PA_LoadBackground(0,1,&amp;bg);

    while (1)
    {
        PA_WaitForVBL();
    }
   
    return 0;
}</code></pre><p id="r-445636" data-claire-element-id="445636">Nous allons nous amuser à faire défiler l'arrière-plan (scroll). Voici le prototype de la fonction <strong>PA_EasyBgScrollXY</strong> :</p><pre id="r-445637" data-claire-element-id="445637"><code data-claire-semantic="c">void PA_EasyBgScrollXY(u8 ecran,u8 numero_bg,s32 x,s32 y);</code></pre><p id="r-445638" data-claire-element-id="445638">Voici le code pour un petit défilement :</p><pre id="r-445639" data-claire-element-id="445639"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &quot;all_gfx.h&quot;
 
int main (int argc, char **argv)
{
    int scrollx=0,scrolly=0;
    PA_Init();
    
    PA_LoadBackground(0,1,&amp;bg);
    while (1)
    {
        scrollx++;
        scrolly++;
        PA_EasyBgScrollXY(0,1,scrollx,scrolly);
        PA_WaitForVBL();
    }
    return 0;
}</code></pre><aside id="r-445641" data-claire-element-id="445641" data-claire-semantic="warning"><p id="r-445640" data-claire-element-id="445640">Si votre défilement dépasse les dimensions de l'arrière-plan, vous aurez un drôle de rendu :lol: !</p></aside><h3 id="r-code-pour-tilebg-seulement-pour-les-polices" data-claire-element-id="445648">Code pour TileBg (seulement pour les polices)</h3><p id="r-445643" data-claire-element-id="445643">Voici la fonction de <strong>PA_LoadText</strong> :</p><pre id="r-445644" data-claire-element-id="445644"><code data-claire-semantic="c">void PA_LoadText(u8 ecran, u8 numero_bg, const PA_BgStruct* police);</code></pre><pre id="r-445645" data-claire-element-id="445645"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &quot;all_gfx.h&quot;
 
int main(int argc, char ** argv)
{
    PA_Init();
        
    PA_LoadText(1,0,&amp;police);
    PA_OutputText(1,0,0,&quot;Pas mal, la nouvelle police :) &quot;);
    while (1)
    {
        PA_WaitForVBL();
    }
    return 0;
}</code></pre><aside id="r-445647" data-claire-element-id="445647" data-claire-semantic="warning"><p id="r-445646" data-claire-element-id="445646">Gardez en tête qu'il n'y a que 4 couches d'arrière-plans disponibles (de 0 à 3) !</p></aside><h3 id="r-les-sprites-3" data-claire-element-id="445651">Les sprites</h3><p id="r-445649" data-claire-element-id="445649">A présent, passons aux sprites.<br/> Il faut toujours inclure :</p><pre id="r-445650" data-claire-element-id="445650"><code data-claire-semantic="c">#include &quot;all_gfx.h&quot;</code></pre><h3 id="r-code-pour-sprites-standards" data-claire-element-id="445740">Code pour sprites standards</h3><p id="r-445652" data-claire-element-id="445652">Tout d'abord, il faut charger la palette de sprites. On va utiliser cette fonction :</p><pre id="r-445653" data-claire-element-id="445653"><code data-claire-semantic="c">void PA_LoadSpritePal(u8 ecran,u8 numero_palette,(void*)fichier_palette_cree_par_PAGfx);</code></pre><div id="r-445655" data-claire-element-id="445655" data-claire-semantic="question"><p id="r-445654" data-claire-element-id="445654">Mais comment connaître Fichier_palette_cree_par_PAGfx ?</p></div><p id="r-445656" data-claire-element-id="445656">C'est simple, supposons que votre PAGfx.ini comporte :</p><p id="r-445657" data-claire-element-id="445657"><cite>Citation</cite></p><blockquote id="r-445661" data-claire-element-id="445661"><p id="r-445658" data-claire-element-id="445658">#TranspColor Magenta</p><p id="r-445659" data-claire-element-id="445659">#Sprites :<br/> mario.PNG 256colors <strong>sprites</strong><br/> wario.PNG 256colors <strong>sprites</strong></p><p id="r-445660" data-claire-element-id="445660">#Backgrounds :</p></blockquote><p id="r-445662" data-claire-element-id="445662">Le troisième mot est la palette. Pour le code, il suffit de rajouter _Pal.<br/> Ce qui donne :</p><pre id="r-445663" data-claire-element-id="445663"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &quot;all_gfx.h&quot;
 
int main(int argc, char ** argv)
{
    PA_Init();
 
    PA_LoadSpritePal(0,0,(void*)sprites_Pal);
 
    while(1)
    {
        PA_WaitForVBL();
    }
    return 0;
}</code></pre><p id="r-445664" data-claire-element-id="445664">Et maintenant, on va créer le sprite avec <strong>PA_CreateSprite</strong> :</p><pre id="r-445665" data-claire-element-id="445665"><code data-claire-semantic="c">void PA_CreateSprite(u8 ecran,u8 numero_sprite,(void*)nom_sprite_cree_par_PAGfx,u8 forme,u8 taille,u8 mode_couleurs,u8 palette,s16 position_x,s16 position_y);</code></pre><p id="r-445666" data-claire-element-id="445666">Pour obtenir Nom_sprite_cree_par_PAGfx, il faut regarder ça dans PAGfx.ini :</p><p id="r-445667" data-claire-element-id="445667"><cite>Citation</cite></p><blockquote id="r-445671" data-claire-element-id="445671"><p id="r-445668" data-claire-element-id="445668">#TranspColor Magenta</p><p id="r-445669" data-claire-element-id="445669">#Sprites :<br/><strong>mario</strong>.PNG 256colors sprites<br/><strong>wario</strong>.PNG 256colors sprites</p><p id="r-445670" data-claire-element-id="445670">#Backgrounds :</p></blockquote><p id="r-445672" data-claire-element-id="445672">Il s'agit en fait du nom des images sans l'extension.<br/> À ces noms, il faut rajouter _Sprite.<br/> Il y a plusieurs tailles différentes (variables <em>forme</em> et <em>taille</em>), voici la liste <strong>complète</strong> :</p><ul id="r-445697" data-claire-element-id="445697"><li id="r-445674" data-claire-element-id="445674"><p id="r-445673" data-claire-element-id="445673">OBJ_SIZE_8X8 : pour un sprite de 8*8 :)</p></li><li id="r-445676" data-claire-element-id="445676"><p id="r-445675" data-claire-element-id="445675">OBJ_SIZE_16X16</p></li><li id="r-445678" data-claire-element-id="445678"><p id="r-445677" data-claire-element-id="445677">OBJ_SIZE_32X32</p></li><li id="r-445680" data-claire-element-id="445680"><p id="r-445679" data-claire-element-id="445679">OBJ_SIZE_64X64</p></li><li id="r-445682" data-claire-element-id="445682"><p id="r-445681" data-claire-element-id="445681">OBJ_SIZE_16X8</p></li><li id="r-445684" data-claire-element-id="445684"><p id="r-445683" data-claire-element-id="445683">OBJ_SIZE_32X8</p></li><li id="r-445686" data-claire-element-id="445686"><p id="r-445685" data-claire-element-id="445685">OBJ_SIZE_32X16</p></li><li id="r-445688" data-claire-element-id="445688"><p id="r-445687" data-claire-element-id="445687">OBJ_SIZE_64X32</p></li><li id="r-445690" data-claire-element-id="445690"><p id="r-445689" data-claire-element-id="445689">OBJ_SIZE_8X16</p></li><li id="r-445692" data-claire-element-id="445692"><p id="r-445691" data-claire-element-id="445691">OBJ_SIZE_8X32</p></li><li id="r-445694" data-claire-element-id="445694"><p id="r-445693" data-claire-element-id="445693">OBJ_SIZE_16X32</p></li><li id="r-445696" data-claire-element-id="445696"><p id="r-445695" data-claire-element-id="445695">OBJ_SIZE_32X64</p></li></ul><aside id="r-445699" data-claire-element-id="445699" data-claire-semantic="warning"><p id="r-445698" data-claire-element-id="445698">Les constantes OBJ_SIZE_[...]X[...] remplacent les arguments <em>forme</em> et <em>taille</em>. Vous n'avez donc plus 9 mais 8 arguments à fournir.</p></aside><div id="r-445701" data-claire-element-id="445701" data-claire-semantic="question"><p id="r-445700" data-claire-element-id="445700">Et si mon image faisait 20*10 ? Il n'existe pas de constante adaptée...</p></div><p id="r-445702" data-claire-element-id="445702">Il suffit de prendre la constante qui est juste au-dessus de la valeur (hauteur ou largeur) la plus grande. Ici, 20 est la plus grande valeur, donc il faudra créer un sprite de 32*16, et les pixels qui ne seront pas utilisés (après 20 dans les x et après 10 dans les y) devront être de la couleur transparente définie dans PAGfx.ini.</p><div id="r-445704" data-claire-element-id="445704" data-claire-semantic="question"><p id="r-445703" data-claire-element-id="445703">Gnein ? o_O</p></div><p id="r-445705" data-claire-element-id="445705">Bon, je vais faire une image :</p><figure id="r-445707" data-claire-element-id="445708"><img id="r-445706" data-claire-element-id="445706" src="medias/uploads.siteduzero.com_files_109001_110000_109273.png" alt="Image utilisateur"/></figure><p id="r-445709" data-claire-element-id="445709">C'est un rectangle de 20*10, qui doit être mis en 32*16 ou plus.</p><div id="r-445711" data-claire-element-id="445711" data-claire-semantic="question"><p id="r-445710" data-claire-element-id="445710">Et si une des valeurs de mon image dépassait 64 ?</p></div><p id="r-445712" data-claire-element-id="445712">Vous avez trois solutions :</p><ul id="r-445719" data-claire-element-id="445719"><li id="r-445714" data-claire-element-id="445714"><p id="r-445713" data-claire-element-id="445713">Réduire l'image en format 64*64 (en conservant le ratio largeur/hauteur, mais la qualité diminuera).</p></li><li id="r-445716" data-claire-element-id="445716"><p id="r-445715" data-claire-element-id="445715">Le transformer en arrière-plan (plus rare, mais possible).</p></li><li id="r-445718" data-claire-element-id="445718"><p id="r-445717" data-claire-element-id="445717">Mettre plusieurs sprites côte à côte contenant chacun un morceau de l'image et la reconstituant une fois regroupés (pas très conseillé car il n'y a que 128 sprites disponibles par écran).</p></li></ul><p id="r-445720" data-claire-element-id="445720">Ensuite, mode_couleur peut prendre deux valeurs : soit 0 ; soit 1.</p><div id="r-445722" data-claire-element-id="445722" data-claire-semantic="question"><p id="r-445721" data-claire-element-id="445721">Mais comment on fait pour savoir s'il faut mettre 1 ou 0 ?</p></div><p id="r-445723" data-claire-element-id="445723">Il faut regarder :</p><p id="r-445724" data-claire-element-id="445724"><cite>Citation</cite></p><blockquote id="r-445728" data-claire-element-id="445728"><p id="r-445725" data-claire-element-id="445725">#TranspColor Magenta</p><p id="r-445726" data-claire-element-id="445726">#Sprites :<br/> mario.PNG <strong>256colors</strong> sprites<br/> wario.PNG <strong>256colors</strong> sprites</p><p id="r-445727" data-claire-element-id="445727">#Backgrounds :</p></blockquote><p id="r-445729" data-claire-element-id="445729">Il faut mettre 1 pour 256 couleurs, et 0 pour 16 couleurs.<br/> Palette est le numéro de la palette (définie plus haut).<br/> Voici un code récapitulatif (avec notre rectangle :p ) :</p><pre id="r-445730" data-claire-element-id="445730"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &quot;all_gfx.h&quot;
 
int main(int argc, char ** argv)
{
    PA_Init();
 
    PA_LoadSpritePal(0,0,(void*)sprites_Pal);
    PA_CreateSprite(0,0,(void*)rectangle_Sprite,OBJ_SIZE_32X16,1,0,0,0);
    /* On crée un sprite sur l'écran tactile (0), son numéro est 0, c'est un sprite semblable à rectangle.png
       Vu qu'il fait 20*10, il faut le mettre en 32*16, 256 couleurs donc 1, utilise la palette 0, sa position dans
       les X est 0, comme dans les y. */
 
    while(1)
    {
        PA_WaitForVBL();
    }
    return 0;
}</code></pre><p id="r-445731" data-claire-element-id="445731">On peut changer les coordonnées d'un sprite avec <strong>PA_SetSpriteXY</strong> :</p><pre id="r-445732" data-claire-element-id="445732"><code data-claire-semantic="c">void PA_SetSpriteXY(ecran,numero_sprite,position_x,position_y);</code></pre><p id="r-445733" data-claire-element-id="445733">Voici un petit jeu :</p><pre id="r-445734" data-claire-element-id="445734"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &quot;gfx/all_gfx.h&quot;
 
int main(int argc, char ** argv)
{
    int x=100,y=100;
    PA_Init();
 
    PA_LoadSpritePal(0,0,(void*)sprites_Pal);
    PA_CreateSprite(0,0,(void*)rectangle_Sprite,OBJ_SIZE_32X16,1,0,0,0);
 
    while(1)
    {
        PA_SetSpriteXY(0,0,x,y);
        PA_WaitForVBL();
    }
    return 0;
}</code></pre><p id="r-445735" data-claire-element-id="445735">Si vous devez gérer une IA, et que chaque élément contrôlé par ordinateur (ou par vous) est le même, vous pouvez utiliser la macro <code data-claire-semantic="c">PA_CloneSprite(ecran,numero_du_sprite_a_creer,numero_du_sprite_qui_va_etre_cloné) </code> pour cloner le sprite que vous voulez. Ainsi, si vous faites <code data-claire-semantic="c">PA_CloneSprite(0,1,0); </code>, vous créerez, dans l'écran 0, un clone du sprite 0 ayant pour numéro 1.<br/> Vous pouvez aussi libérer la mémoire en détruisant des sprites qui ne servent plus à rien avec :</p><pre id="r-445736" data-claire-element-id="445736"><code data-claire-semantic="c">void PA_DeleteSprite(u8 ecran,u8 numero_sprite);</code></pre><aside id="r-445738" data-claire-element-id="445738" data-claire-semantic="warning"><p id="r-445737" data-claire-element-id="445737">Il ne peut y avoir que 128 sprites sur chaque écran, donc à vous de les utiliser à bon escient...</p></aside><p id="r-445739" data-claire-element-id="445739">C'était un gros chapitre, qui pose les bases de la 2D, le suivant nous permettra de découvrir d'autres fonctions et utilités de la 2D ! :)</p><h2 id="r-la-2d-avancee" data-claire-element-id="445759">La 2D avancée</h2><p id="r-445742" data-claire-element-id="445742">Nous allons voir comment créer des sprites qui vont sur les deux écrans (DualSprites), des sprites animés, des arrière-plans sur les deux écrans, ainsi que des rotations et des zooms.</p><h3 id="r-les-arriere-plans-1" data-claire-element-id="445757">Les arrière-plans</h3><p id="r-445743" data-claire-element-id="445743">Je savais que vous vous rueriez sur cette partie pour faire de jolis arrière-plans sur les deux écrans simultanément :p .<br/> De plus en plus de monde en raffole :) !<br/> Sachez que nous utiliserons toujours des LargeBg pour faire des arrière-plans sur les deux écrans...<br/> On va donc regarder la fonction <strong>PA_DualLoadBackground</strong> :</p><pre id="r-445744" data-claire-element-id="445744"><code data-claire-semantic="c">void PA_DualLoadBackground(u8 numero_bg, const PA_BgStruct* bg);</code></pre><aside id="r-445746" data-claire-element-id="445746" data-claire-semantic="information"><p id="r-445745" data-claire-element-id="445745">Notez qu'il n'y a pas besoin de préciser l'écran puisque cet arrière-plan sera sur les deux ! :)</p></aside><p id="r-445747" data-claire-element-id="445747">Voici un code complet :</p><pre id="r-445748" data-claire-element-id="445748"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &quot;all_gfx.h&quot;
 
int main (int argc, char **argv)
{
    PA_Init();
    
    PA_DualLoadBackground(1,&amp;bg);
    while (1)
    {
        PA_WaitForVBL();
    }
   
    return 0;
}</code></pre><p id="r-445749" data-claire-element-id="445749">Pour le faire défiler, c'est simple, on utilisera cette fonction :</p><pre id="r-445750" data-claire-element-id="445750"><code data-claire-semantic="c">void PA_DualEasyBgScrollXY(u8 bg_select, s32 x, s32 y);</code></pre><p id="r-445751" data-claire-element-id="445751">On en tirera donc ce code :</p><pre id="r-445752" data-claire-element-id="445752"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &quot;all_gfx.h&quot;
 
int main (int argc, char **argv)
{
    int scrollx=0,scrolly=0;
    PA_Init();
    
    PA_DualLoadBackground(1,bg);
    while (1)
    {
        scrollx++;
        scrolly++;
        PA_DualEasyBgScrollXY(1,scrollx,scrolly);
        PA_WaitForVBL();
    }
   
    return 0;
}</code></pre><p id="r-445753" data-claire-element-id="445753">Vous pouvez aussi modifier le nombre de pixels de décalage (dans les y) entre les deux écrans avec :</p><pre id="r-445754" data-claire-element-id="445754"><code data-claire-semantic="c">void PA_SetScreenSpace(s16 nombre_de_pixels);</code></pre><p id="r-445755" data-claire-element-id="445755">Si vous voulez inverser les deux écrans, vous pouvez utiliser :</p><pre id="r-445756" data-claire-element-id="445756"><code data-claire-semantic="c">void PA_SwitchScreens(void);</code></pre><h3 id="r-les-sprites-4" data-claire-element-id="445758">Les sprites</h3><h2 id="r-les-dualsprites" data-claire-element-id="445783">Les DualSprites</h2><p id="r-445760" data-claire-element-id="445760">Les sprites utilisables sur les deux écrans s'appellent les DualSprites.<br/> Pour les DualSprites, vous n'avez pas besoin d'utiliser une autre syntaxe que les sprites en ce qui concerne PAGfx.ini.</p><aside id="r-445762" data-claire-element-id="445762" data-claire-semantic="warning"><p id="r-445761" data-claire-element-id="445761">Avant tout, il faut que vous sachiez que chaque DualSprite alloue un sprite dans l'écran supérieur et un dans l'écran inférieur. Vous ne pouvez donc avoir que 128 DualSprites.</p></aside><p id="r-445763" data-claire-element-id="445763">D'abord, il faut charger la palette, mais à la différence des sprites normaux, on va utiliser <strong>PA_DualLoadSpritePal</strong> :</p><pre id="r-445764" data-claire-element-id="445764"><code data-claire-semantic="c">void PA_DualLoadSpritePal(u8 numero_palette,(void*)palette_cree_par_PAGfx);</code></pre><aside id="r-445766" data-claire-element-id="445766" data-claire-semantic="information"><p id="r-445765" data-claire-element-id="445765">Palette_cree_par_PAGfx s'obtient par la même méthode décrite dans la partie des sprites standards.</p></aside><aside id="r-445768" data-claire-element-id="445768" data-claire-semantic="information"><p id="r-445767" data-claire-element-id="445767">Remarquez qu'il ne faut pas mentionner l'écran puisque la palette s'appliquera sur les deux écrans simultanément.</p></aside><p id="r-445769" data-claire-element-id="445769">Pour charger un DualSprite, nous utiliserons <strong>PA_DualCreateSprite</strong> :</p><pre id="r-445770" data-claire-element-id="445770"><code data-claire-semantic="c">void PA_DualCreateSprite(u8 numero_sprite,(void*)sprite_cree_par_PAGfx,u8 forme,u8 taille,u8 mode_couleurs,u8 numero_palette,u8 position_x,u8 position_y);</code></pre><aside id="r-445772" data-claire-element-id="445772" data-claire-semantic="information"><p id="r-445771" data-claire-element-id="445771">Pour les DualSprites, les constantes OBJ_SIZE_[...]X[...] remplacent aussi les variables <em>forme</em> et <em>taille</em>.</p></aside><p id="r-445773" data-claire-element-id="445773">Voici un code complet :</p><pre id="r-445774" data-claire-element-id="445774"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &quot;all_gfx.h&quot;
 
int main(int argc, char ** argv)
{
    PA_Init();
 
    PA_DualLoadSpritePal(0,(void*)sprites_Pal);
    PA_DualCreateSprite(0,(void*)rectangle_Sprite,OBJ_SIZE_32X32,1,0,0,0);
 
    while(1)
    {
        PA_WaitForVBL();
    }
    return 0;
}</code></pre><p id="r-445775" data-claire-element-id="445775">Pour déplacer des DualSprites, on va utiliser <strong>PA_DualSetSpriteXY</strong> :</p><pre id="r-445776" data-claire-element-id="445776"><code data-claire-semantic="c">void PA_DualSetSpriteXY(u8 numero_sprite,s16 position_x,s16 position_y);</code></pre><p id="r-445777" data-claire-element-id="445777">Et un nouveau code ;) :</p><pre id="r-445778" data-claire-element-id="445778"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &quot;all_gfx.h&quot;
 
int main(int argc, char ** argv)
{
    int x=100,y=100;
    PA_Init();
 
    PA_DualLoadSpritePal(0,(void*)sprites_Pal);
    PA_DualCreateSprite(0,(void*)rectangle_Sprite,OBJ_SIZE_32X32,1,0,0,0);
 
    while(1)
    {
        y++;
        PA_DualSetSpriteXY(0,x,y);
        PA_WaitForVBL();
    }
    return 0;
}</code></pre><p id="r-445779" data-claire-element-id="445779">Vous pouvez cloner des DualSprites avec :</p><pre id="r-445780" data-claire-element-id="445780"><code data-claire-semantic="c">void PA_DualCloneSprite(u8 numero_sprite_a_creer,u8 numero_sprite_cloné);</code></pre><p id="r-445781" data-claire-element-id="445781">Ou encore les supprimer :</p><pre id="r-445782" data-claire-element-id="445782"><code data-claire-semantic="c">void PA_DualDeleteSprite(u8 numero_sprite);</code></pre><h2 id="r-les-animations-de-sprites" data-claire-element-id="445837">Les animations de Sprites</h2><h3 id="r-animations-de-sprites-standards" data-claire-element-id="445828">Animations de sprites standards</h3><p id="r-445784" data-claire-element-id="445784">Vous aurez sûrement besoin d'animer les sprites. Par exemple, si vous avez un personnage à faire marcher, il doit bouger :) !<br/> Bon, pour cette partie, on va prendre notre joli rectangle ;) . L'animation sera la coloration de celui-ci.</p><div id="r-445786" data-claire-element-id="445786" data-claire-semantic="question"><p id="r-445785" data-claire-element-id="445785">Mais comment on va s'y prendre ?</p></div><p id="r-445787" data-claire-element-id="445787">On va créer une planche de sprites. En fait, on va multiplier la hauteur l'image contenant notre sprite par le nombre de frames (état d'une animation). Si on veut faire 3 frames (rectangle jaune, rectangle rouge et rectangle noir), il faudra avoir créé un sprite de 32*96 (puisque 32*3=96).<br/> Voici notre planche de sprites (contenant 3 frames) :</p><figure id="r-445789" data-claire-element-id="445790"><img id="r-445788" data-claire-element-id="445788" src="medias/uploads.siteduzero.com_files_109001_110000_109373.png" alt="Image utilisateur"/></figure><ul id="r-445797" data-claire-element-id="445797"><li id="r-445792" data-claire-element-id="445792"><p id="r-445791" data-claire-element-id="445791">le rectangle jaune (0;0 -&gt; 32;32) est le frame 0 ;</p></li><li id="r-445794" data-claire-element-id="445794"><p id="r-445793" data-claire-element-id="445793">le rectangle rouge (0;32 -&gt; 32;64) est le frame 1 ;</p></li><li id="r-445796" data-claire-element-id="445796"><p id="r-445795" data-claire-element-id="445795">le rectangle noir (0;64 -&gt; 32;96) est le frame 2.</p></li></ul><p id="r-445798" data-claire-element-id="445798">Après avoir chargé la palette et le sprite, on va l'animer avec <strong>PA_StartSpriteAnim</strong> :</p><pre id="r-445799" data-claire-element-id="445799"><code data-claire-semantic="c">void PA_StartSpriteAnim(u8 ecran,u8 numero_sprite,s16 frame_de_depart,s16 frame_d_arrivee,s16 fps);</code></pre><p id="r-445800" data-claire-element-id="445800"><em>Fps</em> est le nombre de frames par seconde.<br/> Voici un code complet :</p><pre id="r-445801" data-claire-element-id="445801"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &quot;all_gfx.h&quot;
 
int main(int argc, char ** argv)
{
    PA_Init();
 
    PA_LoadSpritePal(0,0,(void*)sprites_Pal);
    PA_CreateSprite(0,0,(void*)rectangle_Sprite,OBJ_SIZE_32X32,1,0,0,0);
 
    PA_StartSpriteAnim(0,0,0,2,1);
    while(1)
    {
        PA_WaitForVBL();
    }
    return 0;
}</code></pre><p id="r-445802" data-claire-element-id="445802">Pour arrêter l'animation d'un sprite, on peut utiliser :</p><pre id="r-445803" data-claire-element-id="445803"><code data-claire-semantic="c">void PA_StopSpriteAnim(u8 ecran, u8 numero_sprite);</code></pre><p id="r-445804" data-claire-element-id="445804">Pour choisir le type d'animation, on peut utiliser :</p><pre id="r-445805" data-claire-element-id="445805"><code data-claire-semantic="c">void PA_StartSpriteAnimEx(u8 ecran, u8 numero_sprite, s16 frame_de_depart, s16 frame_d_arrivee, s16 fps, u8 type, s16 nombre_de_cycles);</code></pre><p id="r-445806" data-claire-element-id="445806">Les arguments sont les mêmes que <code data-claire-semantic="c">PA_StartSpriteAnim </code>, sauf que l'on rajoute <em>type</em> et <em>nombre_de_cycles</em>. La variable <em>type</em> est le type d'animation. Elle peut prendre pour valeur <em>ANIM_UPDOWN</em> (joue l'animation dans un sens puis dans l'autre) ou <em>ANIM_LOOP</em> (animation normale). La variable <em>nombre_de_cycles</em> correspond au nombre d'exécutions de l'animation. Elle peut prendre pour valeur -1 (infini) ou tout autre nombre positif (n boucles). Il y a une valeur spéciale, qui donne une valeur aux deux dernièrs paramètres (au lieu de 7 ; il n'y en a plus que 6 à fournir) : <em>ANIM_ONESHOT</em> (une seule fois), ce qui correspond à <em>ANIM_LOOP</em> pour <em>type</em> et à 1 pour <em>nombre_de_cycles</em>.</p><aside id="r-445808" data-claire-element-id="445808" data-claire-semantic="warning"><p id="r-445807" data-claire-element-id="445807">Pour une animation <em>ANIM_UPDOWN</em>, si vous voulez exécuter l'animation plusieurs fois, mais pas à l'infini (donc supérieur ou égal à 0), pour que votre animation soit complète, il faut que la varible <em>nombre_de_cycles</em> soit paire, car quand l'animation va dans un sens, 1 tour est fait, ainsi que lorsqu'elle va dans l'autre sens !</p></aside><p id="r-445809" data-claire-element-id="445809">Pour choisir l'image de l'animation à afficher, on utilise :</p><pre id="r-445810" data-claire-element-id="445810"><code data-claire-semantic="c">void PA_SetSpriteAnimFrame(u8 ecran, u8 numero_sprite, s16 frame);</code></pre><p id="r-445811" data-claire-element-id="445811">Où <em>frame</em> est le numéro de frame que l'on veut appliquer au sprite.</p><p id="r-445812" data-claire-element-id="445812">Pour savoir le numéro de frame courant d'un sprite, on utilise :</p><pre id="r-445813" data-claire-element-id="445813"><code data-claire-semantic="c">u16 PA_GetSpriteAnimFrame(u8 ecran, u8 numero_sprite);</code></pre><p id="r-445814" data-claire-element-id="445814">La valeur retournée est un <em>u16</em> !</p><p id="r-445815" data-claire-element-id="445815">Pour (re)définir la rapidité de l'animation d'un sprite, on peut utiliser :</p><pre id="r-445816" data-claire-element-id="445816"><code data-claire-semantic="c">void PA_SetSpriteAnimSpeed(u8 ecran, u8 numero_sprite, s16 fps);</code></pre><p id="r-445817" data-claire-element-id="445817">Pour obtenir le nombre de FPS de l'animation d'un sprite, on utilise :</p><pre id="r-445818" data-claire-element-id="445818"><code data-claire-semantic="c">u16 PA_GetSpriteAnimSpeed(u8 ecran, u8 numero_sprite)</code></pre><p id="r-445819" data-claire-element-id="445819">La valeur retournée est un <em>u16</em> !</p><p id="r-445820" data-claire-element-id="445820">Pour définir le nombre d'exécutions de l'animation d'un sprite, on utilise :</p><pre id="r-445821" data-claire-element-id="445821"><code data-claire-semantic="c">void PA_SetSpriteNCycles(u8 ecran, u8 numero_sprite, s16 numero_de_cycles);</code></pre><p id="r-445822" data-claire-element-id="445822">Pour obtenir le nombre d'exécutions restantes de l'animation d'un sprite, on peut utiliser :</p><pre id="r-445823" data-claire-element-id="445823"><code data-claire-semantic="c">u16 PA_GetSpriteNCycles(u8 ecran, u8 numero_sprite);</code></pre><p id="r-445824" data-claire-element-id="445824">La valeur retournée est un <em>u16</em> !</p><p id="r-445825" data-claire-element-id="445825">Pour mettre en pause ou reprendre l'animation d'un sprite, on utilise :</p><pre id="r-445826" data-claire-element-id="445826"><code data-claire-semantic="c">void PA_SpriteAnimPause(u8 ecran, u8 numero_sprite, u8 pause);</code></pre><p id="r-445827" data-claire-element-id="445827">La variable <em>pause</em> a une fonction de booléen, donc il faut mettre 1 pour mettre en pause ou 0 pour reprendre l'animation.</p><h3 id="r-animations-de-dualsprites" data-claire-element-id="445834">Animations de DualSprites</h3><p id="r-445829" data-claire-element-id="445829">Là aussi, il faut déjà avoir créé la DualPalette et le DualSprite. Ensuite, pour animer, c'est simple avec <strong>PA_DualStartSpriteAnim</strong> (non, ce n'est pas de la propagande :p ) :</p><pre id="r-445830" data-claire-element-id="445830"><code data-claire-semantic="c">void PA_DualStartSpriteAnim(u8 numero_sprite,s16 frame_de_depart,s16 frame_d_arrivee,s16 fps);</code></pre><p id="r-445831" data-claire-element-id="445831">Et voici notre dernier code complet :</p><pre id="r-445832" data-claire-element-id="445832"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &quot;all_gfx.h&quot;
 
int main(int argc, char ** argv)
{
    PA_Init();
 
    PA_DualLoadSpritePal(0,(void*)sprites_Pal);
    PA_DualCreateSprite(0,(void*)rectangle_Sprite,OBJ_SIZE_32X32,1,0,0,0);
 
    PA_DualStartSpriteAnim(0,0,2,1);
    while(1)
    {
        PA_WaitForVBL();
    }
    return 0;
}</code></pre><p id="r-445833" data-claire-element-id="445833">Toutes les fonctions énoncées pour les animations de sprites standards sont les mêmes avec les dualsprites sauf que l'on met <strong>Dual_</strong> devant et que l'on enlève le paramètre <em>ecran</em>.</p><h3 id="r-faire-des-rotations-et-des-zooms" data-claire-element-id="445836">Faire des rotations et des zooms</h3><p id="r-445835" data-claire-element-id="445835">Voilà : on a appris comment créer un sprite, charger sa palette, etc. mais on va s'attaquer aux techniques avancées des sprites : les rotations et les zooms :pirate: .</p><h2 id="r-les-rotations-1" data-claire-element-id="445879">Les rotations</h2><h3 id="r-les-arriere-plans-2" data-claire-element-id="445869">Les arrière-plans</h3><p id="r-445838" data-claire-element-id="445838">Pour les arrière-plans, il faut mettre le mode vidéo de la Nintendo DS en 2 sur l'écran tactile avec <code data-claire-semantic="c">PA_SetVideoMode(0,2); </code><br/> Ensuite, au lieu de charger normalement l'arrière-plan, on va utiliser la macro :</p><pre id="r-445839" data-claire-element-id="445839"><code data-claire-semantic="c">void PA_LoadPAGfxRotBg(ecran,numero_bg,nom_bg,taille)</code></pre><p id="r-445840" data-claire-element-id="445840">On connaît déjà à quoi correspondent les 3 premiers arguments, mais pas le dernier : <em>taille</em>. Il est défini par une autre macro. On distingue :</p><ul id="r-445849" data-claire-element-id="445849"><li id="r-445842" data-claire-element-id="445842"><p id="r-445841" data-claire-element-id="445841">BG_ROT_128X128 ;</p></li><li id="r-445844" data-claire-element-id="445844"><p id="r-445843" data-claire-element-id="445843">BG_ROT_256X256 ;</p></li><li id="r-445846" data-claire-element-id="445846"><p id="r-445845" data-claire-element-id="445845">BG_ROT_512X512 ;</p></li><li id="r-445848" data-claire-element-id="445848"><p id="r-445847" data-claire-element-id="445847">BG_ROT_1024X1024.</p></li></ul><p id="r-445850" data-claire-element-id="445850">Il n'en existe pas d'autre ! Il faut donc que votre arrière-plan soit à une de ces dimensions : 128*128 ; 256*256 ; 512*512 ou 1024*1024 pixels.<br/> Pour effectuer notre rotation (la fonction fait zoom aussi :-° ), nous allons utiliser :</p><pre id="r-445851" data-claire-element-id="445851"><code data-claire-semantic="c">void PA_SetBgRot(u8 ecran, u8 numero_bg, s32 defilement_x, s32 defilement_y, s32 defilement_centre_x, s32 defilement_centre_y, s16 angle, s32 zoom);</code></pre><p id="r-445852" data-claire-element-id="445852">La mesure d'un angle est comprise entre 0 et 511 inclus. Pour convertir des degrés en unités d'angle de palib, il faut les multiplier par 511 puis à les diviser par 360, c'est juste une question de proportionnalité !</p><div id="r-445854" data-claire-element-id="445854" data-claire-semantic="question"><p id="r-445853" data-claire-element-id="445853">Pourquoi avoir comme arguments <em>defilement_x</em>/<em>defilement_centre_x</em> et <em>defilement_y</em>/<em>defilement_centre_y</em> ? Les arguments <em>defilement_x</em> et <em>defilement_y</em> suffisent, non ?</p></div><p id="r-445855" data-claire-element-id="445855">Je vais vous expliquer avec des images. Supposons que nous ayons cette image comme arrière_plan :</p><p id="r-445856" data-claire-element-id="445856"><cite>Citation : Légende</cite></p><blockquote id="r-445858" data-claire-element-id="445858"><p id="r-445857" data-claire-element-id="445857">Rouge = <em>defilement_x</em><br/>Bleu = <em>defilement_y</em><br/>Vert = <em>defilement_centre_x</em><br/>Jaune = <em>defilement_centre_y</em></p></blockquote><figure id="r-445860" data-claire-element-id="445861"><img id="r-445859" data-claire-element-id="445859" src="medias/uploads.siteduzero.com_files_141001_142000_141752.png" alt="Image utilisateur"/></figure><p id="r-445862" data-claire-element-id="445862">Ensuite, voilà à quoi ça ressemble avec une rotation quelconque (par exemple 44°) :</p><figure id="r-445864" data-claire-element-id="445865"><img id="r-445863" data-claire-element-id="445863" src="medias/uploads.siteduzero.com_files_141001_142000_141756.png" alt="Image utilisateur"/></figure><p id="r-445866" data-claire-element-id="445866">Voilà, vous venez de vous rendre compte : malgré la rotation, <em>defilement_centre_x</em> et <em>defilement_centre_y</em> restent dans les mêmes axes, alors que <em>defilement_x</em> et <em>defilement_y</em> subissent la rotation de l'image...</p><p id="r-445867" data-claire-element-id="445867">Voici un exemple, avec la première image par exemple que vous pouvez renommer &quot;bg&quot; par exemple :</p><pre id="r-445868" data-claire-element-id="445868"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

#include &quot;gfx/all_gfx.c&quot;
#include &quot;gfx/all_gfx.h&quot;

int main(int argc, char ** argv)
{
    PA_Init();
    PA_InitVBL();
    
    PA_SetVideoMode(0, 2);

    PA_LoadPAGfxRotBg(0,3,bg,1);
    
    PA_InitText(1, 0);
   
    s32 scrollx = 0;
    s32 scrolly = 0;
    s32 rotcenterx = 0;
    s32 rotcentery = 0;
    s16 angle = 0;
    
    PA_OutputSimpleText(1, 2, 3, &quot;ScrollX    : Gauche/Droite&quot;);
    PA_OutputSimpleText(1, 2, 4, &quot;Scrolly    : Haut/Bas&quot;);
    PA_OutputSimpleText(1, 2, 5, &quot;RotCenterX : A/Y&quot;);
    PA_OutputSimpleText(1, 2, 6, &quot;RotCenterY : B/X&quot;);
    PA_OutputSimpleText(1, 2, 7, &quot;Angle      : R/L&quot;);


    while (1)
    {
        if(Pad.Held.Right)
            scrollx++;
        else if(Pad.Held.Left)
            scrollx--;
        else if(Pad.Held.Down)
            scrolly++;
        else if(Pad.Held.Up)
            scrolly--;
        else if(Pad.Held.A)
            rotcenterx++;
        else if(Pad.Held.Y)
            rotcenterx--;
        else if(Pad.Held.B)
            rotcentery++;
        else if(Pad.Held.X)
            rotcentery--;
        else if(Pad.Held.R)
            angle++;
        else if(Pad.Held.L)
            angle--;
        
        PA_SetBgRot(0, 3, scrollx, scrolly, rotcenterx, rotcentery, angle,256);

        PA_WaitForVBL();
    }
    
    return 0;
}</code></pre><h3 id="r-les-sprites-5" data-claire-element-id="445878">Les sprites</h3><p id="r-445870" data-claire-element-id="445870">Après avoir créé votre sprite, il faut dire que l'on veut faire tourner un sprite.<br/> On utilise :</p><pre id="r-445871" data-claire-element-id="445871"><code data-claire-semantic="c">void PA_SetSpriteRotEnable(ecran,sprite,rotset);</code></pre><p id="r-445872" data-claire-element-id="445872"><strong>ecran</strong> : le numéro de l'écran ;<br/><strong>sprite</strong> : le numéro du sprite ;<br/><strong>rotset</strong> : le numéro du rotset. Il doit être compris entre 0 et 31 inclus. Les sprites ayant le même numéro de rotset subiront la même rotation.</p><p id="r-445873" data-claire-element-id="445873">Ensuite pour effectuer la rotation on utilise :</p><pre id="r-445874" data-claire-element-id="445874"><code data-claire-semantic="c">void PA_SetRotsetNoZoom(u8 ecran, u8 rotset, s16 angle);</code></pre><p id="r-445875" data-claire-element-id="445875"><strong>angle</strong> : souvenez-vous que c'est la mesure d'un angle compris entre 0 et 511 inclus et que pour convertir des degrés en unités d'angle de palib, il faut les multiplier par 511 puis à les diviser par 360, c'est juste une question de proportionnalité ^^ .</p><p id="r-445876" data-claire-element-id="445876">Pour dire que l'on ne veut plus faire tourner un sprite, on utilise :</p><pre id="r-445877" data-claire-element-id="445877"><code data-claire-semantic="c">void PA_SetSpriteRotDisable(ecran, sprite);</code></pre><h2 id="r-les-zooms" data-claire-element-id="445924">Les zooms</h2><h3 id="r-les-arriere-plans-3" data-claire-element-id="445882">Les arrière-plans</h3><p id="r-445880" data-claire-element-id="445880">On a vu que la fonction qui fait des rotations d'arrière-plans fait aussi leur zoom.<br/> L'indice de zoom peut être de 256 : pas de zoom (zoom x1), de 512 : 2x plus petit (zoom x0.5), de 128 : 2x plus grand (zoom x2), etc.</p><pre id="r-445881" data-claire-element-id="445881"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

#include &quot;gfx/all_gfx.c&quot;
#include &quot;gfx/all_gfx.h&quot;

int main(int argc, char ** argv)
{
    PA_Init();
    PA_InitVBL();
    
    PA_SetVideoMode(0, 2);

    PA_LoadPAGfxRotBg(0,3,Rot,BG_ROT_256X256);
    
    PA_InitText(1, 0);
    
    s32 zoom=256;

    PA_OutputSimpleText(1, 2, 3, &quot;Zoom : Haut/Bas&quot;);

    while (1)
    {
        if(Pad.Held.Up)
            zoom--;
        else if(Pad.Held.Down)
            zoom++;
        
        PA_SetBgRot(0, 3,0,0,0,0, 0,zoom);

        PA_WaitForVBL();
    }
    
    return 0;
}</code></pre><h3 id="r-les-sprites-6" data-claire-element-id="445893">Les sprites</h3><aside id="r-445884" data-claire-element-id="445884" data-claire-semantic="information"><p id="r-445883" data-claire-element-id="445883">Pour dire que l'on veut faire ou arrêter les zooms, il faut utiliser les même macros que pour les rotations.</p></aside><p id="r-445885" data-claire-element-id="445885">Pour effectuer la rotation on utilise :</p><pre id="r-445886" data-claire-element-id="445886"><code data-claire-semantic="c">void PA_SetRotsetNoAngle(u8 ecran, u8 rotset, u16 zoomx, u16 zoomy);</code></pre><aside id="r-445890" data-claire-element-id="445890" data-claire-semantic="information"><p id="r-445887" data-claire-element-id="445887">Avec un zoom grandissant l'image, l'image est agrandie, mais pas sa taille. Si elle fait 16x16 à la base et que vous faites un zoom x2, vous aurez toujours un sprite de 16x16, mais avec l'image plus grosse donc seulement partielle ! Vous pouvez corriger ce problème avec :</p><pre id="r-445888" data-claire-element-id="445888"><code data-claire-semantic="c">void PA_SetSpriteDblsize(ecran, sprite, dblsize);</code></pre><p id="r-445889" data-claire-element-id="445889"><strong>dblsize</strong> : vaut 0 si on ne veut plus autoriser à doubler la taille du sprite et 1 si on veut la doubler en cas de zoom. Notez que la position du sprite change.</p></aside><p id="r-445891" data-claire-element-id="445891">Si vous voulez faire des rotations et des zooms en même temps, il faut dire que l'on veut faire des rotations comme décrit dans la partie sur les rotations et utiliser cette fonction raccourci :</p><pre id="r-445892" data-claire-element-id="445892"><code data-claire-semantic="c">void PA_SetRotset(u8 ecran, u8 rotset, s16 angle, u16 zoomx, u16 zoomy);</code></pre><h3 id="r-exercice-sortez-l-aspirine" data-claire-element-id="445895">Exercice : sortez l'Aspirine !</h3><p id="r-445894" data-claire-element-id="445894">On a accumulé beaucoup de connaissances en deux chapitres seulement ! Il est temps de les tester un faisant un petit jeu : le jeu de l'Aspirine...</p><h3 id="r-presentation-du-projet-2" data-claire-element-id="445897">Présentation du projet</h3><p id="r-445896" data-claire-element-id="445896">On va créer un jeu (très bête :lol: ), dans lequel le joueur va diriger une pastille effervescente (pour guérir vos maux de tête engendrés par cet exo :) ) uniquement pour aller à gauche ou à droite.<br/> Comme une vraie, elle devra descendre du haut de l'écran tactile et tomber au fond du verre (comme si on la lâchait dans un verre d'eau). Cette pastille dégagera des bulles de différentes tailles qui se dirigeront vers le haut (il y en a 255). Une fois toutes les bulles parties, la pastille remontera.</p><h3 id="r-notions-a-utiliser-et-preparatifs" data-claire-element-id="445909">Notions à utiliser et préparatifs</h3><aside id="r-445899" data-claire-element-id="445899" data-claire-semantic="information"><p id="r-445898" data-claire-element-id="445898">Les bulles partent de la pastille, mais de n'importe quel point dans ses abscisses. On va donc apprendre à créer des nombres aléatoires !</p></aside><p id="r-445900" data-claire-element-id="445900">Tout d'abord, on va apprendre à créer des nombres aléatoires. Il faut initialiser le système avec <strong>PA_InitRand();</strong> sinon les nombres que vous aurez seront les même ! En fait, PA_InitRand() se base sur l'heure de votre DS, il sera donc impossible de retrouver la même série de nombres.<br/> Ensuite, il existe trois fonctions pour trouver des nombres aléatoires (si vous avez fait le TP du Plus ou Moins, vous pouvez passer au paragraphe ci-dessous) :</p><ul id="r-445907" data-claire-element-id="445907"><li id="r-445902" data-claire-element-id="445902"><p id="r-445901" data-claire-element-id="445901"><strong>PA_Rand();</strong> mais cette fonction renvoie un nombre exorbitant :p ;</p></li><li id="r-445904" data-claire-element-id="445904"><p id="r-445903" data-claire-element-id="445903"><strong>PA_RandMax(max);</strong> sert à tirer un nombre entre 0 et <strong>max</strong> inclus ;</p></li><li id="r-445906" data-claire-element-id="445906"><p id="r-445905" data-claire-element-id="445905"><strong>PA_RandMinMax(min,max);</strong> sert à tirer un nombre entre <strong>min</strong> et <strong>max</strong> inclus.</p></li></ul><p id="r-445908" data-claire-element-id="445908">Ensuite, voici le dossier gfx : <a href="http://www.mediafire.com/?5tchtrb31rhru87">gfx.zip (100707)</a> ; <a href="http://www.mediafire.com/?frdaev2gkl6emlw">gfx.zip (080823)</a>.<br/> N'oubliez pas d'inclure all_gfx, de charger la palette, de créer les sprites...<br/> Je vous conseille de créer deux structures : la première pour la pastille et la deuxième pour les bulles.<br/> Créez un tableau pour les bulles.<br/> Définissez (à l'aide de defines) la largeur de l'écran (256), sa hauteur (192), la largeur et la hauteur de la pastille (regardez dans le fichier png), le diamètre maximal des bulles (6 ; elles sont toutes de largeur égale à la hauteur) et le nombre maximum de bulles.</p><h3 id="r-correction-149" data-claire-element-id="445913">Correction</h3><p id="r-445910" data-claire-element-id="445910">Voici ma correction :</p><div id="r-445912" data-claire-element-id="445912"><pre id="r-445911" data-claire-element-id="445911"><code data-claire-semantic="c">//INCLUDES
#include &lt;PA9.h&gt;

//IMAGES
#include &quot;all_gfx.h&quot;

//DEFINES
#define LARGEUR_ECRAN 256
#define HAUTEUR_ECRAN 192
#define MAX_BULLES 256
#define LARGEUR_PASTILLE 32
#define HAUTEUR_PASTILLE 9
#define DIAMETRE_BULLE 6

typedef struct
{
    int x,y;
    /*X : position dans les x de l'aspirine
    Y : position dans les y de l'aspirine*/
}pastille;

typedef struct
{
    int x,y,cree,tps_creation;
    /*X : position de la bulle dans les x
    Y : position de la bulle dans les y
    cree : sert à savoir si la bulle est créée et encore dans l'écran
    tps_creation : sert à savoir si une bulle n'est simplement pas créée ou si elle est sortie de l'écran*/
}bulle;

int main(int argc, char ** argv)
{
    int i , actionx=0, gravite=2, bulle_courante, nb_out=0, min=0, max=MAX_BULLES-1;
    /* i est le compteur général
    actionx sert à déterminer la direction de la pastille
    bulle_courante servira à créer les bulles
    nb_out compte le nombre de bulles sorties de l'écran
    min est le numéro de la première bulle pas créée
    max est le numéro de la dernière bulle pas créée*/
    pastille aspirine;
    bulle bubbles[MAX_BULLES];
    aspirine.x=(LARGEUR_ECRAN-LARGEUR_PASTILLE)/2; //ON LA CENTRE
    aspirine.y=0;
    for(i = 0; i &lt;MAX_BULLES ; i++)
    {
        bubbles[i].x=0;
        bubbles[i].y=0;
        bubbles[i].cree=0;
        bubbles[i].tps_creation=0;
    }
    PA_Init();
    PA_InitVBL();
    PA_InitRand();

    PA_LoadSpritePal(0,0,(void*)sprites_Pal);
    PA_CreateSprite(0,0,(void*)cachet_Sprite,OBJ_SIZE_32X32,1,0,aspirine.x,aspirine.y);
    for(i = 0; i &lt; MAX_BULLES - 1; i++)
    {
        PA_CreateSprite(0,i+1,(void*)bulle_Sprite,OBJ_SIZE_8X8,1,0,-8,-8);
        PA_StartSpriteAnim(0,i+1,PA_RandMax(2),0,0); //Bulle plus ou moins grosse
    }
    while (1)
    {
        aspirine.x+=Pad.Held.Right-Pad.Held.Left; //gestion des touches fléchées gauche et droite
        aspirine.y+=gravite; //gestion de la gravité
        if(nb_out==MAX_BULLES-1)
            gravite=-4; //si toutes les bulles sont parties
        nb_out=0;
        bulle_courante=PA_RandMinMax(min,max);
        if(!bubbles[bulle_courante].cree&amp;&amp;!bubbles[bulle_courante].tps_creation) //on crée une bulle si elle n'est pas créée
        {
            bubbles[bulle_courante].x=PA_RandMinMax(aspirine.x,aspirine.x+LARGEUR_PASTILLE-DIAMETRE_BULLE);
            bubbles[bulle_courante].y=aspirine.y;
            bubbles[bulle_courante].cree=1;
        }
        for(i=0;i&lt;MAX_BULLES-1;i++)
        {
            if(bubbles[i].cree)
            {
                actionx=PA_RandMax(1);
                if(!actionx)
                    bubbles[i].x--;
                else
                    bubbles[i].x++;
                if(bubbles[i].x&lt;0)
                    bubbles[i].x=0; //on ne dépasse pas de l'écran
                else if(bubbles[i].x+DIAMETRE_BULLE&gt;LARGEUR_ECRAN)
                    bubbles[i].x=LARGEUR_ECRAN-DIAMETRE_BULLE; //idem
                bubbles[i].y--; //les bulles remontent
                if(bubbles[i].y+DIAMETRE_BULLE&lt;0)
                    bubbles[i].cree=0; //si elle est sortie on la considère comme morte
                bubbles[i].tps_creation++; //son ancienneté augmente
                PA_SetSpriteXY(0,i+1,bubbles[i].x,bubbles[i].y); //on place la bulle
            }
            else
                nb_out++;//on augmente le nombre de bulles parties
        }
        for(i=0;i&lt;MAX_BULLES-1;i++) //on restreint le minimum à la première bulle non créée
        {
            if(!bubbles[i].cree &amp;&amp; !bubbles[i].tps_creation)
            {
                min=i;
                break;
            }
        }
        for(i=MAX_BULLES-1;i&gt;=0;i--) //on restreint le maximum à la dernière bulle non créée
        {
            if(!bubbles[i].cree &amp;&amp; !bubbles[i].tps_creation)
            {
                max=i;
                break;
            }
        }
        if(aspirine.x&lt;0)
            aspirine.x=0;//on ne dépasse pas de l'écran
        else if(aspirine.x+LARGEUR_PASTILLE&gt;LARGEUR_ECRAN)
            aspirine.x=LARGEUR_ECRAN-LARGEUR_PASTILLE;//on ne dépasse pas de l'écran
        if(aspirine.y+HAUTEUR_PASTILLE&lt;0) //Si la pastille est remontée, on arrête le jeu
        {
            PA_DeleteSprite(0,0);
            break;
        }
        else if(aspirine.y+HAUTEUR_PASTILLE&gt;HAUTEUR_ECRAN)
            aspirine.y=HAUTEUR_ECRAN-HAUTEUR_PASTILLE; //on ne passe pas sous l'écran
        PA_SetSpriteXY(0,0,aspirine.x,aspirine.y); //on place la pastille
        PA_WaitForVBL();
    }
    return 0;
}</code></pre></div><h3 id="r-amelioration-exercice" data-claire-element-id="445917">Amélioration (exercice)</h3><p id="r-445914" data-claire-element-id="445914">Pour notre première amélioration, on va mettre l'animation sur les deux écrans simultanément (pensez aux DualSprites !). N'oubliez pas d'enlever les indications d'écran pour les DualSprites !</p><aside id="r-445916" data-claire-element-id="445916" data-claire-semantic="warning"><p id="r-445915" data-claire-element-id="445915">Au début, la pastille, en tombant, doit traverser les deux écrans, donc le sol se trouve à l'équivalent de deux fois l'écran (192*2). Il faut aussi éditer l'espace entre les écrans sinon le sol sera 48 pixels plus haut (ou alors vous pouvez mettre le sol à 192*2+48) !</p></aside><h3 id="r-correction-de-l-amelioration" data-claire-element-id="445923">Correction de l'amélioration</h3><p id="r-445918" data-claire-element-id="445918">Voilà :</p><div id="r-445920" data-claire-element-id="445920"><pre id="r-445919" data-claire-element-id="445919"><code data-claire-semantic="c">//INCLUDES
#include &lt;PA9.h&gt;
 
//IMAGES
#include &quot;all_gfx.h&quot;
 
//DEFINES
#define LARGEUR_ECRAN 256
#define HAUTEUR_ECRAN 192
#define MAX_BULLES 128
#define LARGEUR_PASTILLE 32
#define HAUTEUR_PASTILLE 9
#define DIAMETRE_BULLE 6
 
typedef struct
{
    int x,y;
    /*X : position dans les x de l'aspirine
    Y : position dans les y de l'aspirine*/
}pastille;
 
typedef struct
{
    int x,y,cree,tps_creation;
    /*X : position de la bulle dans les x
    Y : position de la bulle dans les y
    cree : sert à savoir si la bulle est créée et encore dans l'écran
    tps_creation : sert à savoir si une bulle n'est simplement pas créée ou si elle est sortie de l'écran*/
}bulle;
 
int main(int argc, char ** argv)
{
    int i , actionx=0, gravite=2, bulle_courante, nb_out=0, min=0, max=MAX_BULLES-1;
    /* i est le compteur général
    actionx sert à déterminer la direction de la pastille
    bulle_courante servira à créer les bulles
    nb_out compte le nombre de bulles sorties de l'écran
    min est le numéro de la première bulle pas créée
    max est le numéro de la dernière bulle pas créée*/
    pastille aspirine;
    bulle bubbles[MAX_BULLES];
    aspirine.x=(LARGEUR_ECRAN-LARGEUR_PASTILLE)/2; //ON LA CENTRE
    aspirine.y=0;
    for(i=0;i&lt;MAX_BULLES;i++)
    {
        bubbles[i].x=0;
        bubbles[i].y=0;
        bubbles[i].cree=0;
        bubbles[i].tps_creation=0;
    }
    PA_Init();
    PA_InitVBL();
    PA_InitRand();
        
    PA_DualLoadSpritePal(0,(void*)sprites_Pal);
    PA_DualCreateSprite(0,(void*)cachet_Sprite,OBJ_SIZE_32X32,1,0,aspirine.x,aspirine.y);
    for(i=0;i&lt;MAX_BULLES-1;i++)
    {
        PA_DualCreateSprite(i+1,(void*)bulle_Sprite,OBJ_SIZE_8X8,1,0,-8,-8);
        PA_DualStartSpriteAnim(i+1,PA_RandMax(2),0,0); //Bulle plus ou moins grosse
    }
        PA_SetScreenSpace(0);
    while (1)
    {
        aspirine.x+=Pad.Held.Right-Pad.Held.Left; //gestion des touches fléchées gauche et droite
        aspirine.y+=gravite; //gestion de la gravité
        if(nb_out==MAX_BULLES-1)
            gravite=-4; //si toutes les bulles sont parties
        nb_out=0;
        bulle_courante=PA_RandMinMax(min,max);
        if(!bubbles[bulle_courante].cree&amp;&amp;!bubbles[bulle_courante].tps_creation) //on crée une bulle si elle n'est pas créée
        {
            bubbles[bulle_courante].x=PA_RandMinMax(aspirine.x,aspirine.x+LARGEUR_PASTILLE-DIAMETRE_BULLE);
            bubbles[bulle_courante].y=aspirine.y;
            bubbles[bulle_courante].cree=1;
        }
        for(i=0;i&lt;MAX_BULLES-1;i++)
        {
            if(bubbles[i].cree)
            {
                actionx=PA_RandMax(1);
                if(!actionx)
                    bubbles[i].x--;
                else
                    bubbles[i].x++;
                if(bubbles[i].x&lt;0)
                    bubbles[i].x=0; //on ne dépasse pas de l'écran
                else if(bubbles[i].x+DIAMETRE_BULLE&gt;LARGEUR_ECRAN)
                    bubbles[i].x=LARGEUR_ECRAN-DIAMETRE_BULLE; //idem
                bubbles[i].y--; //les bulles remontent
                if(bubbles[i].y+DIAMETRE_BULLE&lt;0)
                    bubbles[i].cree=0; //si elle est sortie on la considère comme morte
                bubbles[i].tps_creation++; //son ancienneté augmente
                PA_DualSetSpriteXY(i+1,bubbles[i].x,bubbles[i].y); //on place la bulle
            }
            else
                nb_out++;//on augmente le nombre de bulles parties
        }
        for(i=0;i&lt;MAX_BULLES-1;i++) //on restreint le minimum à la première bulle non créée
        {
            if(!bubbles[i].cree &amp;&amp; !bubbles[i].tps_creation)
            {
                min=i;
                break;
            }
        }
        for(i=MAX_BULLES-1;i&gt;=0;i--) //on restreint le maximum à la drnière bulle non créée
        {
            if(!bubbles[i].cree &amp;&amp; !bubbles[i].tps_creation)
            {
                max=i;
                break;
            }
        }
        if(aspirine.x&lt;0)
            aspirine.x=0;//on ne dépasse pas de l'écran
        else if(aspirine.x+LARGEUR_PASTILLE&gt;LARGEUR_ECRAN)
            aspirine.x=LARGEUR_ECRAN-LARGEUR_PASTILLE;//on ne dépasse pas de l'écran
        if(aspirine.y+HAUTEUR_PASTILLE&lt;0) //Si la pastille est remontée, on arrête le jeu
        {
            PA_DualDeleteSprite(0);
            break;
        }
        else if(aspirine.y+HAUTEUR_PASTILLE&gt;HAUTEUR_ECRAN*2)
            aspirine.y=HAUTEUR_ECRAN*2-HAUTEUR_PASTILLE; //on ne passe pas sous l'écran
        PA_DualSetSpriteXY(0,aspirine.x,aspirine.y); //on place la pastille
        PA_WaitForVBL();
    }
    return 0;
}</code></pre></div><p id="r-445921" data-claire-element-id="445921">Voici une vidéo :<br/><a href="http://fr.youtube.com/watch?v=kQPVcGamfIg">Vidéo du TP</a>.</p><p id="r-445922" data-claire-element-id="445922">Voilà, vous maîtrisez les techniques avancées de la 2D :) !</p><h2 id="r-le-dessin-2" data-claire-element-id="445939">Le dessin</h2><p id="r-445925" data-claire-element-id="445925">Vous cherchez à dessiner sur un écran de votre Nintendo DS ? Alors ce chapitre est fait pour vous ;) .On va apprendre à dessiner sur l'écran en le mettant en mode 16 bit. Certes c'est peu, mais ça peut être bien ^^ .</p><h3 id="r-le-mode-16-bit" data-claire-element-id="445936">Le mode 16 bit</h3><div id="r-445927" data-claire-element-id="445927" data-claire-semantic="question"><p id="r-445926" data-claire-element-id="445926">Pourquoi avoir choisi le 16 bit ?</p></div><p id="r-445928" data-claire-element-id="445928">Le 16 bit offre une grande gamme de couleurs, et avec ce mode (ainsi qu'avec le 8 bit, mais avec ce-dernier nous serions obligés de sélectionner 256 couleurs), on peut ainsi dessiner tout ce que l'on veut sur l'écran : allant du simple pixel à des disques (ou mieux :-° ).</p><p id="r-445929" data-claire-element-id="445929">Comme pour chaque partie de PALib, il faut initialiser l'écran avec <code data-claire-semantic="c">void PA_Init16bitBg(u8 ecran,u8 arriere_plan) </code>.<br/> Pour afficher un pixel à l'écran, nous utiliserons <code data-claire-semantic="c">void PA_Put16bitPixel (u8 ecran,s16 x,s16 y,u16 couleur) </code> où <em>couleur</em> est la valeur donnée par la macro <code data-claire-semantic="c">PA_RGB8(r,g,b) </code>.</p><aside id="r-445932" data-claire-element-id="445932" data-claire-semantic="information"><p id="r-445930" data-claire-element-id="445930"><em>R, G</em> et <em>B</em> sont 3 indices correspondant respectivement à la quantité lumineuse de rouge, vert et bleu contenue dans la couleur désirée. Ces indices sont compris entre 0 et 255 inclus. Plus c'est proche de 0, plus c'est sombre et plus c'est proche de 255, plus c'est clair. Sur n'importe quel logiciel de dessin vous avez une interface avec laquelle vous pouvez créer votre couleur à partir des indices RGB. Vous pouvez utiliser ces logiciels pour vous procurer les indices correspondant à la couleur voulue.<br/> Avec PALib, les indices ne sont pas compris entre 0 et 255, mais entre 0 et 31 (ça me rappelle le développement sur Gameboy Color :D ). Mais il existe une fonction qui nous facilite la vie :</p><pre id="r-445931" data-claire-element-id="445931"><code data-claire-semantic="c">PA_RGB8(255,0,0); // Rouge</code></pre></aside><p id="r-445933" data-claire-element-id="445933">Pour tracer une ligne en mode 16 bit, on utilisera <code data-claire-semantic="c">void PA_Draw16bitLine (u8 ecran,u16 x1,u16 y1,u16 x2,u16 y2,u16 couleur) </code>.<br/> Pour dessiner un rectangle en mode 16 bit, il faut utiliser <code data-claire-semantic="c">void PA_Draw16bitRect (u8 ecran,s16 debutX,s16 debutY,s16 finX,s16 finY,u16 color) </code>.<br/> Si vous voulez effacer l'écran, on utilisera la macro <code data-claire-semantic="c">PA_Clear16bitBg(ecran) </code>.</p><aside id="r-445935" data-claire-element-id="445935" data-claire-semantic="information"><p id="r-445934" data-claire-element-id="445934">Remarquez que l'on peut utiliser le 16 bit, les sprites et les arrière-plans sur un même écran ! (À condition qu'ils ne soient pas sur la même &quot;couche&quot; de l'écran.)</p></aside><h3 id="r-exercices-28" data-claire-element-id="445938">Exercices</h3><p id="r-445937" data-claire-element-id="445937">La base était facile, nous allons donc nous attaquer à la pratique ;) !</p><h2 id="r-coloration-du-passage-du-stylet" data-claire-element-id="445952">Coloration du passage du stylet</h2><p id="r-445940" data-claire-element-id="445940">Nous allons coder un programme qui colore le passage du stylet sur l'écran !<br/> Si vous ne vous souvenez plus du stylet (ce dont je doute ;) ), vous pouvez à tout moment retourner au chapitre sur les événements...<br/> Petite fantaisie : le dessin sera sur les deux écrans !</p><div id="r-445942" data-claire-element-id="445942" data-claire-semantic="question"><p id="r-445941" data-claire-element-id="445941">Mais comment on va faire ? Les deux écrans ne sont pas tactiles ! o_O</p></div><p id="r-445943" data-claire-element-id="445943">Le joueur va dessiner sur l'écran tactile, et le dessin sera reproduit sur l'écran supérieur.</p><h3 id="r-correction-150" data-claire-element-id="445947">Correction</h3><div id="r-445945" data-claire-element-id="445945"><pre id="r-445944" data-claire-element-id="445944"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

int main(int argc, char ** argv)
{
    PA_Init();
    PA_InitVBL();

    PA_Init16bitBg(0,0);
    PA_Init16bitBg(1,0);
 
    while(1)
    {
        PA_WaitFor(Stylus.Newpress||Stylus.Held); //On attend un nouvel appui du stylet ou un maintient de celui-ci sur l'écran tactile
        PA_Put16bitPixel(0,Stylus.X,Stylus.Y,PA_RGB8(255,0,0)); //On dessine le pixel sur l'écran tactile
        PA_Put16bitPixel(1,Stylus.X,Stylus.Y,PA_RGB8(0,255,255)); //On dessine le pixel sur l'écran supérieur
        PA_WaitForVBL();
    }

    return 0;
}</code></pre></div><p id="r-445946" data-claire-element-id="445946">Vous avez vu que le tracé est saccadé, il serait donc mieux d'utiliser des lignes.<br/> Il faut utiliser un compteur, attendre un événement du stylet et bien sûr tracer des lignes ^^ .</p><h3 id="r-correction-151" data-claire-element-id="445951">Correction</h3><div id="r-445949" data-claire-element-id="445949"><pre id="r-445948" data-claire-element-id="445948"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

int main(int argc, char ** argv)
{
    int i=0;
    s16 x1=0,y1=0,styletX=0,styletY=0;
    PA_Init();
    PA_InitVBL();
    
    PA_Init16bitBg(0,0);
    PA_Init16bitBg(1,0);
 
    while(1)
    {
        PA_WaitFor(Stylus.Newpress||Stylus.Held);
        styletX=Stylus.X;
        styletY=Stylus.Y;
        if(i==1)
        {
            x1=styletX;
            y1=styletY;
        }
        else
        {
            PA_Draw16bitLine(0,x1,y1,styletX,styletY,PA_RGB8(255,0,0));
            PA_Draw16bitLine(1,x1,y1,styletX,styletY,PA_RGB8(0,255,255));
            x1=styletX;
            y1=styletY;
        }
        i++;
        if(i&gt;2)
            i=2; // Permet d'éviter que i prenne une valeur trop importante
        PA_WaitForVBL();
    }

    return 0;
}</code></pre></div><p id="r-445950" data-claire-element-id="445950">Bon, je suis sûr que vous allez me détester, mais il existe une fonction toute faite et meilleure que la nôtre pour le faire : <code data-claire-semantic="c">void PA_16bitDraw (u8 ecran,u16 couleur) </code>. Ce n'est pas grave, c'est le <em>besoin d'accomplissement personnel</em> de la pyramide de Maslow qui vient de se combler :p .</p><h2 id="r-dessiner-des-cercles" data-claire-element-id="445966">Dessiner des cercles</h2><aside id="r-445957" data-claire-element-id="445957" data-claire-semantic="information"><p id="r-445953" data-claire-element-id="445953">Rappel :</p><p id="r-445954" data-claire-element-id="445954"><cite>Citation</cite></p><blockquote id="r-445956" data-claire-element-id="445956"><p id="r-445955" data-claire-element-id="445955">Un cercle est une figure géométrique plane constituée de tous les points équidistants d'un point donné, nommé centre.</p></blockquote></aside><p id="r-445958" data-claire-element-id="445958">De cette définition (ainsi que de la représentation graphique qui en découle), on peut se dire qu'on ne travaillera que sur un quart, et qu'on reportera les pixels sur les trois autres par miroir. Je travaille toujours sur le quart en haut à gauche, mais vous pouvez en choisir un autre ;) .</p><p id="r-445959" data-claire-element-id="445959">Vous le savez peut-être déjà, dans un repère orthonormé (ce qui est le cas des écrans de votre Nintendo DS), l'équation du cercle de centre O(a;b) et de rayon r est (x-a)^2+(y-b)^2=r^2.<br/> On va exprimer x en fonction de y (on peut faire l'inverse aussi ^^ ).<br/> Donc nous avons :<br/>(x-a)^2+(y-b)^2=r^2(x-a)^2=r^2-(y-b)^2(x-a)^2=(r-y+b)(r+y-b)<br/> Donc x-a=sqrt{(r-y+b)(r+y-b)}<br/> et x-a=-sqrt{(r-y+b)(r+y-b)}.</p><p id="r-445960" data-claire-element-id="445960">On peut donc dire que x=a+sqrt{(r-y+b)(r+y-b)}<br/> et x=a-sqrt{(r-y+b)(r+y-b)}.<br/> Mais vu que l'on ne travaillera que sur le côté gauche, nous ne retiendrons que x=a-sqrt{(r-y+b)(r+y-b)}.</p><p id="r-445961" data-claire-element-id="445961">Ne vous arrêtez pas à la racine carrée, je sais que la racine carrée est une opération lourde, mais la technique employée est légère. En effet, pour un cercle de 100 pixels de diamètre, il n'y a que 50 tours de boucles contenant chacune 2 racines carrées, soit 100 racines carrées. De plus, j'ai testé le fps, il reste à 60 donc on ne peut pas dire que ça prenne beaucoup de CPU...</p><p id="r-445962" data-claire-element-id="445962">Comme on l'a fait dans l'exercice de la coloration du passage du stylet, il faudra utiliser les lignes et non les points.<br/> Voici ce que le programme doit faire : par défaut, le centre du cercle doit être au centre de l'écran, et son rayon doit être de 100 px. En appuyant sur L, le rayon doit être augmenté de 1 px ; sur R, le rayon doit être diminué de 1 px ; et sur les touches multidirectionnelles, le centre doit se déplacer dans la direction voulue de 1 px. Bien sûr, à chaque fois que vous appuyez sur ces touches, l'écran doit être effacé. Le cercle <strong>ne doit pas</strong> dépasser de l'écran, sinon vous aurez une belle surprise :p ...<br/> Je vous laisse coder :) .</p><h3 id="r-correction-152" data-claire-element-id="445965">Correction</h3><div id="r-445964" data-claire-element-id="445964"><pre id="r-445963" data-claire-element-id="445963"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &lt;math.h&gt;

#define LARGEUR_ECRAN 255
#define HAUTEUR_ECRAN 191

typedef struct
{
    int x,y;
}Point;

void dessiner_cercle(Point,int);

int main(int argc, char ** argv)
{
    Point centre;
    centre.x=LARGEUR_ECRAN/2;
    centre.y=HAUTEUR_ECRAN/2;
    int rayon=50;
    
    PA_Init();
    PA_InitVBL();
    
    PA_Init16bitBg(0,0);
    
    while(1)
    {
        if(Pad.Held.L)
        {
            rayon++;
            PA_Clear16bitBg(0);
        }
        if(Pad.Held.R)
        {
            rayon--;
            PA_Clear16bitBg(0);
        }
        if(Pad.Held.Left)
        {
            centre.x--;
            PA_Clear16bitBg(0);
        }
        else if(Pad.Held.Right)
        {
            centre.x++;
            PA_Clear16bitBg(0);
        }
        if(Pad.Held.Up)
        {
            centre.y--;
            PA_Clear16bitBg(0);
        }
        else if(Pad.Held.Down)
        {
            centre.y++;
            PA_Clear16bitBg(0);
        }
        if(rayon&lt;10)
            rayon=10;
        else if(rayon&gt;HAUTEUR_ECRAN/2)
            rayon=HAUTEUR_ECRAN/2;
        if(centre.x-rayon&lt;0)
            centre.x=rayon;
        else if(centre.x+rayon&gt;LARGEUR_ECRAN)
            centre.x=LARGEUR_ECRAN-rayon;
        if(centre.y-rayon&lt;0)
            centre.y=rayon;
        else if(centre.y+rayon&gt;HAUTEUR_ECRAN)
            centre.y=HAUTEUR_ECRAN-rayon;
        dessiner_cercle(centre,rayon);
        PA_WaitForVBL();
    }

    return 0;
}

void dessiner_cercle(Point centre,int rayon)
{
    int x,x1,y;
    for(y=centre.y-rayon;y&lt;centre.y;y++)
    {
        x=(int)(centre.x-sqrt((rayon+y-centre.y)*(rayon-y+centre.y)));
        x1=(int)(centre.x-sqrt((rayon+y+1-centre.y)*(rayon-y-1+centre.y)));
        PA_Draw16bitLine(0,x,y,x1,y+1,PA_RGB8(255,0,0)); // En haut à gauche
        PA_Draw16bitLine(0,2*centre.x-x,y,2*centre.x-x1,y+1,PA_RGB8(255,0,0)); // En haut à droite
        PA_Draw16bitLine(0,x,2*centre.y-y,x1,2*centre.y-y-1,PA_RGB8(255,0,0)); // En bas à gauche
        PA_Draw16bitLine(0,2*centre.x-x,2*centre.y-y,2*centre.x-x1,2*centre.y-y-1,PA_RGB8(255,0,0)); // En bas à droite
    }
}</code></pre></div><h2 id="r-dessiner-la-fonction-pa-randmax" data-claire-element-id="445977">Dessiner la fonction PA_RandMax !</h2><p id="r-445967" data-claire-element-id="445967">Vous connaissez sûrement le principe des fonctions mathématiques.<br/> Je ne vais pas vous faire un cours de maths là-dessus ^^ , mais nous allons dessiner PA_RandMax.<br/> Pour cela, nous allons dessiner une suite de lignes qui se suivent pour notre courbe. Nous allons d'abord créer un compteur que l'on incrémentera à chaque tour de boucle. Il représentera nos x. Son image (<code data-claire-semantic="c">PA_RandMax(192) </code>) sera nos y.<br/> Ce qui est logique puisque c'est comme ça que l'on dessine une fonction.<br/> Les mathématiciens (et pas qu'eux ^^ ) mettent l'origine de leur repère orthonormé en bas à gauche. Il faudra donc soustraire à la hauteur de l'écran les y puisque ceux-ci sont inversés (le 0 en haut).</p><aside id="r-445969" data-claire-element-id="445969" data-claire-semantic="warning"><p id="r-445968" data-claire-element-id="445968">Si un de vos y est négatif, il ne faut pas tracer la courbe, sinon elle piquera vers le bas :p .</p></aside><p id="r-445970" data-claire-element-id="445970">Vous savez assez de notions pour le faire maintenant.</p><h3 id="r-correction-153" data-claire-element-id="445976">Correction</h3><p id="r-445971" data-claire-element-id="445971">Encore une fois, voici ma correction :) :</p><div id="r-445973" data-claire-element-id="445973"><pre id="r-445972" data-claire-element-id="445972"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

#define RGB(r,g,b) PA_RGB((int)(r*31./255.),(int)(g*31./255.),(int)(b*31./255.))

#define LARGEUR_ECRAN 256
#define HAUTEUR_ECRAN 192

int main(int argc, char ** argv)
{	
    int x=0,y=0,y1=0;
    PA_Init();
    PA_InitVBL();
	
    PA_Init16bitBg(0,0);
    PA_InitRand();
	
    while(x&lt;LARGEUR_ECRAN)
    {
        if(!x)
            y=PA_RandMax(HAUTEUR_ECRAN);
        else
        {
            y1=PA_RandMax(HAUTEUR_ECRAN);
            if(y&gt;=0&amp;&amp;y1&gt;=0)
                PA_Draw16bitLine(0,x-1,y,x,y1,RGB(255,0,0));
            y=y1;
			
        }
        x++;
        PA_WaitForVBL();
    }
	
    return 0;
}</code></pre></div><p id="r-445974" data-claire-element-id="445974">Et voilà, vous obtiendrez une courbe rouge sur un fond noir qui se trace en direct ^^ !</p><p id="r-445975" data-claire-element-id="445975">Voilà, vous savez comment dessiner sur votre écran :) . N'hésitez pas à relire le chapitre si vous n'avez pas bien assimilé une notion. Nous allons étudier un système indispensable pour tout jeu : le son :magicien: !</p><h2 id="r-le-son-3" data-claire-element-id="446000">Le son</h2><p id="r-445978" data-claire-element-id="445978">Vous avez déjà vu un jeu sans son ? Bon oui d'accord ça s'est déjà vu par le passé, mais à l'heure actuelle un jeu sans son serait assez mal vu. C'est pourquoi nous allons aborder cette notion tout de suite ;) !</p><h3 id="r-outils-necessaires-1" data-claire-element-id="445995">Outils nécessaires</h3><p id="r-445979" data-claire-element-id="445979">Les Nintendo DS savent lire deux types de fichiers : les .raw et les .mod . On va uniquement créer des fichiers .raw parce qu'ils sont plus faciles à créer.<br/> Mais nous devons télécharger un programme qui peut transformer des fichiers .mp3, .wav, etc. en fichiers .raw.<br/> Pour cela, je vous conseille <a href="http://www.01net.com/outils/telecharger/windows/Multimedia/encodeurs_et_decodeurs/fiches/tele32122.html">Switch</a>.<br/> Vous aurez peut-être aussi besoin d'éditer les fichiers sons avec <a href="http://www.01net.com/outils/telecharger/windows/Multimedia/edition_audio/fiches/tele19762.html">Audacity</a> (<a href="http://www.siteduzero.com/tutoriel-3-34572-audacity-prise-en-main.html">petit tuto sur le sujet</a> :) ). Mais je ne vais pas vous en dire plus sur ce dernier.</p><div id="r-445981" data-claire-element-id="445981" data-claire-semantic="question"><p id="r-445980" data-claire-element-id="445980">Mais comment on transforme un fichier .wav en fichier .raw, alors ?</p></div><p id="r-445982" data-claire-element-id="445982">Lancez Switch. Glissez le fichier à transformer dans le grand panel blanc où il est écrit :</p><p id="r-445983" data-claire-element-id="445983"><cite>Citation</cite></p><blockquote id="r-445985" data-claire-element-id="445985"><p id="r-445984" data-claire-element-id="445984">Add Files to Convert into this list by clicking the &quot;Add Files&quot; button or pressing Alt+A on your keyboard.</p></blockquote><p id="r-445986" data-claire-element-id="445986">Ecrivez le chemin du dossier (dans lequel sera mis le fichier .raw) à droite de &quot;Output Folder&quot;.<br/> Ensuite, dans &quot;Output Format&quot;, sélectionnez &quot;.raw&quot;.<br/> Puis, cliquez sur &quot;Encoder Options...&quot; et mettez :</p><ul id="r-445993" data-claire-element-id="445993"><li id="r-445988" data-claire-element-id="445988"><p id="r-445987" data-claire-element-id="445987">Format : 8 bit signed ;</p></li><li id="r-445990" data-claire-element-id="445990"><p id="r-445989" data-claire-element-id="445989">Sample rate : 11025 ;</p></li><li id="r-445992" data-claire-element-id="445992"><p id="r-445991" data-claire-element-id="445991">Channels : Stereo.</p></li></ul><p id="r-445994" data-claire-element-id="445994">Et cliquez sur ok.<br/> Enfin, cliquez sur le gros bouton &quot;Convert&quot;.<br/> Et voilà :) .<br/> Créez ensuite un dossier nommé &quot;data&quot; dans le répertoire de votre jeu et copiez-y le fichier .raw.</p><h3 id="r-le-code-enfin" data-claire-element-id="445999">Le code, enfin</h3><p id="r-445996" data-claire-element-id="445996">Il faut d'abord importer le son. Lorsque vous cliquez sur build.bat, le compilateur met le fichier raw et tous les fichiers mp3 dans du code : si vous avez le_nom_du_fichier.raw, vous devrez inclure le_nom_du_fichier.h, idem pour les fichiers mp3.<br/> Il faut initialiser le son avec :</p><pre id="r-445997" data-claire-element-id="445997"><code data-claire-semantic="c">AS_Init(AS_MODE_MP3 | AS_MODE_SURROUND | AS_MODE_16CH);
AS_SetDefaultSettings(AS_PCM_8BIT, 11025, AS_SURROUND);</code></pre><p id="r-445998" data-claire-element-id="445998">.<br/> Et vous aurez un son en surround.</p><h2 id="r-les-sons-mp3" data-claire-element-id="446020">Les sons MP3</h2><p id="r-446001" data-claire-element-id="446001">Les sons MP3 ont une façon spécifique de fonctionner. Pour jouer un MP3, il faut écrire (par exemple pour <em>data/test.mp3</em>) :</p><pre id="r-446002" data-claire-element-id="446002"><code data-claire-semantic="c">AS_MP3DirectPlay((u8*)test, (u32)test_size);</code></pre><p id="r-446003" data-claire-element-id="446003">Si vous voulez jouer le son en boucle, vous utiliserez la fonction :</p><pre id="r-446004" data-claire-element-id="446004"><code data-claire-semantic="c">AS_SetMP3Loop(1);</code></pre><p id="r-446005" data-claire-element-id="446005">A l'inverse, si vous ne voulez plus que le son soit joué en boucle, mettez 0.</p><p id="r-446006" data-claire-element-id="446006">Pour mettre un MP3 en pause, on utilisera <code data-claire-semantic="c">AS_MP3Pause(); </code>, pour arrêter un MP3 <code data-claire-semantic="c">AS_MP3Stop(); </code>.<br/> Si vous voulez obtenir des indications sur le système MP3 (si un son est joué, en pause, arrêté, etc.), la fonction <code data-claire-semantic="c">AS_GetMP3Status(); </code> nous renvoie des flags pouvant être :</p><ul id="r-446019" data-claire-element-id="446019"><li id="r-446008" data-claire-element-id="446008"><p id="r-446007" data-claire-element-id="446007">MP3ST_STOPPED (canal stoppé) ;</p></li><li id="r-446010" data-claire-element-id="446010"><p id="r-446009" data-claire-element-id="446009">MP3ST_PAUSED (canal en pause) ;</p></li><li id="r-446012" data-claire-element-id="446012"><p id="r-446011" data-claire-element-id="446011">MP3ST_PLAYING (canal occupé) ;</p></li><li id="r-446014" data-claire-element-id="446014"><p id="r-446013" data-claire-element-id="446013">MP3ST_OUT_OF_DATA (on a dépassé le nombre maximal de données de la musique, ne devrait pas arriver) ;</p></li><li id="r-446016" data-claire-element-id="446016"><p id="r-446015" data-claire-element-id="446015">MP3ST_DECODE_ERROR (le système n'a pas pu décoder le MP3) ;</p></li><li id="r-446018" data-claire-element-id="446018"><p id="r-446017" data-claire-element-id="446017">MP3ST_INITFAILED (l'initialisation du système MP3 a échoué).</p></li></ul><h2 id="r-les-fichiers-raw" data-claire-element-id="446043">Les fichiers RAW</h2><p id="r-446021" data-claire-element-id="446021">Si vous voulez jouer un son RAW (supposons que vous ayez <em>data/boum.raw</em>) :</p><pre id="r-446022" data-claire-element-id="446022"><code data-claire-semantic="c">AS_SoundQuickPlay(boum);</code></pre><p id="r-446023" data-claire-element-id="446023">Et votre son sera joué ;) !</p><aside id="r-446025" data-claire-element-id="446025" data-claire-semantic="information"><p id="r-446024" data-claire-element-id="446024">Vous pouvez aussi utiliser des sons <em>PSG</em> : vous définissez note par note les sons qui seront joués dans votre Nintendo DS. L'avantage c'est que l'on peut jouer facilement sur les sons (que l'enceinte droite, que l'enceinte gauche, créer soi-même ses sons, etc.). L'inconvénient (qui efface totalement l'avantage), est que souvent le son est bizarre et il faut une bonne habitude des <em>PSG</em> pour faire une belle mélodie, alors qu'avec la méthode que je vous ai citée plus haut, vous n'avez pas besoin de définir le contenu de la chanson ;) . Vous pouvez chercher dans les exemples de PALib des codes permettant de jouer des <em>PSG</em>.</p></aside><aside id="r-446027" data-claire-element-id="446027" data-claire-semantic="error"><p id="r-446026" data-claire-element-id="446026">Gardez bien en tête que si votre musique n'est ni de vous, ni libre, elle est soumise aux droits d'auteurs !</p></aside><h3 id="r-le-micro" data-claire-element-id="446042">Le micro !</h3><p id="r-446028" data-claire-element-id="446028">Vous attendiez sûrement ce moment : contrôler le micro :p !<br/> Le mieux dans tout ça, est que c'est super facile.<br/> Il y a quatre étapes :</p><ul id="r-446037" data-claire-element-id="446037"><li id="r-446030" data-claire-element-id="446030"><p id="r-446029" data-claire-element-id="446029">déclarer globalement la variable qui contiendra la voix du joueur (cette variable est aussi appelée &quot;buffer&quot;) ;</p></li><li id="r-446032" data-claire-element-id="446032"><p id="r-446031" data-claire-element-id="446031">enregistrer la voix avec <code data-claire-semantic="c">void PA_MicStartRecording(u8 *buffer,s32 longueur) </code> ;</p></li><li id="r-446034" data-claire-element-id="446034"><p id="r-446033" data-claire-element-id="446033">réécouter la voix avec <code data-claire-semantic="c">void PA_MicReplay(u8 *buffer,s32 longueur) </code> ;</p></li><li id="r-446036" data-claire-element-id="446036"><p id="r-446035" data-claire-element-id="446035">afficher l'intensité de la voix avec la macro <code data-claire-semantic="c">PA_MicGetVol(); </code>.</p></li></ul><p id="r-446038" data-claire-element-id="446038">Voici donc ce que l'on peut faire :</p><pre id="r-446039" data-claire-element-id="446039"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
 
u8 buffer[100000];
int main(int argc, char ** argv)
{
    PA_Init();
    PA_InitVBL();
        
    PA_InitText(1,0);

    AS_Init(AS_MODE_SURROUND | AS_MODE_16CH);
    AS_SetDefaultSettings(AS_PCM_8BIT, 11025, AS_SURROUND);
 
    PA_OutputText(1,0,0,&quot;Appuyez sur A pour enregistrer et sur B pour réécouter&quot;);
        
    while (1)
    {           
        if(Pad.Newpress.A)
            PA_MicStartRecording(buffer,sizeof(buffer)/sizeof(u8));
 
        else if(Pad.Newpress.B) 
            PA_MicReplay(buffer,sizeof(buffer)/sizeof(u8));
 
        PA_OutputText(1,0,10,&quot;%d  &quot;,PA_MicGetVol());
        PA_WaitForVBL();
    }
    return 0;
}</code></pre><p id="r-446040" data-claire-element-id="446040">Avouez que ce n'était pas bien compliqué :p</p><p id="r-446041" data-claire-element-id="446041">Voilà, vous vous coucherez encore plus intelligent ce soir :p .</p><h2 id="r-des-fonctionnalites-utiles" data-claire-element-id="446046">Des fonctionnalités utiles</h2><p id="r-446044" data-claire-element-id="446044">Tous les jeux officiels (de DS) auxquels vous avez joués se mettent en pause lorsque vous refermez votre DS, récupèrent le nom de votre utilisateur, etc.<br/> Nous allons apprendre à récupérer toutes ces données.</p><h3 id="r-les-fonctions-et-les-structures" data-claire-element-id="446045">Les fonctions et les structures !</h3><h2 id="r-verifier-si-l-ecran-superieur-est-rabattu" data-claire-element-id="446050">Vérifier si l'écran supérieur est rabattu</h2><p id="r-446047" data-claire-element-id="446047">PAlib a créé une fonction pour ce cas, c'est <code data-claire-semantic="c">void PA_CheckLid() </code>. Cette fonction renvoie 1 si c'est fermé, et la Nintendo DS se met automatiquement en pause...</p><pre id="r-446048" data-claire-element-id="446048"><code data-claire-semantic="c">/*Mettre le code de début*/
while(1)
{
    PA_CheckLid();
    PA_WaitForVBL();
}
/*Mettre le code de fin*/</code></pre><p id="r-446049" data-claire-element-id="446049">Si vous voulez simplement savoir si la Nintendo DS est fermée (sans pause), vous pouvez utiliser la macro <code data-claire-semantic="c">PA_LidClosed() </code>.<br/> Si vous voulez savoir si la Nintendo DS est fermée, avec pause et en jouant un son (que vous choisissez), vous pouvez utiliser la macro <code data-claire-semantic="c">PA_CloseLidSound(canal,son) </code>, et si vous voulez mettre un son quand elle est fermée et un quand elle se réouvre, il faut utiliser la macro <code data-claire-semantic="c">PA_CloseLidSound2(canal,son_ferme,son_ouvert) </code>.</p><h2 id="r-recuperer-le-temps" data-claire-element-id="446069">Récupérer le temps</h2><p id="r-446051" data-claire-element-id="446051">La structure &quot;PA_RTC&quot; continent des membres exprimant la date :</p><ul id="r-446066" data-claire-element-id="446066"><li id="r-446053" data-claire-element-id="446053"><p id="r-446052" data-claire-element-id="446052">Seconds : les secondes ;</p></li><li id="r-446055" data-claire-element-id="446055"><p id="r-446054" data-claire-element-id="446054">Minutes : les minutes ;</p></li><li id="r-446059" data-claire-element-id="446059"><p id="r-446056" data-claire-element-id="446056">Hour : les heures ;</p><aside id="r-446058" data-claire-element-id="446058" data-claire-semantic="information"><p id="r-446057" data-claire-element-id="446057">Si le nombre retourné est négatif, précisez que c'est le matin ou alors ajoutez douze heures.</p></aside></li><li id="r-446061" data-claire-element-id="446061"><p id="r-446060" data-claire-element-id="446060">Day : le jour ;</p></li><li id="r-446063" data-claire-element-id="446063"><p id="r-446062" data-claire-element-id="446062">Month : le mois ;</p></li><li id="r-446065" data-claire-element-id="446065"><p id="r-446064" data-claire-element-id="446064">Year : l'année, renvoie 0 pour 2000, 1 pour 2001, etc.</p></li></ul><p id="r-446067" data-claire-element-id="446067">On peut écrire :</p><pre id="r-446068" data-claire-element-id="446068"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
 
int main(int argc, char ** argv)
{
        PA_Init();
        PA_InitVBL();
 
        PA_InitText(0,0);
        
        while (1)
        {               
                PA_OutputText(0, 2, 10, &quot;%02d/%02d/%02d&quot;, PA_RTC.Day, PA_RTC.Month, PA_RTC.Year); // Date
                PA_OutputText(0, 2, 12, &quot;%02d:%02d  %02d secondes&quot;, PA_RTC.Hour, PA_RTC.Minutes, PA_RTC.Seconds); // Time
                PA_WaitForVBL();
        }
        return 0;
}</code></pre><h2 id="r-recuperer-les-donnees-de-l-utilisateur" data-claire-element-id="446088">Récupérer les données de l'utilisateur</h2><p id="r-446070" data-claire-element-id="446070">La structure &quot;PA_UserInfo&quot; a pour membres :</p><ul id="r-446087" data-claire-element-id="446087"><li id="r-446072" data-claire-element-id="446072"><p id="r-446071" data-claire-element-id="446071">Name : le nom de l'utilisateur ;</p></li><li id="r-446074" data-claire-element-id="446074"><p id="r-446073" data-claire-element-id="446073">BdayDay : le jour de l'anniversaire ;</p></li><li id="r-446076" data-claire-element-id="446076"><p id="r-446075" data-claire-element-id="446075">BdayMonth : le mois de l'anniversaire ;</p></li><li id="r-446078" data-claire-element-id="446078"><p id="r-446077" data-claire-element-id="446077">Language : la langue de la DS, utile pour faire de bons jeux :<br/> - 0 : japonais ; <br/> - 1 : anglais ; <br/> - 2 : français ; <br/> - 3 : allemand ; <br/> - 4 : italien ; <br/> - 5 : espagnol.</p></li><li id="r-446080" data-claire-element-id="446080"><p id="r-446079" data-claire-element-id="446079">Message : le message de l'utilisateur ;</p></li><li id="r-446082" data-claire-element-id="446082"><p id="r-446081" data-claire-element-id="446081">AlarmHour : l'heure de l'alarme programmée ;</p></li><li id="r-446084" data-claire-element-id="446084"><p id="r-446083" data-claire-element-id="446083">AlarmMinute : la minute de l'alarme programmée ;</p></li><li id="r-446086" data-claire-element-id="446086"><p id="r-446085" data-claire-element-id="446085">Color : la couleur préférée de l'utilisateur.</p></li></ul><h2 id="r-faire-vibrer-votre-nintendo-ds" data-claire-element-id="446092">Faire vibrer votre Nintendo DS</h2><p id="r-446089" data-claire-element-id="446089">Pour ceux qui auraient un Rumble Pak (un composant qui permet des vibrations), vous pouvez l'utiliser dans vos homebrews, et simplement :soleil: ! Ce que nous allons voir ne dépend pas de PALib, mais de la libnds.<br/> Il faut vérifier si le Rumble Pak est inséré avec <code data-claire-semantic="c">bool isRumbleInserted(void); </code>. Cette fonction renvoie vrai lorsque le Rumble Pak est inséré, et faux dans le cas contraire.<br/> A présent, on peut faire vibrer notre Rumble Pak avec <code data-claire-semantic="c">void setRumble(bool position); </code>. Si <em>position</em> est vraie, votre Nintendo DS se met à vibrer. A l'inverse, si <em>position</em> est fausse, votre Nintendo DS <strong>s'arrête</strong> de vibrer.</p><aside id="r-446091" data-claire-element-id="446091" data-claire-semantic="warning"><p id="r-446090" data-claire-element-id="446090">N'oubliez pas qu'à chaque appel à la vibration, il doit y avoir un arrêt, sinon votre Nintendo DS ne fera que vibrer !</p></aside><h2 id="r-jouer-avec-la-luminosite-de-l-ecran" data-claire-element-id="446125">Jouer avec la luminosité de l'écran</h2><p id="r-446093" data-claire-element-id="446093">Une seule fonction permet de régler la luminosité d'un écran, applaudissons <code data-claire-semantic="c">void PA_SetBrightness(u8 ecran, s8 brillance); </code> :p ! La valeur de <em>brillance</em> doit varier entre -31 et 31. Si sa valeur est négative, l'écran penchera vers le noir (-31 est le noir complet). A l'inverse, si sa valeur est plus grande que 0 l'écran penchera vers le blanc(31 est le blanc total). Mettez <em>brillance</em> à 0 et vous aurez un éclairage normal. Cette fonction est souvent utilisée dans les transitions, les splashes et les menus.</p><h3 id="r-exercice-39" data-claire-element-id="446094">Exercice</h3><h3 id="r-presentation-121" data-claire-element-id="446103">Présentation</h3><p id="r-446095" data-claire-element-id="446095">Maintenant, on va faire un jeu qui annonce à l'utilisateur dans combien de jours son anniversaire viendra ou alors depuis combien de jour il est passé.<br/> Il faut que la DS affiche :</p><pre id="r-446096" data-claire-element-id="446096"><code data-claire-semantic="console">Votre anniversaire est dans [1] [2].</code></pre><p id="r-446097" data-claire-element-id="446097">Ou :</p><pre id="r-446098" data-claire-element-id="446098"><code data-claire-semantic="console">Votre anniversaire est passé de [1] [2].</code></pre><p id="r-446099" data-claire-element-id="446099">Ou encore :</p><pre id="r-446100" data-claire-element-id="446100"><code data-claire-semantic="console">Joyeux anniversaire !</code></pre><aside id="r-446102" data-claire-element-id="446102" data-claire-semantic="information"><p id="r-446101" data-claire-element-id="446101">[1] est le nombre de jours et [2] est &quot;jour&quot; au singulier ou au pluriel, à vous d'étudier les cas ;) . Pour mettre jour au singulier ou au pluriel, il est conseillé de déclarer d'abord la variable contenant le mot, puis d'utiliser la fonction <strong>sprintf</strong> (pensez à inclure string.h !).</p></aside><h3 id="r-aide-4" data-claire-element-id="446112">Aide</h3><p id="r-446104" data-claire-element-id="446104">Il faudra d'abord créer une variable de type double qui va transformer la date actuelle (mois et jour) en nombre de jours. Vous devez donc trouvez un système pour convertir des mois en jours (d'où le double).<br/> Ensuite, il faudra appliquer ce même système pour la date d'anniversaire.<br/> Puis, on créera une fonction pour arrondir des doubles.<br/> On mettra dans une variable de type int le résultat arrondi (d'où la fonction) de la différence entre la date d'anniversaire et la date actuelle.<br/> Si cette différence est plus grande que 1 ou plus petite que -1, il faudra mettre &quot;jour&quot; au pluriel, sinon on le met au singulier.<br/> Si la différence est négative, on affiche :</p><pre id="r-446105" data-claire-element-id="446105"><code data-claire-semantic="console">Votre anniversaire est passé de [1] [2].</code></pre><aside id="r-446107" data-claire-element-id="446107" data-claire-semantic="warning"><p id="r-446106" data-claire-element-id="446106">La différence étant négative, il faut la mettre en positif avant de la montrer à l'utilisateur.</p></aside><p id="r-446108" data-claire-element-id="446108">Si la différence est positive, on affiche :</p><pre id="r-446109" data-claire-element-id="446109"><code data-claire-semantic="console">Votre anniversaire est dans [1] [2].</code></pre><p id="r-446110" data-claire-element-id="446110">Si la différence est égale à zéro, on affiche :</p><pre id="r-446111" data-claire-element-id="446111"><code data-claire-semantic="console">Joyeux anniversaire !</code></pre><h3 id="r-correction-154" data-claire-element-id="446124">Correction</h3><div id="r-446121" data-claire-element-id="446121"><pre id="r-446113" data-claire-element-id="446113"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &lt;string.h&gt;
 
int arrondir(double);
 
int main(int argc, char ** argv)
{
    PA_Init();
    PA_InitVBL();
        
    PA_InitText(1,0);
 
    double date_actuelle=((double)PA_RTC.Month/12.*365.)+(double)PA_RTC.Day;
    double date_anniv=((double)PA_UserInfo.BdayMonth/12.*365.)+(double)PA_UserInfo.BdayDay;
    int difference=arrondir(date_anniv-date_actuelle);
    char jour[6]=&quot;&quot;;
    if(difference&lt;-1||difference&gt;1)
        sprintf(jour,&quot;jours&quot;);
    else
        sprintf(jour,&quot;jour&quot;);
    if(difference&lt;0)
        PA_OutputText(1,0,0,&quot;Votre anniversaire est passé de %d %s.&quot;,-difference,jour);
    else if(difference&gt;0)
        PA_OutputText(1,0,0,&quot;Votre anniversaire est dans %d %s.&quot;,difference,jour);
    else
        PA_OutputText(1,0,0,&quot;Joyeux anniversaire !&quot;);
        
    while (1)
    {
        PA_WaitForVBL();
    }
    return 0;
}
 
int arrondir(double nombre)
{
    if(nombre-(int)nombre&gt;=.5)
        nombre+=.5;
    return (int)nombre;
}</code></pre><p id="r-446114" data-claire-element-id="446114">Explications pour la fonction arrondir :<br/> La variable nombre est un double. Si l'on fait <strong>(int)nombre</strong>, on obtiendra sa <strong>troncature à l'unité</strong>. Autrement dit, vous aurez la partie entière de nombre. La règle de l'arrondi est :</p><p id="r-446115" data-claire-element-id="446115"><cite>Citation</cite></p><blockquote id="r-446117" data-claire-element-id="446117"><p id="r-446116" data-claire-element-id="446116">Si la décimale qui suit la décimale de la limite de l'arrondi est plus grand que 4, la décimale de la limite de l'arrondi est augmentée de 1.<br/> En gros, si vous avez 4,45 ; son arrondi au dixième sera 4,5 ; et son arrondi à l'unité sera 4.</p></blockquote><p id="r-446118" data-claire-element-id="446118">Donc si la différence entre nombre et sa troncature à l'unité (on obtient sa partie décimale) est supérieure ou égale à 0,5 alors on augmente nombre de 0,5 pour que <strong>(int)nombre</strong> prenne la valeur entière +1 de nombre.<br/> On aurait aussi très bien pu faire :</p><pre id="r-446119" data-claire-element-id="446119"><code data-claire-semantic="c">int arrondir(double nombre)
{
    if(nombre-(int)nombre&gt;=.5)
        return (int)nombre+ 1;
    else
        return (int)nombre;
}</code></pre><p id="r-446120" data-claire-element-id="446120">Il ne faut pas oublier le prototype de la fonction &quot;arrondir&quot;.<br/>Explications du main :<br/> Tout d'abord, on initialise PAlib et le texte sur l'écran supérieur (ça aurait pu être l'écran tactile aussi).<br/> Pour mettre un mois en jour, il faut utiliser la proportionnalité. Il y a douze mois et trois cent soixante-cinq jours (au diable les années bissextiles :p ). Il faut donc diviser le numéro du mois par douze et multiplier le résultat par trois cent soixante-cinq. A ce résultat, il faut bien sûr ajouter le numéro du jour.</p></div><p id="r-446122" data-claire-element-id="446122">Bon, voilà c'était quand même assez facile :) .</p><p id="r-446123" data-claire-element-id="446123">Nous avons acquis les bases, maintenant attaquons-nous aux techniques avancées :pirate: !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds">Programmez sur votre Nintendo DS !</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-bases-de-palib">
Les bases de PAlib
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-techniques-avancees">
Les techniques avancées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/annexes-38">
Annexes
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-techniques-avancees">
<span class="next">Les techniques avancées</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lestechniquesavances"></a><h2>Les techniques avancées</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-bases-de-palib">
<span class="arrow"></span>
<span class="next">Les bases de PAlib</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/annexes-38">
<span class="next">Annexes</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-446127" data-claire-element-id="446127">Nous venons de voir les bases, maintenant nous allons voir les techniques avancées. Nous allons apprendre à créer des menus, gérer les fichiers, etc. Mais on y verra ce que vous attendez depuis toujours : la 3D :D !</p><h2 id="r-les-menus-et-les-sauvegardes" data-claire-element-id="446144">Les menus et les sauvegardes</h2><p id="r-446128" data-claire-element-id="446128">Vous vous demandiez comment faire un menu avec PALib ? Une seule solution (enfin, c'est la plus propre) : créer plusieurs boucles ! Nous ne ferons que de la théorie puisqu'il n'y a pas qu'une façon de faire des menus :) .</p><h3 id="r-creer-un-menu-1" data-claire-element-id="446140">Créer un menu</h3><p id="r-446129" data-claire-element-id="446129">Nous allons y aller en douceur ^^ pour commencer : nous allons créer un des menus les plus basiques qui soient.</p><div id="r-446131" data-claire-element-id="446131" data-claire-semantic="question"><p id="r-446130" data-claire-element-id="446130">Qu'est-ce qu'un menu ?</p></div><p id="r-446132" data-claire-element-id="446132">Un menu est constitué d'un arrière-plan, et d'éléments (boutons, texte, images, etc...) permettant d'accéder à diverses partie du jeu (nouveau jeu, options, etc...).</p><div id="r-446134" data-claire-element-id="446134" data-claire-semantic="question"><p id="r-446133" data-claire-element-id="446133">Comment créer un menu ?</p></div><p id="r-446135" data-claire-element-id="446135">Tout simplement en ajoutant une boucle :</p><pre id="r-446136" data-claire-element-id="446136"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

int main(int argc,char **argv)
{
    PA_Init();
    PA_InitVBL();

    while(1) // Boucle du menu
    {
        PA_WaitForVBL();
    }

    while(1) // Boucle du jeu
    {
        PA_WaitForVBL();
    }

    return 0;
}</code></pre><p id="r-446137" data-claire-element-id="446137">Bien sûr, vu que le menu appelle le jeu et que le jeu appelera le menu (si on a une fonctionnalité pour quitter le jeu), on peut créer deux fonctions : <em>menu</em> et <em>jeu</em> :</p><pre id="r-446138" data-claire-element-id="446138"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

typedef enum Choix Choix; // Cette énumération permet de connaître le choix du joueur
enum Choix
{
    AUCUN,JOUER
};

void menu(void);
void jeu(void);

int main(int argc,char **argv)
{
    PA_Init();
    PA_InitVBL();

    menu();

    return 0;
}

void menu(void)
{
    Choix choix=AUCUN;
    while(choix==AUCUN)
    {
        PA_WaitForVBL();
    }
    
    switch(choix)
    {
        case JOUER:
            jeu();
            break;
        default:
            break;
    }
}

void jeu(void)
{
    int quitter=0;
    while(1)
    {
        if(quitter)
            break;
        PA_WaitForVBL();
    }
    menu();
}</code></pre><p id="r-446139" data-claire-element-id="446139">Un bon menu, selon moi, est un menu qui comporte un arrière-plan pour les deux écrans, avec le nom du jeu sur l'écran supérieur, et les éléments du menu sur l'écran tactile.<br/> Ce menu doit avoir deux méthodes de choix : un par le stylet et un par les touches multi-directionnelles pour déplacer un curseur avec A ou Start pour valider.<br/> Ca c'est un bon menu basique ^^ .<br/> A vous de réfléchir à des systèmes plus élaborés pour faire des systèmes plus originaux ;) .</p><h3 id="r-creer-une-sauvegarde" data-claire-element-id="446143">Créer une sauvegarde</h3><aside id="r-446142" data-claire-element-id="446142" data-claire-semantic="information"><p id="r-446141" data-claire-element-id="446141">Tout d'abord, il faut que vous sachiez qu'on ne peut pas utiliser de chemins relatifs (à partir du dossier courant). Donc tous les noms de fichiers dans lesquels vous voudrez écrire ou lire devront être écrits en partant de la racine...</p></aside><h2 id="r-les-bases-23" data-claire-element-id="446157">Les bases</h2><p id="r-446145" data-claire-element-id="446145">Il faut commencer par inclure le header de FAT et stdio:</p><pre id="r-446146" data-claire-element-id="446146"><code data-claire-semantic="c">#include &lt;stdio.h&gt;
#include &lt;fat.h&gt;</code></pre><p id="r-446147" data-claire-element-id="446147">Puis on initialise FAT avec <code data-claire-semantic="cpp">bool fatInitDefault (void); </code> (ne vous arrêtez pas à <code data-claire-semantic="cpp">bool </code>, cette fonction marche très bien en C ;) ).<br/> Le reste est ce que vous avez déjà appris en C. En effet, pour créer une variable contenant un fichier on fait :</p><pre id="r-446148" data-claire-element-id="446148"><code data-claire-semantic="c">FILE *fichier=NULL;</code></pre><p id="r-446149" data-claire-element-id="446149">Pour initialiser une variable il suffit de faire :</p><pre id="r-446150" data-claire-element-id="446150"><code data-claire-semantic="c">fichier=fopen(&quot;fichier.ext&quot;,&quot;mode&quot;);</code></pre><p id="r-446151" data-claire-element-id="446151"><em>mode</em> peut être &quot;w&quot;, &quot;wb&quot;, &quot;r&quot;, &quot;rb&quot;, &quot;a&quot;, etc...<br/> Pour fermer un fichier il faut écrire :</p><pre id="r-446152" data-claire-element-id="446152"><code data-claire-semantic="c">fclose(fichier);</code></pre><p id="r-446153" data-claire-element-id="446153">Pour écrire dans un fichier, on utilisera <code data-claire-semantic="c">size_t fwrite(const void * contenu, size_t compte, size_t taille_du_contenu, FILE * fichier); </code> où <em>contenu</em> est le texte à écrire dans le fichier, <em>compte</em> est le nombre d'éléments (nous laisserons toujours 1), <em>taille_du_contenu</em> est la taille du contenu, et où <em>fichier</em> est le fichier.<br/> Par exemple :</p><pre id="r-446154" data-claire-element-id="446154"><code data-claire-semantic="c">FILE *fichier=fopen(&quot;test.txt&quot;,&quot;w&quot;);
fwrite(&quot;hello !&quot;,1,8,fichier);</code></pre><p id="r-446155" data-claire-element-id="446155">Pour lire un fichier, c'est quasiment pareil :) ! On crée une chaîne de caractères vide, et on fait un appel à <em>fread</em> qui prend les mêmes arguments que sa cousine <em>fwrite</em>. Par exemple :</p><pre id="r-446156" data-claire-element-id="446156"><code data-claire-semantic="c">char contenu[256];
FILE *fichier=fopen(&quot;test.txt&quot;,&quot;r&quot;);
fread(contenu,1,256,fichier);
/* Et voilà, la variable &quot;contenu&quot; contient le contenu du fichier test.txt ;) */</code></pre><h2 id="r-lister-les-fichiers-et-les-repertoires-d-un-dossier" data-claire-element-id="446179">Lister les fichiers et les répertoires d'un dossier</h2><p id="r-446158" data-claire-element-id="446158">On va inclure <em>fat.h</em>, bien sûr, mais aussi <em>sys/dir.h</em> pour lister le dossier courant.<br/> On va écrire dans un fichier .txt le contenu du dossier.<br/> Pour cela, on va devoir :</p><ul id="r-446175" data-claire-element-id="446175"><li id="r-446160" data-claire-element-id="446160"><p id="r-446159" data-claire-element-id="446159">Créer une variable de type <em>stat</em> (pas de <code data-claire-semantic="c">typedef </code> donc il faudra mettre <code data-claire-semantic="c">struct </code>). Cette variable va nous permettre de savoir si l'élément est un dossier ou un fichier.</p></li><li id="r-446162" data-claire-element-id="446162"><p id="r-446161" data-claire-element-id="446161">Créer un tableau de <em>char</em> qui contiendra le nom de l'élément en cours, ainsi qu'un autre tableau qui contiendra le texte à mettre dans le fichier .txt.</p></li><li id="r-446164" data-claire-element-id="446164"><p id="r-446163" data-claire-element-id="446163">Créer un pointeur de type <em>DIR_ITER</em>, cette variable représente le dossier que l'on va examiner (ici, le courant).</p></li><li id="r-446166" data-claire-element-id="446166"><p id="r-446165" data-claire-element-id="446165">Créer un pointeur de type <em>FILE</em>, c'est le fichier .txt de sortie.</p></li><li id="r-446168" data-claire-element-id="446168"><p id="r-446167" data-claire-element-id="446167">Initialiser PALib puis fat.</p></li><li id="r-446170" data-claire-element-id="446170"><p id="r-446169" data-claire-element-id="446169"><strong>Puis</strong> ouvrir le dossier avec <em>diropen</em>.</p></li><li id="r-446172" data-claire-element-id="446172"><p id="r-446171" data-claire-element-id="446171">Parcourir le dossier avec <em>dirnext</em>.</p></li><li id="r-446174" data-claire-element-id="446174"><p id="r-446173" data-claire-element-id="446173">Enfin, écrire le contenu du dossier dans notre fichier .txt.</p></li></ul><p id="r-446176" data-claire-element-id="446176">Voici à quoi ressemble notre code :</p><pre id="r-446177" data-claire-element-id="446177"><code data-claire-semantic="c">#include &lt;PA9.h&gt;
#include &lt;fat.h&gt;
#include &lt;sys/dir.h&gt;

int main(int argc, char ** argv)
{
    struct stat st;
    char buf[512]=&quot;&quot;,filename[256]=&quot;&quot;;
    DIR_ITER* dir = NULL;
    FILE *fichier=NULL;
    
    PA_Init();
    PA_InitVBL();
    
    PA_InitText(0,0);
    
    fatInitDefault();
    
    dir=diropen(&quot;/&quot;); // Lit le dossier courant

    if (dir==NULL) // Le dossier n'a pas pu être lu
        PA_OutputText(0,0,0,&quot;Une erreur est survenue, réessayez.&quot;);
    else 
    {
        PA_OutputText(0,0,0,&quot;Lecture du dossier en cours...&quot;);
        fichier=fopen(&quot;liste.txt&quot;,&quot;w&quot;);
        while (dirnext(dir,filename,&amp;st) == 0) 
        {
            // Si (st.st_mode&amp;S_IFDIR) alors c'est un dossier, sinon c'est un fichier
            sprintf(buf,&quot;%s : %s\n&quot;,(st.st_mode&amp;S_IFDIR?&quot;Dossier&quot;:&quot;Fichier&quot;),filename);
            fwrite(buf,1,sizeof(buf),fichier); // On écrit dans le fichier .txt
        }
        fclose(fichier);
        PA_OutputText(0,0,1,&quot;Lecture du dossier termniée !&quot;);
    }
    
    while (1)
        PA_WaitForVBL();
    
    return 0;
}</code></pre><p id="r-446178" data-claire-element-id="446178">A partir de maintenant, vous pouvez ajouter des menus sympas à vos jeux ;) ...</p><h2 id="r-les-timers-3" data-claire-element-id="446197">Les timers</h2><p id="r-446180" data-claire-element-id="446180">Nous avons appris beaucoup de choses jusqu'à maintenant, mais nous n'avons pas encore vu comment créer des timers. Par exemple, vous faites un jeu dans lequel les personnages meurent quand ils n'ont plus de vie (logique :) ), et vous voulez qu'ils disparaissent 3 secondes plus tard, donc il faut utiliser les timers !</p><h3 id="r-les-timers-palib" data-claire-element-id="446189">Les timers PALib</h3><p id="r-446181" data-claire-element-id="446181">La première méthode est : utiliser les compteurs de PALib.<br/> Pendant que vous faites appel à <em>PA_WaitForVBL</em>, les compteurs actifs augmentent de 1. Ainsi, vous pouvez connaître le nombre de VBL depuis le lancement du timer (il ne reste plus qu'à diviser par 60 pour avoir un nombre de secondes).</p><div id="r-446183" data-claire-element-id="446183" data-claire-semantic="question"><p id="r-446182" data-claire-element-id="446182">Mais, s'il y a un compteur, il doit y avoir risque de dépassement, non ?</p></div><p id="r-446184" data-claire-element-id="446184">En fait, si le type est un <em>int</em>, vous pouvez attendre <strong>414 jours, 6 heures, 3 minutes et 14.133 secondes</strong> environ. Si c'est un <em>unsigned int</em>, vous aurez le droit au double. Donc je pense qu'il n'y a pas de soucis de ce côté là :p ...</p><p id="r-446185" data-claire-element-id="446185">Voici le prototype de la fonction permettant de démarrer/redémarrer un compteur : <code data-claire-semantic="c">void PA_VBLCounterStart(u8 c); </code> où <em>c</em> est le numéro du compteur (doit être compris entre 0 et 15 inclus). Pour mettre un compteur en pause, on utilisera <code data-claire-semantic="c">void PA_VBLCounterPause(u8 c); </code>, et pour qu'un compteur reprenne le compte, on utilisera <code data-claire-semantic="c">void PA_VBLCounterUnpause(u8 c); </code>. Enfin, pour accéder au contenu du compteur, il faut écire <code data-claire-semantic="c">PA_VBLCounter[c] </code> (le résultat est en VBL).<br/> Voici un petit exemple :</p><pre id="r-446186" data-claire-element-id="446186"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

int main(int argc,char **argv)
{
	PA_Init();
	PA_InitVBL();
	
	PA_InitText(1,0);
	
	PA_VBLCounterStart(0);
	
	while(1)
        {
	    PA_OutputText(1,0,0,&quot;%d secondes&quot;,PA_VBLCounter[0]/60);	
	    PA_WaitForVBL();
	}
	return 0;
}</code></pre><aside id="r-446188" data-claire-element-id="446188" data-claire-semantic="warning"><p id="r-446187" data-claire-element-id="446187">Vous ne pouvez utiliser que 16 compteurs en même temps. De plus, supposez que vous ayez un gros calcul à faire et qu'il vous prenne une seconde (sans appel à <em>PA_WaitForVBL</em>), votre compteur ne sera pas mis à jour, mais une seconde sera quand même passée. Donc vous aurez un contrôle du temps limité. La deuxième méthode, elle, évite ce problème.</p></aside><h3 id="r-la-recuperation-directe-du-temps" data-claire-element-id="446196">La récupération directe du temps</h3><p id="r-446190" data-claire-element-id="446190">C'est celle que j'utilise. Elle consiste à récupérer la durée en secondes depuis le 1er Janvier 1970 (c'est l'équivalent de la fonction <code data-claire-semantic="c">time(NULL); </code> qui ne fonctionne pas sur DS).<br/> Voici la fonction (au départ je l'ai conçue en C++) :</p><pre id="r-446191" data-claire-element-id="446191"><code data-claire-semantic="c">int bi(int y)
{
    if((!(y%4)&amp;&amp;!(y%1000))||(!(y%4)&amp;&amp;(y%100)))
        return 1;
    else
        return 0;
}
unsigned int getTicks(void)
{
    unsigned int ret=0;
	int i;
	unsigned int mois[12]={31,0,31,30,31,30,31,31,30,31,30,31};
    for(i=0;i&lt;30+PA_RTC.Year;i++)
        ret+=(bi(1970+i)?366:365)*24*3600;
    for(i=0;i&lt;PA_RTC.Month-1;i++)
    {
        mois[1]=(bi(2000+PA_RTC.Year)?29:28);
        ret+=mois[i]*24*3600;
    }
    ret+=(PA_RTC.Day-1)*24*3600;
	ret+=PA_RTC.Seconds+PA_RTC.Minutes*60+(PA_RTC.Hour-1)*3600;
    return ret;
}</code></pre><p id="r-446192" data-claire-element-id="446192">La fonction <em>bi</em> sert juste à savoir si une année est bissextile ou pas ; c'est la fonction <em>getTicks</em> qui nous intéresse.<br/> Ainsi, nous pouvons faire le code suivant :</p><pre id="r-446193" data-claire-element-id="446193"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

int main(int argc, char ** argv)
{
	PA_Init();
	PA_InitVBL();
	
	PA_InitText(1,0);
	
	PA_WaitForVBL();PA_WaitForVBL();PA_WaitForVBL();
	
	unsigned int debut=getTicks();
	
	while(1)
	{
		PA_OutputText(1,0,0,&quot;%d&quot;,getTicks()-debut); // Affiche le nombre de secondes depuis que le jeu est lancé
		PA_WaitForVBL();
	}
	
	return 0;
}</code></pre><p id="r-446194" data-claire-element-id="446194">Voilà, vous connaissez les deux méthodes, à vous de choisir :) !</p><p id="r-446195" data-claire-element-id="446195">A présent, vous contrôlez le temps :diable: ...</p><h2 id="r-la-3d" data-claire-element-id="446224">La 3D</h2><p id="r-446198" data-claire-element-id="446198">Vous ne pensiez tout de même pas en rester à la 2D ! Nous allons donc voir comment créer un jeu en 3D ^^ .<br/> Vous devez avoir acquis les 5 premiers chapitre de <a href="http://www.siteduzero.com/tutoriel-3-5014-creez-des-programmes-en-3d-avec-opengl.html">Créez des programmes en 3D avec OpenGL</a> (de Kayl) car nous utiliserons des fonctions d'OpenGL.</p><h3 id="r-les-bases-24" data-claire-element-id="446221">Les bases</h3><p id="r-446199" data-claire-element-id="446199">PALib ne gère pas la 3D. Il faudra donc passer par une bibliothèque utilisée par PALib mais de plus bas niveau (en tout cas, la 3D est de haut niveau, mais pas le reste ^^ ), la <em>libnds</em>. La 3D ne peut être utilisée uniquement sur l'écran tactile. Il faut tout d'abord initialiser OpenGL avec <code data-claire-semantic="c">void glInit(); </code>. Ensuite, on va définir notre caméra en plein écran avec <code data-claire-semantic="c">void glViewport(uint8 x1, uint8 y1, uint8 x2, uint8 y2); </code>, nous allons tout le temps l'utiliser comme ceci :</p><pre id="r-446200" data-claire-element-id="446200"><code data-claire-semantic="c">glViewport(0,0,255,191);</code></pre><p id="r-446201" data-claire-element-id="446201">Puis il faut définir une couleur de rafraichissement <strong>opaque</strong> avec <code data-claire-semantic="c">void glClearColor(uint8 r, uint8 g, uint8 b, uint8 a); </code> où <em>r</em>, <em>g</em>, <em>b</em> et <em>a</em> correspondent aux valeurs RGBA de la couleur (31 est la valeur maximale). Donc, si on veut que le fond soit noir (et opaque), il faudra écrire :</p><pre id="r-446202" data-claire-element-id="446202"><code data-claire-semantic="c">glClearColor(0,0,0,31);</code></pre><p id="r-446203" data-claire-element-id="446203">Puis, on définit la perspective (exactement pareil qu'OpenGL sur ordinateur) :</p><pre id="r-446204" data-claire-element-id="446204"><code data-claire-semantic="c">glMatrixMode(GL_PROJECTION);
glLoadIdentity();
gluPerspective(70,(double)256/192,0.1,1000);</code></pre><p id="r-446205" data-claire-element-id="446205">Et là, si vous voulez que votre scène ait un rendu, il faut écrire cette ligne :</p><pre id="r-446206" data-claire-element-id="446206"><code data-claire-semantic="c">glPolyFmt(POLY_ALPHA(31) | POLY_CULL_NONE );</code></pre><p id="r-446207" data-claire-element-id="446207">Dans la boucle, l'écran exécute automatiquement le clear, donc nous n'avons pas besoin de le mettre.<br/> Alors nous n'avons plus qu'à mettre :</p><pre id="r-446208" data-claire-element-id="446208"><code data-claire-semantic="c">glMatrixMode( GL_MODELVIEW );
glLoadIdentity();</code></pre><p id="r-446209" data-claire-element-id="446209">Et à définir la position, la trajectoire et la verticale de la caméra comme sur ordinateur avec :</p><pre id="r-446210" data-claire-element-id="446210"><code data-claire-semantic="c">void gluLookAt(float eyex, float eyey, float eyez,float lookAtx, float lookAty, float lookAtz, float upx, float upy, float upz);</code></pre><p id="r-446211" data-claire-element-id="446211">Vous pouvez ensuite programmer la scène comme bon vous chante, les fonctions étant les mêmes que sur ordinateur.</p><aside id="r-446213" data-claire-element-id="446213" data-claire-semantic="error"><p id="r-446212" data-claire-element-id="446212">La libnds ne prend pas en compte les fonctions ayant le suffixe &quot;d&quot; (prenant des <em>doubles</em> comme argument), il faudra donc utiliser les fonctions ayant le suffixe &quot;f&quot; (flottants). Et le suffixe &quot;ub&quot; a été remplacé par le suffixe &quot;b&quot;.<br/> Il faut faire attention aussi à une chose : la couleur donnée à <em>glClearColor</em> est constituée de valeurs comprises entre 0 et 31 inclus, alors que la couleur donnée aux autres fonctions comme <em>glColor3b</em> est constituée de valeurs comprises entre 0 et 255 inclus.</p></aside><p id="r-446214" data-claire-element-id="446214">Pour afficher la scène il faut faire :</p><pre id="r-446215" data-claire-element-id="446215"><code data-claire-semantic="c">glFlush(0);</code></pre><p id="r-446216" data-claire-element-id="446216">Et il ne reste qu'à mettre <em>PA_WaitForVBL</em> :) !<br/> Voici un code d'exemple (dessin trouvé dans le tuto de Kayl) :</p><pre id="r-446217" data-claire-element-id="446217"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

#define LARGEUR_ECRAN 256
#define HAUTEUR_ECRAN 192

int main(int argc, char ** argv)
{
	int i=0;
	
	PA_Init();
	PA_InitVBL();
	
	videoSetMode(MODE_0_3D);
	
	glInit();
	
	glViewport(0,0,LARGEUR_ECRAN-1,HAUTEUR_ECRAN-1);
	
	glClearColor(0,0,0,31);
	
	glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(70,(double)LARGEUR_ECRAN/HAUTEUR_ECRAN,.1,1000);
    
    glPolyFmt(POLY_ALPHA(31) | POLY_CULL_NONE );
	
	while(1)
	{
		glMatrixMode( GL_MODELVIEW );
		glLoadIdentity( );

		gluLookAt(3,4,2,0,0,0,0,0,1);
		
		glRotatef(i,0,0,1);

	    glBegin(GL_QUADS);

		    glColor3b(255,0,0); //face rouge
		    glVertex3f(1,1,1);
		    glVertex3f(1,1,-1);
		    glVertex3f(-1,1,-1);
		    glVertex3f(-1,1,1);

		    glColor3b(0,255,0); //face verte
		    glVertex3f(1,-1,1);
		    glVertex3f(1,-1,-1);
		    glVertex3f(1,1,-1);
		    glVertex3f(1,1,1);

		    glColor3b(0,0,255); //face bleue
		    glVertex3f(-1,-1,1);
		    glVertex3f(-1,-1,-1);
		    glVertex3f(1,-1,-1);
		    glVertex3f(1,-1,1);

		    glColor3b(255,255,0); //face jaune
		    glVertex3f(-1,1,1);
		    glVertex3f(-1,1,-1);
		    glVertex3f(-1,-1,-1);
		    glVertex3f(-1,-1,1);

		    glColor3b(0,255,255); //face cyan
		    glVertex3f(1,1,-1);
		    glVertex3f(1,-1,-1);
		    glVertex3f(-1,-1,-1);
		    glVertex3f(-1,1,-1);
			
		    glColor3b(255,0,255); //face magenta
		    glVertex3f(1,-1,1);
		    glVertex3f(1,1,1);
		    glVertex3f(-1,1,1);
		    glVertex3f(-1,-1,1);

		glEnd();

		i++;
		i%=360;

		glFlush(0);
		PA_WaitForVBL();
	}
	return 0;
}</code></pre><p id="r-446218" data-claire-element-id="446218">Et vous obtenez un beu cube multicolore qui tourne sur son axe Z ^^ .</p><aside id="r-446220" data-claire-element-id="446220" data-claire-semantic="information"><p id="r-446219" data-claire-element-id="446219">Les quadriques ne sont pas implémentées avec la libnds, il faudra donc les coder vous-même :) .</p></aside><h3 id="r-les-textures-8" data-claire-element-id="446223">Les textures</h3><p id="r-446222" data-claire-element-id="446222">Alors là, les choses se compliquent (j'ai passé une semaine à jouer aux 7 erreurs pour trouver comment créer une texture :-° ).</p><h2 id="r-creer-la-texture" data-claire-element-id="446241">Créer la texture</h2><p id="r-446225" data-claire-element-id="446225">Nous allons commencer par créer un dossier &quot;data&quot; dans le dossier de votre projet, c'est-à-dire là où se trouve <em>build.bat</em>.<br/> Ensuite, il faut télécharger le logiciel <a href="http://www.siteduzero.com/tutoriel-2-157-gimp.html">Gimp</a>.</p><aside id="r-446227" data-claire-element-id="446227" data-claire-semantic="warning"><p id="r-446226" data-claire-element-id="446226">Si vous ne voulez pas télécharger un logiciel aussi lourd et gourmand que Gimp, tournez-vous plutôt vers <a href="http://www.xnview.com/fr/download.html">XnView</a>... L'interface est presque la même pour ce qui est du tuto.</p></aside><p id="r-446228" data-claire-element-id="446228">Une fois installé, lancez-le et faites Ctrl+N (nouveau). Définissez le format de l'image à 128x128. Cliquez sur &quot;Options avancées&quot;, choisissez 72,000 pour la résolution X et Y. Mettez &quot;Couleur RVB&quot; pour &quot;Espace de couleurs&quot; et &quot;Blanc&quot; pour &quot;Remplir avec&quot;.</p><figure id="r-446230" data-claire-element-id="446231"><img id="r-446229" data-claire-element-id="446229" src="medias/uploads.siteduzero.com_files_157001_158000_157302.jpg" alt="Image utilisateur"/></figure><p id="r-446232" data-claire-element-id="446232">Faites votre dessin, puis faites Image -&gt; Mode -&gt; Couleurs Indexées :</p><figure id="r-446234" data-claire-element-id="446235"><img id="r-446233" data-claire-element-id="446233" src="medias/uploads.siteduzero.com_files_157001_158000_157322.jpg" alt="Image utilisateur"/></figure><p id="r-446236" data-claire-element-id="446236">Un fenêtre apparaît alors. Cochez &quot;Générer une palette optimale&quot;, et mettez 255 à &quot;Nombre maximal de couleurs&quot; :</p><figure id="r-446238" data-claire-element-id="446239"><img id="r-446237" data-claire-element-id="446237" src="medias/uploads.siteduzero.com_files_157001_158000_157323.jpg" alt="Image utilisateur"/></figure><p id="r-446240" data-claire-element-id="446240">Il ne vous reste plus, ensuite, qu'à enregistrer l'image dans le dossier <em>data</em>, en mettant l'extension <em>.pcx</em> à votre fichier.</p><h2 id="r-charger-la-texture" data-claire-element-id="446282">Charger la texture</h2><p id="r-446242" data-claire-element-id="446242">Sachez que la mémoire graphique de la DS s'exprime, entre autres, par des VRAM.<br/> Nous allons donc initialiser le système de textures avec :</p><pre id="r-446243" data-claire-element-id="446243"><code data-claire-semantic="c">vramSetMainBanks(VRAM_A_TEXTURE,VRAM_B_TEXTURE,VRAM_C_LCD,VRAM_D_LCD);</code></pre><p id="r-446244" data-claire-element-id="446244">Comme ça, les VRAM A et B sont déclarées en mode texture, et les C et D sont normales. Vous pouvez y aller en tatonnant ^^ . Si certaines textures ne s'affichent pas, c'est qu'il n'y a pas assez de mémoire texture, donc vous pouvez initialiser d'autres VRAM en mode texture.<br/> Puis, on active le système de textures :</p><pre id="r-446245" data-claire-element-id="446245"><code data-claire-semantic="c">glEnable(GL_TEXTURE_2D);</code></pre><p id="r-446246" data-claire-element-id="446246">Et maintenant, on va charger la texture (ellse s'appelle <em>tex_1.pcx</em>).<br/> Mais il faut définir une taille. Les constantes se trouvent dans l'énumération <em>GL_TEXTURE_SIZE_ENUM</em>. Cette-dernière contient (liste complète) :</p><ul id="r-446263" data-claire-element-id="446263"><li id="r-446248" data-claire-element-id="446248"><p id="r-446247" data-claire-element-id="446247">TEXTURE_SIZE_8</p></li><li id="r-446250" data-claire-element-id="446250"><p id="r-446249" data-claire-element-id="446249">TEXTURE_SIZE_16</p></li><li id="r-446252" data-claire-element-id="446252"><p id="r-446251" data-claire-element-id="446251">TEXTURE_SIZE_32</p></li><li id="r-446254" data-claire-element-id="446254"><p id="r-446253" data-claire-element-id="446253">TEXTURE_SIZE_64</p></li><li id="r-446256" data-claire-element-id="446256"><p id="r-446255" data-claire-element-id="446255">TEXTURE_SIZE_128</p></li><li id="r-446258" data-claire-element-id="446258"><p id="r-446257" data-claire-element-id="446257">TEXTURE_SIZE_256</p></li><li id="r-446260" data-claire-element-id="446260"><p id="r-446259" data-claire-element-id="446259">TEXTURE_SIZE_512</p></li><li id="r-446262" data-claire-element-id="446262"><p id="r-446261" data-claire-element-id="446261">TEXTURE_SIZE_1024</p></li></ul><p id="r-446264" data-claire-element-id="446264">Il faudra fournir d'abord la largeur, puis la hauteur. Ici, nos textures ne sont que des carrés de 128*128 ; donc nous mettrons deux fois <em>TEXTURE_SIZE_128</em>.</p><pre id="r-446265" data-claire-element-id="446265"><code data-claire-semantic="c">#include &quot;tex_1.h&quot;
int texture; // Contiendra notre texture
sImage pcx; // Représente l'image
loadPCX((u8*)tex_1, &amp;pcx); // On charge l'image
image8to16(&amp;pcx); // Obligatoire sinon un rendu bizarre :)
// On alloue de la mémoire pour la texture
glGenTextures(1, &amp;texture);
glBindTexture(0, texture);
// On crée la texture
glTexImage2D(0, 0, GL_RGB, TEXTURE_SIZE_128 , TEXTURE_SIZE_128, 0, TEXGEN_TEXCOORD, pcx.image.data8);
imageDestroy(&amp;pcx); // On détruit l'image (mais pas la texture :p )</code></pre><aside id="r-446267" data-claire-element-id="446267" data-claire-semantic="information"><p id="r-446266" data-claire-element-id="446266">Remarquez que le header est le nom du fichier sans &quot;.pcx&quot;, et à la place on a l'extension &quot;.h&quot;. La variable contenant l'image est le nom du fichier sans &quot;.pcx&quot;.</p></aside><p id="r-446268" data-claire-element-id="446268">Ensuite, pour définir la texture courante, on fait :</p><pre id="r-446269" data-claire-element-id="446269"><code data-claire-semantic="c">glBindTexture(GL_TEXTURE_2D, texture);</code></pre><p id="r-446270" data-claire-element-id="446270">Et pour appliquer des coordonnées d'une texture sur un sommet, il suffit de faire :</p><pre id="r-446271" data-claire-element-id="446271"><code data-claire-semantic="c">glTexCoord2f(x,y);  glVertex3f(x1,y1,z);</code></pre><p id="r-446272" data-claire-element-id="446272">Bonne nouvelle, j'ai créé une fonction toute simple qui retourne une texture :</p><pre id="r-446273" data-claire-element-id="446273"><code data-claire-semantic="c">int chargerTexture(const u8 *tex,GL_TEXTURE_SIZE_ENUM width,GL_TEXTURE_SIZE_ENUM height)
{
    sImage pcx;
    int texture;
    loadPCX((u8*)tex, &amp;pcx);
    image8to16(&amp;pcx);
    glGenTextures(1, &amp;texture);
    glBindTexture(0, texture);
    glTexImage2D(0, 0, GL_RGB, width , height, 0, TEXGEN_TEXCOORD, pcx.image.data8);
    imageDestroy(&amp;pcx);
    return texture;
}</code></pre><p id="r-446274" data-claire-element-id="446274">Voici comment elle s'utilise :</p><pre id="r-446275" data-claire-element-id="446275"><code data-claire-semantic="c">#include &quot;tex_1.h&quot; // La texture
int texture=chargerTexture(tex_1,TEXTURE_SIZE_128,TEXTURE_SIZE_128);</code></pre><p id="r-446276" data-claire-element-id="446276">Voici un pack de textures que j'ai programmé pour le cube (les textures sont donc censées être parfaites :) ) : <a href="http://www.megaupload.com/?d=TF0CLHIM">télécharger le pack</a>.<br/> Et un code pour vous montrer que c'est facile :</p><pre id="r-446277" data-claire-element-id="446277"><code data-claire-semantic="c">#include &lt;PA9.h&gt;

#include &quot;tex_1.h&quot;
#include &quot;tex_2.h&quot;
#include &quot;tex_3.h&quot;
#include &quot;tex_4.h&quot;
#include &quot;tex_5.h&quot;
#include &quot;tex_6.h&quot;

#define LARGEUR_ECRAN 256
#define HAUTEUR_ECRAN 192

int chargerTexture(const u8 *tex,GL_TEXTURE_SIZE_ENUM width,GL_TEXTURE_SIZE_ENUM height);

int main(int argc, char ** argv)
{
	int x1=0,x2=0,y1=0,y2=0,c=0;
	int texture[6];
	float rotationX=0.,rotationZ=0.;
	
	PA_Init();
	PA_InitVBL();
	
	videoSetMode(MODE_0_3D);
	vramSetMainBanks(VRAM_A_TEXTURE,VRAM_B_TEXTURE,VRAM_C_LCD,VRAM_D_LCD);
	
	glInit();
	
	glEnable(GL_TEXTURE_2D);
	
	glViewport(0,0,LARGEUR_ECRAN-1,HAUTEUR_ECRAN-1);
	
	glClearColor(0,0,0,31);
	
	texture[0]=chargerTexture(tex_1,TEXTURE_SIZE_128,TEXTURE_SIZE_128);
	texture[1]=chargerTexture(tex_2,TEXTURE_SIZE_128,TEXTURE_SIZE_128);
	texture[2]=chargerTexture(tex_3,TEXTURE_SIZE_128,TEXTURE_SIZE_128);
	texture[3]=chargerTexture(tex_4,TEXTURE_SIZE_128,TEXTURE_SIZE_128);
	texture[4]=chargerTexture(tex_5,TEXTURE_SIZE_128,TEXTURE_SIZE_128);
	texture[5]=chargerTexture(tex_6,TEXTURE_SIZE_128,TEXTURE_SIZE_128);

	glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(70,(double)LARGEUR_ECRAN/HAUTEUR_ECRAN,.1,1000);
    
    glPolyFmt(POLY_ALPHA(31) | POLY_CULL_NONE );
	
	while(1)
	{
		glMatrixMode( GL_MODELVIEW );
		glLoadIdentity( );

		gluLookAt(3,4,2,0,0,0,0,0,1);
		
		glRotatef(rotationX,1,0,0);
		glRotatef(rotationZ,0,0,1);
		
		glColor3b(255,255,255);
		
		glBindTexture(GL_TEXTURE_2D, texture[0]);

	    glBegin(GL_QUADS);
		    glTexCoord2f(0,0);glVertex3f(1,1,1);
		    glTexCoord2f(0,1);glVertex3f(1,1,-1);
		    glTexCoord2f(1,1);glVertex3f(-1,1,-1);
		    glTexCoord2f(1,0);glVertex3f(-1,1,1);
		glEnd();
		
		glBindTexture(GL_TEXTURE_2D, texture[1]);
		
		glBegin(GL_QUADS);
		    glTexCoord2f(0,0);glVertex3f(1,-1,1);
		    glTexCoord2f(0,1);glVertex3f(1,-1,-1);
		    glTexCoord2f(1,1);glVertex3f(1,1,-1);
		    glTexCoord2f(1,0);glVertex3f(1,1,1);
		glEnd();
		
		glBindTexture(GL_TEXTURE_2D, texture[5]);
		
		glBegin(GL_QUADS);
		    glTexCoord2f(0,0);glVertex3f(-1,-1,1);
		    glTexCoord2f(0,1);glVertex3f(-1,-1,-1);
		    glTexCoord2f(1,1);glVertex3f(1,-1,-1);
		    glTexCoord2f(1,0);glVertex3f(1,-1,1);
		glEnd();
		
		glBindTexture(GL_TEXTURE_2D, texture[4]);
		
		glBegin(GL_QUADS);
		    glTexCoord2f(0,0);glVertex3f(-1,1,1);
		    glTexCoord2f(0,1);glVertex3f(-1,1,-1);
		    glTexCoord2f(1,1);glVertex3f(-1,-1,-1);
		    glTexCoord2f(1,0);glVertex3f(-1,-1,1);
		glEnd();
		
		glBindTexture(GL_TEXTURE_2D, texture[2]);
		
		glBegin(GL_QUADS);
		    glTexCoord2f(0,0);glVertex3f(1,1,-1);
		    glTexCoord2f(0,1);glVertex3f(1,-1,-1);
		    glTexCoord2f(1,1);glVertex3f(-1,-1,-1);
		    glTexCoord2f(1,0);glVertex3f(-1,1,-1);
		glEnd();
		
		glBindTexture(GL_TEXTURE_2D, texture[3]);
		
		glBegin(GL_QUADS);
		    glTexCoord2f(0,0);glVertex3f(1,-1,1);
		    glTexCoord2f(0,1);glVertex3f(1,1,1);
		    glTexCoord2f(1,1);glVertex3f(-1,1,1);
		    glTexCoord2f(1,0);glVertex3f(-1,-1,1);
		glEnd();
		
		if(Stylus.Held)
		{
			if(!(c%2))
			{
				x1=Stylus.X;
				y1=Stylus.Y;
			}
			else
			{
				x2=Stylus.X;
				y2=Stylus.Y;
				rotationZ+=x1-x2;
				rotationX+=(y2-y1)*LARGEUR_ECRAN/HAUTEUR_ECRAN;
			}
			c++;
		}
		else if(Stylus.Released)
			c=0;
		glFlush(0);
		PA_WaitForVBL();
	}
	return 0;
}

int chargerTexture(const u8 *tex,GL_TEXTURE_SIZE_ENUM width,GL_TEXTURE_SIZE_ENUM height)
{
    sImage pcx;
    int texture;
    loadPCX((u8*)tex, &amp;pcx);
    image8to16(&amp;pcx);
    glGenTextures(1, &amp;texture);
    glBindTexture(0, texture);
    glTexImage2D(0, 0, GL_RGB, width , height, 0, TEXGEN_TEXCOORD, pcx.image.data8);
    imageDestroy(&amp;pcx);
    return texture;
}</code></pre><aside id="r-446279" data-claire-element-id="446279" data-claire-semantic="warning"><p id="r-446278" data-claire-element-id="446278">Pour cet exemple, il n'y avait que 6 textures. Mais pour vos futures créations, vous aurez sûrement besoin de plus de textures. Donc il faudra investir dans l'UV-Mapping (image ou groupe d'images regroupant toutes les textures).</p></aside><h3 id="r-charger-des-modeles" data-claire-element-id="446281">Charger des modèles</h3><p id="r-446280" data-claire-element-id="446280">Le fait de coder point par point vous fait fuir ? Nous allons voir ici comment charger des fichiers .obj.</p><h2 id="r-charger-des-modeles-de-facon-statique" data-claire-element-id="446298">Charger des modèles de façon statique</h2><p id="r-446283" data-claire-element-id="446283">J'ai développé un logiciel (dont le fonctionnement peut-être comparé avec PAGfx) qui code votre fichier .obj en fichiers .h et .cpp. Ne vous arrêtez pas à l'extension, le code que les fichiers contiennent est compatible C <strong>et</strong> C++... Pour le télécharger c'est <a href="http://www.megaupload.com/?d=I74N06X6">ici</a>. Son petit nom est Obj2NDS. Etonnant, non ;) ?</p><aside id="r-446285" data-claire-element-id="446285" data-claire-semantic="information"><p id="r-446284" data-claire-element-id="446284">Le logiciel a ses limites : il n'exporte pas les normales, seule une texture est acceptée, et les matériaux autres que texture (couleurs, etc.) sont ignorés...</p></aside><div id="r-446287" data-claire-element-id="446287" data-claire-semantic="question"><p id="r-446286" data-claire-element-id="446286">Comment ça fonctionne ?</p></div><p id="r-446288" data-claire-element-id="446288">Pour simplifier les explications, nous allons partir du principe que nous avons un fichier cube.obj (en bleu ce qui change en fonction du nom du fichier .obj).<br/> Lancez le programme. Suivez les instructions (pour les tailles, ce sont celles qui correspondent à TEXTURE_SIZE_XXX). Ensuite vous aurez deux fichiers (cubeOBJ.cpp et cubeOBJ.h) dans le dossier du logiciel. Il faut les copier dans votre dossier source. Puis, comme pour les programmes précédents, il faut créer un dossier data et y mettre votre texture (n'oubliez pas qu'elle doit être au format .pcx et doit contenir 255 couleurs).<br/> Dans votre fichier main, il faut inclure le fichier cubeOBJcpp.<br/> Ce n'est pas tout, il faut initialiser la texture du modèle en faisant un appel à la fonction :</p><p id="r-446289" data-claire-element-id="446289"><cite>Citation</cite></p><blockquote id="r-446291" data-claire-element-id="446291"><p id="r-446290" data-claire-element-id="446290">void initTexCube();</p></blockquote><p id="r-446292" data-claire-element-id="446292">Enfin, pour dessiner votre modèle, il faut faire un appel à la fonction :</p><p id="r-446293" data-claire-element-id="446293"><cite>Citation</cite></p><blockquote id="r-446295" data-claire-element-id="446295"><p id="r-446294" data-claire-element-id="446294">void dessinerCube();</p></blockquote><aside id="r-446297" data-claire-element-id="446297" data-claire-semantic="warning"><p id="r-446296" data-claire-element-id="446296">Même si vous avez écrit &quot;cube&quot; en minuscules, pour les fonctions d'initialisation et de dessin du cube, l'initiale sera <strong>en majuscule</strong> (ce n'est pas une faute d'inattention de ma part ^^ ).</p></aside><h2 id="r-charger-des-modeles-de-facon-dynamique" data-claire-element-id="446309">Charger des modèles de façon dynamique</h2><p id="r-446299" data-claire-element-id="446299">Ici, nous allons voir utiliser une petite lib que j'ai programmée qui charge votre fichier .obj dynamiquement. Pour commencer, il faut la télécharger <a href="http://www.megaupload.com/?d=T38H4ROP">ici</a>. Puis, on extrait les deux fichiers dans le dossier source. Enfin, on inclut le header comme ceci :</p><pre id="r-446300" data-claire-element-id="446300"><code data-claire-semantic="c">#include &quot;OBJlib.h&quot;</code></pre><p id="r-446301" data-claire-element-id="446301">(le fichier .c sera inclu lors de la compilation, automatiquement).</p><p id="r-446302" data-claire-element-id="446302">Nous allons créer une variable qui contiendra notre modèle comme ceci :</p><pre id="r-446303" data-claire-element-id="446303"><code data-claire-semantic="c">MeshObj obj;</code></pre><p id="r-446304" data-claire-element-id="446304">Puis on charge le modèle avec <code data-claire-semantic="c">int charger_obj(MeshObj *modele,char *nom,int largeur,int hauteur); </code>, où <em>modele</em> est la variable qui recevra le modèle, <em>nom</em> le nom du fichier, <em>largeur</em> et <em>hauteur</em> les constante de OpenGL TEXTURE_SIZE_XXX.<br/> En reprenant notre exemple, nous avons un code du genre :</p><pre id="r-446305" data-claire-element-id="446305"><code data-claire-semantic="c">charger_obj(&amp;obj,&quot;modele.obj&quot;,TEXTURE_SIZE_128,TEXTURE_SIZE_128);</code></pre><p id="r-446306" data-claire-element-id="446306">Enfin, pour dessiner votre modèle, il faudra appeler <code data-claire-semantic="c">void draw_model(MeshObj *modele); </code>.<br/> Cette fonction ne fait que dessiner votre modèle, vous pouvez donc appliquer des modifications de matrice (changement d'échelle, translation, rotation, etc.).</p><p id="r-446307" data-claire-element-id="446307">Voilà, bonne modélisation ;) !</p><p id="r-446308" data-claire-element-id="446308">Voilà, alors maintenant faites-moi de beaux jeux en 3D !</p><h2 id="r-systemes-de-connexion" data-claire-element-id="446313">Systèmes de connexion</h2><p id="r-446310" data-claire-element-id="446310">Maintenant que vous savez faire de belles oeuvres, il ne vous manque plus que le mode multijoueur ^^ . Dans cette partie, nous allons voir comment réaliser une connexion Wifi à un site Internet, mais aussi DS à DS.</p><h3 id="r-wifi" data-claire-element-id="446312">Wifi</h3><p id="r-446311" data-claire-element-id="446311">Nous allons voir ici comment nous connecter à une adresse, envoyer des messages et en recevoir.<br/> Rassurez-vous, la méthode ne diffère pas trop de celle employée sur ordinateur...</p><h2 id="r-initialiser-et-arreter-le-wifi" data-claire-element-id="446317">Initialiser et arrêter le Wifi</h2><p id="r-446314" data-claire-element-id="446314">Tout d'abord, jetez un oeil dans votre Makefile. Il faut décommenter <code data-claire-semantic="make">#ARM7_SELECTED = ARM7_MP3_DSWIFI </code> (enlevez le caractère <code data-claire-semantic="make"># </code>) et commenter <code data-claire-semantic="make">ARM7_SELECTED = ARM7_BASIC </code> (ajoutez un <code data-claire-semantic="make"># </code> au début de la ligne).</p><p id="r-446315" data-claire-element-id="446315">Maintenant, retournons à notre fichier source :) ! Nous allons initialiser le système Wifi avec la fonction <code data-claire-semantic="c">void PA_InitWifi(); </code>. A présent, il faut utiliser les paramètres définis à partir d'un jeu commercial (il faut qu'il y ait le logo Wifi) avec la fonction <code data-claire-semantic="cpp">bool PA_ConnectWifiWFC(); </code>. Et là, sa valeur de retour compte plus que d'autres fonctions, car cette fonction rate assez souvent. Elle renvoie vrai si la connection a pu être effectuée ou faux dans le cas contraire.</p><p id="r-446316" data-claire-element-id="446316">Pour vous déconnecter du point d'accès, nous utiliserons <code data-claire-semantic="c">Wifi_DisconnectAP(); </code>, et pour arrêter le Wifi <code data-claire-semantic="c">Wifi_DisableWifi(); </code>.</p><h2 id="r-creer-et-utiliser-des-sockets" data-claire-element-id="446358">Créer et utiliser des sockets</h2><p id="r-446318" data-claire-element-id="446318">Pour établir une connexion en Wifi, il faut passer par les sockets. Comme sur l'ordinateur en fait :) . Une socket est une variable de type <em>int</em> donnée par la fonction <code data-claire-semantic="c">int PA_InitSocket(int *socket,char *host,int port,int mode); </code> où <em>socket</em> est un <strong>pointeur</strong> sur votre socket à initialiser, <em>host</em> est l'adresse IP ou la DNS à laquelle on veut se connecter, <em>port</em> est le... port :p et <em>mode</em> est le type de socket. <em>mode</em> ne peut prendre que deux valeurs différentes :</p><ul id="r-446323" data-claire-element-id="446323"><li id="r-446320" data-claire-element-id="446320"><p id="r-446319" data-claire-element-id="446319">PA_NORMAL_TCP (socket TCP normale).</p></li><li id="r-446322" data-claire-element-id="446322"><p id="r-446321" data-claire-element-id="446321">PA_NONBLOCKING_TCP (socket TCP non bloquée, c'est-à-dire qu'elle ne bloque pas le programme pour attendre la réception d'un message).</p></li></ul><p id="r-446324" data-claire-element-id="446324">L'envoi et la réception de messages sont exatement pareils que sur ordinateur. Nous allons voir cela par le biais d'exemples.</p><h3 id="r-l-envoi-2" data-claire-element-id="446326">L'envoi</h3><pre id="r-446325" data-claire-element-id="446325"><code data-claire-semantic="c">char buf[]=&quot;Hello World !&quot;;
send(sock,buf,sizeof(buf),0);</code></pre><h3 id="r-la-reception-1" data-claire-element-id="446332">La réception</h3><pre id="r-446327" data-claire-element-id="446327"><code data-claire-semantic="c">char buf[256];
recv(sock,buf,sizeof(buf),0);</code></pre><p id="r-446328" data-claire-element-id="446328">Vous le savez sûrement, mais on peut tout envoyer avec les sockets.<br/> Nous allons voir comment faire envoi et une réception optimisée.<br/> Pour cela, nous allons créer deux fonctions (envoi et reception) qui auront pour arguments la socket et un tableau de <em>char</em> (pour envoi : le message à envoyer, pour reception : le contenu du message reçu).<br/> L'envoi doit se faire comme ceci : on envoie d'abord la taille du message, puis le message lui-même.<br/> Et la réception doit se faire comme ceci : on reçoit la taille du message, on fait une allocation dynamique, puis on récupère le message.<br/> On supposera que les types sont traités de la même façon de part et d'autre de la connexion.<br/> Je vous laisse coder ;) ...</p><p id="r-446329" data-claire-element-id="446329"></p><div id="r-446331" data-claire-element-id="446331"><pre id="r-446330" data-claire-element-id="446330"><code data-claire-semantic="c">void envoi(int sock,char *buf)
{
    int taille=sizeof(buf);
    send(sock,&amp;taille,sizeof(taille),0);
    send(sock,buf,taille,0);
}

void reception(int sock,char *buf)
{
    int taille=0;
    if(buf)
        free(buf);
    recv(sock,&amp;taille,sizeof(int),0);
    buf=(char*)malloc(taille*sizeof(char));
    recv(sock,buf,sizeof(buf),0);
}</code></pre></div><h3 id="r-ds-a-ds" data-claire-element-id="446357">DS à DS</h3><p id="r-446333" data-claire-element-id="446333">Nous allons utiliser une bibliothèque qui permet une connexion DS à DS. Elle s'appelle la libLobby. Elle permet des connexions directes ou alors via des <em>rooms</em>.<br/> Normalement, vous l'avez sous forme de zip dans votre disque dur. Allez dans <em>devkitpro\Other libs\</em> et normalement vous avez un zip dont le nom commence par &quot;liblobby&quot;. Ouvrez-le (au besoin, dézippez-le), allez dans le dossier &quot;include&quot; et copiez 802.11.h, lobby.h ainsi que MessageQueue.h.<br/> Maintenant, nous allons modifier notre Makefile. Commentez <code data-claire-semantic="make">ARM7_SELECTED = ARM7_BASIC </code> et décommentez <code data-claire-semantic="make">#ARM7_SELECTED = ARM7_MP3_LIBLOBBY </code>.</p><p id="r-446334" data-claire-element-id="446334">Dans votre source, il faut inclure les trois headers :</p><pre id="r-446335" data-claire-element-id="446335"><code data-claire-semantic="c">#include &quot;MessageQueue.h&quot;
#include &quot;802.11.h&quot;
#include &quot;lobby.h&quot;</code></pre><p id="r-446336" data-claire-element-id="446336">Maintenant on va initialiser la libLobby avec :</p><pre id="r-446337" data-claire-element-id="446337"><code data-claire-semantic="c">IPC_Init();
IPC_SetChannelCallback(0, &amp;LWIFI_IPC_Callback);
LOBBY_Init();</code></pre><p id="r-446338" data-claire-element-id="446338">Maintenant, il faut donner une fonction de réception à la libLobby. En fait, les communications sont non-bloquantes et il n'y a pas de fonction de réception. Vous devez la créer, puis la passer en argument à <code data-claire-semantic="c">void LOBBY_SetStreamHandler(unsigned short streamID, LOBBY_STREAMHANDLER_PROC callback); </code> pour indiquer à la libLobby que votre fonction doit être appelée à chaque réception.<br/> Elle doit être de type <em>void</em> et doit avoir trois arguments (dans l'ordre) :</p><ul id="r-446345" data-claire-element-id="446345"><li id="r-446340" data-claire-element-id="446340"><p id="r-446339" data-claire-element-id="446339">un <strong>pointeur</strong> de type <em>unsigned char</em> : c'est le message.</p></li><li id="r-446342" data-claire-element-id="446342"><p id="r-446341" data-claire-element-id="446341">une variable de type <em>int</em> : c'est la taille du message.</p></li><li id="r-446344" data-claire-element-id="446344"><p id="r-446343" data-claire-element-id="446343">une variable de type <em>LPLOBBY_USER</em> : c'est l'utilisateur qui a envoyé le message.</p></li></ul><p id="r-446346" data-claire-element-id="446346">Voici donc un exemple de fonction de réception :</p><pre id="r-446347" data-claire-element-id="446347"><code data-claire-semantic="c">void reception(unsigned char *message,int taille,LPLOBBY_USER from)
{
    PA_OutputText(0,0,0,&quot;Recu : %s&quot;,(char*)message);
}</code></pre><p id="r-446348" data-claire-element-id="446348">Maintenant nous allons indiquer à la libLobby que la fonction <em>reception</em> est la fonction de réception :</p><pre id="r-446349" data-claire-element-id="446349"><code data-claire-semantic="c">LOBBY_SetStreamHandler(1,&amp;reception);</code></pre><div id="r-446351" data-claire-element-id="446351" data-claire-semantic="question"><p id="r-446350" data-claire-element-id="446350">Qu'est-ce que ce nombre avant le pointeur sur <em>recepetion</em> ?</p></div><p id="r-446352" data-claire-element-id="446352">Il s'agit de l'indentifiant d'un canal. D'après la source, ce nombre peut aller jusqu'à 32 768 mais le canal 32 767 est réservé.</p><div id="r-446354" data-claire-element-id="446354" data-claire-semantic="question"><p id="r-446353" data-claire-element-id="446353">Mais à quoi servent ces canaux ?</p></div><p id="r-446355" data-claire-element-id="446355">En fait, nous le verrons juste après, quand on fait un envoi, il faut préciser le canal. Ceci permet 32 767 fonctions de réceptions différentes. A vous de les gérer pour bien séparer les tâches.</p><p id="r-446356" data-claire-element-id="446356">A présent il faut connaître le nombre de joueurs connectés avec <code data-claire-semantic="c">unsigned short LOBBY_GetNumberOfKnownUsers(void); </code>.</p><h2 id="r-les-fonctions-sur-les-utilisateurs" data-claire-element-id="446365">Les fonctions sur les utilisateurs</h2><p id="r-446359" data-claire-element-id="446359">On peut obtenir un utilisateur par son identifiant avec <code data-claire-semantic="c">LPLOBBY_USER LOBBY_GetUserByID(unsigned short id); </code> où <em>id</em> est compris entre 0 et la valeur de retour de <em>LOBBY_GetNumberOfKnownUsers</em><strong>non inclus</strong>.</p><p id="r-446360" data-claire-element-id="446360">On peut aussi obtenir un utilisateur par son adresse MAC (à voir dans un jeu officiel) avec <code data-claire-semantic="c">LPLOBBY_USER LOBBY_GetUserByMAC(unsigned char *adresse); </code>.</p><p id="r-446361" data-claire-element-id="446361">Pour savoir si un utilisateur est déconnecté on utilise <code data-claire-semantic="c">int LOBBY_IsTimedOut(LPLOBBY_USER utilisateur); </code>. Cette fonction renvoie 1 s'il est déconnecté ou 0 dans le cas contraire.</p><p id="r-446362" data-claire-element-id="446362">Pour obtenir le nom d'un utilisateur on utilisera <code data-claire-semantic="c">const char *LOBBY_GetUserName(LPLOBBY_USER utilisateur); </code>.</p><p id="r-446363" data-claire-element-id="446363">Maintenant que nous connaissons beaucoup de fonctions concernant les utilisateurs, nous allons voir comment leur envoyer des messages.<br/> Il existe la fonction <code data-claire-semantic="c">void LOBBY_SendToUser(LPLOBBY_USER user,unsigned short canal,unsigned char *message,int taille); </code>. C'est là qu'intervient la variable <em>canal</em>. Supposons que vous créez un jeu de combat en temps réel multijoueur. Vous pouvez utiliser la variable <em>canal</em> pour séparer les types d'envois. Par exemple le canal 1 peut servir d'envoi/réception d'infos concernant les autres joueurs connectés, et le canal 2 peut servir d'envoi/réception de messages du système de chat que vous avez récemment intégré au jeu ;) . Ca nous simplifie la vie, et comme nous avons quelques dizaines de milliers de canaux, on peut dire que vous n'avez pas de limite :) .</p><p id="r-446364" data-claire-element-id="446364">Vous pouvez aussi envoyer un message à tous les utilisateurs connus avec <code data-claire-semantic="c">void LOBBY_SendToAll(unsigned short canal, unsigned char *message, int taille); </code>.</p><h2 id="r-les-rooms" data-claire-element-id="446399">Les rooms</h2><aside id="r-446367" data-claire-element-id="446367" data-claire-semantic="information"><p id="r-446366" data-claire-element-id="446366">Il ne peut y avoir qu'une seule room par DS.</p></aside><p id="r-446368" data-claire-element-id="446368">Les rooms sont caractérisées par leur nom, le nombre d'utilisateur maximal, l'identifiant du jeu et sa version.</p><div id="r-446370" data-claire-element-id="446370" data-claire-semantic="question"><p id="r-446369" data-claire-element-id="446369">A quoi servent l'identifiant du jeu et sa version ?</p></div><p id="r-446371" data-claire-element-id="446371">L'identifiant du jeu est un nombre qui indique le jeu utilisant la room. Sa version permet de connaître le fonctionnement du jeu. En fait, si les deux joueurs ont le même jeu, et si chez un joueur, l'identifiant est le même que chez un autre, on peut penser que le fonctionnement est le même (sauf si la version est différente).</p><p id="r-446372" data-claire-element-id="446372">Alors créons notre room avec <code data-claire-semantic="c">void LOBBY_CreateRoom(char *nom,int maxUsers,unsigned short gameCode,unsigned short version); </code>.<br/> On peut définit la visibilité de la room avec <code data-claire-semantic="c">void LOBBY_SetRoomVisibility(int visible); </code>. Si <em>visible</em> vaut 0 la room sera invisible. A l'inverse, si <em>visible</em> vaut 1 la room sera visible. Seul le créateur de la room peut effectuer cette action.</p><p id="r-446373" data-claire-element-id="446373">Pour savoir combien il y a de rooms visibles, on fera appel à <code data-claire-semantic="c">unsigned short LOBBY_GetNumberOfKnownRooms(void); </code>.</p><p id="r-446374" data-claire-element-id="446374">Pour obtenir une room, on utilisera <code data-claire-semantic="c">LPLOBBY_ROOM LOBBY_GetRoomByID(unsigned long id);</code></p><aside id="r-446376" data-claire-element-id="446376" data-claire-semantic="error"><p id="r-446375" data-claire-element-id="446375">Il ne faut pas confondre <em>id</em> avec <em>gameCode</em> (utilisé dans <em>LOBBY_CreateRoom</em>). En effet, <em>id</em> est le &quot;numéro d'apparition&quot; de la room. Par exemple, si c'est la première à avoir été détectée, il faut mettre 0.</p></aside><p id="r-446377" data-claire-element-id="446377">Vous pouvez aussi obtenir une room à partir de l'adresse MAC de la DS du créateur de la room :D en utilisant <code data-claire-semantic="c">LPLOBBY_ROOM LOBBY_GetRoomByMAC(unsigned char *mac); </code>.</p><p id="r-446378" data-claire-element-id="446378">Si vous voulez obtenir la room d'un utilisateur en particulier, il faudra appeler la fonction <code data-claire-semantic="c">LPLOBBY_ROOM LOBBY_GetRoomByUser(LPLOBBY_USER user); </code>.</p><p id="r-446379" data-claire-element-id="446379">De même, si vous voulez obtenir une room à partir de son <em>gameCode</em>, il faudra appeler la fonction <code data-claire-semantic="c">LPLOBBY_ROOM LOBBY_GetRoomByGame(LPLOBBY_ROOM anchor, unsigned short gameCode); </code>. La variable <em>anchor</em> sert à déterminer à partir de quelle room on lance la recherche. Si c'est 0 ce sera la première trouvée.</p><p id="r-446380" data-claire-element-id="446380">Pour savoir combien il y a d'utilisateurs dans une room, on va utiliser <code data-claire-semantic="c">unsigned short LOBBY_GetUsercountInRoom(LPLOBBY_ROOM room); </code>.<br/> De même, pour obtenir le nombre maximal d'utilisateurs, on appellera <code data-claire-semantic="c">unsigned short LOBBY_GetMaxUsercountInRoom(LPLOBBY_ROOM room); </code>. Ces deux fonctions sont très importantes car elles permettent de trouver le nombre de places restantes dans une room.</p><p id="r-446381" data-claire-element-id="446381">Vous pouvez obtenir le nom d'une room avec <code data-claire-semantic="c">char* LOBBY_GetRoomName(LPLOBBY_ROOM room); </code>, son <em>gameCode</em> avec <code data-claire-semantic="c">unsigned short LOBBY_GetRoomGameCode(LPLOBBY_ROOM room); </code> et sa version avec <code data-claire-semantic="c">unsigned short LOBBY_GetRoomGameVersion(LPLOBBY_ROOM room); </code>.</p><p id="r-446382" data-claire-element-id="446382">Avec les fonctions vues ci-dessus, vous pouvez choisir dans quelle room aller. Si vous voulez vous joindre à une room, il faudra utiliser <code data-claire-semantic="c">void LOBBY_JoinRoom(LPLOBBY_ROOM room); </code>. Si vous voulez la quitter, il faudra appeler <code data-claire-semantic="c">void LOBBY_LeaveRoom(void); </code>.</p><p id="r-446383" data-claire-element-id="446383">Vous pouvez envoyer des messages à tous les utilisateurs d'une room avec <code data-claire-semantic="c">void LOBBY_SendToRoom(LPLOBBY_ROOM room, unsigned short canal, unsigned char *message, int taille); </code>. Mais vous pouvez ne pas envoyer de message à tous. En fait, via l'argument <em>canal</em>, vous pouvez faire le tri. Par exemple, si vous voulez envoyer des messages au créateur de la room sans que les autres utilisateurs ne les voient, il faut créer un canal chez le créateur qui n'est pas créé chez les autres. Ainsi, par le biais de ce canal, seul le créateur de la room pourra recevoir les messages...</p><p id="r-446384" data-claire-element-id="446384">Dans vos boucles, au même titre que <em>PA_WaitForVBL</em>, il faudra systématiquement mettre :</p><pre id="r-446385" data-claire-element-id="446385"><code data-claire-semantic="c">IPC_RcvCompleteCheck();
LOBBY_Update();</code></pre><p id="r-446386" data-claire-element-id="446386">Sinon vous ne pourrez jamais ni détecter des utilisateurs et des rooms, ni envoyer ou recevoir de messages...</p><h3 id="r-l-emulateur-4" data-claire-element-id="446398">L'émulateur</h3><p id="r-446387" data-claire-element-id="446387">J'ai une bonne nouvelle : l'émulateur No$GBA supporte très bien la liblobby ! Pour utiliser plus de Nintendo DS au sein de votre émulateur, faites F11 et rendez-vous dans la section &quot;Number of Emulated Gameboys&quot;, et modifiez le nombre en mettant 2 à la place. Faites OK puis Options-&gt;Save Options. Fermez NO$GBA et lancez votre homebrew de nouveau. A présent, vous pouvez constater la résultat :magicien: .<br/> Par contre, si vous voulez revenir à une seule Nintendo DS, il faut aller dans le dossier de NO$GBA et ouvrir NO$GBA.ini. Cherchez une ligne commençant par :</p><p id="r-446388" data-claire-element-id="446388"><cite>Citation : NO$GBA.ini</cite></p><blockquote id="r-446390" data-claire-element-id="446390"><p id="r-446389" data-claire-element-id="446389">Number of Emulated Gameboys ==</p></blockquote><p id="r-446391" data-claire-element-id="446391">Remplacez cette ligne <strong>intégralement</strong> par :</p><p id="r-446392" data-claire-element-id="446392"><cite>Citation : NO$GBA.ini</cite></p><blockquote id="r-446394" data-claire-element-id="446394"><p id="r-446393" data-claire-element-id="446393">Number of Emulated Gameboys == -One Machine</p></blockquote><p id="r-446395" data-claire-element-id="446395">Et voilà ;) !</p><p id="r-446396" data-claire-element-id="446396">Les connexions sur DS n'ont à présent plus aucun secret pour vous ;) !</p><p id="r-446397" data-claire-element-id="446397">Voilà, vous pouvez faire de bons jeux poussés sur votre Nintendo DS préférée :soleil: !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds">Programmez sur votre Nintendo DS !</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-bases-de-palib">
Les bases de PAlib
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-techniques-avancees">
Les techniques avancées
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/annexes-38">
Annexes
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-bases-de-palib">
<span class="arrow"></span>
<span class="next">Les bases de PAlib</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/annexes-38">
<span class="next">Annexes</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Annexes"></a><h2>Annexes</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-techniques-avancees">
<span class="arrow"></span>
<span class="next">Les techniques avancées</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-446401" data-claire-element-id="446401">Ici se trouveront des systèmes particuliers dans un domaine précis, non essentiels au développement sur Nintendo DS.</p><h2 id="r-les-labyrinthes-1" data-claire-element-id="446438">Les labyrinthes</h2><p id="r-446402" data-claire-element-id="446402">Nous allons apprendre comment utiliser les labyrinthes pour guider des personnages contrôlés par l'IA, pour éviter, entre autres, de marcher sur des murs ou d'autres personnages :p ...</p><h3 id="r-les-labyrinthes" data-claire-element-id="446437">Les labyrinthes</h3><p id="r-446403" data-claire-element-id="446403">Vous vous doutez sûrement qu'il est difficile de créer un système aussi complexe qu'un labyrinthe. Ici, il n'est pas question de générer un labyrinthe, mais de pouvoir créer une IA se déplaçant à l'intérieur, sans jamais heurter les murs qui le composent, en arrivant toujours à l'endroit voulu (sauf s'il est entouré de murs :-° ). Mais en fait, grâce à PALib, cette tâche est rendue la plus simple possible.<br/> En effet, il existe plusieurs méthodes pour aller d'un point à un autre. Celle utilisée par PALib est la méthode <strong><a href="http://fr.wikipedia.org/wiki/Algorithme_A%2A">A*</a></strong> (A star). Cette méthode allège les temps de calcul, mais le chemin emprunté n'est pas forcément le plus court (ça dépend de la qualité de l'algorithme). Un tutoriel sur le site à <a href="http://www.siteduzero.com/tutoriel-3-34333-le-pathfinding-avec-a.html">cette adresse</a> montre en détail l'algorithme A*.</p><p id="r-446404" data-claire-element-id="446404">Il faut penser en <em>tiles</em> : définir la taille d'un carré représentant l'unité utilisée par le labyrinthe (par exemple 8x8). Puis, il faut songer aux dimensions du labyrinthe. Elles peuvent être tout ce que vous voulez, mais le labyrinthe doit être absolument un carré. Donc, si vous utilisez un rectangle, vous devrez déclarer le carré à la longueur maximale de la scène, et donc certaines <em>tiles</em> ne seront pas utilisées, mais pas de problème ;) ...</p><p id="r-446405" data-claire-element-id="446405">Donc nous allons initialiser le système de labyrinthes avec <code data-claire-semantic="c">void PA_InitAstar(u16 lx, u16 ly); </code> où <em>lx</em> est le nombre de <em>tiles</em> dans les X du labyrinthe et <em>ly</em> est le nombre de <em>tiles</em> dans les Y du labyrinthes.<br/> Par exemple, si votre scène est un écran, et que vos <em>tiles</em> doivent mesurer 8*8 pixels, alors vous initialiserez le système ainsi :</p><pre id="r-446406" data-claire-element-id="446406"><code data-claire-semantic="c">PA_InitAstar(32,32); //N'oubliez pas, c'est un carré !</code></pre><p id="r-446407" data-claire-element-id="446407">Ou si vous préférez les divisions, voici l'équivalent :</p><pre id="r-446408" data-claire-element-id="446408"><code data-claire-semantic="c">PA_InitAstar(256/8,256/8);</code></pre><p id="r-446409" data-claire-element-id="446409">Cette fonction initialise une variable globale : <em>maze</em> (tableau de <em>u16</em>).</p><div id="r-446411" data-claire-element-id="446411" data-claire-semantic="question"><p id="r-446410" data-claire-element-id="446410">Comment utiliser cette variable ?</p></div><p id="r-446412" data-claire-element-id="446412">Pour y accéder, il faut faire :</p><pre id="r-446413" data-claire-element-id="446413"><code data-claire-semantic="c">maze[x/TAILLE_TILE][y/TAILLE_TILE]</code></pre><p id="r-446414" data-claire-element-id="446414">Maintenant, il faut mettre notre labyrinthe dans la variable <em>maze</em>.<br/> Il existe un &quot;code&quot; permettant de mettre notre labyrinthe dans <em>maze</em> :</p><ul id="r-446423" data-claire-element-id="446423"><li id="r-446416" data-claire-element-id="446416"><p id="r-446415" data-claire-element-id="446415">0 : rien ; le personnage peut passer</p></li><li id="r-446418" data-claire-element-id="446418"><p id="r-446417" data-claire-element-id="446417">1 : point de départ ; position du personnage</p></li><li id="r-446420" data-claire-element-id="446420"><p id="r-446419" data-claire-element-id="446419">2 : arrivée du personnage</p></li><li id="r-446422" data-claire-element-id="446422"><p id="r-446421" data-claire-element-id="446421">5 : mur ; le personnage ne peut pas passer</p></li></ul><p id="r-446424" data-claire-element-id="446424">Donc, si nos <em>tiles</em> mesurent 8*8 pixels, et que le <em>tile</em> (32;16;40;24) doit être un mur, il faudra écrire :</p><pre id="r-446425" data-claire-element-id="446425"><code data-claire-semantic="c">maze[32/8][16/8]=5;</code></pre><p id="r-446426" data-claire-element-id="446426">Ce qui est l'équivalent de :</p><pre id="r-446427" data-claire-element-id="446427"><code data-claire-semantic="c">maze[4][2]=5;</code></pre><div id="r-446429" data-claire-element-id="446429" data-claire-semantic="question"><p id="r-446428" data-claire-element-id="446428">Comment connaître le déplacement à effectuer ?</p></div><p id="r-446430" data-claire-element-id="446430">Avec <code data-claire-semantic="c">s8 PA_Astar(u16 lx, u16 ly); </code> prenant les mêmes arguments que <code data-claire-semantic="c">void PA_InitAstar(u16 lx, u16 ly); </code>.<br/> La fonction retourne un entier qui peut être analysé comme ceci (pour des <em>tiles</em> de 8*8 pixels) :</p><pre id="r-446431" data-claire-element-id="446431"><code data-claire-semantic="c">switch(PA_Astar(256/8,256/8))
{
    case 1: // Gauche
        x-=8;
        break;
    case 2: // Droite
        x+=8;
        break;
    case 3: // Haut
        y-=8;
        break;
    case 4: // Bas
        y+=8;
        break;
    default:
        break;
}</code></pre><p id="r-446432" data-claire-element-id="446432">Voilà, c'est tout, vous êtes dorénavant capable de réaliser une IA pouvant se déplacer dans un labyrinthe ^^ ...</p><figure id="r-446434" data-claire-element-id="446435"><img id="r-446433" data-claire-element-id="446433" src="medias/uploads.siteduzero.com_files_130001_131000_130972.png" alt="Image utilisateur"/></figure><p id="r-446436" data-claire-element-id="446436">Le tutoriel n'est pas fini ! Les chapitres sortent lorsque nous avons le temps de les rédiger, patience... :p</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds">Programmez sur votre Nintendo DS !</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-bases-de-palib">
Les bases de PAlib
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-techniques-avancees">
Les techniques avancées
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/annexes-38">
Annexes
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/programmez-sur-votre-nintendo-ds/les-techniques-avancees">
<span class="arrow"></span>
<span class="next">Les techniques avancées</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/rogrammez-sur-votre-nintendo-ds.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 02:52:44 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/rogrammez-sur-votre-nintendo-ds.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 04:37:50 GMT -->
</html>
<html>

<!-- Mirrored from 62.4.17.167/sdz/sdz/creez-un-jeu-de-sokoban-en-flash.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 11:23:17 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/creez-un-jeu-de-sokoban-en-flash.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:50:15 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Tutoriel : Créez un jeu de Sokoban en Flash !</title>
<link href="medias/sdz_main.css" type="text/css" rel="stylesheet" media="all"/>
</head>
        <body>
<a href="../www.siteduzero.com/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash.html" class="version_en_ligne">Version en ligne</a>
<h1>Tutoriel : Créez un jeu de Sokoban en Flash !</h1>
<h2>Table des matières</h2><div class="table_des_matieres"><a href="#CrezunjeudeSokobanenFlash">Créez un jeu de Sokoban en Flash !</a><br/><a href="#Lecahierdescharges">Le cahier des charges</a><br/><a href="#Lamiseenplacedutableau">La mise en place du tableau</a><br/><a href="#Lagestiondesdplacements">La gestion des déplacements</a><br/><a href="#Lecomptagedespoints">Le comptage des points</a><br/><a href="#LafonctionUndo">La fonction Undo</a><br/><a href="#Enchanementdestableaux">Enchaînement des tableaux</a><br/><a href="#Conclusion">Conclusion</a><br/></div>
<a name="CrezunjeudeSokobanenFlash"></a><h2>Créez un jeu de Sokoban en Flash !</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-cahier-des-charges-7">
<span class="next">Le cahier des charges</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div class="content">
<p id="r-579906" data-claire-element-id="579906">Vous connaissez un peu ActionScript, vous avez lu le tutoriel officiel qui proposait de réaliser un Mario Sokoban en C, et vous vous demandez comment faire un tel programme en Flash...</p><p id="r-579907" data-claire-element-id="579907">Vous êtes tombé au bon endroit ! ^^ <br/> Dans ce tutoriel, je vous propose de réaliser un jeu de Sokoban à l'aide de Flash et d'ActionScript. Vous apprendrez des fonctions avancées de Flash et prendrez au fur et à mesure des habitudes de programmation digne des professionnels !</p>
</div><a name="Lecahierdescharges"></a><h2>Le cahier des charges</h2><div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-mise-en-place-du-tableau">
<span class="next">La mise en place du tableau</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-prerequis-28" data-claire-element-id="579925">Prérequis</h2><p id="r-579908" data-claire-element-id="579908">Ce tutoriel s'adresse aux Zér0s connaissant un minimum les principes de programmation de base en ActionScript (ce ne sont donc plus vraiment des Zér0s :p ). Si vous ne connaissez pas du tout l'ActionScript mais que vous avez des notions en PHP ou en C, je vous propose de lire le début du <a href="http://www.siteduzero.com/tuto-3-276-0-introduction-a-l-039-actionscript.html">tutoriel d'introduction à ActionScript</a> afin de vous adapter à la syntaxe de ce langage qui est toutefois plus ou moins similaire. Quoi qu'il en soit, la lecture de ce tutoriel se révelera sans doute fructueuse, quel que soit le lecteur (du moins j'espère).</p><p id="r-579909" data-claire-element-id="579909">Les notions utilisées dans ce tutoriel seront les suivantes :</p><ul id="r-579922" data-claire-element-id="579922"><li id="r-579911" data-claire-element-id="579911"><p id="r-579910" data-claire-element-id="579910">Déclaration et opérations sur les variables</p></li><li id="r-579913" data-claire-element-id="579913"><p id="r-579912" data-claire-element-id="579912">Manipulations graphiques de clips sur la scène</p></li><li id="r-579915" data-claire-element-id="579915"><p id="r-579914" data-claire-element-id="579914">Gestion des champs de texte dynamiques</p></li><li id="r-579917" data-claire-element-id="579917"><p id="r-579916" data-claire-element-id="579916">Structures de contrôle (conditions, boucles, fonctions)</p></li><li id="r-579919" data-claire-element-id="579919"><p id="r-579918" data-claire-element-id="579918">Importation de variables à partir de fichiers .txt</p></li><li id="r-579921" data-claire-element-id="579921"><p id="r-579920" data-claire-element-id="579920">Syntaxe pointée, tableaux numérotés et indexés</p></li></ul><aside id="r-579924" data-claire-element-id="579924" data-claire-semantic="information"><p id="r-579923" data-claire-element-id="579923">Je le répète, la connaissance de toutes ces notions n'est pas indispensable à la compréhension du tuto. Seule une connaissance globale des structures de contrôle est nécessaire.</p></aside><h2 id="r-le-jeu-de-sokoban" data-claire-element-id="579931">Le jeu de Sokoban</h2><p id="r-579926" data-claire-element-id="579926">Le jeu de Sokoban est un jeu de réflexion qui se joue seul. Le concept est que vous êtes un magasinier qui doit ranger des caisses dans les couloirs d'un entrepôt. Les couloirs ont des formes spécifiques à chaque niveau et il faudra réfléchir de quelle manière et dans quel ordre pousser chaque caisse pour arriver à les caser toutes dans les bons emplacements...<br/> Voici la version de Sokoban que nous allons réaliser ensemble :</p><figure id="r-579928" data-claire-element-id="579929"><img id="r-579927" data-claire-element-id="579927" src="medias/uploads.siteduzero.com_files_40001_41000_40671.jpg" alt="Image utilisateur"/></figure><p id="r-579930" data-claire-element-id="579930">Comme vous pouvez le constater, le magasinier et les caisses ont été ici réduits à leur plus simple expression. En effet, la plupart des version de Sokoban que l'on trouve sur le Web ont abandonné l'idée originale du magasinier et de ses caisses. J'ai décidé, pour ne pas me compliquer la vie, de respecter cette habitude... :-° <br/> Quoi qu'il en soit, je vous propose de <a href="http://www.tryptone.com/sokoban.html">tester ici </a>la version de Sokoban que nous allons réaliser ensemble. Chouette ! :lol:</p><h2 id="r-le-cahier-des-charges-6" data-claire-element-id="579937">Le cahier des charges</h2><p id="r-579932" data-claire-element-id="579932">Maintenant que vous connaissez le principe du jeu, nous allons nous fixer des objectifs pour sa création. Les différentes étapes seront les suivantes :</p><h3 id="r-creation-d-un-premier-tableau" data-claire-element-id="579934">Création d'un premier tableau</h3><p id="r-579933" data-claire-element-id="579933">Nous commencerons par créer un seul niveau. Le but du jeu est donc de mettre un certain nombre de boules dans les emplacements que nous aurons définis. Le jeu se jouera au clavier : les quatre touches directionnelles déplaceront le magasinier, que nous appellerons désormais <em>poussoir</em>. Mais lorsque le poussoir se trouve juste à côté d'une boule, le déplacement suivant provoquera un mouvement du poussoir <em>et</em> de la boule. Autre chose : le poussoir ne peut pousser qu'une boule à la fois. Il faudra donc empêcher celui-ci de se déplacer lorsqu'il se trouve face à deux ou trois boules... Enfin, quand la boule est placée dans l'emplacement destiné à cet effet, le joueur gagne un point. Lorsque le joueur a obtenu autant de points que le nombre de boules, il a gagné et le jeu est fini...</p><h3 id="r-enchainement-des-niveaux" data-claire-element-id="579936">Enchaînement des niveaux</h3><p id="r-579935" data-claire-element-id="579935">Après cette première partie, le plus gros du travail aura été réalisé. Mais nous devrons penser à créer plusieurs niveaux et un programme permettant de passer de l'un à l'autre. Il faudra pour cela modifier notre code en profondeur pour généraliser notre code à plusieurs tableaux. Vous pourrez ainsi ajouter autant de tableaux que vous le souhaitez.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash">Créez un jeu de Sokoban en Flash !</a>
</li>
<ul class="subchapter-parts">
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-cahier-des-charges-7">
Le cahier des charges
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-mise-en-place-du-tableau">
La mise en place du tableau
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-gestion-des-deplacements">
La gestion des déplacements
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-comptage-des-points">
Le comptage des points
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-fonction-undo">
La fonction Undo
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/enchainement-des-tableaux">
Enchaînement des tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/conclusion-58">
Conclusion
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-mise-en-place-du-tableau">
<span class="next">La mise en place du tableau</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lamiseenplacedutableau"></a><h2>La mise en place du tableau</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-cahier-des-charges-7">
<span class="arrow"></span>
<span class="next">Le cahier des charges</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-gestion-des-deplacements">
<span class="next">La gestion des déplacements</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-dans-la-bibliotheque" data-claire-element-id="579965">Dans la bibliothèque</h2><p id="r-579939" data-claire-element-id="579939">Pour commencer, je vous propose de télécharger les images utilisées pour la création des tableaux (clic droit -&gt; enregistrer sous) :</p><figure id="r-579941" data-claire-element-id="579942"><img id="r-579940" data-claire-element-id="579940" src="medias/uploads.siteduzero.com_files_40001_41000_40669.jpg" alt="Image utilisateur"/></figure><p id="r-579943" data-claire-element-id="579943">Le poussoir est contrôlé par le clavier et sert à pousser les boules.</p><figure id="r-579945" data-claire-element-id="579946"><img id="r-579944" data-claire-element-id="579944" src="medias/uploads.siteduzero.com_files_40001_41000_40676.jpg" alt="Image utilisateur"/></figure><p id="r-579947" data-claire-element-id="579947">Les boules sont poussées par le poussoir et doivent se rendre sur les emplacements.</p><figure id="r-579949" data-claire-element-id="579950"><img id="r-579948" data-claire-element-id="579948" src="medias/uploads.siteduzero.com_files_40001_41000_40674.jpg" alt="Image utilisateur"/></figure><p id="r-579951" data-claire-element-id="579951">Les couloirs sont les endroits où le poussoir et les boules peuvent se mouvoir.</p><figure id="r-579953" data-claire-element-id="579954"><img id="r-579952" data-claire-element-id="579952" src="medias/uploads.siteduzero.com_files_40001_41000_40670.jpg" alt="Image utilisateur"/></figure><p id="r-579955" data-claire-element-id="579955">Les murs délimitent la fin du tableau. Le poussoir et les boules s'y cognent.</p><figure id="r-579957" data-claire-element-id="579958"><img id="r-579956" data-claire-element-id="579956" src="medias/uploads.siteduzero.com_files_40001_41000_40675.jpg" alt="Image utilisateur"/></figure><p id="r-579959" data-claire-element-id="579959">Les cibles sont les emplacements destinés à recevoir les boules.</p><figure id="r-579961" data-claire-element-id="579962"><img id="r-579960" data-claire-element-id="579960" src="medias/uploads.siteduzero.com_files_40001_41000_40673.jpg" alt="Image utilisateur"/></figure><p id="r-579963" data-claire-element-id="579963">Le fond est l'arrière-plan qui se trouve au-delà des murs. Le poussoir ne peut y accéder.</p><p id="r-579964" data-claire-element-id="579964">Dans votre nouveau document Flash, commencez par importer ces six images dans la bibliothèque. Ensuite, créez une occurence de chacune d'elles que vous placerez sur la scène et que vous convertirez en symbole de clip. Donnez à chaque clip le nom de l'image qu'il contient (poussoir, boule, mur, fond, couloir, cible). Votre bibliothèque devrait contenir maintenant six images et six clips de même nom.</p><h2 id="r-sur-la-scene" data-claire-element-id="579982">Sur la scène</h2><h3 id="r-les-cases-vides" data-claire-element-id="579972">Les cases vides</h3><p id="r-579966" data-claire-element-id="579966">Un tableau de Sokoban fait au maximum 20*16 cases. Il existe des tableaux plus petits, mais les tableaux originaux de Sokoban ont une grandeur maximale de 20 cases en longueur et de 16 cases en hauteur. Libre à vous bien sûr d'agrandir le tableau par après si ça vous chante... ^^ <br/> Etant donné que chaque case fait 32*32 pixels, la taille de votre animation devra être de 640*512 pixels.</p><p id="r-579967" data-claire-element-id="579967">Maintenant que notre scène a les bonnes dimensions, nous allons placer les cases de notre tableau. Mais attention ! Nous n'allons pas nous contenter d'insérer les éléments de chaque case au bon endroit. En effet, imaginez que vous installiez chaque élément à sa place, un mur par-ci, une cible par-là. Si vous désirez alors changer la disposition des éléments, ou si vous voulez créer plusieurs niveaux, vous serez obligés de permuter les clips entre eux, ce qui vous prendrait bien trop de temps !</p><p id="r-579968" data-claire-element-id="579968">Pour éviter cela, au lieu de placer des clips sur chaque case, nous allons placer des cases &quot;vides&quot; sur la totalité de la scène. Ainsi, lorsque on dira à Flash de charger le niveau 1, il dira à telle ou telle case vide de devenir soit un mur, soit un couloir etc. Cette méthode, bien qu'elle puisse vous paraître repoussante de prime abord, est la méthode la plus orthodoxe et est d'ailleurs utilisée dans toutes les versions de Sokoban...</p><div id="r-579970" data-claire-element-id="579970" data-claire-semantic="question"><p id="r-579969" data-claire-element-id="579969">Bon, tout ça c'est bien, mais concrètement, qu'est ce que je dois faire pour avoir des cases &quot;vides&quot; ?</p></div><p id="r-579971" data-claire-element-id="579971">Pas de panique ! Nous allons tout simplement créer un nouveau clip qui contiendra juste un carré de la taille d'une case. Concrètement donc : dessinez un carré de 32*32 pixels sans remplissage, convertissez-le en clip et donnez-lui le nom de 'vide'. Placez une première occurrence de ce clip en dehors de la scène et appelez-la 'case0000'. Cette case servira de modèle à toutes les autres cases du tableau...</p><h3 id="r-la-grille-du-tableau" data-claire-element-id="579981">La grille du tableau</h3><p id="r-579973" data-claire-element-id="579973">Nous devons maintenant copier cette première case de 'base' autant de fois que nécessaire pour remplir tout le tableau. Mais comme je doute que vous ayez envie d'y aller à coups de copier-coller, manuellement, je vous propose de créer toutes les cases vides avec ActionScript.</p><p id="r-579974" data-claire-element-id="579974">Je vais volontairement omettre de vous expliquer le code qui suit, pour la simple et bonne raison que ce code vous sera expliqué en long et en large dans la suite de cette partie... Pour l'instant, contentez-vous de le taper dans le panneau actions de la première image du scénario...</p><pre id="r-579975" data-claire-element-id="579975"><code>for(y = 0; y &lt; 16; y++) {
   if(y &lt; 10) { y = &quot;0&quot; + y; }
      for(x = 0; x &lt; 20; x++) {
         if(x &lt; 10) { x = &quot;0&quot; + x; }
            case0000.duplicateMovieClip(&quot;case&quot; + y + x, this.getNextHighestDepth());
            _root[&quot;case&quot; + y + x]._x = 32 * Number(x);
            _root[&quot;case&quot; + y + x]._y = 32 * Number(y);
      }
}</code></pre><p id="r-579976" data-claire-element-id="579976">Ce code permet donc d'afficher une panoplie de cases vides prêtes à prendre l'aspect d'un des quatre états possibles (couloir, mur, cible, fond).<br/> Ce qu'il faut savoir, c'est que chaque case a un nom. En fait, le nom d'occurrence de chaque case est de la forme suivante : 'case' + sa position verticale en 2 chiffres + sa position horizontale en 2 chiffres. Ainsi, la première case s'appellera 'case0000' et la dernière 'case1519' (remarquez que l'on commence la numérotation à 0 et pas à 1). Voici le nom des premières cases de votre tableau :</p><figure id="r-579978" data-claire-element-id="579979"><img id="r-579977" data-claire-element-id="579977" src="medias/uploads.siteduzero.com_files_40001_41000_40672.jpg" alt="Image utilisateur"/></figure><p id="r-579980" data-claire-element-id="579980">Ainsi, lorsque Flash chargera un niveau, il demandera à chacune de ces cases de prendre un des quatre aspects disponibles. &quot;Eh toi, là, la septième case de la neuvième colonne, pour ce niveau t'es un mur !&quot; ^^</p><h2 id="r-dans-le-panneau-actions" data-claire-element-id="580005">Dans le panneau Actions</h2><p id="r-579983" data-claire-element-id="579983">Vous allez enfin commencer à programmer ! :) <br/> Ouvrez le panneau Actions sur l'image 1 du scénario principal. Nous allons expliquer à l'ordinateur l'aspect que doit prendre chaque case. Si vous voulez bien, le tableau que nous allons créer est le suivant :</p><figure id="r-579985" data-claire-element-id="579986"><img id="r-579984" data-claire-element-id="579984" src="medias/uploads.siteduzero.com_files_40001_41000_40671.jpg" alt="Image utilisateur"/></figure><p id="r-579987" data-claire-element-id="579987">Il va falloir à présent transformer ce tableau visuel en un tableau compréhensible pour l'ordinateur. Pour cela, nous allons créer un tableau au sens figuré du terme, c'est-à-dire un objet Array...</p><div id="r-579989" data-claire-element-id="579989" data-claire-semantic="question"><p id="r-579988" data-claire-element-id="579988">Mais... Mais... Pourquoi un objet Array ? o_O</p></div><p id="r-579990" data-claire-element-id="579990">Parce que, pour simuler un tableau visuel, il est logique d'utiliser un tableau virtuel ! Dans tous les jeux de plateaux qui comprennent des cases, vous devrez adopter cette technique.<br/> Donc, vous allez créer un tableau à deux dimensions, que vous appellerez 'level1'.</p><pre id="r-579991" data-claire-element-id="579991"><code>level1 = new Array();</code></pre><p id="r-579992" data-claire-element-id="579992">Chaque index de ce tableau sera un tableau imbriqué qui représentera chaque fois une ligne du plateau. Et chaque index des tableaux imbriqués contiendra un chiffre qui représentera l'aspect que devra prendre une case. Les chiffres utilisés seront les suivants :</p><ul id="r-580001" data-claire-element-id="580001"><li id="r-579994" data-claire-element-id="579994"><p id="r-579993" data-claire-element-id="579993">0 = fond</p></li><li id="r-579996" data-claire-element-id="579996"><p id="r-579995" data-claire-element-id="579995">1 = couloir</p></li><li id="r-579998" data-claire-element-id="579998"><p id="r-579997" data-claire-element-id="579997">2 = mur</p></li><li id="r-580000" data-claire-element-id="580000"><p id="r-579999" data-claire-element-id="579999">3 = cible</p></li></ul><p id="r-580002" data-claire-element-id="580002">Mais, comme un petit code source vaut mieux qu'un grand discours, voici le code : :lol:</p><pre id="r-580003" data-claire-element-id="580003"><code>level1[0] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level1[1] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level1[2] =[0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0];
level1[3] =[0,0,0,0,2,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0];
level1[4] =[0,0,0,0,2,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0];
level1[5] =[0,0,2,2,2,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0];
level1[6] =[0,0,2,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0];
level1[7] =[2,2,2,1,2,1,2,2,1,2,0,0,0,2,2,2,2,2,2,0];
level1[8] =[2,1,1,1,2,1,2,2,1,2,2,2,2,2,1,1,3,3,2,0];
level1[9] =[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,2,0];
level1[10]=[2,2,2,2,2,1,2,2,2,1,2,1,2,2,1,1,3,3,2,0];
level1[11]=[0,0,0,0,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,0];
level1[12]=[0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0];
level1[13]=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level1[14]=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level1[15]=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];</code></pre><p id="r-580004" data-claire-element-id="580004">Je réexplique pour ceux qui n'auraient pas compris (je ne vise personne :-° ).<br/> Donc, 'level1' est le nom de l'objet Array qui contient les informations sur tout le tableau. Chaque index de cet Array (il y en a 16) représente une ligne du tableau et est lui-même un Array. Simplement, au lieu d'avoir une valeur Number ou String dans notre Array, nous avons un valeur de type Array...<br/> Chaque ligne, donc, est un Array qui contient cette-fois 20 index (le nombre de colonnes). Et chaque index renferme une valeur cette-fois numérique. Le chiffre doit être compris entre 0 et 3, et chaque valeur représente un état...</p><h2 id="r-interpretation-du-array" data-claire-element-id="580029">Interprétation du Array</h2><p id="r-580006" data-claire-element-id="580006">Nous avons encodé ce que j'appelle une base de donnée, c'est-à-dire que nous avons indiqué à Flash les informations dont il a besoin pour créer le tableau. Seulement, nous devons encore lui expliquer comment interpréter ces informations...</p><p id="r-580007" data-claire-element-id="580007">Pour cela, nous allons lui dire de parcourir chaque case du tableau. A chaque case, il regardera la valeur correspondante dans l'Array bidimensionnel et changera l'aspect du clip en fonction. Mais comment changer l'aspect du clip ? Vous allez devoir utiliser la fonction <em>attachMovie()</em> qui permet d'afficher un clip dans un autre clip...</p><p id="r-580008" data-claire-element-id="580008">Essayons donc cette fonction avec une seule case, pour commencer. Disons par exemple que nous voulons que la case0000 soit un mur... Le prototype de la fonction est le suivant :</p><pre id="r-580009" data-claire-element-id="580009"><code>MovieClip.attachMovie(identifiant:String, nouveaunom:String, profondeur:Number);</code></pre><p id="r-580010" data-claire-element-id="580010">Vous voyez que cette fonction nécessite un identifiant. Cela signifie que le clip destiné à être chargé doit avoir été exporté pour ActionScript. Pour cela, cliquez droit sur le clip dans la bibliothèque et dans le menu de liaison, cochez la case &quot;Exporter pour ActionScript&quot;. Dans le champ identifiant, tapez &quot;aspect&quot; + le numéro de code que nous lui avons attribué (ici 2 pour mur). Répétez l'opération pour les autres clips. Vous aurez donc quatre identifiants nommés respectivement aspect0, aspect1, aspect2, aspect3.</p><p id="r-580011" data-claire-element-id="580011">Maintenant que nous avons un identifiant, examinons les autres paramètres... La profondeur sert à indiquer si le clip devra passer au-dessus ou en-dessous de certains éléments. Dans notre cas, on notera 0 pour qu'il soit au-dessus de tout. Quant au nouveau nom, il ne nous intéresse pas dans notre cas. Nous écrivons donc la propriété <em>_name</em> qui renvoie le nom actuel du clip... En bref, votre code est le suivant :</p><pre id="r-580012" data-claire-element-id="580012"><code>case0000.attachMovie(&quot;aspect2&quot;, this._name, 0);</code></pre><p id="r-580013" data-claire-element-id="580013">Essayez, ça marche ! :) <br/> Bien, maintenant, plutôt que de souffler à l'ordinateur que c'est un mur, nous allons lui dire d'aller voir dans la base de donnée. Pour cela, il faut lui dire de chercher le numéro dans le tableau au bon endroit, et d'accueillir le clip qui porte ce numéro :</p><pre id="r-580014" data-claire-element-id="580014"><code>case0000.attachMovie(&quot;aspect&quot; + level1[0][0], this._name, 0);</code></pre><p id="r-580015" data-claire-element-id="580015">Maintenant, nous n'avons plus qu'à copier ce code pour toutes les cases ! Mais cette opération ne sera pas aussi facile qu'elle n'en a l'air. En effet, à première vue, il faudrait utiliser une boucle. Ou plutôt deux ! En effet, les cases ont chacune deux coordonnées : une pour la ligne et une pour la colonne.<br/> Essayez de comprendre ce code à boucles imbriquées :</p><pre id="r-580016" data-claire-element-id="580016"><code>for(y = 0; y &lt; 16; y++) {
   for(x = 0; x &lt; 20; x++) {
      _root[&quot;case&quot; + y + x].attachMovie(&quot;aspect&quot; + level1[y][x], this._name, 0);
   }
}</code></pre><p id="r-580017" data-claire-element-id="580017">On pourrait considérer x et y, variables d'itérations, comme les coordonnées du 'pointeur' virtuel. Lorsque x vaut 13 et que y vaut 9, le programme s'est déjà occupé des treize premières lignes et est occupé à traiter la dixième case de la quatorzième ligne... L'instruction du milieu, traduite en français, donne : &quot;Prends l'aspect avec le numéro que t'as trouvé dans le tableau, et charge-le dans la case où le pointeur se trouve.&quot; - en très simplifié :D .</p><p id="r-580018" data-claire-element-id="580018">Bon, assez parlé, maintenant testons ce code !</p><div id="r-580020" data-claire-element-id="580020" data-claire-semantic="question"><p id="r-580019" data-claire-element-id="580019">Mais il marche même pas ce code il affiche qu'une partie des cases, comment ça se fait ? o_O</p></div><p id="r-580021" data-claire-element-id="580021">Effectivement... Le gros problème est que nos cases sont numérotées en deux positions, alors que les variables d'itérations sont stockées sous forme de nombre. Or, pour Flash, un nombre c'est par exemple 7 et pas 07. Donc, lorsqu'on lui dit de chercher l'index qui porte le numéro de la case, il cherchera un index 07 et il ne trouvera pas. Donc il va rien charger du tout... C'est bête, quand on y pense, un pc ! :p</p><p id="r-580022" data-claire-element-id="580022">Blague à part, il faudrait trouver une solution... La seule envisageble est d'ajouter un &quot;0&quot; à la variable d'itération si elle est inférieure à dix... Voilà ce que ça donne en code :</p><pre id="r-580023" data-claire-element-id="580023"><code>for(y = 0; y &lt; 16; y++) {
   if(y &lt; 10) { y = &quot;0&quot; + y; }
   for(x = 0; x &lt; 20; x++) {
     if(x &lt; 10) { x = &quot;0&quot; + x; }
     _root[&quot;case&quot;+y+x].attachMovie(&quot;aspect&quot;+level1[Number(y)][Number(x)], this._name, 0);
   }
}</code></pre><div id="r-580025" data-claire-element-id="580025" data-claire-semantic="question"><p id="r-580024" data-claire-element-id="580024">C'est quoi ce truc de fou ? Et d'où il vient ce Number ? :o</p></div><p id="r-580026" data-claire-element-id="580026">Je crois qu'une petite explication s'impose ! ^^ <br/> J'ai ajouté deux conditions. Une pour la boucle des lignes et une pour la boucle des colonnes. La condition dit que, avant d'effectuer quoi que ce soit, on examine la variable d'itération (x ou y). Si elle est plus petite que 10, on va avoir des problèmes pour la suite. Donc, on s'empresse d'ajouter un &quot;0&quot; devant. Mais le problème c'est qu'alors la variable d'itération n'est plus un nombre. C'est devenu un String ! Donc, pour aller chercher dans le tableau, on le convertit en nombre juste le temps de trouver la bonne case. Ensuite, avant de recommencer la boucle, on doit le convertir en nombre définitivement cette fois, pour que l'opération d'incrémentation n'essaie pas bêtement d'incrémenter un string...</p><p id="r-580027" data-claire-element-id="580027">Et voilà ! Essayez donc, ça marche parfaitement. Vous n'avez qu'à vous amuser à changer les chiffres dans le Array pour vérifier ! ^^</p><p id="r-580028" data-claire-element-id="580028">(En fait, le code permettant de créer les cases vides et que je ne vous ai pas expliqué dans un premier temps, avait cette même structure complexe. C'est pour ça que j'ai volontairement passé l'explication sous silence.)</p><h2 id="r-placement-des-boules" data-claire-element-id="580048">Placement des boules</h2><p id="r-580030" data-claire-element-id="580030">Il nous reste une dernière chose à ajouter. En effet, notre système de base de données renseigne Flash sur le dessin du niveau mais pas sur l'emplacement des boules ni du poussoir. Pour cela, commencez par insérez une occurrence du clip <em>poussoir</em>, n'importe où sur la scène. Nommez-la tout simplement <em>poussoir</em> et insérez le code suivant :</p><pre id="r-580031" data-claire-element-id="580031"><code>poussoir1 = [11,10];
poussoir1.swapDepths(this.getNextHighestDepth())</code></pre><p id="r-580032" data-claire-element-id="580032">En fait, nous avons créé un tableau qui renseigne, en premier index, la position horizontale, et en deuxième index, la position verticale... Nous avons ajouté un &quot;1&quot; après le poussoir pour spécifier qu'il s'agit du poussoir du premier niveau (restons toujours dans l'optique qu'il y aura plusieurs niveaux).<br/> Pour l'interprétation, il nous faut tout simplement dire de déplacer le poussoir en fonction des valeurs présentes dans cet Array. Mais notre unité de mesure est en 'cases' alors que celle de Flash est en pixels. Qu'à cela ne tienne, la conversion se fait simplement en multipliant les cases par 32 (la taille en pixels d'une case).</p><p id="r-580033" data-claire-element-id="580033">En ce qui concerne la deuxième ligne, elle sert a renseigner la 'profondeur' du clip poussoir. En effet, si on ne fait pas cela, le poussoir risque de se retrouver en-dessous du clip couloir et on ne le verrait pas parce qu'il serait caché. Il faut donc, par sécurité, spécifier que le clip doit se trouver &quot;tout au-dessus&quot;. Pour cela, on utilise la fonction swapDepths() qui permet de placer un clip à une certaine profondeur. Mais comme on ne connaît pas la profondeur du clip, on va utiliser une méthode qui renvoie la profondeur la &quot;moins profonde&quot; de l'animation. Cette propriété, c'est getNextHighestDepth(). Oui je sais, vous pouviez pas deviner ^^</p><pre id="r-580034" data-claire-element-id="580034"><code>poussoir._x = 32 * poussoir1[0];
poussoir._y = 32 * poussoir1[1];</code></pre><p id="r-580035" data-claire-element-id="580035">Voilà pour le poussoir ! Pour les boules, c'est plus compliqué parce qu'il y en a plusieurs... Commencez par insérer une occurrence du clip <em>boule</em> et placez-la n'importe où sur la scène. Nommez-la <em>boule1</em>. Comme nous ne savons pas dès le départ le nombre de boules que comportera notre niveau, on n'en crée qu'une seule pour l'instant et on la nomme tout simplement <em>boule</em>.</p><p id="r-580036" data-claire-element-id="580036">Pour la base de données, nous allons procéder de même façon que pour le poussoir. Chaque boule sera un Array à deux index. Mais comme il y en a plusieurs, nous ajouterons un Array principal qui comprendra la liste des boules.</p><pre id="r-580037" data-claire-element-id="580037"><code>boules1 = [[5,4],[5,6],[7,5],[7,6],[2,9],[5,9]];</code></pre><p id="r-580038" data-claire-element-id="580038">L'Array <em>boules1</em> est la liste des boules contenues dans le premier niveau, et chaque index est lui-même un Array. J'ai juste utilisé une syntaxe un peu moins claire mais beaucoup plus courte.</p><p id="r-580039" data-claire-element-id="580039">Pour l'interprétation, c'est un rien plus complexe. Il faudra d'abord demander à Flash de copier la boule autant de fois que nécessaire, puis de placer chaque boule à sa place. Pour savoir combien de fois il faut copier la boule, il suffit de demander la longueur du Array <em>boules1</em>. Et pour copier la boule, on utilise une méthode particulière dont voici le prototype :</p><pre id="r-580040" data-claire-element-id="580040"><code>MovieClip.duplicateMovieClip(nouveaunom:String, profondeur:Number)</code></pre><p id="r-580041" data-claire-element-id="580041">Les boules doivent apparaître au-dessus de tout le reste, y compris des cases. En ActionScript, il existe une instruction pour dire cela : <em>getNextHighestDepth</em>. Quant au nouveau nom, ce sera chaque fois <em>boule</em> + le numéro de la boule.</p><pre id="r-580042" data-claire-element-id="580042"><code>for(i = 0; i &lt; boules1.length; i++) {
   boule.duplicateMovieClip(&quot;boule&quot; + i, this.getNextHighestDepth());
}</code></pre><p id="r-580043" data-claire-element-id="580043">Pour l'instant, nous avons six occurrences du clip <em>boule</em> mais elles se trouvent toutes au même endroit. Pour les amener à leurs places respectives, on ajoute ceci dans la boucle :</p><pre id="r-580044" data-claire-element-id="580044"><code>_root[&quot;boule&quot; + i]._x = 32 * boules1[i][0];
_root[&quot;boule&quot; + i]._y = 32 * boules1[i][1];</code></pre><p id="r-580045" data-claire-element-id="580045">Et voilà ! La mise en place du tableau est maintenant terminée. Pour récapituler, voici le code complet auquel vous devriez arriver :</p><pre id="r-580046" data-claire-element-id="580046"><code>//Création des cases
for(y = 0; y &lt; 16; y++) {
   if(y &lt; 10) { y = &quot;0&quot; + y; }
   for(x = 0; x &lt; 20; x++) {
      if(x &lt; 10) { x = &quot;0&quot; + x; }
      case0000.duplicateMovieClip(&quot;case&quot; + y + x, this.getNextHighestDepth());
      _root[&quot;case&quot; + y + x]._x = 32 * Number(x);
      _root[&quot;case&quot; + y + x]._y = 32 * Number(y);
   }
}
//Création de la BDD
level1 = new Array();
level1[0] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level1[1] =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level1[2] =[0,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0];
level1[3] =[0,0,0,0,2,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0];
level1[4] =[0,0,0,0,2,1,1,1,2,0,0,0,0,0,0,0,0,0,0,0];
level1[5] =[0,0,2,2,2,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0];
level1[6] =[0,0,2,1,1,1,1,1,1,2,0,0,0,0,0,0,0,0,0,0];
level1[7] =[2,2,2,1,2,1,2,2,1,2,0,0,0,2,2,2,2,2,2,0];
level1[8] =[2,1,1,1,2,1,2,2,1,2,2,2,2,2,1,1,3,3,2,0];
level1[9] =[2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,2,0];
level1[10]=[2,2,2,2,2,1,2,2,2,1,2,1,2,2,1,1,3,3,2,0];
level1[11]=[0,0,0,0,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,0];
level1[12]=[0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0];
level1[13]=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level1[14]=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level1[15]=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
poussoir1 = [11,10];
boules1 = [[5,4],[5,6],[7,5],[7,6],[2,9],[5,9]];

//Interprétation de la BDD

for(y = 0; y &lt; 16; y++) {
   if(y &lt; 10) { y = &quot;0&quot; + y; }
   for(x = 0; x &lt; 20; x++) {
     if(x &lt; 10) { x = &quot;0&quot; + x; }
     _root[&quot;case&quot;+y+x].attachMovie(&quot;aspect&quot;+level1[Number(y)][Number(x)], this._name, 0);
   }
}
poussoir._x = 32 * poussoir1[0];
poussoir._y = 32 * poussoir1[1];
for(i = 0; i &lt; boules1.length; i++) {
   boule.duplicateMovieClip(&quot;boule&quot; + i, this.getNextHighestDepth());
   _root[&quot;boule&quot; + i]._x = 32 * boules1[i][0];
   _root[&quot;boule&quot; + i]._y = 32 * boules1[i][1];
}</code></pre><p id="r-580047" data-claire-element-id="580047">Maintenant, nous allons nous occuper des mouvements du poussoir dans notre labyrinthe ! :)</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash">Créez un jeu de Sokoban en Flash !</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-cahier-des-charges-7">
Le cahier des charges
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-mise-en-place-du-tableau">
La mise en place du tableau
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-gestion-des-deplacements">
La gestion des déplacements
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-comptage-des-points">
Le comptage des points
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-fonction-undo">
La fonction Undo
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/enchainement-des-tableaux">
Enchaînement des tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/conclusion-58">
Conclusion
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-cahier-des-charges-7">
<span class="arrow"></span>
<span class="next">Le cahier des charges</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-gestion-des-deplacements">
<span class="next">La gestion des déplacements</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lagestiondesdplacements"></a><h2>La gestion des déplacements</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-mise-en-place-du-tableau">
<span class="arrow"></span>
<span class="next">La mise en place du tableau</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-comptage-des-points">
<span class="next">Le comptage des points</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-deplacement-du-poussoir" data-claire-element-id="580069">Déplacement du poussoir</h2><p id="r-580050" data-claire-element-id="580050">Nous allons maintenant nous occuper du déplacement du poussoir dans le tableau. Ce sont les touches directionnelles qui commandent le déplacement. Nous allons donc utiliser la classe <em>Key</em> qui gère les événements claviers. Nous allons ajouter un écouteur qui se chargera de 'surveiller' le clavier. Lorsqu'on appuiera sur une touche, il préviendra l'ordinateur qui vérifiera alors quelle touche a été enfoncée. Si c'est la touche gauche, le poussoir se déplacera à gauche ; si c'est la touche droite, il se déplacera à droite, et ainsi de suite...</p><pre id="r-580051" data-claire-element-id="580051"><code>ecouteur = new Object();
ecouteur.onKeyDown = function () {
   bougerpoussoir(Key.getCode());
}
Key.addListener(ecouteur);</code></pre><p id="r-580052" data-claire-element-id="580052">En résumé, ce code appelle la fonction <em>bougerpoussoir</em> et lui passe comme paramètre le code de la touche enfoncée. Bien sûr, cette fonction <em>bougerpoussoir</em> n'existe pas : nous allons la créer maintenant. :)</p><p id="r-580053" data-claire-element-id="580053">Si on considère les coordonnées d'une case comme (x,y), on peut représenter les déplacements case par case du poussoir selon le schéma suivant :</p><ul id="r-580062" data-claire-element-id="580062"><li id="r-580055" data-claire-element-id="580055"><p id="r-580054" data-claire-element-id="580054">Droite --&gt; (x,y) devient (x+1,y)</p></li><li id="r-580057" data-claire-element-id="580057"><p id="r-580056" data-claire-element-id="580056">Gauche --&gt; (x,y) devient (x-1,y)</p></li><li id="r-580059" data-claire-element-id="580059"><p id="r-580058" data-claire-element-id="580058">Bas --&gt; (x,y) devient (x,y+1)</p></li><li id="r-580061" data-claire-element-id="580061"><p id="r-580060" data-claire-element-id="580060">Haut --&gt; (x,y) devient (x,y-1)</p></li></ul><p id="r-580063" data-claire-element-id="580063">Cela signifie par exemple que, lorsque l'on veut déplacer le poussoir vers la droite, on doit incrémenter la position horizontale de 1. Si par contre on veut le déplacer vers le haut, on doit diminuer la position verticale de 1. Nous allons mettre tout cela en code, tout en gardant à l'esprit qu'une case mesure 32 pixels :</p><pre id="r-580064" data-claire-element-id="580064"><code>function bougerpoussoir(codetouche:Number) {
   switch(codetouche) {
      case Key.RIGHT:
      poussoir._x += 32; break;
      case Key.LEFT:
      poussoir._x -= 32; break;
      case Key.DOWN:
      poussoir._y += 32; break;
      case Key.UP:
      poussoir._y -= 32; break;
   }
}</code></pre><p id="r-580065" data-claire-element-id="580065">Cette fonction est facile à comprendre. Flash analyse le paramètre <em>direction</em> passé par l'appel de la fonction et déplace le poussoir en fonction. Essayez ce code : le poussoir se déplace partout, même à travers les murs. C'est tout à fait normal puisque nous n'avons pas encore fait la gestion des collisions...</p><p id="r-580066" data-claire-element-id="580066">Mais tant qu'on y est, programmons une fonction pour le déplacement des boules. Même si on ne l'appellera pas dans un premier temps, autant la définir en même temps.</p><pre id="r-580067" data-claire-element-id="580067"><code>function bougerboule(codetouche:Number, noboule:Number) {
   switch(codetouche) {
      case Key.RIGHT:
      _root[&quot;boule&quot; + noboule]._x += 32; break;
      case Key.LEFT:
      _root[&quot;boule&quot; + noboule]._x -= 32; break;
      case Key.DOWN:
      _root[&quot;boule&quot; + noboule]._y += 32; break;
      case Key.UP:
      _root[&quot;boule&quot; + noboule]._y -= 32; break;
   }
}</code></pre><p id="r-580068" data-claire-element-id="580068">Pour le déplacement des boules, on doit juste faire passer un paramètre de plus pour que Flash sache quelle boule déplacer... Pour le reste, c'est le même principe que la fonction <em>bougerpoussoir</em>.</p><h2 id="r-anticipation-des-cases" data-claire-element-id="580085">Anticipation des cases</h2><p id="r-580070" data-claire-element-id="580070">Le mouvement du poussoir ne devra s'effectuer que dans des conditions très précises. L'énumération de ces conditions s'appelle la synthèse des collisions. Si on réalise cette synthèse mentalement, on se rend compte que, lorsqu'on veut déplacer le poussoir, deux éléments sont importants : l'aspect des deux cases qui suivent directement le poussoir, et la présence ou non d'une boule sur chacune de ces cases.</p><p id="r-580071" data-claire-element-id="580071">Nous allons donc créer des variables qui rendent compte de ces éléments. Pour cela, commencez par les définir avant la fonction <em>onKeyDown</em> :</p><pre id="r-580072" data-claire-element-id="580072"><code>suivante = new Object();
postsuiv = new Object();</code></pre><p id="r-580073" data-claire-element-id="580073">L'objet <em>suivante</em> renseignera sur la case suivante tandis que l'objet <em>postsuiv</em> renseignera sur la case d'après. Ces objets auront chacun quatre propriétés : <em>posx</em>, <em>posy</em>, <em>aspect</em> et <em>boule</em>.</p><p id="r-580074" data-claire-element-id="580074">A chaque fois que le poussoir se déplacera, il faudra changer les valeurs de ces propriétés. Nous allons donc modifier notre fonction <em>onKeyDown</em>. Les deux premières propriétés, qui renseignent la position de la case, sont trouvées en ajoutant ou en soustrayant 1 ou 2 à la position horizontale ou verticale du poussoir :</p><pre id="r-580075" data-claire-element-id="580075"><code>ecouteur.onKeyDown = function() {
   posx = poussoir._x / 32;
   posy = poussoir._y / 32;
   if(Key.getCode() == Key.RIGHT) {
      suivante.posx = posx + 1;
      suivante.posy = posy;
      postsuiv.posx = posx + 2;
      postsuiv.posy = posy;
   }
   else if(Key.getCode() == Key.LEFT) {
      suivante.posx = posx - 1;
      suivante.posy = posy;
      postsuiv.posx = posx - 2;
      postsuiv.posy = posy;
   }
   else if(Key.getCode() == Key.DOWN) {
      suivante.posx = posx;
      suivante.posy = posy + 1;
      postsuiv.posx = posx;
      postsuiv.posy = posy + 2;

   }
   else if(Key.getCode() == Key.UP) {
      suivante.posx = posx;
      suivante.posy = posy - 1;
      postsuiv.posx = posx;
      postsuiv.posy = posy - 2;
   }
   bougerpoussoir(Key.getCode());
}</code></pre><p id="r-580076" data-claire-element-id="580076">Ce code n'a rien changé de visible dans notre jeu, mais grâce à lui, l'ordinateur peut maintenant connaître à tout moment les coordonnées des deux cases suivantes... C'est déjà bien, mais il faut qu'il soit également renseigné sur l'aspect de ces deux cases. Pour cela, on doit aller chercher dans l'Array principal l'aspect qui correspond aux deux positions que nous venons de définir. Ajoutez donc le code suivant à la suite du reste :</p><pre id="r-580077" data-claire-element-id="580077"><code>suivante.aspect = level1[suivante.posy][suivante.posx];
postsuiv.aspect = level1[postsuiv.posy][postsuiv.posx];</code></pre><p id="r-580078" data-claire-element-id="580078">Flash connaît à présent l'aspect et la position des cases qui se trouvent face à notre poussoir. Nous pouvons maintenant définir la dernière propriété de ces cases : la présence ou non d'une boule... Pour cela, nous devons utiliser une boucle qui vérifiera, pour chaque boule, si oui ou non sa position est la même que celle de la case :</p><pre id="r-580079" data-claire-element-id="580079"><code>ecouteur.onKeyDown = function() {
   // Position des cases suivantes
   posx = poussoir._x / 32;
   posy = poussoir._y / 32;
   if(Key.getCode() == Key.RIGHT) {
      suivante.posx = posx + 1;
      suivante.posy = posy;
      postsuiv.posx = posx + 2;
      postsuiv.posy = posy;
   }
   else if(Key.getCode() == Key.LEFT) {
      suivante.posx = posx - 1;
      suivante.posy = posy;
      postsuiv.posx = posx - 2;
      postsuiv.posy = posy;
   }
   else if(Key.getCode() == Key.DOWN) {
      suivante.posx = posx;
      suivante.posy = posy + 1;
      postsuiv.posx = posx;
      postsuiv.posy = posy + 2;

   }
   else if(Key.getCode() == Key.UP) {
      suivante.posx = posx;
      suivante.posy = posy - 1;
      postsuiv.posx = posx;
      postsuiv.posy = posy - 2;
   }
   // Aspect des cases suivantes
   suivante.aspect = level1[suivante.posy][suivante.posx];
   postsuiv.aspect = level1[postsuiv.posy][postsuiv.posx];
   // Présence d'une boule aux cases suivantes  
   for(i = 0; i &lt; boules1.length; i++) {
      if(_root[&quot;boule&quot; + i]._x / 32 == suivante.posx) {
      if(_root[&quot;boule&quot; + i]._y / 32 == suivante.posy) {
         suivante.boule = i; break;
      }
      }
      else { suivante.boule = undefined; }
   }
for(i = 0; i &lt; boules1.length; i++) {
   if(_root[&quot;boule&quot; + i]._x / 32 == postsuiv.posx) {
   if(_root[&quot;boule&quot; + i]._y / 32 == postsuiv.posy) {
      postsuiv.boule = i; break;
   }
   }
   else { postsuiv.boule = undefined; }
}
   bougerpoussoir(Key.getCode());
}</code></pre><p id="r-580080" data-claire-element-id="580080">Commentons ce code. La première partie se charge de déterminer la position X et Y des deux cases suivantes. Seulement, pour savoir de quelle case 'suivante' on parle, il faut connaître la direction désirée. C'est pour ça qu'il y a une condition... Quant à la deuxième partie, elle renseigne sur l'aspect de ces deux cases en fouillant l'Array principal. La troisième partie, elle, passe toutes les boules en revue et vérifie chaque fois si cette boule se trouve ou non sur la case. Si oui, la propriété <em>boule</em> prend le numéro de cette boule. Si non, la propriété prend la valeur <em>undefined</em>.</p><div id="r-580082" data-claire-element-id="580082" data-claire-semantic="question"><p id="r-580081" data-claire-element-id="580081">Bon, tout ça c'est bien, mais je comprends pas à quoi elles peuvent bien servir toutes ces variables ? Comment vont-elles nous aider à gérer les collisions ? o_O</p></div><p id="r-580083" data-claire-element-id="580083">C'est vrai qu'on pourrait s'interroger sur l'utilité de ces paramètres. Mais vous comprendrez mieux à quel point c'est important lorsque nous nous attaquerons aux tests de collisions. Au moins, maintenant, lorsque l'utilisateur désire se déplacer, Flash maîtrise la situation. Il connaît les élément qui risquent d'intervenir dans le mouvement.</p><p id="r-580084" data-claire-element-id="580084">Mais ne vous inquiétez pas, nous allons mettre tout ça en pratique avec les tests de collisions. :)</p><h2 id="r-gestion-des-collisions-3" data-claire-element-id="580106">Gestion des collisions</h2><p id="r-580086" data-claire-element-id="580086">Maintenant que l'ordinateur connaît bien la situation, nous allons pouvoir attaquer les tests de collisions. Tout d'abord, faisons ensemble la synthèse exhaustive des conditions :</p><ul id="r-580100" data-claire-element-id="580100"><li id="r-580088" data-claire-element-id="580088"><p id="r-580087" data-claire-element-id="580087">Si la case suivante est un mur ou le fond --&gt; Le poussoir reste immobile.</p></li><li id="r-580090" data-claire-element-id="580090"><p id="r-580089" data-claire-element-id="580089">Si la case suivante est une cible ou un couloir exempt de boule --&gt; Le poussoir se déplace.</p></li><li id="r-580099" data-claire-element-id="580099"><p id="r-580091" data-claire-element-id="580091">Si la case suivante est une cible ou un couloir occupé par une boule :</p><ul id="r-580098" data-claire-element-id="580098"><li id="r-580093" data-claire-element-id="580093"><p id="r-580092" data-claire-element-id="580092">Si la case post-suivante est un mur ou le fond --&gt; Le poussoir et la boule restent immobiles</p></li><li id="r-580095" data-claire-element-id="580095"><p id="r-580094" data-claire-element-id="580094">Si la case post-suivante est une cible ou un couloir exempt de boule --&gt; Le poussoir et la boule se déplacent.</p></li><li id="r-580097" data-claire-element-id="580097"><p id="r-580096" data-claire-element-id="580096">Si la case post-suivante est une cible ou un couloir occupé par une boule --&gt; Le poussoir et les deux boules restent immobiles.</p></li></ul></li></ul><p id="r-580101" data-claire-element-id="580101">Maintenant, grâce aux objets <em>suivante</em> et <em>postsuiv</em> que l'on a déterminés, il est facile de rédiger le code qui régit le déplacement du poussoir et des boules :</p><pre id="r-580102" data-claire-element-id="580102"><code>if(suivante.aspect == 1 || suivante.aspect == 3) {
   if(suivante.boule == undefined) {
      bougerpoussoir(Key.getCode());
   }
   else if(suivante.boule != undefined) {
      if(postsuiv.aspect == 1 || postsuiv.aspect == 3) {
         if(postsuiv.boule == undefined) {
            bougerpoussoir(Key.getCode());
            bougerboule(Key.getCode(), suivante.boule);
         }
      }
   }
}</code></pre><p id="r-580103" data-claire-element-id="580103">Ca paraît compliqué, mais quand on y regarde de plus près, on s'aperçoit vite que c'est juste la pure traduction de la synthèse des collisions faite plus haut ! Un petit peu d'habitude avec les <em>if/else</em> suffit à s'y retrouver... ;)</p><p id="r-580104" data-claire-element-id="580104">Plus qu'à tester le code... Normalement, si votre code est en tout point identique au mien, cela devrait fonctionner parfaitement ! Mais n'hésitez pas à tester toutes les possibilités : essayez de pousser deux boules en même temps ou de pousser une boule contre un mur etc.</p><p id="r-580105" data-claire-element-id="580105">La gestion des déplacements est maintenant terminée. Si le code reste encore trouble dans votre esprit, relisez-le en détachant chaque instruction et vous verrez que cela vous paraîtra plus clair... Quoi qu'il en soit, notre premier tableau est presque fini. Il nous reste encore deux étapes. La première est nécessaire, c'est le comptage des points lorsqu'on pousse une boule sur une cible. La deuxième est facultative, c'est la possibilité de revenir plusieurs coups en arrière si l'on s'est trompé...</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash">Créez un jeu de Sokoban en Flash !</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-cahier-des-charges-7">
Le cahier des charges
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-mise-en-place-du-tableau">
La mise en place du tableau
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-gestion-des-deplacements">
La gestion des déplacements
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-comptage-des-points">
Le comptage des points
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-fonction-undo">
La fonction Undo
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/enchainement-des-tableaux">
Enchaînement des tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/conclusion-58">
Conclusion
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-mise-en-place-du-tableau">
<span class="arrow"></span>
<span class="next">La mise en place du tableau</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-comptage-des-points">
<span class="next">Le comptage des points</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Lecomptagedespoints"></a><h2>Le comptage des points</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-gestion-des-deplacements">
<span class="arrow"></span>
<span class="next">La gestion des déplacements</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-fonction-undo">
<span class="next">La fonction Undo</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-580108" data-claire-element-id="580108">Une dernière étape avant d'avoir terminé ce premier tableau est d'ajouter une fonctionnalité de comptage des points. On pourrait à la limite s'en passer car l'utilisateur est censé savoir quand il a terminé le niveau, mais si on reste dans l'optique d'une aventure de plusieurs niveaux, il faudra que le jeu passe au prochain niveau dès que toutes les boules sont dans les cibles. Il faut donc, à chaque déplacement du poussoir, compter le nombre de boules dans les cibles...</p><p id="r-580109" data-claire-element-id="580109">Nous allons donc ajouter à la fonction <em>onKeyDown</em> un appel vers la fonction de comptage des points que nous allons créer. Cet appel doit impérativement se trouver à la fin de <em>onKeyDown</em> parce qu'il est important que les instructions soient exécutées avant la fonction :</p><pre id="r-580110" data-claire-element-id="580110"><code>comptage();</code></pre><p id="r-580111" data-claire-element-id="580111">Nous allons maintenant créer la fonction <em>comptage</em>. Placez cette fonction après les fonctions <em>bougerpoussoir</em> et <em>bougerboule</em>. Cette fonction devra d'abord parcourir toutes les cases et vérifier si l'état de cette case est une cible. Si c'est le cas, elle devra alors parcourir toutes les boules et vérifier si telle ou telle boule se trouve sur cette case. Si c'est le cas, alors on incrémente la variable <em>points</em>.<br/> Allons-y pas à pas ! Pour commencer, codons la boucle qui parcourera toutes les cases :</p><pre id="r-580112" data-claire-element-id="580112"><code>function comptage() {
   points = 0;
   for(y = 0; y &lt; 16; y++) {
      if(y &lt; 10) { y = &quot;0&quot; + y; }
      for(x = 0; x &lt; 20; x++) {
         if(x &lt; 10) { x = &quot;0&quot; + x; }
         //instructions
      }
   }
}</code></pre><p id="r-580113" data-claire-element-id="580113">J'ai commencé par initialiser la variable <em>points</em>, puis j'ai tout simplement recopié la boucle que nous avons utilisé lors de la mise en place du tableau. Vous vous souvenez, le truc avec les Number et les &quot;0&quot; ? :D <br/> Maintenant, pour chaque case qu'elle parcourt, il faut demander à notre fonction si c'est une cible :</p><pre id="r-580114" data-claire-element-id="580114"><code>function comptage() {
   points = 0;
   for(y = 0; y &lt; 16; y++) {
      if(y &lt; 10) { y = &quot;0&quot; + y; }
      for(x = 0; x &lt; 20; x++) {
         if(x &lt; 10) { x = &quot;0&quot; + x; }
         if(level1[Number(y)][Number(x)] == 3) {
            //instructions;
         }
      }
   }
}</code></pre><p id="r-580115" data-claire-element-id="580115">Maintenant, la fonction lit la ligne <em>instructions</em> seulement quand il tombe sur une case de type cible. Nous devons alors lui dire de parcourir toutes les boules et d'incrémenter la variable <em>points</em> chaque fois qu'une boule se trouve sur une cible :</p><pre id="r-580116" data-claire-element-id="580116"><code>function comptage() {
   points = 0;
   for(y = 0; y &lt; 16; y++) {
      if(y &lt; 10) { y = &quot;0&quot; + y; }
      for(x = 0; x &lt; 20; x++) {
         if(x &lt; 10) { x = &quot;0&quot; + x; }
         if(level1[Number(y)][Number(x)] == 3) {
            for(i = 0; i &lt; boules1.length; i++) {
               if(_root[&quot;boule&quot; + i]._x / 32 == x &amp;&amp; _root[&quot;boule&quot; + i]._y / 32 == y) {
                  points++;
               }
            }
         }
      }
   }
}</code></pre><p id="r-580117" data-claire-element-id="580117">Et voilà. Vous n'avez plus qu'à tester l'animation ! Elle devrait fonctionner sans problème, pour autant que vous ayez placé la fonction <em>comptage</em> au bon endroit de telle sorte qu'elle soit déclarée avant d'être appelée...</p><p id="r-580118" data-claire-element-id="580118">Mais avant de pouvoir dire que vous avez vraiment terminé votre premier tableau, vous devez encore ajouter une petite fonctionnalité à votre jeu : un bouton permettant de revenir un ou plusieurs coups en arrière.</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash">Créez un jeu de Sokoban en Flash !</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-cahier-des-charges-7">
Le cahier des charges
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-mise-en-place-du-tableau">
La mise en place du tableau
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-gestion-des-deplacements">
La gestion des déplacements
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-comptage-des-points">
Le comptage des points
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-fonction-undo">
La fonction Undo
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/enchainement-des-tableaux">
Enchaînement des tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/conclusion-58">
Conclusion
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-gestion-des-deplacements">
<span class="arrow"></span>
<span class="next">La gestion des déplacements</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-fonction-undo">
<span class="next">La fonction Undo</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="LafonctionUndo"></a><h2>La fonction Undo</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-comptage-des-points">
<span class="arrow"></span>
<span class="next">Le comptage des points</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/enchainement-des-tableaux">
<span class="next">Enchaînement des tableaux</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-580120" data-claire-element-id="580120">Nous allons maintenant programmer une fonction permettant de revenir plusieurs coups en arrière. Ce sera aussi l'occasion de commencer à soigner l'interface du jeu. Je vous conseille de déjà écrire un titre à votre jeu, de mettre un peu de couleurs, etc. Je vous fais confiance pour ça... ;)</p><h2 id="r-creation-d-un-historique" data-claire-element-id="580139">Création d'un historique</h2><p id="r-580121" data-claire-element-id="580121">La première étape nécessaire à une fonction Undo est de retenir tous les coups joués depuis le début de la partie. Le plus simple pour coder cela est d'utiliser un Array où chaque index représenterait un coup. On pourrait associer une lettre à chaque coup possible :</p><ul id="r-580130" data-claire-element-id="580130"><li id="r-580123" data-claire-element-id="580123"><p id="r-580122" data-claire-element-id="580122">&quot;g&quot; pour un déplacement vers la gauche</p></li><li id="r-580125" data-claire-element-id="580125"><p id="r-580124" data-claire-element-id="580124">&quot;d&quot; pour un déplacement vers la droite</p></li><li id="r-580127" data-claire-element-id="580127"><p id="r-580126" data-claire-element-id="580126">&quot;h&quot; pour un déplacement vers le haut</p></li><li id="r-580129" data-claire-element-id="580129"><p id="r-580128" data-claire-element-id="580128">&quot;b&quot; pour un déplacement vers le bas</p></li></ul><p id="r-580131" data-claire-element-id="580131">Ainsi, à chaque déplacement du poussoir, on ajouterait un index au Array. Mais il faut aussi que Flash soit renseigné sur les mouvements des boules opérés par le poussoir. On va donc, dans le cas d'un déplacement de boule, ajouter à la lettre le numéro de la boule : par exemple, lorsqu'on pousse la boule n° 3 vers le bas, on ajoute la valeur &quot;d3&quot;...</p><p id="r-580132" data-claire-element-id="580132">Pour la mise en code, il faut commencer par initialiser l'objet Array que nous appellerons <em>historique</em>. Placez cette instruction après la déclaration des objets <em>ecouteur</em>, <em>suivante</em> et <em>postsuiv</em>.</p><pre id="r-580133" data-claire-element-id="580133"><code>historique = new Array();</code></pre><p id="r-580134" data-claire-element-id="580134">Ca, c'est facile ! :) Maintenant, on doit placer le code qui permet d'ajouter un index à cet Array à chaque déplacement. Commencons par le déplacement simple (sans poussage de boule). Le code est à placer dans la fonction <em>bougerpoussoir</em></p><pre id="r-580135" data-claire-element-id="580135"><code>function bougerpoussoir(codetouche:Number) {
   switch(codetouche) {
      case Key.RIGHT:
      poussoir._x += 32; historique.push(&quot;d&quot;); break;
      case Key.LEFT:
      poussoir._x -= 32; historique.push(&quot;g&quot;); break;
      case Key.DOWN:
      poussoir._y += 32; historique.push(&quot;b&quot;); break;
      case Key.UP:
      poussoir._y -= 32; historique.push(&quot;h&quot;); break;
   }
}</code></pre><p id="r-580136" data-claire-element-id="580136">J'ai utilisé la fonction <em>push</em> qui permet tout simplement d'ajouter un index à un objet Array. Pour le déplacement avec boule, c'est la même chose mais le code est à placer dans la fonction <em>bougerboule</em>.</p><pre id="r-580137" data-claire-element-id="580137"><code>function bougerboule(codetouche:Number, noboule:Number) {
   switch(codetouche) {
      case Key.RIGHT:
      _root[&quot;boule&quot; + noboule]._x += 32; historique.push(&quot;d&quot; + noboule); break;
      case Key.LEFT:
      _root[&quot;boule&quot; + noboule]._x -= 32; historique.push(&quot;g&quot; + noboule); break;
      case Key.DOWN:
      _root[&quot;boule&quot; + noboule]._y += 32; historique.push(&quot;b&quot; + noboule); break;
      case Key.UP:
      _root[&quot;boule&quot; + noboule]._y -= 32; historique.push(&quot;h&quot; + noboule); break;
   }
}</code></pre><p id="r-580138" data-claire-element-id="580138">Maintenant, sans que nous le sachions, l'ordinateur retient tous les coups que nous jouons dans une liste des coups.</p><h2 id="r-le-bouton-undo" data-claire-element-id="580149">Le bouton Undo</h2><p id="r-580140" data-claire-element-id="580140">Il faut maintenant programmer la fonction qui se déclenche lorsque le joueur appuie sur le bouton Undo. Pour commencer, créez un bouton (un rectangle gris et un texte, par exemple) que vous convertirez en symbole de clip. Donnez-lui simplement <em>undo</em> comme nom d'occurrence.</p><p id="r-580141" data-claire-element-id="580141">Pour le code, il faudra dire à Flash d'effectuer le mouvement inverse de celui désigné par la lettre g,d,b ou h. Commençons par le mouvement simple :</p><pre id="r-580142" data-claire-element-id="580142"><code>undo.onRelease = function() {
   if(historique[historique.length - 1].length == 1) {
      switch(historique[historique.length - 1]) {
         case &quot;d&quot;:
         poussoir._x -= 32; break;
         case &quot;g&quot;:
         poussoir._x += 32; break;
         case &quot;h&quot;:
         poussoir._y += 32; break;
         case &quot;b&quot;:
         poussoir._y -= 32; break;
      }
   }
   historique.pop();
}</code></pre><p id="r-580143" data-claire-element-id="580143">La première ligne sert à savoir si le mouvement à inverser est un mouvement simple ou une poussée de boule. La fonction cherche le dernier index de l'historique, et examine sa longueur. Si elle vaut 1 (g, d, b, h), c'est que c'est un déplacement simple. Si elle vaut 2 (g2, d3, h5, b0), c'est que c'est un poussage de boule.</p><p id="r-580144" data-claire-element-id="580144">Ici donc, l'instruction <em>if</em> vérifie si c'est un mouvement simple. Si c'en est un, alors on déplace le poussoir dans la direction inverse de celle désignée par la lettre trouvée. Mais lorsqu'on revient un coup en arrière, il faut effacer ce coup de l'historique. C'est pourquoi j'ai ajouté l'instruction <em>pop</em> qui permet d'effacer le dernier index d'un Array.</p><p id="r-580145" data-claire-element-id="580145">Ajoutons maintenant le code pour un poussage de boule :</p><pre id="r-580146" data-claire-element-id="580146"><code>undo.onRelease = function() {
   if(historique[historique.length - 1].length == 1) {
      switch(historique[historique.length - 1]) {
         case &quot;d&quot;:
         poussoir._x -= 32; break;
         case &quot;g&quot;:
         poussoir._x += 32; break;
         case &quot;h&quot;:
         poussoir._y += 32; break;
         case &quot;b&quot;:
         poussoir._y -= 32; break;
      }
   }
   else if(historique[historique.length - 1].length == 2) {
      noboule = historique[historique.length - 1].charAt(1);
      switch(historique[historique.length - 1].charAt(0)) {
         case &quot;d&quot;:
         poussoir._x -= 32;
         _root[&quot;boule&quot; + noboule]._x -= 32; break;
         case &quot;g&quot;:
         poussoir._x += 32;
         _root[&quot;boule&quot; + noboule]._x += 32; break;
         case &quot;h&quot;:
         poussoir._y += 32;
         _root[&quot;boule&quot; + noboule]._y += 32; break;
         case &quot;b&quot;:
         poussoir._y -= 32;
         _root[&quot;boule&quot; + noboule]._y -= 32; break;
      }
      historique.pop();
   }
   historique.pop();
}</code></pre><p id="r-580147" data-claire-element-id="580147">La deuxième partie du code est lue uniquement si on a affaire à un déplacement avec poussage de boule. Dans ce cas, on doit bouger le poussoir mais également la boule dont le numéro se trouve dans l'historique. J'ai également ajouté une deuxième instruction <em>pop</em> car on doit effacer de l'historique deux déplacements : celui du poussoir et celui de la boule.</p><p id="r-580148" data-claire-element-id="580148">Et voilà, la création de notre premier tableau Sokoban est enfin terminée. :)</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash">Créez un jeu de Sokoban en Flash !</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-cahier-des-charges-7">
Le cahier des charges
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-mise-en-place-du-tableau">
La mise en place du tableau
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-gestion-des-deplacements">
La gestion des déplacements
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-comptage-des-points">
Le comptage des points
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-fonction-undo">
La fonction Undo
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/enchainement-des-tableaux">
Enchaînement des tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/conclusion-58">
Conclusion
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-comptage-des-points">
<span class="arrow"></span>
<span class="next">Le comptage des points</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/enchainement-des-tableaux">
<span class="next">Enchaînement des tableaux</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Enchanementdestableaux"></a><h2>Enchaînement des tableaux</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-fonction-undo">
<span class="arrow"></span>
<span class="next">La fonction Undo</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/conclusion-58">
<span class="next">Conclusion</span>
<span class="arrow"></span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<p id="r-580151" data-claire-element-id="580151">Nous allons maintenant nous attaquer à la dernière phase de création de notre Sokoban, à savoir la création de d'une aventure de plusieurs tableaux et la possibilité d'en ajouter.</p><h2 id="r-duplication-de-la-base-de-donnees" data-claire-element-id="580165">Duplication de la base de données</h2><p id="r-580152" data-claire-element-id="580152">Rappelez-vous : la base de données comprenant les informations de notre premier tableau est constituée des éléments suivants :</p><ul id="r-580159" data-claire-element-id="580159"><li id="r-580154" data-claire-element-id="580154"><p id="r-580153" data-claire-element-id="580153">Un tableau <em>level1</em> pour l'aspect des cases (tableau bidimensionnel)</p></li><li id="r-580156" data-claire-element-id="580156"><p id="r-580155" data-claire-element-id="580155">Un tableau <em>boules1</em> pour la position des boules (tableau bidimensionnel)</p></li><li id="r-580158" data-claire-element-id="580158"><p id="r-580157" data-claire-element-id="580157">Un tableau <em>poussoir1</em> pour la position du poussoir</p></li></ul><p id="r-580160" data-claire-element-id="580160">Pour créer trois tableaux différents, il faut commencer par copier la base de données dix fois en modifiant juste les noms des Array (level2, boules2 ,poussoir2). A partir de là, on change l'aspect des cases, la position du poussoir et celle des boules dans chacun de ces Array.</p><p id="r-580161" data-claire-element-id="580161">Les trois tableaux que je vais vous proposer sont les plus classiques, présents dans la plupart des jeux de Sokoban en ligne. Bien sûr, il est aussi amusant d'en créer soi-même, vous pourrez donc par la suite ajouter d'autres niveaux en plus des trois premiers...</p><p id="r-580162" data-claire-element-id="580162">Vous pouvez donc ajouter le code suivant à la suite de la base de donnée du premier tableau :</p><pre id="r-580163" data-claire-element-id="580163"><code>level2 = new Array();
level2[0] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level2[1] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level2[2] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level2[3] = [0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0];
level2[4] = [0,0,0,2,3,3,1,1,2,1,1,1,1,1,2,2,2,0,0,0];
level2[5] = [0,0,0,2,3,3,1,1,2,1,1,1,1,1,1,1,2,0,0,0];
level2[6] = [0,0,0,2,3,3,1,1,2,1,2,2,2,2,1,1,2,0,0,0];
level2[7] = [0,0,0,2,3,3,1,1,1,1,1,1,2,2,1,1,2,0,0,0];
level2[8] = [0,0,0,2,3,3,1,1,2,1,2,1,1,1,1,2,2,0,0,0];
level2[9] = [0,0,0,2,2,2,2,2,2,1,2,2,1,1,1,1,2,0,0,0];
level2[10]= [0,0,0,0,0,2,1,1,1,1,1,1,1,1,1,1,2,0,0,0];
level2[11]= [0,0,0,0,0,2,1,1,1,1,2,1,1,1,1,1,2,0,0,0];
level2[12]= [0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0];
level2[13]= [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level2[14]= [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level2[15]= [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
poussoir2 = [10,07];
boules2 = [[7,10],[9,6],[10,5],[13,5],[13,8],[14,9],[14,10],[12,9],[12,10],[10,10]];
level3 = new Array();
level3[0] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level3[1] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level3[2] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level3[3] = [0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0];
level3[4] = [0,0,0,0,0,0,0,0,0,2,1,1,1,1,1,1,2,0,0,0];
level3[5] = [0,0,0,0,0,0,0,0,0,2,1,1,2,1,1,2,2,0,0,0];
level3[6] = [0,0,0,0,0,0,0,0,0,2,1,1,1,1,1,2,0,0,0,0];
level3[7] = [0,0,0,0,0,0,0,0,0,2,2,1,1,1,1,2,0,0,0,0];
level3[8] = [0,2,2,2,2,2,2,2,2,2,1,1,1,2,1,2,2,2,0,0];
level3[9] = [0,2,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,2,0,0];
level3[10] = [0,2,2,3,3,3,1,1,1,1,1,1,1,1,1,1,1,2,0,0];
level3[11] = [0,2,3,3,3,3,1,1,2,2,2,2,2,2,2,2,2,2,0,0];
level3[12] = [0,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0];
level3[13] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level3[14] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
level3[15] = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
poussoir3 = [15,04];
boules3 = [[10,10],[11,5],[11,6],[11,7],[11,8],[11,9],[13,5],[14,6],[13,7],[14,9],[13,10]];</code></pre><p id="r-580164" data-claire-element-id="580164">A présent, ActionScript a toutes les informations nécessaires à la mise en place des trois tableaux de notre Sokoban. Le travail de base de données est donc terminé. Mais nous devons maintenant changer l'interprétation de cette base de données, puisque elle ne gère pour l'instant qu'un seul niveau.</p><h2 id="r-interpretation-de-la-base-de-donnees" data-claire-element-id="580181">Interprétation de la base de données</h2><p id="r-580166" data-claire-element-id="580166">Rappelez-vous du code que nous avons utilisé pour interpréter la base de donnée du premier tableau :</p><pre id="r-580167" data-claire-element-id="580167"><code>for(y = 0; y &lt; 16; y++) {
   if(y &lt; 10) { y = &quot;0&quot; + y; }
   for(x = 0; x &lt; 20; x++) {
     if(x &lt; 10) { x = &quot;0&quot; + x; }
     _root[&quot;case&quot;+y+x].attachMovie(&quot;aspect&quot;+level1[Number(y)][Number(x)], this._name, 0);
   }
}
poussoir._x = 32 * poussoir1[0];
poussoir._y = 32 * poussoir1[1];
for(i = 0; i &lt; boules1.length; i++) {
   boule.duplicateMovieClip(&quot;boule&quot; + i, this.getNextHighestDepth());
   _root[&quot;boule&quot; + i]._x = 32 * boules1[i][0];
   _root[&quot;boule&quot; + i]._y = 32 * boules1[i][1];
}</code></pre><p id="r-580168" data-claire-element-id="580168">Réflechissez un petit peu. Ce code est limité à un seul tableau, et il faut le généraliser pour tous les tableaux. En imaginant que l'on aie une variable <em>noniveau</em> qui représente le numéro du tableau en cours, on pourrait remplacer :</p><ul id="r-580175" data-claire-element-id="580175"><li id="r-580170" data-claire-element-id="580170"><p id="r-580169" data-claire-element-id="580169">level1 par _root[&quot;level&quot; + noniveau]</p></li><li id="r-580172" data-claire-element-id="580172"><p id="r-580171" data-claire-element-id="580171">boules1 par _root[&quot;boules&quot; + noniveau]</p></li><li id="r-580174" data-claire-element-id="580174"><p id="r-580173" data-claire-element-id="580173">poussoir1 par _root[&quot;poussoir&quot; + noniveau]</p></li></ul><p id="r-580176" data-claire-element-id="580176">C'est exactement ce que nous allons faire. Remplacez le code d'interprétation par le code suivant, et observez les modifications qui ont été apportées :</p><pre id="r-580177" data-claire-element-id="580177"><code>for(y = 0; y &lt; 16; y++) {
   if(y &lt; 10) { y = &quot;0&quot; + y; }
   for(x = 0; x &lt; 20; x++) {
     if(x &lt; 10) { x = &quot;0&quot; + x; }
     _root[&quot;case&quot;+y+x].attachMovie(&quot;aspect&quot;+_root[&quot;level&quot; + noniveau][Number(y)][Number(x)], this._name, 0);
   }
}
poussoir._x = 32 * _root[&quot;poussoir&quot; + noniveau][0];
poussoir._y = 32 * _root[&quot;poussoir&quot; + noniveau][1];
for(i = 0; i &lt; _root[&quot;boules&quot; + noniveau].length; i++) {
   boule.duplicateMovieClip(&quot;boule&quot; + i, this.getNextHighestDepth());
   _root[&quot;boule&quot; + i]._x = 32 * _root[&quot;boules&quot; + noniveau][i][0];
   _root[&quot;boule&quot; + i]._y = 32 * _root[&quot;boules&quot; + noniveau][i][1];
}</code></pre><p id="r-580178" data-claire-element-id="580178">Et voilà ! En effectuant simplement le remplacement d'un terme par un autre, on a généralisé le code d'interprétation pour n'importe quel niveau. Pour tester ce code, initialisez la variable du numéro du tableau :</p><pre id="r-580179" data-claire-element-id="580179"><code>noniveau = 2;</code></pre><p id="r-580180" data-claire-element-id="580180">Placez cette instruction à la toute première ligne de votre code puis lancez l'animation. Vous verrez alors apparaître sous vos yeux un nouveau tableau de Sokoban ! Testez aussi la valeur 3 pour essayer encore un autre tableau !</p><h2 id="r-generalisation-des-deplacements" data-claire-element-id="580188">Généralisation des déplacements</h2><p id="r-580182" data-claire-element-id="580182">Bien sûr, tout n'est pas encore parfait ! Vous pouvez visualiser les nouveaux tableaux, mais pas encore vous déplacer dedans. Pour cela, il faudra faire la même opération que précédemment, mais pour la section &quot;gestion des déplacements&quot; de notre code. Il suffit de remplacer le <em>1</em> par le numéro du tableau en cours.</p><p id="r-580183" data-claire-element-id="580183">Les fonctions <em>bougerboule</em> et <em>bougerpoussoir</em> ne demandent à aucun moment le numéro du niveau. On ne les modifiera donc pas. Pour ce qui concerne le bouton Undo, c'est pareil : on n'y touchera pas. Par contre, la fonction <em>onKeyDown</em> qui gère les déplacements a besoin du numéro du tableau lorsqu'elle cherche l'aspect des cases suivantes et post-suivantes. Voici donc la partie modifiée de cette fonction <em>onKeyDown</em> :</p><pre id="r-580184" data-claire-element-id="580184"><code>// Aspect des cases suivantes
suivante.aspect = _root[&quot;level&quot; + noniveau][suivante.posy][suivante.posx];
postsuiv.aspect = _root[&quot;level&quot; + noniveau][postsuiv.posy][postsuiv.posx];
// Présence d'une boule aux cases suivantes 
for(i = 0; i &lt; _root[&quot;boules&quot; + noniveau].length; i++) {
   if(_root[&quot;boule&quot; + i]._x / 32 == suivante.posx) {
      if(_root[&quot;boule&quot; + i]._y / 32 == suivante.posy) {
         suivante.boule = i; break;
      }
   }
   else { suivante.boule = undefined; }
}
for(i = 0; i &lt; _root[&quot;boules&quot; + noniveau].length; i++) {
   if(_root[&quot;boule&quot; + i]._x / 32 == postsuiv.posx) {
      if(_root[&quot;boule&quot; + i]._y / 32 == postsuiv.posy) {
         postsuiv.boule = i; break;
      }
   }
   else { postsuiv.boule = undefined; }
}</code></pre><p id="r-580185" data-claire-element-id="580185">Testez à présent le code. Le joueur peut se déplacer dans le tableau et pousser des boules. Cependant, le comptage des points ne marche pas... C'est normal, car la fonction <em>comptage</em> fait elle aussi appel au numéro du tableau. La voici donc modifiée :</p><pre id="r-580186" data-claire-element-id="580186"><code>function comptage() {
   points = 0;
   for(y = 0; y &lt; 16; y++) {
      if(y &lt; 10) { y = &quot;0&quot; + y; }
      for(x = 0; x &lt; 20; x++) {
         if(x &lt; 10) { x = &quot;0&quot; + x; }
         if(_root[&quot;level&quot; + noniveau][Number(y)][Number(x)] == 3) {
            for(i = 0; i &lt; _root[&quot;boules&quot; + noniveau].length; i++) {
               if(_root[&quot;boule&quot; + i]._x / 32 == x &amp;&amp; _root[&quot;boule&quot; + i]._y / 32 == y) {
                  points++;
               }
            }
         }
      }
   }
}</code></pre><p id="r-580187" data-claire-element-id="580187">Voilà ! Tous les remplacements ayant été faits, notre programme est maintenant capable de gérer plusieurs tableaux.</p><h2 id="r-passage-d-un-niveau-a-un-autre" data-claire-element-id="580203">Passage d'un niveau à un autre</h2><p id="r-580189" data-claire-element-id="580189">Nous allons maintenant coder la dernière partie du code qui permet de passer au tableau suivant lorsque le premier est terminé. En pratique, il faudra effectuer la section &quot;interprétation&quot; de notre code à chaque fois que l'on change de niveau. Et pour cela, on est obligés de transformer cette partie du code en une fonction.</p><p id="r-580190" data-claire-element-id="580190">Pour cela, il faut d'abord initialiser la fonction, qu'on appellera <em>interpretation</em>. Et nous allons déplacer une série d'éléments de notre code dans notre fonction. En fait, tout les instructions 'libre' - extérieurs à une fonction - vont être placées dans la fonction <em>interpretation</em> qui sera appelée à chaque changement de tableau et qui servira à remettre à zéro toutes les variables. Cela donne donc :</p><pre id="r-580191" data-claire-element-id="580191"><code>function interpretation() {
   historique = new Array();
   suivante = new Object();
   postsuiv = new Object();
   for(y = 0; y &lt; 16; y++) {
      if(y &lt; 10) { y = &quot;0&quot; + y; }
      for(x = 0; x &lt; 20; x++) {
         if(x &lt; 10) { x = &quot;0&quot; + x; }
        _root[&quot;case&quot;+y+x].attachMovie(&quot;aspect&quot;+_root[&quot;level&quot; + noniveau][Number(y)][Number(x)], this._name, 0);
      }
   }
   poussoir._x = 32 * _root[&quot;poussoir&quot; + noniveau][0];
   poussoir._y = 32 * _root[&quot;poussoir&quot; + noniveau][1];
   for(i = 0; i &lt; _root[&quot;boules&quot; + noniveau].length; i++) {
      boule.duplicateMovieClip(&quot;boule&quot; + i, this.getNextHighestDepth());
      _root[&quot;boule&quot; + i]._x = 32 * _root[&quot;boules&quot; + noniveau][i][0];
      _root[&quot;boule&quot; + i]._y = 32 * _root[&quot;boules&quot; + noniveau][i][1];
   }
}
noniveau = 1;
interpretation();</code></pre><p id="r-580192" data-claire-element-id="580192">Après la définition de la fonction, on l'appelle une première fois pour la mise en place du premier tableau.<br/> La fonction est définie, il ne reste plus qu'à l'appeler ! Cet appel devra se faire uniquement lorsque l'utilisateur place la dernière boule sur une cible. On va donc ajouter une condition qui surveillera la variable <em>points</em> et qui examinera sa valeur chaque fois que celle-ci change. Elle lorsque le nombre de points est égal au nombre de boules, on passe au tableau suivant en appelant la fonction après avoir incrémenté la variable <em>noniveau</em>. Cet appel se fait dans la fonction <em>comptage</em> :</p><pre id="r-580193" data-claire-element-id="580193"><code>function comptage() {
   points = 0;
   for(y = 0; y &lt; 16; y++) {
      if(y &lt; 10) { y = &quot;0&quot; + y; }
      for(x = 0; x &lt; 20; x++) {
         if(x &lt; 10) { x = &quot;0&quot; + x; }
         if(level1[Number(y)][Number(x)] == 3) {
            for(i = 0; i &lt; boules1.length; i++) {
               if(_root[&quot;boule&quot; + i]._x / 32 == x &amp;&amp; _root[&quot;boule&quot; + i]._y / 32 == y) {
                  points++;
                  if(points == _root[&quot;boules&quot; + noniveau].length) {
                     noniveau++;
                     interpretation();
                  }
               }
            }
         }
      }
   }
}</code></pre><p id="r-580194" data-claire-element-id="580194">Voilà ! A la fin de cette opération, votre code n'est plus constitué que de fonctions - hormis la base de données. Toute les fonctionnalités du jeu sont sous forme de fonctions qui s'appellent les unes les autres. La seule instruction libre restante est bien sûr le premier appel de la fonction <em>interpretation</em>.</p><p id="r-580195" data-claire-element-id="580195">Si vous n'avez pas très bien compris ce qu'il fallait mettre dans la fonction <em>interpretation</em>, voici un petit résumé des bouts de codes qui se sont glissés à l'intérieur de la fonction :</p><ul id="r-580202" data-claire-element-id="580202"><li id="r-580197" data-claire-element-id="580197"><p id="r-580196" data-claire-element-id="580196">Toute la partie que j'appelle &quot;interprétation du code&quot; et que nous avons codé dans la section &quot;Mise en place du tableau&quot;.</p></li><li id="r-580199" data-claire-element-id="580199"><p id="r-580198" data-claire-element-id="580198">L'initialisation du Array <em>historique</em>, pour que l'ordinateur ne retiennent pas les coups des niveaux précédents.</p></li><li id="r-580201" data-claire-element-id="580201"><p id="r-580200" data-claire-element-id="580200">L'initialisation des Objects <em>suivante</em> et <em>postsuiv</em>, également pour que l'ordinateur oublie tout du niveau précédent.</p></li></ul>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash">Créez un jeu de Sokoban en Flash !</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-cahier-des-charges-7">
Le cahier des charges
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-mise-en-place-du-tableau">
La mise en place du tableau
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-gestion-des-deplacements">
La gestion des déplacements
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-comptage-des-points">
Le comptage des points
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-fonction-undo">
La fonction Undo
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/enchainement-des-tableaux">
Enchaînement des tableaux
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/conclusion-58">
Conclusion
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-fonction-undo">
<span class="arrow"></span>
<span class="next">La fonction Undo</span>
</a>
<a class="after" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/conclusion-58">
<span class="next">Conclusion</span>
<span class="arrow"></span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div><a name="Conclusion"></a><h2>Conclusion</h2><div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/enchainement-des-tableaux">
<span class="arrow"></span>
<span class="next">Enchaînement des tableaux</span>
</a>
</div>
<hr class="top"/>
<div class="clear"></div> <div id="content" role="article">
<h2 id="r-synthese-du-code" data-claire-element-id="580208">Synthèse du code</h2><p id="r-580205" data-claire-element-id="580205">J'ai le plaisir de vous annoncer que vous avez terminé votre jeu de Sokoban ! Le code, exempt de tout commentaire et passage de ligne, fait exactement 217 lignes et 6487 caractères, espaces non compris. Ca paraît peu mais cela représente beaucoup de travail, comme vous avez pu le constater. Je vous propose de télécharger le fichier source au format .fla ici :</p><aside id="r-580207" data-claire-element-id="580207" data-claire-semantic="information"><p id="r-580206" data-claire-element-id="580206"><strong>Note du validateur, le 07/02/2010 : le lien auparavant proposé ici n'est plus valide à ce jour, suite à des soucis d'hébergement. Il est temporairement retiré de la version en ligne de ce tutoriel, d'ici à ce que son auteur ait le temps de le remplacer par un nouveau lien fonctionnel. Pour toute requête, adressez-vous directement à lui par MP, merci de ne pas utiliser le système d'alertes pour ce problème.</strong></p></aside><h2 id="r-idees-d-ameliorations-4" data-claire-element-id="580220">Idées d'améliorations</h2><p id="r-580209" data-claire-element-id="580209">Cependant, le programme est loin d'être parfait, bien que déjà assez complet. Je vous propose quelques idées d'améliorations qui m'ont traversé l'esprit ou que j'ai moi-même ajouté à mon programme sans pour autant leur consacrer un tutoriel. Parmi celles-ci, je cite :</p><ul id="r-580218" data-claire-element-id="580218"><li id="r-580211" data-claire-element-id="580211"><p id="r-580210" data-claire-element-id="580210">Vous pourriez, plutôt que de les taper directement sous Flash, charger vos tableaux à partir d'un fichier externe à l'extension &quot;.sok&quot;. Ainsi, vous ne devriez pas ouvrir Flash pour faire une modification, et vous pourriez ajouter des nouveaux tableaux très facilement.</p></li><li id="r-580213" data-claire-element-id="580213"><p id="r-580212" data-claire-element-id="580212">Un gros travail serait de créer un éditeur de tableaux qui permettrait d'enregistrer vos créations au format &quot;.sok&quot; pour les essayer ensuite dans le jeu. Cela demande un peu d'astuce mais surtout une bonne connaissance de la gestion des données externes, c'est pourquoi je ne me suis pas attardé là-dessus dans ce tutoriel.</p></li><li id="r-580215" data-claire-element-id="580215"><p id="r-580214" data-claire-element-id="580214">Plus facile à réaliser : un petit compteur qui affiche le nombre de coups joués par l'utilisateur. On pourrait alors enregistrer ce nombre de coups dans un fichier et proposer à l'utilisateur d'essayer de battre son record !</p></li><li id="r-580217" data-claire-element-id="580217"><p id="r-580216" data-claire-element-id="580216">Un peu plus complexe : comme on a utilisé un historique qui retient tous les coups, se serait dommage de ne pas l'utiliser à 100% ! Pourquoi ne pas proposer de sauvegarder, en même temps que le nombre de coups, la solution complète à laquelle le joueur est arrivé ? Il pourrait alors observer ses anciennes parties dans une visionneuse et les comparer pour essayer de mieux jouer !</p></li></ul><p id="r-580219" data-claire-element-id="580219">Merci d'avoir lu ce tutoriel jusqu'au bout ! J'espère avoir été assez clair et vous avoir appris des notions de programmation en ActionScript... :) <br/> N'hésitez pas à laissez des commentaires et à bientôt, amis Zér0s !</p>
<aside class="aside-menu">
<ul class="content-menu subchapter" role="navigation">
<li class="tuto">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash">Créez un jeu de Sokoban en Flash !</a>
</li>
<ul class="subchapter-parts">
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-cahier-des-charges-7">
Le cahier des charges
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-mise-en-place-du-tableau">
La mise en place du tableau
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-gestion-des-deplacements">
La gestion des déplacements
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/le-comptage-des-points">
Le comptage des points
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/la-fonction-undo">
La fonction Undo
</a>
</li>
<li>
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/enchainement-des-tableaux">
Enchaînement des tableaux
</a>
</li>
<li class="active">
<a href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/conclusion-58">
Conclusion
</a>
</li>
</ul>
</ul>
</aside>
</div>
<div id="content-bottom-menu"></div>
<hr/>
<div class="paginate-tuto">
<a class="before" href="http://62.4.17.167/informatique/tutoriels/creez-un-jeu-de-sokoban-en-flash/enchainement-des-tableaux">
<span class="arrow"></span>
<span class="next">Enchaînement des tableaux</span>
</a>
</div>
<hr class="bottom"/>
<div class="clear"></div> <div class="adBan">
<script type='text/javascript'>
    if (window.innerWidth >= 728)
    {
        document.write('<div id="div-gpt-ad-1350977194635-8" class="megaban"></div>');
        googletag.cmd.push(function() {
            googletag.display('div-gpt-ad-1350977194635-8');
        });
    }
            else
        {
            document.write('<div id="div-gpt-ad-1350977284180-8" class="miniban"></div>');
            googletag.cmd.push(function() {
                googletag.display('div-gpt-ad-1350977284180-8');
            });
        }
    </script>
</div>
<div class="clear"></div>
</body>
<!-- Mirrored from 62.4.17.167/sdz/sdz/creez-un-jeu-de-sokoban-en-flash.html by HTTrack Website Copier/3.x [XR&CO'2013], Sun, 27 Oct 2013 11:23:20 GMT -->

<!-- Mirrored from sdz.tdct.org/sdz/creez-un-jeu-de-sokoban-en-flash.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 30 Nov 2015 05:50:17 GMT -->
</html>